/* automatically generated by rust-bindgen */

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage, Align>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    storage: Storage,
    align: [Align; 0],
}

impl<Storage, Align> __BindgenBitfieldUnit<Storage, Align>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn new(storage: Storage) -> Self {
        Self { storage, align: [] }
    }

    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());

        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];

        let bit_index = index % 8;
        let mask = 1 << bit_index;

        byte & mask == mask
    }

    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());

        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];

        let bit_index = index % 8;
        let mask = 1 << bit_index;

        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }

    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());

        let mut val = 0;

        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                val |= 1 << i;
            }
        }

        val
    }

    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());

        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            self.set_bit(i + bit_offset, val_bit_is_set);
        }
    }
}
pub const G_GNUC_FUNCTION: &'static [u8; 1usize] = b"\0";
pub const G_GNUC_PRETTY_FUNCTION: &'static [u8; 1usize] = b"\0";
pub const G_ANALYZER_ANALYZING: u32 = 0;
pub const FALSE: u32 = 0;
pub const __DARWIN_ONLY_64_BIT_INO_T: u32 = 0;
pub const __DARWIN_ONLY_VERS_1050: u32 = 0;
pub const __DARWIN_ONLY_UNIX_CONFORMANCE: u32 = 1;
pub const __DARWIN_UNIX03: u32 = 1;
pub const __DARWIN_64_BIT_INO_T: u32 = 0;
pub const __DARWIN_VERS_1050: u32 = 0;
pub const __DARWIN_NON_CANCELABLE: u32 = 0;
pub const __DARWIN_SUF_EXTSN: &'static [u8; 14usize] = b"$DARWIN_EXTSN\0";
pub const __DARWIN_C_ANSI: u32 = 4096;
pub const __DARWIN_C_FULL: u32 = 900000;
pub const __DARWIN_C_LEVEL: u32 = 900000;
pub const __STDC_WANT_LIB_EXT1__: u32 = 1;
pub const _DARWIN_FEATURE_ONLY_UNIX_CONFORMANCE: u32 = 1;
pub const _DARWIN_FEATURE_UNIX_CONFORMANCE: u32 = 3;
pub const __DARWIN_CLK_TCK: u32 = 100;
pub const CHAR_BIT: u32 = 8;
pub const MB_LEN_MAX: u32 = 6;
pub const CLK_TCK: u32 = 100;
pub const SCHAR_MAX: u32 = 127;
pub const SCHAR_MIN: i32 = -128;
pub const UCHAR_MAX: u32 = 255;
pub const CHAR_MAX: u32 = 127;
pub const CHAR_MIN: i32 = -128;
pub const USHRT_MAX: u32 = 65535;
pub const SHRT_MAX: u32 = 32767;
pub const SHRT_MIN: i32 = -32768;
pub const UINT_MAX: u32 = 4294967295;
pub const INT_MAX: u32 = 2147483647;
pub const INT_MIN: i32 = -2147483648;
pub const ULONG_MAX: i32 = -1;
pub const LONG_MAX: u64 = 9223372036854775807;
pub const LONG_MIN: i64 = -9223372036854775808;
pub const ULLONG_MAX: i32 = -1;
pub const LLONG_MAX: u64 = 9223372036854775807;
pub const LLONG_MIN: i64 = -9223372036854775808;
pub const LONG_BIT: u32 = 64;
pub const SSIZE_MAX: u64 = 9223372036854775807;
pub const WORD_BIT: u32 = 32;
pub const SIZE_T_MAX: i32 = -1;
pub const UQUAD_MAX: i32 = -1;
pub const QUAD_MAX: u64 = 9223372036854775807;
pub const QUAD_MIN: i64 = -9223372036854775808;
pub const ARG_MAX: u32 = 262144;
pub const CHILD_MAX: u32 = 266;
pub const GID_MAX: u32 = 2147483647;
pub const LINK_MAX: u32 = 32767;
pub const MAX_CANON: u32 = 1024;
pub const MAX_INPUT: u32 = 1024;
pub const NAME_MAX: u32 = 255;
pub const NGROUPS_MAX: u32 = 16;
pub const UID_MAX: u32 = 2147483647;
pub const OPEN_MAX: u32 = 10240;
pub const PATH_MAX: u32 = 1024;
pub const PIPE_BUF: u32 = 512;
pub const BC_BASE_MAX: u32 = 99;
pub const BC_DIM_MAX: u32 = 2048;
pub const BC_SCALE_MAX: u32 = 99;
pub const BC_STRING_MAX: u32 = 1000;
pub const CHARCLASS_NAME_MAX: u32 = 14;
pub const COLL_WEIGHTS_MAX: u32 = 2;
pub const EQUIV_CLASS_MAX: u32 = 2;
pub const EXPR_NEST_MAX: u32 = 32;
pub const LINE_MAX: u32 = 2048;
pub const RE_DUP_MAX: u32 = 255;
pub const NZERO: u32 = 20;
pub const _POSIX_ARG_MAX: u32 = 4096;
pub const _POSIX_CHILD_MAX: u32 = 25;
pub const _POSIX_LINK_MAX: u32 = 8;
pub const _POSIX_MAX_CANON: u32 = 255;
pub const _POSIX_MAX_INPUT: u32 = 255;
pub const _POSIX_NAME_MAX: u32 = 14;
pub const _POSIX_NGROUPS_MAX: u32 = 8;
pub const _POSIX_OPEN_MAX: u32 = 20;
pub const _POSIX_PATH_MAX: u32 = 256;
pub const _POSIX_PIPE_BUF: u32 = 512;
pub const _POSIX_SSIZE_MAX: u32 = 32767;
pub const _POSIX_STREAM_MAX: u32 = 8;
pub const _POSIX_TZNAME_MAX: u32 = 6;
pub const _POSIX2_BC_BASE_MAX: u32 = 99;
pub const _POSIX2_BC_DIM_MAX: u32 = 2048;
pub const _POSIX2_BC_SCALE_MAX: u32 = 99;
pub const _POSIX2_BC_STRING_MAX: u32 = 1000;
pub const _POSIX2_EQUIV_CLASS_MAX: u32 = 2;
pub const _POSIX2_EXPR_NEST_MAX: u32 = 32;
pub const _POSIX2_LINE_MAX: u32 = 2048;
pub const _POSIX2_RE_DUP_MAX: u32 = 255;
pub const _POSIX_AIO_LISTIO_MAX: u32 = 2;
pub const _POSIX_AIO_MAX: u32 = 1;
pub const _POSIX_DELAYTIMER_MAX: u32 = 32;
pub const _POSIX_MQ_OPEN_MAX: u32 = 8;
pub const _POSIX_MQ_PRIO_MAX: u32 = 32;
pub const _POSIX_RTSIG_MAX: u32 = 8;
pub const _POSIX_SEM_NSEMS_MAX: u32 = 256;
pub const _POSIX_SEM_VALUE_MAX: u32 = 32767;
pub const _POSIX_SIGQUEUE_MAX: u32 = 32;
pub const _POSIX_TIMER_MAX: u32 = 32;
pub const _POSIX_CLOCKRES_MIN: u32 = 20000000;
pub const _POSIX_THREAD_DESTRUCTOR_ITERATIONS: u32 = 4;
pub const _POSIX_THREAD_KEYS_MAX: u32 = 128;
pub const _POSIX_THREAD_THREADS_MAX: u32 = 64;
pub const PTHREAD_DESTRUCTOR_ITERATIONS: u32 = 4;
pub const PTHREAD_KEYS_MAX: u32 = 512;
pub const PTHREAD_STACK_MIN: u32 = 8192;
pub const _POSIX_HOST_NAME_MAX: u32 = 255;
pub const _POSIX_LOGIN_NAME_MAX: u32 = 9;
pub const _POSIX_SS_REPL_MAX: u32 = 4;
pub const _POSIX_SYMLINK_MAX: u32 = 255;
pub const _POSIX_SYMLOOP_MAX: u32 = 8;
pub const _POSIX_TRACE_EVENT_NAME_MAX: u32 = 30;
pub const _POSIX_TRACE_NAME_MAX: u32 = 8;
pub const _POSIX_TRACE_SYS_MAX: u32 = 8;
pub const _POSIX_TRACE_USER_EVENT_MAX: u32 = 32;
pub const _POSIX_TTY_NAME_MAX: u32 = 9;
pub const _POSIX2_CHARCLASS_NAME_MAX: u32 = 14;
pub const _POSIX2_COLL_WEIGHTS_MAX: u32 = 2;
pub const _POSIX_RE_DUP_MAX: u32 = 255;
pub const OFF_MIN: i64 = -9223372036854775808;
pub const OFF_MAX: u64 = 9223372036854775807;
pub const PASS_MAX: u32 = 128;
pub const NL_ARGMAX: u32 = 9;
pub const NL_LANGMAX: u32 = 14;
pub const NL_MSGMAX: u32 = 32767;
pub const NL_NMAX: u32 = 1;
pub const NL_SETMAX: u32 = 255;
pub const NL_TEXTMAX: u32 = 2048;
pub const _XOPEN_IOV_MAX: u32 = 16;
pub const IOV_MAX: u32 = 1024;
pub const _XOPEN_NAME_MAX: u32 = 255;
pub const _XOPEN_PATH_MAX: u32 = 1024;
pub const G_MINSHORT: i32 = -32768;
pub const G_MAXSHORT: u32 = 32767;
pub const G_MAXUSHORT: u32 = 65535;
pub const G_MININT: i32 = -2147483648;
pub const G_MAXINT: u32 = 2147483647;
pub const G_MAXUINT: u32 = 4294967295;
pub const G_MINLONG: i64 = -9223372036854775808;
pub const G_MAXLONG: u64 = 9223372036854775807;
pub const G_MAXULONG: i32 = -1;
pub const G_GINT16_MODIFIER: &'static [u8; 2usize] = b"h\0";
pub const G_GINT16_FORMAT: &'static [u8; 3usize] = b"hi\0";
pub const G_GUINT16_FORMAT: &'static [u8; 3usize] = b"hu\0";
pub const G_GINT32_MODIFIER: &'static [u8; 1usize] = b"\0";
pub const G_GINT32_FORMAT: &'static [u8; 2usize] = b"i\0";
pub const G_GUINT32_FORMAT: &'static [u8; 2usize] = b"u\0";
pub const G_HAVE_GINT64: u32 = 1;
pub const G_GINT64_MODIFIER: &'static [u8; 2usize] = b"l\0";
pub const G_GINT64_FORMAT: &'static [u8; 3usize] = b"li\0";
pub const G_GUINT64_FORMAT: &'static [u8; 3usize] = b"lu\0";
pub const GLIB_SIZEOF_VOID_P: u32 = 8;
pub const GLIB_SIZEOF_LONG: u32 = 8;
pub const GLIB_SIZEOF_SIZE_T: u32 = 8;
pub const GLIB_SIZEOF_SSIZE_T: u32 = 8;
pub const G_GSIZE_MODIFIER: &'static [u8; 2usize] = b"l\0";
pub const G_GSSIZE_MODIFIER: &'static [u8; 2usize] = b"l\0";
pub const G_GSIZE_FORMAT: &'static [u8; 3usize] = b"lu\0";
pub const G_GSSIZE_FORMAT: &'static [u8; 3usize] = b"li\0";
pub const G_MAXSIZE: i32 = -1;
pub const G_MINSSIZE: i64 = -9223372036854775808;
pub const G_MAXSSIZE: u64 = 9223372036854775807;
pub const G_GOFFSET_MODIFIER: &'static [u8; 2usize] = b"l\0";
pub const G_GOFFSET_FORMAT: &'static [u8; 3usize] = b"li\0";
pub const G_POLLFD_FORMAT: &'static [u8; 3usize] = b"%d\0";
pub const G_GINTPTR_MODIFIER: &'static [u8; 2usize] = b"l\0";
pub const G_GINTPTR_FORMAT: &'static [u8; 3usize] = b"li\0";
pub const G_GUINTPTR_FORMAT: &'static [u8; 3usize] = b"lu\0";
pub const GLIB_MAJOR_VERSION: u32 = 2;
pub const GLIB_MINOR_VERSION: u32 = 54;
pub const GLIB_MICRO_VERSION: u32 = 3;
pub const G_VA_COPY_AS_ARRAY: u32 = 1;
pub const G_HAVE_ISO_VARARGS: u32 = 1;
pub const G_HAVE_GNUC_VARARGS: u32 = 1;
pub const G_HAVE_GROWING_STACK: u32 = 0;
pub const G_MODULE_SUFFIX: &'static [u8; 3usize] = b"so\0";
pub const G_PID_FORMAT: &'static [u8; 2usize] = b"i\0";
pub const GLIB_SYSDEF_AF_UNIX: u32 = 1;
pub const GLIB_SYSDEF_AF_INET: u32 = 2;
pub const GLIB_SYSDEF_AF_INET6: u32 = 30;
pub const GLIB_SYSDEF_MSG_OOB: u32 = 1;
pub const GLIB_SYSDEF_MSG_PEEK: u32 = 2;
pub const GLIB_SYSDEF_MSG_DONTROUTE: u32 = 4;
pub const __PTHREAD_SIZE__: u32 = 8176;
pub const __PTHREAD_ATTR_SIZE__: u32 = 56;
pub const __PTHREAD_MUTEXATTR_SIZE__: u32 = 8;
pub const __PTHREAD_MUTEX_SIZE__: u32 = 56;
pub const __PTHREAD_CONDATTR_SIZE__: u32 = 8;
pub const __PTHREAD_COND_SIZE__: u32 = 40;
pub const __PTHREAD_ONCE_SIZE__: u32 = 8;
pub const __PTHREAD_RWLOCK_SIZE__: u32 = 192;
pub const __PTHREAD_RWLOCKATTR_SIZE__: u32 = 16;
pub const __DARWIN_WCHAR_MIN: i32 = -2147483648;
pub const _FORTIFY_SOURCE: u32 = 0;
pub const __MAC_10_0: u32 = 1000;
pub const __MAC_10_1: u32 = 1010;
pub const __MAC_10_2: u32 = 1020;
pub const __MAC_10_3: u32 = 1030;
pub const __MAC_10_4: u32 = 1040;
pub const __MAC_10_5: u32 = 1050;
pub const __MAC_10_6: u32 = 1060;
pub const __MAC_10_7: u32 = 1070;
pub const __MAC_10_8: u32 = 1080;
pub const __MAC_10_9: u32 = 1090;
pub const __MAC_10_10: u32 = 101000;
pub const __MAC_10_10_2: u32 = 101002;
pub const __MAC_10_10_3: u32 = 101003;
pub const __MAC_10_11: u32 = 101100;
pub const __MAC_10_11_2: u32 = 101102;
pub const __MAC_10_11_3: u32 = 101103;
pub const __MAC_10_11_4: u32 = 101104;
pub const __MAC_10_12: u32 = 101200;
pub const __MAC_10_12_1: u32 = 101201;
pub const __MAC_10_12_2: u32 = 101202;
pub const __MAC_10_12_4: u32 = 101204;
pub const __IPHONE_2_0: u32 = 20000;
pub const __IPHONE_2_1: u32 = 20100;
pub const __IPHONE_2_2: u32 = 20200;
pub const __IPHONE_3_0: u32 = 30000;
pub const __IPHONE_3_1: u32 = 30100;
pub const __IPHONE_3_2: u32 = 30200;
pub const __IPHONE_4_0: u32 = 40000;
pub const __IPHONE_4_1: u32 = 40100;
pub const __IPHONE_4_2: u32 = 40200;
pub const __IPHONE_4_3: u32 = 40300;
pub const __IPHONE_5_0: u32 = 50000;
pub const __IPHONE_5_1: u32 = 50100;
pub const __IPHONE_6_0: u32 = 60000;
pub const __IPHONE_6_1: u32 = 60100;
pub const __IPHONE_7_0: u32 = 70000;
pub const __IPHONE_7_1: u32 = 70100;
pub const __IPHONE_8_0: u32 = 80000;
pub const __IPHONE_8_1: u32 = 80100;
pub const __IPHONE_8_2: u32 = 80200;
pub const __IPHONE_8_3: u32 = 80300;
pub const __IPHONE_8_4: u32 = 80400;
pub const __IPHONE_9_0: u32 = 90000;
pub const __IPHONE_9_1: u32 = 90100;
pub const __IPHONE_9_2: u32 = 90200;
pub const __IPHONE_9_3: u32 = 90300;
pub const __IPHONE_10_0: u32 = 100000;
pub const __IPHONE_10_1: u32 = 100100;
pub const __IPHONE_10_2: u32 = 100200;
pub const __IPHONE_10_3: u32 = 100300;
pub const __TVOS_9_0: u32 = 90000;
pub const __TVOS_9_1: u32 = 90100;
pub const __TVOS_9_2: u32 = 90200;
pub const __TVOS_10_0: u32 = 100000;
pub const __TVOS_10_0_1: u32 = 100001;
pub const __TVOS_10_1: u32 = 100100;
pub const __TVOS_10_2: u32 = 100200;
pub const __WATCHOS_1_0: u32 = 10000;
pub const __WATCHOS_2_0: u32 = 20000;
pub const __WATCHOS_2_1: u32 = 20100;
pub const __WATCHOS_2_2: u32 = 20200;
pub const __WATCHOS_3_0: u32 = 30000;
pub const __WATCHOS_3_1: u32 = 30100;
pub const __WATCHOS_3_1_1: u32 = 30101;
pub const __WATCHOS_3_2: u32 = 30200;
pub const __MAC_OS_X_VERSION_MAX_ALLOWED: u32 = 101204;
pub const CLOCKS_PER_SEC: u32 = 1000000;
pub const G_E: f64 = 2.718281828459045;
pub const G_LN2: f64 = 0.6931471805599453;
pub const G_LN10: f64 = 2.302585092994046;
pub const G_PI: f64 = 3.141592653589793;
pub const G_PI_2: f64 = 1.5707963267948966;
pub const G_PI_4: f64 = 0.7853981633974483;
pub const G_SQRT2: f64 = 1.4142135623730951;
pub const G_LITTLE_ENDIAN: u32 = 1234;
pub const G_BIG_ENDIAN: u32 = 4321;
pub const G_PDP_ENDIAN: u32 = 3412;
pub const G_IEEE754_FLOAT_BIAS: u32 = 127;
pub const G_IEEE754_DOUBLE_BIAS: u32 = 1023;
pub const G_LOG_2_BASE_10: f64 = 0.3010299956639812;
pub const __GNUC_VA_LIST: u32 = 1;
pub const __DARWIN_NSIG: u32 = 32;
pub const NSIG: u32 = 32;
pub const _I386_SIGNAL_H_: u32 = 1;
pub const SIGHUP: u32 = 1;
pub const SIGINT: u32 = 2;
pub const SIGQUIT: u32 = 3;
pub const SIGILL: u32 = 4;
pub const SIGTRAP: u32 = 5;
pub const SIGABRT: u32 = 6;
pub const SIGIOT: u32 = 6;
pub const SIGEMT: u32 = 7;
pub const SIGFPE: u32 = 8;
pub const SIGKILL: u32 = 9;
pub const SIGBUS: u32 = 10;
pub const SIGSEGV: u32 = 11;
pub const SIGSYS: u32 = 12;
pub const SIGPIPE: u32 = 13;
pub const SIGALRM: u32 = 14;
pub const SIGTERM: u32 = 15;
pub const SIGURG: u32 = 16;
pub const SIGSTOP: u32 = 17;
pub const SIGTSTP: u32 = 18;
pub const SIGCONT: u32 = 19;
pub const SIGCHLD: u32 = 20;
pub const SIGTTIN: u32 = 21;
pub const SIGTTOU: u32 = 22;
pub const SIGIO: u32 = 23;
pub const SIGXCPU: u32 = 24;
pub const SIGXFSZ: u32 = 25;
pub const SIGVTALRM: u32 = 26;
pub const SIGPROF: u32 = 27;
pub const SIGWINCH: u32 = 28;
pub const SIGINFO: u32 = 29;
pub const SIGUSR1: u32 = 30;
pub const SIGUSR2: u32 = 31;
pub const FP_PREC_24B: u32 = 0;
pub const FP_PREC_53B: u32 = 2;
pub const FP_PREC_64B: u32 = 3;
pub const FP_RND_NEAR: u32 = 0;
pub const FP_RND_DOWN: u32 = 1;
pub const FP_RND_UP: u32 = 2;
pub const FP_CHOP: u32 = 3;
pub const FP_STATE_BYTES: u32 = 512;
pub const SIGEV_NONE: u32 = 0;
pub const SIGEV_SIGNAL: u32 = 1;
pub const SIGEV_THREAD: u32 = 3;
pub const ILL_NOOP: u32 = 0;
pub const ILL_ILLOPC: u32 = 1;
pub const ILL_ILLTRP: u32 = 2;
pub const ILL_PRVOPC: u32 = 3;
pub const ILL_ILLOPN: u32 = 4;
pub const ILL_ILLADR: u32 = 5;
pub const ILL_PRVREG: u32 = 6;
pub const ILL_COPROC: u32 = 7;
pub const ILL_BADSTK: u32 = 8;
pub const FPE_NOOP: u32 = 0;
pub const FPE_FLTDIV: u32 = 1;
pub const FPE_FLTOVF: u32 = 2;
pub const FPE_FLTUND: u32 = 3;
pub const FPE_FLTRES: u32 = 4;
pub const FPE_FLTINV: u32 = 5;
pub const FPE_FLTSUB: u32 = 6;
pub const FPE_INTDIV: u32 = 7;
pub const FPE_INTOVF: u32 = 8;
pub const SEGV_NOOP: u32 = 0;
pub const SEGV_MAPERR: u32 = 1;
pub const SEGV_ACCERR: u32 = 2;
pub const BUS_NOOP: u32 = 0;
pub const BUS_ADRALN: u32 = 1;
pub const BUS_ADRERR: u32 = 2;
pub const BUS_OBJERR: u32 = 3;
pub const TRAP_BRKPT: u32 = 1;
pub const TRAP_TRACE: u32 = 2;
pub const CLD_NOOP: u32 = 0;
pub const CLD_EXITED: u32 = 1;
pub const CLD_KILLED: u32 = 2;
pub const CLD_DUMPED: u32 = 3;
pub const CLD_TRAPPED: u32 = 4;
pub const CLD_STOPPED: u32 = 5;
pub const CLD_CONTINUED: u32 = 6;
pub const POLL_IN: u32 = 1;
pub const POLL_OUT: u32 = 2;
pub const POLL_MSG: u32 = 3;
pub const POLL_ERR: u32 = 4;
pub const POLL_PRI: u32 = 5;
pub const POLL_HUP: u32 = 6;
pub const SA_ONSTACK: u32 = 1;
pub const SA_RESTART: u32 = 2;
pub const SA_RESETHAND: u32 = 4;
pub const SA_NOCLDSTOP: u32 = 8;
pub const SA_NODEFER: u32 = 16;
pub const SA_NOCLDWAIT: u32 = 32;
pub const SA_SIGINFO: u32 = 64;
pub const SA_USERTRAMP: u32 = 256;
pub const SA_64REGSET: u32 = 512;
pub const SA_USERSPACE_MASK: u32 = 127;
pub const SIG_BLOCK: u32 = 1;
pub const SIG_UNBLOCK: u32 = 2;
pub const SIG_SETMASK: u32 = 3;
pub const SI_USER: u32 = 65537;
pub const SI_QUEUE: u32 = 65538;
pub const SI_TIMER: u32 = 65539;
pub const SI_ASYNCIO: u32 = 65540;
pub const SI_MESGQ: u32 = 65541;
pub const SS_ONSTACK: u32 = 1;
pub const SS_DISABLE: u32 = 4;
pub const MINSIGSTKSZ: u32 = 32768;
pub const SIGSTKSZ: u32 = 131072;
pub const SV_ONSTACK: u32 = 1;
pub const SV_INTERRUPT: u32 = 2;
pub const SV_RESETHAND: u32 = 4;
pub const SV_NODEFER: u32 = 16;
pub const SV_NOCLDSTOP: u32 = 8;
pub const SV_SIGINFO: u32 = 64;
pub const G_DATALIST_FLAGS_MASK: u32 = 3;
pub const G_DATE_BAD_JULIAN: u32 = 0;
pub const G_DATE_BAD_DAY: u32 = 0;
pub const G_DATE_BAD_YEAR: u32 = 0;
pub const __DARWIN_MAXNAMLEN: u32 = 255;
pub const __DARWIN_MAXPATHLEN: u32 = 1024;
pub const MAXNAMLEN: u32 = 255;
pub const DT_UNKNOWN: u32 = 0;
pub const DT_FIFO: u32 = 1;
pub const DT_CHR: u32 = 2;
pub const DT_DIR: u32 = 4;
pub const DT_BLK: u32 = 6;
pub const DT_REG: u32 = 8;
pub const DT_LNK: u32 = 10;
pub const DT_SOCK: u32 = 12;
pub const DT_WHT: u32 = 14;
pub const DIRBLKSIZ: u32 = 1024;
pub const DTF_HIDEW: u32 = 1;
pub const DTF_NODUP: u32 = 2;
pub const DTF_REWIND: u32 = 4;
pub const __DTF_READALL: u32 = 8;
pub const EPERM: u32 = 1;
pub const ENOENT: u32 = 2;
pub const ESRCH: u32 = 3;
pub const EINTR: u32 = 4;
pub const EIO: u32 = 5;
pub const ENXIO: u32 = 6;
pub const E2BIG: u32 = 7;
pub const ENOEXEC: u32 = 8;
pub const EBADF: u32 = 9;
pub const ECHILD: u32 = 10;
pub const EDEADLK: u32 = 11;
pub const ENOMEM: u32 = 12;
pub const EACCES: u32 = 13;
pub const EFAULT: u32 = 14;
pub const ENOTBLK: u32 = 15;
pub const EBUSY: u32 = 16;
pub const EEXIST: u32 = 17;
pub const EXDEV: u32 = 18;
pub const ENODEV: u32 = 19;
pub const ENOTDIR: u32 = 20;
pub const EISDIR: u32 = 21;
pub const EINVAL: u32 = 22;
pub const ENFILE: u32 = 23;
pub const EMFILE: u32 = 24;
pub const ENOTTY: u32 = 25;
pub const ETXTBSY: u32 = 26;
pub const EFBIG: u32 = 27;
pub const ENOSPC: u32 = 28;
pub const ESPIPE: u32 = 29;
pub const EROFS: u32 = 30;
pub const EMLINK: u32 = 31;
pub const EPIPE: u32 = 32;
pub const EDOM: u32 = 33;
pub const ERANGE: u32 = 34;
pub const EAGAIN: u32 = 35;
pub const EWOULDBLOCK: u32 = 35;
pub const EINPROGRESS: u32 = 36;
pub const EALREADY: u32 = 37;
pub const ENOTSOCK: u32 = 38;
pub const EDESTADDRREQ: u32 = 39;
pub const EMSGSIZE: u32 = 40;
pub const EPROTOTYPE: u32 = 41;
pub const ENOPROTOOPT: u32 = 42;
pub const EPROTONOSUPPORT: u32 = 43;
pub const ESOCKTNOSUPPORT: u32 = 44;
pub const ENOTSUP: u32 = 45;
pub const EPFNOSUPPORT: u32 = 46;
pub const EAFNOSUPPORT: u32 = 47;
pub const EADDRINUSE: u32 = 48;
pub const EADDRNOTAVAIL: u32 = 49;
pub const ENETDOWN: u32 = 50;
pub const ENETUNREACH: u32 = 51;
pub const ENETRESET: u32 = 52;
pub const ECONNABORTED: u32 = 53;
pub const ECONNRESET: u32 = 54;
pub const ENOBUFS: u32 = 55;
pub const EISCONN: u32 = 56;
pub const ENOTCONN: u32 = 57;
pub const ESHUTDOWN: u32 = 58;
pub const ETOOMANYREFS: u32 = 59;
pub const ETIMEDOUT: u32 = 60;
pub const ECONNREFUSED: u32 = 61;
pub const ELOOP: u32 = 62;
pub const ENAMETOOLONG: u32 = 63;
pub const EHOSTDOWN: u32 = 64;
pub const EHOSTUNREACH: u32 = 65;
pub const ENOTEMPTY: u32 = 66;
pub const EPROCLIM: u32 = 67;
pub const EUSERS: u32 = 68;
pub const EDQUOT: u32 = 69;
pub const ESTALE: u32 = 70;
pub const EREMOTE: u32 = 71;
pub const EBADRPC: u32 = 72;
pub const ERPCMISMATCH: u32 = 73;
pub const EPROGUNAVAIL: u32 = 74;
pub const EPROGMISMATCH: u32 = 75;
pub const EPROCUNAVAIL: u32 = 76;
pub const ENOLCK: u32 = 77;
pub const ENOSYS: u32 = 78;
pub const EFTYPE: u32 = 79;
pub const EAUTH: u32 = 80;
pub const ENEEDAUTH: u32 = 81;
pub const EPWROFF: u32 = 82;
pub const EDEVERR: u32 = 83;
pub const EOVERFLOW: u32 = 84;
pub const EBADEXEC: u32 = 85;
pub const EBADARCH: u32 = 86;
pub const ESHLIBVERS: u32 = 87;
pub const EBADMACHO: u32 = 88;
pub const ECANCELED: u32 = 89;
pub const EIDRM: u32 = 90;
pub const ENOMSG: u32 = 91;
pub const EILSEQ: u32 = 92;
pub const ENOATTR: u32 = 93;
pub const EBADMSG: u32 = 94;
pub const EMULTIHOP: u32 = 95;
pub const ENODATA: u32 = 96;
pub const ENOLINK: u32 = 97;
pub const ENOSR: u32 = 98;
pub const ENOSTR: u32 = 99;
pub const EPROTO: u32 = 100;
pub const ETIME: u32 = 101;
pub const EOPNOTSUPP: u32 = 102;
pub const ENOPOLICY: u32 = 103;
pub const ENOTRECOVERABLE: u32 = 104;
pub const EOWNERDEAD: u32 = 105;
pub const EQFULL: u32 = 106;
pub const ELAST: u32 = 106;
pub const __WORDSIZE: u32 = 64;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const INT64_MAX: u64 = 9223372036854775807;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT64_MIN: i64 = -9223372036854775808;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const UINT64_MAX: i32 = -1;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST64_MIN: i64 = -9223372036854775808;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const INT_LEAST64_MAX: u64 = 9223372036854775807;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const UINT_LEAST64_MAX: i32 = -1;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i32 = -32768;
pub const INT_FAST32_MIN: i32 = -2147483648;
pub const INT_FAST64_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u32 = 32767;
pub const INT_FAST32_MAX: u32 = 2147483647;
pub const INT_FAST64_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: u32 = 65535;
pub const UINT_FAST32_MAX: u32 = 4294967295;
pub const UINT_FAST64_MAX: i32 = -1;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const UINTPTR_MAX: i32 = -1;
pub const INTMAX_MIN: i64 = -9223372036854775808;
pub const INTMAX_MAX: u64 = 9223372036854775807;
pub const UINTMAX_MAX: i32 = -1;
pub const PTRDIFF_MIN: i64 = -9223372036854775808;
pub const PTRDIFF_MAX: u64 = 9223372036854775807;
pub const SIZE_MAX: i32 = -1;
pub const RSIZE_MAX: i32 = -1;
pub const WINT_MIN: i32 = -2147483648;
pub const WINT_MAX: u32 = 2147483647;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const PRIO_PROCESS: u32 = 0;
pub const PRIO_PGRP: u32 = 1;
pub const PRIO_USER: u32 = 2;
pub const PRIO_DARWIN_THREAD: u32 = 3;
pub const PRIO_DARWIN_PROCESS: u32 = 4;
pub const PRIO_MIN: i32 = -20;
pub const PRIO_MAX: u32 = 20;
pub const PRIO_DARWIN_BG: u32 = 4096;
pub const PRIO_DARWIN_NONUI: u32 = 4097;
pub const RUSAGE_SELF: u32 = 0;
pub const RUSAGE_CHILDREN: i32 = -1;
pub const RUSAGE_INFO_V0: u32 = 0;
pub const RUSAGE_INFO_V1: u32 = 1;
pub const RUSAGE_INFO_V2: u32 = 2;
pub const RUSAGE_INFO_V3: u32 = 3;
pub const RUSAGE_INFO_CURRENT: u32 = 3;
pub const RLIMIT_CPU: u32 = 0;
pub const RLIMIT_FSIZE: u32 = 1;
pub const RLIMIT_DATA: u32 = 2;
pub const RLIMIT_STACK: u32 = 3;
pub const RLIMIT_CORE: u32 = 4;
pub const RLIMIT_AS: u32 = 5;
pub const RLIMIT_RSS: u32 = 5;
pub const RLIMIT_MEMLOCK: u32 = 6;
pub const RLIMIT_NPROC: u32 = 7;
pub const RLIMIT_NOFILE: u32 = 8;
pub const RLIM_NLIMITS: u32 = 9;
pub const _RLIMIT_POSIX_FLAG: u32 = 4096;
pub const RLIMIT_WAKEUPS_MONITOR: u32 = 1;
pub const RLIMIT_CPU_USAGE_MONITOR: u32 = 2;
pub const RLIMIT_THREAD_CPULIMITS: u32 = 3;
pub const WAKEMON_ENABLE: u32 = 1;
pub const WAKEMON_DISABLE: u32 = 2;
pub const WAKEMON_GET_PARAMS: u32 = 4;
pub const WAKEMON_SET_DEFAULTS: u32 = 8;
pub const WAKEMON_MAKE_FATAL: u32 = 16;
pub const CPUMON_MAKE_FATAL: u32 = 4096;
pub const IOPOL_TYPE_DISK: u32 = 0;
pub const IOPOL_SCOPE_PROCESS: u32 = 0;
pub const IOPOL_SCOPE_THREAD: u32 = 1;
pub const IOPOL_SCOPE_DARWIN_BG: u32 = 2;
pub const IOPOL_DEFAULT: u32 = 0;
pub const IOPOL_IMPORTANT: u32 = 1;
pub const IOPOL_PASSIVE: u32 = 2;
pub const IOPOL_THROTTLE: u32 = 3;
pub const IOPOL_UTILITY: u32 = 4;
pub const IOPOL_STANDARD: u32 = 5;
pub const IOPOL_APPLICATION: u32 = 5;
pub const IOPOL_NORMAL: u32 = 1;
pub const WNOHANG: u32 = 1;
pub const WUNTRACED: u32 = 2;
pub const WCOREFLAG: u32 = 128;
pub const _WSTOPPED: u32 = 127;
pub const WEXITED: u32 = 4;
pub const WSTOPPED: u32 = 8;
pub const WCONTINUED: u32 = 16;
pub const WNOWAIT: u32 = 32;
pub const WAIT_ANY: i32 = -1;
pub const WAIT_MYPGRP: u32 = 0;
pub const _QUAD_HIGHWORD: u32 = 1;
pub const _QUAD_LOWWORD: u32 = 0;
pub const __DARWIN_LITTLE_ENDIAN: u32 = 1234;
pub const __DARWIN_BIG_ENDIAN: u32 = 4321;
pub const __DARWIN_PDP_ENDIAN: u32 = 3412;
pub const __DARWIN_BYTE_ORDER: u32 = 1234;
pub const LITTLE_ENDIAN: u32 = 1234;
pub const BIG_ENDIAN: u32 = 4321;
pub const PDP_ENDIAN: u32 = 3412;
pub const BYTE_ORDER: u32 = 1234;
pub const EXIT_FAILURE: u32 = 1;
pub const EXIT_SUCCESS: u32 = 0;
pub const RAND_MAX: u32 = 2147483647;
pub const G_DIR_SEPARATOR: u8 = 47u8;
pub const G_DIR_SEPARATOR_S: &'static [u8; 2usize] = b"/\0";
pub const G_SEARCHPATH_SEPARATOR: u8 = 58u8;
pub const G_SEARCHPATH_SEPARATOR_S: &'static [u8; 2usize] = b":\0";
pub const G_MEM_ALIGN: u32 = 8;
pub const G_HOOK_FLAG_USER_SHIFT: u32 = 4;
pub const G_PRIORITY_HIGH: i32 = -100;
pub const G_PRIORITY_DEFAULT: u32 = 0;
pub const G_PRIORITY_HIGH_IDLE: u32 = 100;
pub const G_PRIORITY_DEFAULT_IDLE: u32 = 200;
pub const G_PRIORITY_LOW: u32 = 300;
pub const G_SOURCE_REMOVE: u32 = 0;
pub const G_UNICHAR_MAX_DECOMPOSITION_LENGTH: u32 = 18;
pub const G_KEY_FILE_DESKTOP_GROUP: &'static [u8; 14usize] = b"Desktop Entry\0";
pub const G_KEY_FILE_DESKTOP_KEY_TYPE: &'static [u8; 5usize] = b"Type\0";
pub const G_KEY_FILE_DESKTOP_KEY_VERSION: &'static [u8; 8usize] = b"Version\0";
pub const G_KEY_FILE_DESKTOP_KEY_NAME: &'static [u8; 5usize] = b"Name\0";
pub const G_KEY_FILE_DESKTOP_KEY_GENERIC_NAME: &'static [u8; 12usize] = b"GenericName\0";
pub const G_KEY_FILE_DESKTOP_KEY_NO_DISPLAY: &'static [u8; 10usize] = b"NoDisplay\0";
pub const G_KEY_FILE_DESKTOP_KEY_COMMENT: &'static [u8; 8usize] = b"Comment\0";
pub const G_KEY_FILE_DESKTOP_KEY_ICON: &'static [u8; 5usize] = b"Icon\0";
pub const G_KEY_FILE_DESKTOP_KEY_HIDDEN: &'static [u8; 7usize] = b"Hidden\0";
pub const G_KEY_FILE_DESKTOP_KEY_ONLY_SHOW_IN: &'static [u8; 11usize] = b"OnlyShowIn\0";
pub const G_KEY_FILE_DESKTOP_KEY_NOT_SHOW_IN: &'static [u8; 10usize] = b"NotShowIn\0";
pub const G_KEY_FILE_DESKTOP_KEY_TRY_EXEC: &'static [u8; 8usize] = b"TryExec\0";
pub const G_KEY_FILE_DESKTOP_KEY_EXEC: &'static [u8; 5usize] = b"Exec\0";
pub const G_KEY_FILE_DESKTOP_KEY_PATH: &'static [u8; 5usize] = b"Path\0";
pub const G_KEY_FILE_DESKTOP_KEY_TERMINAL: &'static [u8; 9usize] = b"Terminal\0";
pub const G_KEY_FILE_DESKTOP_KEY_MIME_TYPE: &'static [u8; 9usize] = b"MimeType\0";
pub const G_KEY_FILE_DESKTOP_KEY_CATEGORIES: &'static [u8; 11usize] = b"Categories\0";
pub const G_KEY_FILE_DESKTOP_KEY_STARTUP_NOTIFY: &'static [u8; 14usize] = b"StartupNotify\0";
pub const G_KEY_FILE_DESKTOP_KEY_STARTUP_WM_CLASS: &'static [u8; 15usize] = b"StartupWMClass\0";
pub const G_KEY_FILE_DESKTOP_KEY_URL: &'static [u8; 4usize] = b"URL\0";
pub const G_KEY_FILE_DESKTOP_KEY_DBUS_ACTIVATABLE: &'static [u8; 16usize] = b"DBusActivatable\0";
pub const G_KEY_FILE_DESKTOP_KEY_ACTIONS: &'static [u8; 8usize] = b"Actions\0";
pub const G_KEY_FILE_DESKTOP_TYPE_APPLICATION: &'static [u8; 12usize] = b"Application\0";
pub const G_KEY_FILE_DESKTOP_TYPE_LINK: &'static [u8; 5usize] = b"Link\0";
pub const G_KEY_FILE_DESKTOP_TYPE_DIRECTORY: &'static [u8; 10usize] = b"Directory\0";
pub const G_LOG_LEVEL_USER_SHIFT: u32 = 8;
pub const G_OPTION_REMAINING: &'static [u8; 1usize] = b"\0";
pub const G_CSET_A_2_Z: &'static [u8; 27usize] = b"ABCDEFGHIJKLMNOPQRSTUVWXYZ\0";
pub const G_CSET_a_2_z: &'static [u8; 27usize] = b"abcdefghijklmnopqrstuvwxyz\0";
pub const G_CSET_DIGITS: &'static [u8; 11usize] = b"0123456789\0";
pub const G_CSET_LATINC: [u8; 31usize] = [
    192u8, 193u8, 194u8, 195u8, 196u8, 197u8, 198u8, 199u8, 200u8, 201u8, 202u8, 203u8, 204u8,
    205u8, 206u8, 207u8, 208u8, 209u8, 210u8, 211u8, 212u8, 213u8, 214u8, 216u8, 217u8, 218u8,
    219u8, 220u8, 221u8, 222u8, 0u8,
];
pub const G_CSET_LATINS: [u8; 33usize] = [
    223u8, 224u8, 225u8, 226u8, 227u8, 228u8, 229u8, 230u8, 231u8, 232u8, 233u8, 234u8, 235u8,
    236u8, 237u8, 238u8, 239u8, 240u8, 241u8, 242u8, 243u8, 244u8, 245u8, 246u8, 248u8, 249u8,
    250u8, 251u8, 252u8, 253u8, 254u8, 255u8, 0u8,
];
pub const G_STR_DELIMITERS: &'static [u8; 8usize] = b"_-|> <.\0";
pub const G_ASCII_DTOSTR_BUF_SIZE: u32 = 39;
pub const G_USEC_PER_SEC: u32 = 1000000;
pub const G_URI_RESERVED_CHARS_GENERIC_DELIMITERS: &'static [u8; 8usize] = b":/?#[]@\0";
pub const G_URI_RESERVED_CHARS_SUBCOMPONENT_DELIMITERS: &'static [u8; 12usize] = b"!$&'()*+,;=\0";
pub const G_URI_RESERVED_CHARS_ALLOWED_IN_PATH_ELEMENT: &'static [u8; 14usize] = b"!$&'()*+,;=:@\0";
pub const G_URI_RESERVED_CHARS_ALLOWED_IN_PATH: &'static [u8; 15usize] = b"!$&'()*+,;=:@/\0";
pub const G_URI_RESERVED_CHARS_ALLOWED_IN_USERINFO: &'static [u8; 13usize] = b"!$&'()*+,;=:\0";
pub const G_ALLOC_ONLY: u32 = 1;
pub const G_ALLOC_AND_FREE: u32 = 2;
pub const G_ALLOCATOR_LIST: u32 = 1;
pub const G_ALLOCATOR_SLIST: u32 = 2;
pub const G_ALLOCATOR_NODE: u32 = 3;
pub const __DARWIN_FD_SETSIZE: u32 = 1024;
pub const __DARWIN_NBBY: u32 = 8;
pub const NBBY: u32 = 8;
pub const FD_SETSIZE: u32 = 1024;
pub const _PTHREAD_MUTEX_SIG_init: u32 = 850045863;
pub const _PTHREAD_ERRORCHECK_MUTEX_SIG_init: u32 = 850045857;
pub const _PTHREAD_RECURSIVE_MUTEX_SIG_init: u32 = 850045858;
pub const _PTHREAD_FIRSTFIT_MUTEX_SIG_init: u32 = 850045859;
pub const _PTHREAD_COND_SIG_init: u32 = 1018212795;
pub const _PTHREAD_ONCE_SIG_init: u32 = 816954554;
pub const _PTHREAD_RWLOCK_SIG_init: u32 = 766030772;
pub const SCHED_OTHER: u32 = 1;
pub const SCHED_FIFO: u32 = 4;
pub const SCHED_RR: u32 = 2;
pub const __SCHED_PARAM_SIZE__: u32 = 4;
pub const QOS_MIN_RELATIVE_PRIORITY: i32 = -15;
pub const PTHREAD_CREATE_JOINABLE: u32 = 1;
pub const PTHREAD_CREATE_DETACHED: u32 = 2;
pub const PTHREAD_INHERIT_SCHED: u32 = 1;
pub const PTHREAD_EXPLICIT_SCHED: u32 = 2;
pub const PTHREAD_CANCEL_ENABLE: u32 = 1;
pub const PTHREAD_CANCEL_DISABLE: u32 = 0;
pub const PTHREAD_CANCEL_DEFERRED: u32 = 2;
pub const PTHREAD_CANCEL_ASYNCHRONOUS: u32 = 0;
pub const PTHREAD_SCOPE_SYSTEM: u32 = 1;
pub const PTHREAD_SCOPE_PROCESS: u32 = 2;
pub const PTHREAD_PROCESS_SHARED: u32 = 1;
pub const PTHREAD_PROCESS_PRIVATE: u32 = 2;
pub const PTHREAD_PRIO_NONE: u32 = 0;
pub const PTHREAD_PRIO_INHERIT: u32 = 1;
pub const PTHREAD_PRIO_PROTECT: u32 = 2;
pub const PTHREAD_MUTEX_NORMAL: u32 = 0;
pub const PTHREAD_MUTEX_ERRORCHECK: u32 = 1;
pub const PTHREAD_MUTEX_RECURSIVE: u32 = 2;
pub const PTHREAD_MUTEX_DEFAULT: u32 = 0;
pub const G_TYPE_FUNDAMENTAL_SHIFT: u32 = 2;
pub const G_TYPE_RESERVED_GLIB_FIRST: u32 = 22;
pub const G_TYPE_RESERVED_GLIB_LAST: u32 = 31;
pub const G_TYPE_RESERVED_BSE_FIRST: u32 = 32;
pub const G_TYPE_RESERVED_BSE_LAST: u32 = 48;
pub const G_TYPE_RESERVED_USER_FIRST: u32 = 49;
pub const G_VALUE_NOCOPY_CONTENTS: u32 = 134217728;
pub const G_PARAM_MASK: u32 = 255;
pub const G_PARAM_USER_SHIFT: u32 = 8;
pub const G_SIGNAL_FLAGS_MASK: u32 = 511;
pub const G_SIGNAL_MATCH_MASK: u32 = 63;
pub const _POSIX_VERSION: u32 = 200112;
pub const _POSIX2_VERSION: u32 = 200112;
pub const F_OK: u32 = 0;
pub const X_OK: u32 = 1;
pub const W_OK: u32 = 2;
pub const R_OK: u32 = 4;
pub const _READ_OK: u32 = 512;
pub const _WRITE_OK: u32 = 1024;
pub const _EXECUTE_OK: u32 = 2048;
pub const _DELETE_OK: u32 = 4096;
pub const _APPEND_OK: u32 = 8192;
pub const _RMFILE_OK: u32 = 16384;
pub const _RATTR_OK: u32 = 32768;
pub const _WATTR_OK: u32 = 65536;
pub const _REXT_OK: u32 = 131072;
pub const _WEXT_OK: u32 = 262144;
pub const _RPERM_OK: u32 = 524288;
pub const _WPERM_OK: u32 = 1048576;
pub const _CHOWN_OK: u32 = 2097152;
pub const _ACCESS_EXTENDED_MASK: u32 = 4193792;
pub const SEEK_SET: u32 = 0;
pub const SEEK_CUR: u32 = 1;
pub const SEEK_END: u32 = 2;
pub const SEEK_HOLE: u32 = 3;
pub const SEEK_DATA: u32 = 4;
pub const L_SET: u32 = 0;
pub const L_INCR: u32 = 1;
pub const L_XTND: u32 = 2;
pub const ACCESSX_MAX_DESCRIPTORS: u32 = 100;
pub const ACCESSX_MAX_TABLESIZE: u32 = 16384;
pub const _PC_LINK_MAX: u32 = 1;
pub const _PC_MAX_CANON: u32 = 2;
pub const _PC_MAX_INPUT: u32 = 3;
pub const _PC_NAME_MAX: u32 = 4;
pub const _PC_PATH_MAX: u32 = 5;
pub const _PC_PIPE_BUF: u32 = 6;
pub const _PC_CHOWN_RESTRICTED: u32 = 7;
pub const _PC_NO_TRUNC: u32 = 8;
pub const _PC_VDISABLE: u32 = 9;
pub const _PC_NAME_CHARS_MAX: u32 = 10;
pub const _PC_CASE_SENSITIVE: u32 = 11;
pub const _PC_CASE_PRESERVING: u32 = 12;
pub const _PC_EXTENDED_SECURITY_NP: u32 = 13;
pub const _PC_AUTH_OPAQUE_NP: u32 = 14;
pub const _PC_2_SYMLINKS: u32 = 15;
pub const _PC_ALLOC_SIZE_MIN: u32 = 16;
pub const _PC_ASYNC_IO: u32 = 17;
pub const _PC_FILESIZEBITS: u32 = 18;
pub const _PC_PRIO_IO: u32 = 19;
pub const _PC_REC_INCR_XFER_SIZE: u32 = 20;
pub const _PC_REC_MAX_XFER_SIZE: u32 = 21;
pub const _PC_REC_MIN_XFER_SIZE: u32 = 22;
pub const _PC_REC_XFER_ALIGN: u32 = 23;
pub const _PC_SYMLINK_MAX: u32 = 24;
pub const _PC_SYNC_IO: u32 = 25;
pub const _PC_XATTR_SIZE_BITS: u32 = 26;
pub const _PC_MIN_HOLE_SIZE: u32 = 27;
pub const _CS_PATH: u32 = 1;
pub const STDIN_FILENO: u32 = 0;
pub const STDOUT_FILENO: u32 = 1;
pub const STDERR_FILENO: u32 = 2;
pub const _XOPEN_VERSION: u32 = 600;
pub const _XOPEN_XCU_VERSION: u32 = 4;
pub const _POSIX_ADVISORY_INFO: i32 = -1;
pub const _POSIX_ASYNCHRONOUS_IO: i32 = -1;
pub const _POSIX_BARRIERS: i32 = -1;
pub const _POSIX_CHOWN_RESTRICTED: u32 = 200112;
pub const _POSIX_CLOCK_SELECTION: i32 = -1;
pub const _POSIX_CPUTIME: i32 = -1;
pub const _POSIX_FSYNC: u32 = 200112;
pub const _POSIX_IPV6: u32 = 200112;
pub const _POSIX_JOB_CONTROL: u32 = 200112;
pub const _POSIX_MAPPED_FILES: u32 = 200112;
pub const _POSIX_MEMLOCK: i32 = -1;
pub const _POSIX_MEMLOCK_RANGE: i32 = -1;
pub const _POSIX_MEMORY_PROTECTION: u32 = 200112;
pub const _POSIX_MESSAGE_PASSING: i32 = -1;
pub const _POSIX_MONOTONIC_CLOCK: i32 = -1;
pub const _POSIX_NO_TRUNC: u32 = 200112;
pub const _POSIX_PRIORITIZED_IO: i32 = -1;
pub const _POSIX_PRIORITY_SCHEDULING: i32 = -1;
pub const _POSIX_RAW_SOCKETS: i32 = -1;
pub const _POSIX_READER_WRITER_LOCKS: u32 = 200112;
pub const _POSIX_REALTIME_SIGNALS: i32 = -1;
pub const _POSIX_REGEXP: u32 = 200112;
pub const _POSIX_SAVED_IDS: u32 = 200112;
pub const _POSIX_SEMAPHORES: i32 = -1;
pub const _POSIX_SHARED_MEMORY_OBJECTS: i32 = -1;
pub const _POSIX_SHELL: u32 = 200112;
pub const _POSIX_SPAWN: i32 = -1;
pub const _POSIX_SPIN_LOCKS: i32 = -1;
pub const _POSIX_SPORADIC_SERVER: i32 = -1;
pub const _POSIX_SYNCHRONIZED_IO: i32 = -1;
pub const _POSIX_THREAD_ATTR_STACKADDR: u32 = 200112;
pub const _POSIX_THREAD_ATTR_STACKSIZE: u32 = 200112;
pub const _POSIX_THREAD_CPUTIME: i32 = -1;
pub const _POSIX_THREAD_PRIO_INHERIT: i32 = -1;
pub const _POSIX_THREAD_PRIO_PROTECT: i32 = -1;
pub const _POSIX_THREAD_PRIORITY_SCHEDULING: i32 = -1;
pub const _POSIX_THREAD_PROCESS_SHARED: u32 = 200112;
pub const _POSIX_THREAD_SAFE_FUNCTIONS: u32 = 200112;
pub const _POSIX_THREAD_SPORADIC_SERVER: i32 = -1;
pub const _POSIX_THREADS: u32 = 200112;
pub const _POSIX_TIMEOUTS: i32 = -1;
pub const _POSIX_TIMERS: i32 = -1;
pub const _POSIX_TRACE: i32 = -1;
pub const _POSIX_TRACE_EVENT_FILTER: i32 = -1;
pub const _POSIX_TRACE_INHERIT: i32 = -1;
pub const _POSIX_TRACE_LOG: i32 = -1;
pub const _POSIX_TYPED_MEMORY_OBJECTS: i32 = -1;
pub const _POSIX2_C_BIND: u32 = 200112;
pub const _POSIX2_C_DEV: u32 = 200112;
pub const _POSIX2_CHAR_TERM: u32 = 200112;
pub const _POSIX2_FORT_DEV: i32 = -1;
pub const _POSIX2_FORT_RUN: u32 = 200112;
pub const _POSIX2_LOCALEDEF: u32 = 200112;
pub const _POSIX2_PBS: i32 = -1;
pub const _POSIX2_PBS_ACCOUNTING: i32 = -1;
pub const _POSIX2_PBS_CHECKPOINT: i32 = -1;
pub const _POSIX2_PBS_LOCATE: i32 = -1;
pub const _POSIX2_PBS_MESSAGE: i32 = -1;
pub const _POSIX2_PBS_TRACK: i32 = -1;
pub const _POSIX2_SW_DEV: u32 = 200112;
pub const _POSIX2_UPE: u32 = 200112;
pub const __ILP32_OFF32: i32 = -1;
pub const __ILP32_OFFBIG: u32 = 1;
pub const __LP64_OFF64: u32 = 1;
pub const __LPBIG_OFFBIG: u32 = 1;
pub const _POSIX_V6_ILP32_OFF32: i32 = -1;
pub const _POSIX_V6_ILP32_OFFBIG: u32 = 1;
pub const _POSIX_V6_LP64_OFF64: u32 = 1;
pub const _POSIX_V6_LPBIG_OFFBIG: u32 = 1;
pub const _POSIX_V7_ILP32_OFF32: i32 = -1;
pub const _POSIX_V7_ILP32_OFFBIG: u32 = 1;
pub const _POSIX_V7_LP64_OFF64: u32 = 1;
pub const _POSIX_V7_LPBIG_OFFBIG: u32 = 1;
pub const _V6_ILP32_OFF32: i32 = -1;
pub const _V6_ILP32_OFFBIG: u32 = 1;
pub const _V6_LP64_OFF64: u32 = 1;
pub const _V6_LPBIG_OFFBIG: u32 = 1;
pub const _XBS5_ILP32_OFF32: i32 = -1;
pub const _XBS5_ILP32_OFFBIG: u32 = 1;
pub const _XBS5_LP64_OFF64: u32 = 1;
pub const _XBS5_LPBIG_OFFBIG: u32 = 1;
pub const _XOPEN_CRYPT: u32 = 1;
pub const _XOPEN_ENH_I18N: u32 = 1;
pub const _XOPEN_LEGACY: i32 = -1;
pub const _XOPEN_REALTIME: i32 = -1;
pub const _XOPEN_REALTIME_THREADS: i32 = -1;
pub const _XOPEN_SHM: u32 = 1;
pub const _XOPEN_STREAMS: i32 = -1;
pub const _XOPEN_UNIX: u32 = 1;
pub const _SC_ARG_MAX: u32 = 1;
pub const _SC_CHILD_MAX: u32 = 2;
pub const _SC_CLK_TCK: u32 = 3;
pub const _SC_NGROUPS_MAX: u32 = 4;
pub const _SC_OPEN_MAX: u32 = 5;
pub const _SC_JOB_CONTROL: u32 = 6;
pub const _SC_SAVED_IDS: u32 = 7;
pub const _SC_VERSION: u32 = 8;
pub const _SC_BC_BASE_MAX: u32 = 9;
pub const _SC_BC_DIM_MAX: u32 = 10;
pub const _SC_BC_SCALE_MAX: u32 = 11;
pub const _SC_BC_STRING_MAX: u32 = 12;
pub const _SC_COLL_WEIGHTS_MAX: u32 = 13;
pub const _SC_EXPR_NEST_MAX: u32 = 14;
pub const _SC_LINE_MAX: u32 = 15;
pub const _SC_RE_DUP_MAX: u32 = 16;
pub const _SC_2_VERSION: u32 = 17;
pub const _SC_2_C_BIND: u32 = 18;
pub const _SC_2_C_DEV: u32 = 19;
pub const _SC_2_CHAR_TERM: u32 = 20;
pub const _SC_2_FORT_DEV: u32 = 21;
pub const _SC_2_FORT_RUN: u32 = 22;
pub const _SC_2_LOCALEDEF: u32 = 23;
pub const _SC_2_SW_DEV: u32 = 24;
pub const _SC_2_UPE: u32 = 25;
pub const _SC_STREAM_MAX: u32 = 26;
pub const _SC_TZNAME_MAX: u32 = 27;
pub const _SC_ASYNCHRONOUS_IO: u32 = 28;
pub const _SC_PAGESIZE: u32 = 29;
pub const _SC_MEMLOCK: u32 = 30;
pub const _SC_MEMLOCK_RANGE: u32 = 31;
pub const _SC_MEMORY_PROTECTION: u32 = 32;
pub const _SC_MESSAGE_PASSING: u32 = 33;
pub const _SC_PRIORITIZED_IO: u32 = 34;
pub const _SC_PRIORITY_SCHEDULING: u32 = 35;
pub const _SC_REALTIME_SIGNALS: u32 = 36;
pub const _SC_SEMAPHORES: u32 = 37;
pub const _SC_FSYNC: u32 = 38;
pub const _SC_SHARED_MEMORY_OBJECTS: u32 = 39;
pub const _SC_SYNCHRONIZED_IO: u32 = 40;
pub const _SC_TIMERS: u32 = 41;
pub const _SC_AIO_LISTIO_MAX: u32 = 42;
pub const _SC_AIO_MAX: u32 = 43;
pub const _SC_AIO_PRIO_DELTA_MAX: u32 = 44;
pub const _SC_DELAYTIMER_MAX: u32 = 45;
pub const _SC_MQ_OPEN_MAX: u32 = 46;
pub const _SC_MAPPED_FILES: u32 = 47;
pub const _SC_RTSIG_MAX: u32 = 48;
pub const _SC_SEM_NSEMS_MAX: u32 = 49;
pub const _SC_SEM_VALUE_MAX: u32 = 50;
pub const _SC_SIGQUEUE_MAX: u32 = 51;
pub const _SC_TIMER_MAX: u32 = 52;
pub const _SC_NPROCESSORS_CONF: u32 = 57;
pub const _SC_NPROCESSORS_ONLN: u32 = 58;
pub const _SC_2_PBS: u32 = 59;
pub const _SC_2_PBS_ACCOUNTING: u32 = 60;
pub const _SC_2_PBS_CHECKPOINT: u32 = 61;
pub const _SC_2_PBS_LOCATE: u32 = 62;
pub const _SC_2_PBS_MESSAGE: u32 = 63;
pub const _SC_2_PBS_TRACK: u32 = 64;
pub const _SC_ADVISORY_INFO: u32 = 65;
pub const _SC_BARRIERS: u32 = 66;
pub const _SC_CLOCK_SELECTION: u32 = 67;
pub const _SC_CPUTIME: u32 = 68;
pub const _SC_FILE_LOCKING: u32 = 69;
pub const _SC_GETGR_R_SIZE_MAX: u32 = 70;
pub const _SC_GETPW_R_SIZE_MAX: u32 = 71;
pub const _SC_HOST_NAME_MAX: u32 = 72;
pub const _SC_LOGIN_NAME_MAX: u32 = 73;
pub const _SC_MONOTONIC_CLOCK: u32 = 74;
pub const _SC_MQ_PRIO_MAX: u32 = 75;
pub const _SC_READER_WRITER_LOCKS: u32 = 76;
pub const _SC_REGEXP: u32 = 77;
pub const _SC_SHELL: u32 = 78;
pub const _SC_SPAWN: u32 = 79;
pub const _SC_SPIN_LOCKS: u32 = 80;
pub const _SC_SPORADIC_SERVER: u32 = 81;
pub const _SC_THREAD_ATTR_STACKADDR: u32 = 82;
pub const _SC_THREAD_ATTR_STACKSIZE: u32 = 83;
pub const _SC_THREAD_CPUTIME: u32 = 84;
pub const _SC_THREAD_DESTRUCTOR_ITERATIONS: u32 = 85;
pub const _SC_THREAD_KEYS_MAX: u32 = 86;
pub const _SC_THREAD_PRIO_INHERIT: u32 = 87;
pub const _SC_THREAD_PRIO_PROTECT: u32 = 88;
pub const _SC_THREAD_PRIORITY_SCHEDULING: u32 = 89;
pub const _SC_THREAD_PROCESS_SHARED: u32 = 90;
pub const _SC_THREAD_SAFE_FUNCTIONS: u32 = 91;
pub const _SC_THREAD_SPORADIC_SERVER: u32 = 92;
pub const _SC_THREAD_STACK_MIN: u32 = 93;
pub const _SC_THREAD_THREADS_MAX: u32 = 94;
pub const _SC_TIMEOUTS: u32 = 95;
pub const _SC_THREADS: u32 = 96;
pub const _SC_TRACE: u32 = 97;
pub const _SC_TRACE_EVENT_FILTER: u32 = 98;
pub const _SC_TRACE_INHERIT: u32 = 99;
pub const _SC_TRACE_LOG: u32 = 100;
pub const _SC_TTY_NAME_MAX: u32 = 101;
pub const _SC_TYPED_MEMORY_OBJECTS: u32 = 102;
pub const _SC_V6_ILP32_OFF32: u32 = 103;
pub const _SC_V6_ILP32_OFFBIG: u32 = 104;
pub const _SC_V6_LP64_OFF64: u32 = 105;
pub const _SC_V6_LPBIG_OFFBIG: u32 = 106;
pub const _SC_IPV6: u32 = 118;
pub const _SC_RAW_SOCKETS: u32 = 119;
pub const _SC_SYMLOOP_MAX: u32 = 120;
pub const _SC_ATEXIT_MAX: u32 = 107;
pub const _SC_IOV_MAX: u32 = 56;
pub const _SC_PAGE_SIZE: u32 = 29;
pub const _SC_XOPEN_CRYPT: u32 = 108;
pub const _SC_XOPEN_ENH_I18N: u32 = 109;
pub const _SC_XOPEN_LEGACY: u32 = 110;
pub const _SC_XOPEN_REALTIME: u32 = 111;
pub const _SC_XOPEN_REALTIME_THREADS: u32 = 112;
pub const _SC_XOPEN_SHM: u32 = 113;
pub const _SC_XOPEN_STREAMS: u32 = 114;
pub const _SC_XOPEN_UNIX: u32 = 115;
pub const _SC_XOPEN_VERSION: u32 = 116;
pub const _SC_XOPEN_XCU_VERSION: u32 = 121;
pub const _SC_XBS5_ILP32_OFF32: u32 = 122;
pub const _SC_XBS5_ILP32_OFFBIG: u32 = 123;
pub const _SC_XBS5_LP64_OFF64: u32 = 124;
pub const _SC_XBS5_LPBIG_OFFBIG: u32 = 125;
pub const _SC_SS_REPL_MAX: u32 = 126;
pub const _SC_TRACE_EVENT_NAME_MAX: u32 = 127;
pub const _SC_TRACE_NAME_MAX: u32 = 128;
pub const _SC_TRACE_SYS_MAX: u32 = 129;
pub const _SC_TRACE_USER_EVENT_MAX: u32 = 130;
pub const _SC_PASS_MAX: u32 = 131;
pub const _SC_PHYS_PAGES: u32 = 200;
pub const _CS_POSIX_V6_ILP32_OFF32_CFLAGS: u32 = 2;
pub const _CS_POSIX_V6_ILP32_OFF32_LDFLAGS: u32 = 3;
pub const _CS_POSIX_V6_ILP32_OFF32_LIBS: u32 = 4;
pub const _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS: u32 = 5;
pub const _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS: u32 = 6;
pub const _CS_POSIX_V6_ILP32_OFFBIG_LIBS: u32 = 7;
pub const _CS_POSIX_V6_LP64_OFF64_CFLAGS: u32 = 8;
pub const _CS_POSIX_V6_LP64_OFF64_LDFLAGS: u32 = 9;
pub const _CS_POSIX_V6_LP64_OFF64_LIBS: u32 = 10;
pub const _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS: u32 = 11;
pub const _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS: u32 = 12;
pub const _CS_POSIX_V6_LPBIG_OFFBIG_LIBS: u32 = 13;
pub const _CS_POSIX_V6_WIDTH_RESTRICTED_ENVS: u32 = 14;
pub const _CS_XBS5_ILP32_OFF32_CFLAGS: u32 = 20;
pub const _CS_XBS5_ILP32_OFF32_LDFLAGS: u32 = 21;
pub const _CS_XBS5_ILP32_OFF32_LIBS: u32 = 22;
pub const _CS_XBS5_ILP32_OFF32_LINTFLAGS: u32 = 23;
pub const _CS_XBS5_ILP32_OFFBIG_CFLAGS: u32 = 24;
pub const _CS_XBS5_ILP32_OFFBIG_LDFLAGS: u32 = 25;
pub const _CS_XBS5_ILP32_OFFBIG_LIBS: u32 = 26;
pub const _CS_XBS5_ILP32_OFFBIG_LINTFLAGS: u32 = 27;
pub const _CS_XBS5_LP64_OFF64_CFLAGS: u32 = 28;
pub const _CS_XBS5_LP64_OFF64_LDFLAGS: u32 = 29;
pub const _CS_XBS5_LP64_OFF64_LIBS: u32 = 30;
pub const _CS_XBS5_LP64_OFF64_LINTFLAGS: u32 = 31;
pub const _CS_XBS5_LPBIG_OFFBIG_CFLAGS: u32 = 32;
pub const _CS_XBS5_LPBIG_OFFBIG_LDFLAGS: u32 = 33;
pub const _CS_XBS5_LPBIG_OFFBIG_LIBS: u32 = 34;
pub const _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS: u32 = 35;
pub const _CS_DARWIN_USER_DIR: u32 = 65536;
pub const _CS_DARWIN_USER_TEMP_DIR: u32 = 65537;
pub const _CS_DARWIN_USER_CACHE_DIR: u32 = 65538;
pub const F_ULOCK: u32 = 0;
pub const F_LOCK: u32 = 1;
pub const F_TLOCK: u32 = 2;
pub const F_TEST: u32 = 3;
pub const __CTERMID_DEFINED: u32 = 1;
pub const SYNC_VOLUME_FULLSYNC: u32 = 1;
pub const SYNC_VOLUME_WAIT: u32 = 2;
pub const G_FILE_ATTRIBUTE_STANDARD_TYPE: &'static [u8; 15usize] = b"standard::type\0";
pub const G_FILE_ATTRIBUTE_STANDARD_IS_HIDDEN: &'static [u8; 20usize] = b"standard::is-hidden\0";
pub const G_FILE_ATTRIBUTE_STANDARD_IS_BACKUP: &'static [u8; 20usize] = b"standard::is-backup\0";
pub const G_FILE_ATTRIBUTE_STANDARD_IS_SYMLINK: &'static [u8; 21usize] = b"standard::is-symlink\0";
pub const G_FILE_ATTRIBUTE_STANDARD_IS_VIRTUAL: &'static [u8; 21usize] = b"standard::is-virtual\0";
pub const G_FILE_ATTRIBUTE_STANDARD_IS_VOLATILE: &'static [u8; 22usize] =
    b"standard::is-volatile\0";
pub const G_FILE_ATTRIBUTE_STANDARD_NAME: &'static [u8; 15usize] = b"standard::name\0";
pub const G_FILE_ATTRIBUTE_STANDARD_DISPLAY_NAME: &'static [u8; 23usize] =
    b"standard::display-name\0";
pub const G_FILE_ATTRIBUTE_STANDARD_EDIT_NAME: &'static [u8; 20usize] = b"standard::edit-name\0";
pub const G_FILE_ATTRIBUTE_STANDARD_COPY_NAME: &'static [u8; 20usize] = b"standard::copy-name\0";
pub const G_FILE_ATTRIBUTE_STANDARD_DESCRIPTION: &'static [u8; 22usize] =
    b"standard::description\0";
pub const G_FILE_ATTRIBUTE_STANDARD_ICON: &'static [u8; 15usize] = b"standard::icon\0";
pub const G_FILE_ATTRIBUTE_STANDARD_SYMBOLIC_ICON: &'static [u8; 24usize] =
    b"standard::symbolic-icon\0";
pub const G_FILE_ATTRIBUTE_STANDARD_CONTENT_TYPE: &'static [u8; 23usize] =
    b"standard::content-type\0";
pub const G_FILE_ATTRIBUTE_STANDARD_FAST_CONTENT_TYPE: &'static [u8; 28usize] =
    b"standard::fast-content-type\0";
pub const G_FILE_ATTRIBUTE_STANDARD_SIZE: &'static [u8; 15usize] = b"standard::size\0";
pub const G_FILE_ATTRIBUTE_STANDARD_ALLOCATED_SIZE: &'static [u8; 25usize] =
    b"standard::allocated-size\0";
pub const G_FILE_ATTRIBUTE_STANDARD_SYMLINK_TARGET: &'static [u8; 25usize] =
    b"standard::symlink-target\0";
pub const G_FILE_ATTRIBUTE_STANDARD_TARGET_URI: &'static [u8; 21usize] = b"standard::target-uri\0";
pub const G_FILE_ATTRIBUTE_STANDARD_SORT_ORDER: &'static [u8; 21usize] = b"standard::sort-order\0";
pub const G_FILE_ATTRIBUTE_ETAG_VALUE: &'static [u8; 12usize] = b"etag::value\0";
pub const G_FILE_ATTRIBUTE_ID_FILE: &'static [u8; 9usize] = b"id::file\0";
pub const G_FILE_ATTRIBUTE_ID_FILESYSTEM: &'static [u8; 15usize] = b"id::filesystem\0";
pub const G_FILE_ATTRIBUTE_ACCESS_CAN_READ: &'static [u8; 17usize] = b"access::can-read\0";
pub const G_FILE_ATTRIBUTE_ACCESS_CAN_WRITE: &'static [u8; 18usize] = b"access::can-write\0";
pub const G_FILE_ATTRIBUTE_ACCESS_CAN_EXECUTE: &'static [u8; 20usize] = b"access::can-execute\0";
pub const G_FILE_ATTRIBUTE_ACCESS_CAN_DELETE: &'static [u8; 19usize] = b"access::can-delete\0";
pub const G_FILE_ATTRIBUTE_ACCESS_CAN_TRASH: &'static [u8; 18usize] = b"access::can-trash\0";
pub const G_FILE_ATTRIBUTE_ACCESS_CAN_RENAME: &'static [u8; 19usize] = b"access::can-rename\0";
pub const G_FILE_ATTRIBUTE_MOUNTABLE_CAN_MOUNT: &'static [u8; 21usize] = b"mountable::can-mount\0";
pub const G_FILE_ATTRIBUTE_MOUNTABLE_CAN_UNMOUNT: &'static [u8; 23usize] =
    b"mountable::can-unmount\0";
pub const G_FILE_ATTRIBUTE_MOUNTABLE_CAN_EJECT: &'static [u8; 21usize] = b"mountable::can-eject\0";
pub const G_FILE_ATTRIBUTE_MOUNTABLE_UNIX_DEVICE: &'static [u8; 23usize] =
    b"mountable::unix-device\0";
pub const G_FILE_ATTRIBUTE_MOUNTABLE_UNIX_DEVICE_FILE: &'static [u8; 28usize] =
    b"mountable::unix-device-file\0";
pub const G_FILE_ATTRIBUTE_MOUNTABLE_HAL_UDI: &'static [u8; 19usize] = b"mountable::hal-udi\0";
pub const G_FILE_ATTRIBUTE_MOUNTABLE_CAN_START: &'static [u8; 21usize] = b"mountable::can-start\0";
pub const G_FILE_ATTRIBUTE_MOUNTABLE_CAN_START_DEGRADED: &'static [u8; 30usize] =
    b"mountable::can-start-degraded\0";
pub const G_FILE_ATTRIBUTE_MOUNTABLE_CAN_STOP: &'static [u8; 20usize] = b"mountable::can-stop\0";
pub const G_FILE_ATTRIBUTE_MOUNTABLE_START_STOP_TYPE: &'static [u8; 27usize] =
    b"mountable::start-stop-type\0";
pub const G_FILE_ATTRIBUTE_MOUNTABLE_CAN_POLL: &'static [u8; 20usize] = b"mountable::can-poll\0";
pub const G_FILE_ATTRIBUTE_MOUNTABLE_IS_MEDIA_CHECK_AUTOMATIC: &'static [u8; 36usize] =
    b"mountable::is-media-check-automatic\0";
pub const G_FILE_ATTRIBUTE_TIME_MODIFIED: &'static [u8; 15usize] = b"time::modified\0";
pub const G_FILE_ATTRIBUTE_TIME_MODIFIED_USEC: &'static [u8; 20usize] = b"time::modified-usec\0";
pub const G_FILE_ATTRIBUTE_TIME_ACCESS: &'static [u8; 13usize] = b"time::access\0";
pub const G_FILE_ATTRIBUTE_TIME_ACCESS_USEC: &'static [u8; 18usize] = b"time::access-usec\0";
pub const G_FILE_ATTRIBUTE_TIME_CHANGED: &'static [u8; 14usize] = b"time::changed\0";
pub const G_FILE_ATTRIBUTE_TIME_CHANGED_USEC: &'static [u8; 19usize] = b"time::changed-usec\0";
pub const G_FILE_ATTRIBUTE_TIME_CREATED: &'static [u8; 14usize] = b"time::created\0";
pub const G_FILE_ATTRIBUTE_TIME_CREATED_USEC: &'static [u8; 19usize] = b"time::created-usec\0";
pub const G_FILE_ATTRIBUTE_UNIX_DEVICE: &'static [u8; 13usize] = b"unix::device\0";
pub const G_FILE_ATTRIBUTE_UNIX_INODE: &'static [u8; 12usize] = b"unix::inode\0";
pub const G_FILE_ATTRIBUTE_UNIX_MODE: &'static [u8; 11usize] = b"unix::mode\0";
pub const G_FILE_ATTRIBUTE_UNIX_NLINK: &'static [u8; 12usize] = b"unix::nlink\0";
pub const G_FILE_ATTRIBUTE_UNIX_UID: &'static [u8; 10usize] = b"unix::uid\0";
pub const G_FILE_ATTRIBUTE_UNIX_GID: &'static [u8; 10usize] = b"unix::gid\0";
pub const G_FILE_ATTRIBUTE_UNIX_RDEV: &'static [u8; 11usize] = b"unix::rdev\0";
pub const G_FILE_ATTRIBUTE_UNIX_BLOCK_SIZE: &'static [u8; 17usize] = b"unix::block-size\0";
pub const G_FILE_ATTRIBUTE_UNIX_BLOCKS: &'static [u8; 13usize] = b"unix::blocks\0";
pub const G_FILE_ATTRIBUTE_UNIX_IS_MOUNTPOINT: &'static [u8; 20usize] = b"unix::is-mountpoint\0";
pub const G_FILE_ATTRIBUTE_DOS_IS_ARCHIVE: &'static [u8; 16usize] = b"dos::is-archive\0";
pub const G_FILE_ATTRIBUTE_DOS_IS_SYSTEM: &'static [u8; 15usize] = b"dos::is-system\0";
pub const G_FILE_ATTRIBUTE_OWNER_USER: &'static [u8; 12usize] = b"owner::user\0";
pub const G_FILE_ATTRIBUTE_OWNER_USER_REAL: &'static [u8; 17usize] = b"owner::user-real\0";
pub const G_FILE_ATTRIBUTE_OWNER_GROUP: &'static [u8; 13usize] = b"owner::group\0";
pub const G_FILE_ATTRIBUTE_THUMBNAIL_PATH: &'static [u8; 16usize] = b"thumbnail::path\0";
pub const G_FILE_ATTRIBUTE_THUMBNAILING_FAILED: &'static [u8; 18usize] = b"thumbnail::failed\0";
pub const G_FILE_ATTRIBUTE_THUMBNAIL_IS_VALID: &'static [u8; 20usize] = b"thumbnail::is-valid\0";
pub const G_FILE_ATTRIBUTE_PREVIEW_ICON: &'static [u8; 14usize] = b"preview::icon\0";
pub const G_FILE_ATTRIBUTE_FILESYSTEM_SIZE: &'static [u8; 17usize] = b"filesystem::size\0";
pub const G_FILE_ATTRIBUTE_FILESYSTEM_FREE: &'static [u8; 17usize] = b"filesystem::free\0";
pub const G_FILE_ATTRIBUTE_FILESYSTEM_USED: &'static [u8; 17usize] = b"filesystem::used\0";
pub const G_FILE_ATTRIBUTE_FILESYSTEM_TYPE: &'static [u8; 17usize] = b"filesystem::type\0";
pub const G_FILE_ATTRIBUTE_FILESYSTEM_READONLY: &'static [u8; 21usize] = b"filesystem::readonly\0";
pub const G_FILE_ATTRIBUTE_FILESYSTEM_USE_PREVIEW: &'static [u8; 24usize] =
    b"filesystem::use-preview\0";
pub const G_FILE_ATTRIBUTE_FILESYSTEM_REMOTE: &'static [u8; 19usize] = b"filesystem::remote\0";
pub const G_FILE_ATTRIBUTE_GVFS_BACKEND: &'static [u8; 14usize] = b"gvfs::backend\0";
pub const G_FILE_ATTRIBUTE_SELINUX_CONTEXT: &'static [u8; 17usize] = b"selinux::context\0";
pub const G_FILE_ATTRIBUTE_TRASH_ITEM_COUNT: &'static [u8; 18usize] = b"trash::item-count\0";
pub const G_FILE_ATTRIBUTE_TRASH_ORIG_PATH: &'static [u8; 17usize] = b"trash::orig-path\0";
pub const G_FILE_ATTRIBUTE_TRASH_DELETION_DATE: &'static [u8; 21usize] = b"trash::deletion-date\0";
pub const G_FILE_ATTRIBUTE_RECENT_MODIFIED: &'static [u8; 17usize] = b"recent::modified\0";
pub const G_VOLUME_MONITOR_EXTENSION_POINT_NAME: &'static [u8; 19usize] = b"gio-volume-monitor\0";
pub const G_NATIVE_VOLUME_MONITOR_EXTENSION_POINT_NAME: &'static [u8; 26usize] =
    b"gio-native-volume-monitor\0";
pub const G_NETWORK_MONITOR_EXTENSION_POINT_NAME: &'static [u8; 20usize] = b"gio-network-monitor\0";
pub const G_PROXY_EXTENSION_POINT_NAME: &'static [u8; 10usize] = b"gio-proxy\0";
pub const G_PROXY_RESOLVER_EXTENSION_POINT_NAME: &'static [u8; 19usize] = b"gio-proxy-resolver\0";
pub const G_TLS_BACKEND_EXTENSION_POINT_NAME: &'static [u8; 16usize] = b"gio-tls-backend\0";
pub const G_TLS_DATABASE_PURPOSE_AUTHENTICATE_SERVER: &'static [u8; 18usize] =
    b"1.3.6.1.5.5.7.3.1\0";
pub const G_TLS_DATABASE_PURPOSE_AUTHENTICATE_CLIENT: &'static [u8; 18usize] =
    b"1.3.6.1.5.5.7.3.2\0";
pub const G_VFS_EXTENSION_POINT_NAME: &'static [u8; 8usize] = b"gio-vfs\0";
pub const G_VOLUME_IDENTIFIER_KIND_HAL_UDI: &'static [u8; 8usize] = b"hal-udi\0";
pub const G_VOLUME_IDENTIFIER_KIND_UNIX_DEVICE: &'static [u8; 12usize] = b"unix-device\0";
pub const G_VOLUME_IDENTIFIER_KIND_LABEL: &'static [u8; 6usize] = b"label\0";
pub const G_VOLUME_IDENTIFIER_KIND_UUID: &'static [u8; 5usize] = b"uuid\0";
pub const G_VOLUME_IDENTIFIER_KIND_NFS_MOUNT: &'static [u8; 10usize] = b"nfs-mount\0";
pub const G_VOLUME_IDENTIFIER_KIND_CLASS: &'static [u8; 6usize] = b"class\0";
pub const G_MENU_ATTRIBUTE_ACTION: &'static [u8; 7usize] = b"action\0";
pub const G_MENU_ATTRIBUTE_ACTION_NAMESPACE: &'static [u8; 17usize] = b"action-namespace\0";
pub const G_MENU_ATTRIBUTE_TARGET: &'static [u8; 7usize] = b"target\0";
pub const G_MENU_ATTRIBUTE_LABEL: &'static [u8; 6usize] = b"label\0";
pub const G_MENU_ATTRIBUTE_ICON: &'static [u8; 5usize] = b"icon\0";
pub const G_MENU_LINK_SUBMENU: &'static [u8; 8usize] = b"submenu\0";
pub const G_MENU_LINK_SECTION: &'static [u8; 8usize] = b"section\0";
pub const KEV_INET_SUBCLASS: u32 = 1;
pub const KEV_INET_NEW_ADDR: u32 = 1;
pub const KEV_INET_CHANGED_ADDR: u32 = 2;
pub const KEV_INET_ADDR_DELETED: u32 = 3;
pub const KEV_INET_SIFDSTADDR: u32 = 4;
pub const KEV_INET_SIFBRDADDR: u32 = 5;
pub const KEV_INET_SIFNETMASK: u32 = 6;
pub const KEV_INET_ARPCOLLISION: u32 = 7;
pub const KEV_INET_PORTINUSE: u32 = 8;
pub const KEV_INET_ARPRTRFAILURE: u32 = 9;
pub const KEV_INET_ARPRTRALIVE: u32 = 10;
pub const KEV_DL_SUBCLASS: u32 = 2;
pub const KEV_DL_SIFFLAGS: u32 = 1;
pub const KEV_DL_SIFMETRICS: u32 = 2;
pub const KEV_DL_SIFMTU: u32 = 3;
pub const KEV_DL_SIFPHYS: u32 = 4;
pub const KEV_DL_SIFMEDIA: u32 = 5;
pub const KEV_DL_SIFGENERIC: u32 = 6;
pub const KEV_DL_ADDMULTI: u32 = 7;
pub const KEV_DL_DELMULTI: u32 = 8;
pub const KEV_DL_IF_ATTACHED: u32 = 9;
pub const KEV_DL_IF_DETACHING: u32 = 10;
pub const KEV_DL_IF_DETACHED: u32 = 11;
pub const KEV_DL_LINK_OFF: u32 = 12;
pub const KEV_DL_LINK_ON: u32 = 13;
pub const KEV_DL_PROTO_ATTACHED: u32 = 14;
pub const KEV_DL_PROTO_DETACHED: u32 = 15;
pub const KEV_DL_LINK_ADDRESS_CHANGED: u32 = 16;
pub const KEV_DL_WAKEFLAGS_CHANGED: u32 = 17;
pub const KEV_DL_IF_IDLE_ROUTE_REFCNT: u32 = 18;
pub const KEV_DL_IFCAP_CHANGED: u32 = 19;
pub const KEV_DL_LINK_QUALITY_METRIC_CHANGED: u32 = 20;
pub const KEV_DL_NODE_PRESENCE: u32 = 21;
pub const KEV_DL_NODE_ABSENCE: u32 = 22;
pub const KEV_DL_MASTER_ELECTED: u32 = 23;
pub const KEV_DL_ISSUES: u32 = 24;
pub const KEV_DL_IFDELEGATE_CHANGED: u32 = 25;
pub const KEV_DL_AWDL_RESTRICTED: u32 = 26;
pub const KEV_DL_AWDL_UNRESTRICTED: u32 = 27;
pub const KEV_DL_RRC_STATE_CHANGED: u32 = 28;
pub const KEV_DL_QOS_MODE_CHANGED: u32 = 29;
pub const KEV_INET6_SUBCLASS: u32 = 6;
pub const KEV_INET6_NEW_USER_ADDR: u32 = 1;
pub const KEV_INET6_CHANGED_ADDR: u32 = 2;
pub const KEV_INET6_ADDR_DELETED: u32 = 3;
pub const KEV_INET6_NEW_LL_ADDR: u32 = 4;
pub const KEV_INET6_NEW_RTADV_ADDR: u32 = 5;
pub const KEV_INET6_DEFROUTER: u32 = 6;
pub const SOCK_STREAM: u32 = 1;
pub const SOCK_DGRAM: u32 = 2;
pub const SOCK_RAW: u32 = 3;
pub const SOCK_RDM: u32 = 4;
pub const SOCK_SEQPACKET: u32 = 5;
pub const SO_DEBUG: u32 = 1;
pub const SO_ACCEPTCONN: u32 = 2;
pub const SO_REUSEADDR: u32 = 4;
pub const SO_KEEPALIVE: u32 = 8;
pub const SO_DONTROUTE: u32 = 16;
pub const SO_BROADCAST: u32 = 32;
pub const SO_USELOOPBACK: u32 = 64;
pub const SO_LINGER: u32 = 128;
pub const SO_OOBINLINE: u32 = 256;
pub const SO_REUSEPORT: u32 = 512;
pub const SO_TIMESTAMP: u32 = 1024;
pub const SO_TIMESTAMP_MONOTONIC: u32 = 2048;
pub const SO_DONTTRUNC: u32 = 8192;
pub const SO_WANTMORE: u32 = 16384;
pub const SO_WANTOOBFLAG: u32 = 32768;
pub const SO_SNDBUF: u32 = 4097;
pub const SO_RCVBUF: u32 = 4098;
pub const SO_SNDLOWAT: u32 = 4099;
pub const SO_RCVLOWAT: u32 = 4100;
pub const SO_SNDTIMEO: u32 = 4101;
pub const SO_RCVTIMEO: u32 = 4102;
pub const SO_ERROR: u32 = 4103;
pub const SO_TYPE: u32 = 4104;
pub const SO_LABEL: u32 = 4112;
pub const SO_PEERLABEL: u32 = 4113;
pub const SO_NREAD: u32 = 4128;
pub const SO_NKE: u32 = 4129;
pub const SO_NOSIGPIPE: u32 = 4130;
pub const SO_NOADDRERR: u32 = 4131;
pub const SO_NWRITE: u32 = 4132;
pub const SO_REUSESHAREUID: u32 = 4133;
pub const SO_NOTIFYCONFLICT: u32 = 4134;
pub const SO_UPCALLCLOSEWAIT: u32 = 4135;
pub const SO_LINGER_SEC: u32 = 4224;
pub const SO_RANDOMPORT: u32 = 4226;
pub const SO_NP_EXTENSIONS: u32 = 4227;
pub const SO_NUMRCVPKT: u32 = 4370;
pub const SO_NET_SERVICE_TYPE: u32 = 4374;
pub const NET_SERVICE_TYPE_BE: u32 = 0;
pub const NET_SERVICE_TYPE_BK: u32 = 1;
pub const NET_SERVICE_TYPE_SIG: u32 = 2;
pub const NET_SERVICE_TYPE_VI: u32 = 3;
pub const NET_SERVICE_TYPE_VO: u32 = 4;
pub const NET_SERVICE_TYPE_RV: u32 = 5;
pub const NET_SERVICE_TYPE_AV: u32 = 6;
pub const NET_SERVICE_TYPE_OAM: u32 = 7;
pub const NET_SERVICE_TYPE_RD: u32 = 8;
pub const SO_NETSVC_MARKING_LEVEL: u32 = 4377;
pub const NETSVC_MRKNG_UNKNOWN: u32 = 0;
pub const NETSVC_MRKNG_LVL_L2: u32 = 1;
pub const NETSVC_MRKNG_LVL_L3L2_ALL: u32 = 2;
pub const NETSVC_MRKNG_LVL_L3L2_BK: u32 = 3;
pub const SAE_ASSOCID_ANY: u32 = 0;
pub const SAE_CONNID_ANY: u32 = 0;
pub const CONNECT_RESUME_ON_READ_WRITE: u32 = 1;
pub const CONNECT_DATA_IDEMPOTENT: u32 = 2;
pub const CONNECT_DATA_AUTHENTICATED: u32 = 4;
pub const SONPX_SETOPTSHUT: u32 = 1;
pub const SOL_SOCKET: u32 = 65535;
pub const AF_UNSPEC: u32 = 0;
pub const AF_UNIX: u32 = 1;
pub const AF_LOCAL: u32 = 1;
pub const AF_INET: u32 = 2;
pub const AF_IMPLINK: u32 = 3;
pub const AF_PUP: u32 = 4;
pub const AF_CHAOS: u32 = 5;
pub const AF_NS: u32 = 6;
pub const AF_ISO: u32 = 7;
pub const AF_OSI: u32 = 7;
pub const AF_ECMA: u32 = 8;
pub const AF_DATAKIT: u32 = 9;
pub const AF_CCITT: u32 = 10;
pub const AF_SNA: u32 = 11;
pub const AF_DECnet: u32 = 12;
pub const AF_DLI: u32 = 13;
pub const AF_LAT: u32 = 14;
pub const AF_HYLINK: u32 = 15;
pub const AF_APPLETALK: u32 = 16;
pub const AF_ROUTE: u32 = 17;
pub const AF_LINK: u32 = 18;
pub const pseudo_AF_XTP: u32 = 19;
pub const AF_COIP: u32 = 20;
pub const AF_CNT: u32 = 21;
pub const pseudo_AF_RTIP: u32 = 22;
pub const AF_IPX: u32 = 23;
pub const AF_SIP: u32 = 24;
pub const pseudo_AF_PIP: u32 = 25;
pub const AF_NDRV: u32 = 27;
pub const AF_ISDN: u32 = 28;
pub const AF_E164: u32 = 28;
pub const pseudo_AF_KEY: u32 = 29;
pub const AF_INET6: u32 = 30;
pub const AF_NATM: u32 = 31;
pub const AF_SYSTEM: u32 = 32;
pub const AF_NETBIOS: u32 = 33;
pub const AF_PPP: u32 = 34;
pub const pseudo_AF_HDRCMPLT: u32 = 35;
pub const AF_RESERVED_36: u32 = 36;
pub const AF_IEEE80211: u32 = 37;
pub const AF_UTUN: u32 = 38;
pub const AF_MAX: u32 = 40;
pub const SOCK_MAXADDRLEN: u32 = 255;
pub const _SS_MAXSIZE: u32 = 128;
pub const PF_UNSPEC: u32 = 0;
pub const PF_LOCAL: u32 = 1;
pub const PF_UNIX: u32 = 1;
pub const PF_INET: u32 = 2;
pub const PF_IMPLINK: u32 = 3;
pub const PF_PUP: u32 = 4;
pub const PF_CHAOS: u32 = 5;
pub const PF_NS: u32 = 6;
pub const PF_ISO: u32 = 7;
pub const PF_OSI: u32 = 7;
pub const PF_ECMA: u32 = 8;
pub const PF_DATAKIT: u32 = 9;
pub const PF_CCITT: u32 = 10;
pub const PF_SNA: u32 = 11;
pub const PF_DECnet: u32 = 12;
pub const PF_DLI: u32 = 13;
pub const PF_LAT: u32 = 14;
pub const PF_HYLINK: u32 = 15;
pub const PF_APPLETALK: u32 = 16;
pub const PF_ROUTE: u32 = 17;
pub const PF_LINK: u32 = 18;
pub const PF_XTP: u32 = 19;
pub const PF_COIP: u32 = 20;
pub const PF_CNT: u32 = 21;
pub const PF_SIP: u32 = 24;
pub const PF_IPX: u32 = 23;
pub const PF_RTIP: u32 = 22;
pub const PF_PIP: u32 = 25;
pub const PF_NDRV: u32 = 27;
pub const PF_ISDN: u32 = 28;
pub const PF_KEY: u32 = 29;
pub const PF_INET6: u32 = 30;
pub const PF_NATM: u32 = 31;
pub const PF_SYSTEM: u32 = 32;
pub const PF_NETBIOS: u32 = 33;
pub const PF_PPP: u32 = 34;
pub const PF_RESERVED_36: u32 = 36;
pub const PF_UTUN: u32 = 38;
pub const PF_MAX: u32 = 40;
pub const NET_MAXID: u32 = 40;
pub const NET_RT_DUMP: u32 = 1;
pub const NET_RT_FLAGS: u32 = 2;
pub const NET_RT_IFLIST: u32 = 3;
pub const NET_RT_STAT: u32 = 4;
pub const NET_RT_TRASH: u32 = 5;
pub const NET_RT_IFLIST2: u32 = 6;
pub const NET_RT_DUMP2: u32 = 7;
pub const NET_RT_MAXID: u32 = 10;
pub const SOMAXCONN: u32 = 128;
pub const MSG_OOB: u32 = 1;
pub const MSG_PEEK: u32 = 2;
pub const MSG_DONTROUTE: u32 = 4;
pub const MSG_EOR: u32 = 8;
pub const MSG_TRUNC: u32 = 16;
pub const MSG_CTRUNC: u32 = 32;
pub const MSG_WAITALL: u32 = 64;
pub const MSG_DONTWAIT: u32 = 128;
pub const MSG_EOF: u32 = 256;
pub const MSG_WAITSTREAM: u32 = 512;
pub const MSG_FLUSH: u32 = 1024;
pub const MSG_HOLD: u32 = 2048;
pub const MSG_SEND: u32 = 4096;
pub const MSG_HAVEMORE: u32 = 8192;
pub const MSG_RCVMORE: u32 = 16384;
pub const MSG_NEEDSA: u32 = 65536;
pub const SCM_RIGHTS: u32 = 1;
pub const SCM_TIMESTAMP: u32 = 2;
pub const SCM_CREDS: u32 = 3;
pub const SCM_TIMESTAMP_MONOTONIC: u32 = 4;
pub const SHUT_RD: u32 = 0;
pub const SHUT_WR: u32 = 1;
pub const SHUT_RDWR: u32 = 2;
pub const IPPROTO_IP: u32 = 0;
pub const IPPROTO_HOPOPTS: u32 = 0;
pub const IPPROTO_ICMP: u32 = 1;
pub const IPPROTO_IGMP: u32 = 2;
pub const IPPROTO_GGP: u32 = 3;
pub const IPPROTO_IPV4: u32 = 4;
pub const IPPROTO_IPIP: u32 = 4;
pub const IPPROTO_TCP: u32 = 6;
pub const IPPROTO_ST: u32 = 7;
pub const IPPROTO_EGP: u32 = 8;
pub const IPPROTO_PIGP: u32 = 9;
pub const IPPROTO_RCCMON: u32 = 10;
pub const IPPROTO_NVPII: u32 = 11;
pub const IPPROTO_PUP: u32 = 12;
pub const IPPROTO_ARGUS: u32 = 13;
pub const IPPROTO_EMCON: u32 = 14;
pub const IPPROTO_XNET: u32 = 15;
pub const IPPROTO_CHAOS: u32 = 16;
pub const IPPROTO_UDP: u32 = 17;
pub const IPPROTO_MUX: u32 = 18;
pub const IPPROTO_MEAS: u32 = 19;
pub const IPPROTO_HMP: u32 = 20;
pub const IPPROTO_PRM: u32 = 21;
pub const IPPROTO_IDP: u32 = 22;
pub const IPPROTO_TRUNK1: u32 = 23;
pub const IPPROTO_TRUNK2: u32 = 24;
pub const IPPROTO_LEAF1: u32 = 25;
pub const IPPROTO_LEAF2: u32 = 26;
pub const IPPROTO_RDP: u32 = 27;
pub const IPPROTO_IRTP: u32 = 28;
pub const IPPROTO_TP: u32 = 29;
pub const IPPROTO_BLT: u32 = 30;
pub const IPPROTO_NSP: u32 = 31;
pub const IPPROTO_INP: u32 = 32;
pub const IPPROTO_SEP: u32 = 33;
pub const IPPROTO_3PC: u32 = 34;
pub const IPPROTO_IDPR: u32 = 35;
pub const IPPROTO_XTP: u32 = 36;
pub const IPPROTO_DDP: u32 = 37;
pub const IPPROTO_CMTP: u32 = 38;
pub const IPPROTO_TPXX: u32 = 39;
pub const IPPROTO_IL: u32 = 40;
pub const IPPROTO_IPV6: u32 = 41;
pub const IPPROTO_SDRP: u32 = 42;
pub const IPPROTO_ROUTING: u32 = 43;
pub const IPPROTO_FRAGMENT: u32 = 44;
pub const IPPROTO_IDRP: u32 = 45;
pub const IPPROTO_RSVP: u32 = 46;
pub const IPPROTO_GRE: u32 = 47;
pub const IPPROTO_MHRP: u32 = 48;
pub const IPPROTO_BHA: u32 = 49;
pub const IPPROTO_ESP: u32 = 50;
pub const IPPROTO_AH: u32 = 51;
pub const IPPROTO_INLSP: u32 = 52;
pub const IPPROTO_SWIPE: u32 = 53;
pub const IPPROTO_NHRP: u32 = 54;
pub const IPPROTO_ICMPV6: u32 = 58;
pub const IPPROTO_NONE: u32 = 59;
pub const IPPROTO_DSTOPTS: u32 = 60;
pub const IPPROTO_AHIP: u32 = 61;
pub const IPPROTO_CFTP: u32 = 62;
pub const IPPROTO_HELLO: u32 = 63;
pub const IPPROTO_SATEXPAK: u32 = 64;
pub const IPPROTO_KRYPTOLAN: u32 = 65;
pub const IPPROTO_RVD: u32 = 66;
pub const IPPROTO_IPPC: u32 = 67;
pub const IPPROTO_ADFS: u32 = 68;
pub const IPPROTO_SATMON: u32 = 69;
pub const IPPROTO_VISA: u32 = 70;
pub const IPPROTO_IPCV: u32 = 71;
pub const IPPROTO_CPNX: u32 = 72;
pub const IPPROTO_CPHB: u32 = 73;
pub const IPPROTO_WSN: u32 = 74;
pub const IPPROTO_PVP: u32 = 75;
pub const IPPROTO_BRSATMON: u32 = 76;
pub const IPPROTO_ND: u32 = 77;
pub const IPPROTO_WBMON: u32 = 78;
pub const IPPROTO_WBEXPAK: u32 = 79;
pub const IPPROTO_EON: u32 = 80;
pub const IPPROTO_VMTP: u32 = 81;
pub const IPPROTO_SVMTP: u32 = 82;
pub const IPPROTO_VINES: u32 = 83;
pub const IPPROTO_TTP: u32 = 84;
pub const IPPROTO_IGP: u32 = 85;
pub const IPPROTO_DGP: u32 = 86;
pub const IPPROTO_TCF: u32 = 87;
pub const IPPROTO_IGRP: u32 = 88;
pub const IPPROTO_OSPFIGP: u32 = 89;
pub const IPPROTO_SRPC: u32 = 90;
pub const IPPROTO_LARP: u32 = 91;
pub const IPPROTO_MTP: u32 = 92;
pub const IPPROTO_AX25: u32 = 93;
pub const IPPROTO_IPEIP: u32 = 94;
pub const IPPROTO_MICP: u32 = 95;
pub const IPPROTO_SCCSP: u32 = 96;
pub const IPPROTO_ETHERIP: u32 = 97;
pub const IPPROTO_ENCAP: u32 = 98;
pub const IPPROTO_APES: u32 = 99;
pub const IPPROTO_GMTP: u32 = 100;
pub const IPPROTO_PIM: u32 = 103;
pub const IPPROTO_IPCOMP: u32 = 108;
pub const IPPROTO_PGM: u32 = 113;
pub const IPPROTO_SCTP: u32 = 132;
pub const IPPROTO_DIVERT: u32 = 254;
pub const IPPROTO_RAW: u32 = 255;
pub const IPPROTO_MAX: u32 = 256;
pub const IPPROTO_DONE: u32 = 257;
pub const __DARWIN_IPPORT_RESERVED: u32 = 1024;
pub const IPPORT_RESERVED: u32 = 1024;
pub const IPPORT_USERRESERVED: u32 = 5000;
pub const IPPORT_HIFIRSTAUTO: u32 = 49152;
pub const IPPORT_HILASTAUTO: u32 = 65535;
pub const IPPORT_RESERVEDSTART: u32 = 600;
pub const IN_CLASSA_NET: u32 = 4278190080;
pub const IN_CLASSA_NSHIFT: u32 = 24;
pub const IN_CLASSA_HOST: u32 = 16777215;
pub const IN_CLASSA_MAX: u32 = 128;
pub const IN_CLASSB_NET: u32 = 4294901760;
pub const IN_CLASSB_NSHIFT: u32 = 16;
pub const IN_CLASSB_HOST: u32 = 65535;
pub const IN_CLASSB_MAX: u32 = 65536;
pub const IN_CLASSC_NET: u32 = 4294967040;
pub const IN_CLASSC_NSHIFT: u32 = 8;
pub const IN_CLASSC_HOST: u32 = 255;
pub const IN_CLASSD_NET: u32 = 4026531840;
pub const IN_CLASSD_NSHIFT: u32 = 28;
pub const IN_CLASSD_HOST: u32 = 268435455;
pub const INADDR_NONE: u32 = 4294967295;
pub const IN_LOOPBACKNET: u32 = 127;
pub const INET_ADDRSTRLEN: u32 = 16;
pub const IP_OPTIONS: u32 = 1;
pub const IP_HDRINCL: u32 = 2;
pub const IP_TOS: u32 = 3;
pub const IP_TTL: u32 = 4;
pub const IP_RECVOPTS: u32 = 5;
pub const IP_RECVRETOPTS: u32 = 6;
pub const IP_RECVDSTADDR: u32 = 7;
pub const IP_RETOPTS: u32 = 8;
pub const IP_MULTICAST_IF: u32 = 9;
pub const IP_MULTICAST_TTL: u32 = 10;
pub const IP_MULTICAST_LOOP: u32 = 11;
pub const IP_ADD_MEMBERSHIP: u32 = 12;
pub const IP_DROP_MEMBERSHIP: u32 = 13;
pub const IP_MULTICAST_VIF: u32 = 14;
pub const IP_RSVP_ON: u32 = 15;
pub const IP_RSVP_OFF: u32 = 16;
pub const IP_RSVP_VIF_ON: u32 = 17;
pub const IP_RSVP_VIF_OFF: u32 = 18;
pub const IP_PORTRANGE: u32 = 19;
pub const IP_RECVIF: u32 = 20;
pub const IP_IPSEC_POLICY: u32 = 21;
pub const IP_FAITH: u32 = 22;
pub const IP_STRIPHDR: u32 = 23;
pub const IP_RECVTTL: u32 = 24;
pub const IP_BOUND_IF: u32 = 25;
pub const IP_PKTINFO: u32 = 26;
pub const IP_RECVPKTINFO: u32 = 26;
pub const IP_RECVTOS: u32 = 27;
pub const IP_FW_ADD: u32 = 40;
pub const IP_FW_DEL: u32 = 41;
pub const IP_FW_FLUSH: u32 = 42;
pub const IP_FW_ZERO: u32 = 43;
pub const IP_FW_GET: u32 = 44;
pub const IP_FW_RESETLOG: u32 = 45;
pub const IP_OLD_FW_ADD: u32 = 50;
pub const IP_OLD_FW_DEL: u32 = 51;
pub const IP_OLD_FW_FLUSH: u32 = 52;
pub const IP_OLD_FW_ZERO: u32 = 53;
pub const IP_OLD_FW_GET: u32 = 54;
pub const IP_NAT__XXX: u32 = 55;
pub const IP_OLD_FW_RESETLOG: u32 = 56;
pub const IP_DUMMYNET_CONFIGURE: u32 = 60;
pub const IP_DUMMYNET_DEL: u32 = 61;
pub const IP_DUMMYNET_FLUSH: u32 = 62;
pub const IP_DUMMYNET_GET: u32 = 64;
pub const IP_TRAFFIC_MGT_BACKGROUND: u32 = 65;
pub const IP_MULTICAST_IFINDEX: u32 = 66;
pub const IP_ADD_SOURCE_MEMBERSHIP: u32 = 70;
pub const IP_DROP_SOURCE_MEMBERSHIP: u32 = 71;
pub const IP_BLOCK_SOURCE: u32 = 72;
pub const IP_UNBLOCK_SOURCE: u32 = 73;
pub const IP_MSFILTER: u32 = 74;
pub const MCAST_JOIN_GROUP: u32 = 80;
pub const MCAST_LEAVE_GROUP: u32 = 81;
pub const MCAST_JOIN_SOURCE_GROUP: u32 = 82;
pub const MCAST_LEAVE_SOURCE_GROUP: u32 = 83;
pub const MCAST_BLOCK_SOURCE: u32 = 84;
pub const MCAST_UNBLOCK_SOURCE: u32 = 85;
pub const IP_DEFAULT_MULTICAST_TTL: u32 = 1;
pub const IP_DEFAULT_MULTICAST_LOOP: u32 = 1;
pub const IP_MIN_MEMBERSHIPS: u32 = 31;
pub const IP_MAX_MEMBERSHIPS: u32 = 4095;
pub const IP_MAX_GROUP_SRC_FILTER: u32 = 512;
pub const IP_MAX_SOCK_SRC_FILTER: u32 = 128;
pub const IP_MAX_SOCK_MUTE_FILTER: u32 = 128;
pub const MCAST_UNDEFINED: u32 = 0;
pub const MCAST_INCLUDE: u32 = 1;
pub const MCAST_EXCLUDE: u32 = 2;
pub const IP_PORTRANGE_DEFAULT: u32 = 0;
pub const IP_PORTRANGE_HIGH: u32 = 1;
pub const IP_PORTRANGE_LOW: u32 = 2;
pub const IPPROTO_MAXID: u32 = 52;
pub const IPCTL_FORWARDING: u32 = 1;
pub const IPCTL_SENDREDIRECTS: u32 = 2;
pub const IPCTL_DEFTTL: u32 = 3;
pub const IPCTL_RTEXPIRE: u32 = 5;
pub const IPCTL_RTMINEXPIRE: u32 = 6;
pub const IPCTL_RTMAXCACHE: u32 = 7;
pub const IPCTL_SOURCEROUTE: u32 = 8;
pub const IPCTL_DIRECTEDBROADCAST: u32 = 9;
pub const IPCTL_INTRQMAXLEN: u32 = 10;
pub const IPCTL_INTRQDROPS: u32 = 11;
pub const IPCTL_STATS: u32 = 12;
pub const IPCTL_ACCEPTSOURCEROUTE: u32 = 13;
pub const IPCTL_FASTFORWARDING: u32 = 14;
pub const IPCTL_KEEPFAITH: u32 = 15;
pub const IPCTL_GIF_TTL: u32 = 16;
pub const IPCTL_MAXID: u32 = 17;
pub const __KAME_VERSION: &'static [u8; 18usize] = b"2009/apple-darwin\0";
pub const IPV6PORT_RESERVED: u32 = 1024;
pub const IPV6PORT_ANONMIN: u32 = 49152;
pub const IPV6PORT_ANONMAX: u32 = 65535;
pub const IPV6PORT_RESERVEDMIN: u32 = 600;
pub const IPV6PORT_RESERVEDMAX: u32 = 1023;
pub const INET6_ADDRSTRLEN: u32 = 46;
pub const __IPV6_ADDR_SCOPE_NODELOCAL: u32 = 1;
pub const __IPV6_ADDR_SCOPE_INTFACELOCAL: u32 = 1;
pub const __IPV6_ADDR_SCOPE_LINKLOCAL: u32 = 2;
pub const __IPV6_ADDR_SCOPE_SITELOCAL: u32 = 5;
pub const __IPV6_ADDR_SCOPE_ORGLOCAL: u32 = 8;
pub const __IPV6_ADDR_SCOPE_GLOBAL: u32 = 14;
pub const IPV6_SOCKOPT_RESERVED1: u32 = 3;
pub const IPV6_UNICAST_HOPS: u32 = 4;
pub const IPV6_MULTICAST_IF: u32 = 9;
pub const IPV6_MULTICAST_HOPS: u32 = 10;
pub const IPV6_MULTICAST_LOOP: u32 = 11;
pub const IPV6_JOIN_GROUP: u32 = 12;
pub const IPV6_LEAVE_GROUP: u32 = 13;
pub const IPV6_PORTRANGE: u32 = 14;
pub const ICMP6_FILTER: u32 = 18;
pub const IPV6_2292PKTINFO: u32 = 19;
pub const IPV6_2292HOPLIMIT: u32 = 20;
pub const IPV6_2292NEXTHOP: u32 = 21;
pub const IPV6_2292HOPOPTS: u32 = 22;
pub const IPV6_2292DSTOPTS: u32 = 23;
pub const IPV6_2292RTHDR: u32 = 24;
pub const IPV6_2292PKTOPTIONS: u32 = 25;
pub const IPV6_CHECKSUM: u32 = 26;
pub const IPV6_V6ONLY: u32 = 27;
pub const IPV6_BINDV6ONLY: u32 = 27;
pub const IPV6_IPSEC_POLICY: u32 = 28;
pub const IPV6_FAITH: u32 = 29;
pub const IPV6_FW_ADD: u32 = 30;
pub const IPV6_FW_DEL: u32 = 31;
pub const IPV6_FW_FLUSH: u32 = 32;
pub const IPV6_FW_ZERO: u32 = 33;
pub const IPV6_FW_GET: u32 = 34;
pub const IPV6_RECVTCLASS: u32 = 35;
pub const IPV6_TCLASS: u32 = 36;
pub const IPV6_BOUND_IF: u32 = 125;
pub const IPV6_RTHDR_LOOSE: u32 = 0;
pub const IPV6_RTHDR_STRICT: u32 = 1;
pub const IPV6_RTHDR_TYPE_0: u32 = 0;
pub const IPV6_DEFAULT_MULTICAST_HOPS: u32 = 1;
pub const IPV6_DEFAULT_MULTICAST_LOOP: u32 = 1;
pub const IPV6_MIN_MEMBERSHIPS: u32 = 31;
pub const IPV6_MAX_MEMBERSHIPS: u32 = 4095;
pub const IPV6_MAX_GROUP_SRC_FILTER: u32 = 512;
pub const IPV6_MAX_SOCK_SRC_FILTER: u32 = 128;
pub const IPV6_PORTRANGE_DEFAULT: u32 = 0;
pub const IPV6_PORTRANGE_HIGH: u32 = 1;
pub const IPV6_PORTRANGE_LOW: u32 = 2;
pub const IPV6PROTO_MAXID: u32 = 104;
pub const IPV6CTL_FORWARDING: u32 = 1;
pub const IPV6CTL_SENDREDIRECTS: u32 = 2;
pub const IPV6CTL_DEFHLIM: u32 = 3;
pub const IPV6CTL_FORWSRCRT: u32 = 5;
pub const IPV6CTL_STATS: u32 = 6;
pub const IPV6CTL_MRTSTATS: u32 = 7;
pub const IPV6CTL_MRTPROTO: u32 = 8;
pub const IPV6CTL_MAXFRAGPACKETS: u32 = 9;
pub const IPV6CTL_SOURCECHECK: u32 = 10;
pub const IPV6CTL_SOURCECHECK_LOGINT: u32 = 11;
pub const IPV6CTL_ACCEPT_RTADV: u32 = 12;
pub const IPV6CTL_KEEPFAITH: u32 = 13;
pub const IPV6CTL_LOG_INTERVAL: u32 = 14;
pub const IPV6CTL_HDRNESTLIMIT: u32 = 15;
pub const IPV6CTL_DAD_COUNT: u32 = 16;
pub const IPV6CTL_AUTO_FLOWLABEL: u32 = 17;
pub const IPV6CTL_DEFMCASTHLIM: u32 = 18;
pub const IPV6CTL_GIF_HLIM: u32 = 19;
pub const IPV6CTL_KAME_VERSION: u32 = 20;
pub const IPV6CTL_USE_DEPRECATED: u32 = 21;
pub const IPV6CTL_RR_PRUNE: u32 = 22;
pub const IPV6CTL_V6ONLY: u32 = 24;
pub const IPV6CTL_RTEXPIRE: u32 = 25;
pub const IPV6CTL_RTMINEXPIRE: u32 = 26;
pub const IPV6CTL_RTMAXCACHE: u32 = 27;
pub const IPV6CTL_USETEMPADDR: u32 = 32;
pub const IPV6CTL_TEMPPLTIME: u32 = 33;
pub const IPV6CTL_TEMPVLTIME: u32 = 34;
pub const IPV6CTL_AUTO_LINKLOCAL: u32 = 35;
pub const IPV6CTL_RIP6STATS: u32 = 36;
pub const IPV6CTL_PREFER_TEMPADDR: u32 = 37;
pub const IPV6CTL_ADDRCTLPOLICY: u32 = 38;
pub const IPV6CTL_USE_DEFAULTZONE: u32 = 39;
pub const IPV6CTL_MAXFRAGS: u32 = 41;
pub const IPV6CTL_MCAST_PMTU: u32 = 44;
pub const IPV6CTL_NEIGHBORGCTHRESH: u32 = 46;
pub const IPV6CTL_MAXIFPREFIXES: u32 = 47;
pub const IPV6CTL_MAXIFDEFROUTERS: u32 = 48;
pub const IPV6CTL_MAXDYNROUTES: u32 = 49;
pub const ICMPV6CTL_ND6_ONLINKNSRFC4861: u32 = 50;
pub const IPV6CTL_MAXID: u32 = 51;
pub const NICE_ADDRESS_STRING_LEN: u32 = 46;
pub const NICE_CANDIDATE_TYPE_PREF_HOST: u32 = 120;
pub const NICE_CANDIDATE_TYPE_PREF_PEER_REFLEXIVE: u32 = 110;
pub const NICE_CANDIDATE_TYPE_PREF_NAT_ASSISTED: u32 = 105;
pub const NICE_CANDIDATE_TYPE_PREF_SERVER_REFLEXIVE: u32 = 100;
pub const NICE_CANDIDATE_TYPE_PREF_RELAYED_UDP: u32 = 30;
pub const NICE_CANDIDATE_TYPE_PREF_RELAYED: u32 = 20;
pub const NICE_CANDIDATE_TRANSPORT_MS_PREF_UDP: u32 = 15;
pub const NICE_CANDIDATE_TRANSPORT_MS_PREF_TCP: u32 = 6;
pub const NICE_CANDIDATE_DIRECTION_MS_PREF_PASSIVE: u32 = 2;
pub const NICE_CANDIDATE_DIRECTION_MS_PREF_ACTIVE: u32 = 5;
pub const NICE_CANDIDATE_MAX_FOUNDATION: u32 = 33;
pub const NICE_AGENT_MAX_REMOTE_CANDIDATES: u32 = 25;
pub type wchar_t = ::std::os::raw::c_int;
pub type max_align_t = f64;
pub type gint8 = ::std::os::raw::c_schar;
pub type guint8 = ::std::os::raw::c_uchar;
pub type gint16 = ::std::os::raw::c_short;
pub type guint16 = ::std::os::raw::c_ushort;
pub type gint32 = ::std::os::raw::c_int;
pub type guint32 = ::std::os::raw::c_uint;
pub type gint64 = ::std::os::raw::c_long;
pub type guint64 = ::std::os::raw::c_ulong;
pub type gssize = ::std::os::raw::c_long;
pub type gsize = ::std::os::raw::c_ulong;
pub type goffset = gint64;
pub type gintptr = ::std::os::raw::c_long;
pub type guintptr = ::std::os::raw::c_ulong;
pub type GPid = ::std::os::raw::c_int;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_longlong;
pub type __uint64_t = ::std::os::raw::c_ulonglong;
pub type __darwin_intptr_t = ::std::os::raw::c_long;
pub type __darwin_natural_t = ::std::os::raw::c_uint;
pub type __darwin_ct_rune_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union __mbstate_t {
    pub __mbstate8: [::std::os::raw::c_char; 128usize],
    pub _mbstateL: ::std::os::raw::c_longlong,
    _bindgen_union_align: [u64; 16usize],
}
#[test]
fn bindgen_test_layout___mbstate_t() {
    assert_eq!(
        ::std::mem::size_of::<__mbstate_t>(),
        128usize,
        concat!("Size of: ", stringify!(__mbstate_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__mbstate_t>(),
        8usize,
        concat!("Alignment of ", stringify!(__mbstate_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__mbstate_t>())).__mbstate8 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t),
            "::",
            stringify!(__mbstate8)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__mbstate_t>()))._mbstateL as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t),
            "::",
            stringify!(_mbstateL)
        )
    );
}
pub type __darwin_mbstate_t = __mbstate_t;
pub type __darwin_ptrdiff_t = ::std::os::raw::c_long;
pub type __darwin_size_t = ::std::os::raw::c_ulong;
pub type __darwin_va_list = __builtin_va_list;
pub type __darwin_wchar_t = ::std::os::raw::c_int;
pub type __darwin_rune_t = __darwin_wchar_t;
pub type __darwin_wint_t = ::std::os::raw::c_int;
pub type __darwin_clock_t = ::std::os::raw::c_ulong;
pub type __darwin_socklen_t = __uint32_t;
pub type __darwin_ssize_t = ::std::os::raw::c_long;
pub type __darwin_time_t = ::std::os::raw::c_long;
pub type __darwin_blkcnt_t = __int64_t;
pub type __darwin_blksize_t = __int32_t;
pub type __darwin_dev_t = __int32_t;
pub type __darwin_fsblkcnt_t = ::std::os::raw::c_uint;
pub type __darwin_fsfilcnt_t = ::std::os::raw::c_uint;
pub type __darwin_gid_t = __uint32_t;
pub type __darwin_id_t = __uint32_t;
pub type __darwin_ino64_t = __uint64_t;
pub type __darwin_ino_t = __uint32_t;
pub type __darwin_mach_port_name_t = __darwin_natural_t;
pub type __darwin_mach_port_t = __darwin_mach_port_name_t;
pub type __darwin_mode_t = __uint16_t;
pub type __darwin_off_t = __int64_t;
pub type __darwin_pid_t = __int32_t;
pub type __darwin_sigset_t = __uint32_t;
pub type __darwin_suseconds_t = __int32_t;
pub type __darwin_uid_t = __uint32_t;
pub type __darwin_useconds_t = __uint32_t;
pub type __darwin_uuid_t = [::std::os::raw::c_uchar; 16usize];
pub type __darwin_uuid_string_t = [::std::os::raw::c_char; 37usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_pthread_handler_rec {
    pub __routine: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
    pub __arg: *mut ::std::os::raw::c_void,
    pub __next: *mut __darwin_pthread_handler_rec,
}
#[test]
fn bindgen_test_layout___darwin_pthread_handler_rec() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_pthread_handler_rec>(),
        24usize,
        concat!("Size of: ", stringify!(__darwin_pthread_handler_rec))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_pthread_handler_rec>(),
        8usize,
        concat!("Alignment of ", stringify!(__darwin_pthread_handler_rec))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_pthread_handler_rec>())).__routine as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_pthread_handler_rec),
            "::",
            stringify!(__routine)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_pthread_handler_rec>())).__arg as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_pthread_handler_rec),
            "::",
            stringify!(__arg)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_pthread_handler_rec>())).__next as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_pthread_handler_rec),
            "::",
            stringify!(__next)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _opaque_pthread_attr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 56usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_attr_t() {
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_attr_t>(),
        64usize,
        concat!("Size of: ", stringify!(_opaque_pthread_attr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_attr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_attr_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_opaque_pthread_attr_t>())).__sig as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_attr_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_opaque_pthread_attr_t>())).__opaque as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_attr_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _opaque_pthread_cond_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 40usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_cond_t() {
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_cond_t>(),
        48usize,
        concat!("Size of: ", stringify!(_opaque_pthread_cond_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_cond_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_cond_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_opaque_pthread_cond_t>())).__sig as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_cond_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_opaque_pthread_cond_t>())).__opaque as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_cond_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_condattr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 8usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_condattr_t() {
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_condattr_t>(),
        16usize,
        concat!("Size of: ", stringify!(_opaque_pthread_condattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_condattr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_condattr_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_opaque_pthread_condattr_t>())).__sig as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_condattr_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_opaque_pthread_condattr_t>())).__opaque as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_condattr_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _opaque_pthread_mutex_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 56usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_mutex_t() {
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_mutex_t>(),
        64usize,
        concat!("Size of: ", stringify!(_opaque_pthread_mutex_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_mutex_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_mutex_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_opaque_pthread_mutex_t>())).__sig as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_mutex_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_opaque_pthread_mutex_t>())).__opaque as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_mutex_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_mutexattr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 8usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_mutexattr_t() {
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_mutexattr_t>(),
        16usize,
        concat!("Size of: ", stringify!(_opaque_pthread_mutexattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_mutexattr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_mutexattr_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_opaque_pthread_mutexattr_t>())).__sig as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_mutexattr_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_opaque_pthread_mutexattr_t>())).__opaque as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_mutexattr_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_once_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 8usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_once_t() {
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_once_t>(),
        16usize,
        concat!("Size of: ", stringify!(_opaque_pthread_once_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_once_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_once_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_opaque_pthread_once_t>())).__sig as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_once_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_opaque_pthread_once_t>())).__opaque as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_once_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _opaque_pthread_rwlock_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 192usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_rwlock_t() {
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_rwlock_t>(),
        200usize,
        concat!("Size of: ", stringify!(_opaque_pthread_rwlock_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_rwlock_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_rwlock_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_opaque_pthread_rwlock_t>())).__sig as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_rwlock_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_opaque_pthread_rwlock_t>())).__opaque as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_rwlock_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_rwlockattr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 16usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_rwlockattr_t() {
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_rwlockattr_t>(),
        24usize,
        concat!("Size of: ", stringify!(_opaque_pthread_rwlockattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_rwlockattr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_rwlockattr_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_opaque_pthread_rwlockattr_t>())).__sig as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_rwlockattr_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_opaque_pthread_rwlockattr_t>())).__opaque as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_rwlockattr_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _opaque_pthread_t {
    pub __sig: ::std::os::raw::c_long,
    pub __cleanup_stack: *mut __darwin_pthread_handler_rec,
    pub __opaque: [::std::os::raw::c_char; 8176usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_t() {
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_t>(),
        8192usize,
        concat!("Size of: ", stringify!(_opaque_pthread_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_opaque_pthread_t>())).__sig as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_opaque_pthread_t>())).__cleanup_stack as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_t),
            "::",
            stringify!(__cleanup_stack)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_opaque_pthread_t>())).__opaque as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_t),
            "::",
            stringify!(__opaque)
        )
    );
}
pub type __darwin_pthread_attr_t = _opaque_pthread_attr_t;
pub type __darwin_pthread_cond_t = _opaque_pthread_cond_t;
pub type __darwin_pthread_condattr_t = _opaque_pthread_condattr_t;
pub type __darwin_pthread_key_t = ::std::os::raw::c_ulong;
pub type __darwin_pthread_mutex_t = _opaque_pthread_mutex_t;
pub type __darwin_pthread_mutexattr_t = _opaque_pthread_mutexattr_t;
pub type __darwin_pthread_once_t = _opaque_pthread_once_t;
pub type __darwin_pthread_rwlock_t = _opaque_pthread_rwlock_t;
pub type __darwin_pthread_rwlockattr_t = _opaque_pthread_rwlockattr_t;
pub type __darwin_pthread_t = *mut _opaque_pthread_t;
pub type __darwin_nl_item = ::std::os::raw::c_int;
pub type __darwin_wctrans_t = ::std::os::raw::c_int;
pub type __darwin_wctype_t = __uint32_t;
pub type clock_t = __darwin_clock_t;
pub type time_t = __darwin_time_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timespec {
    pub tv_sec: __darwin_time_t,
    pub tv_nsec: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_timespec() {
    assert_eq!(
        ::std::mem::size_of::<timespec>(),
        16usize,
        concat!("Size of: ", stringify!(timespec))
    );
    assert_eq!(
        ::std::mem::align_of::<timespec>(),
        8usize,
        concat!("Alignment of ", stringify!(timespec))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timespec>())).tv_sec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timespec>())).tv_nsec as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_nsec)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tm {
    pub tm_sec: ::std::os::raw::c_int,
    pub tm_min: ::std::os::raw::c_int,
    pub tm_hour: ::std::os::raw::c_int,
    pub tm_mday: ::std::os::raw::c_int,
    pub tm_mon: ::std::os::raw::c_int,
    pub tm_year: ::std::os::raw::c_int,
    pub tm_wday: ::std::os::raw::c_int,
    pub tm_yday: ::std::os::raw::c_int,
    pub tm_isdst: ::std::os::raw::c_int,
    pub tm_gmtoff: ::std::os::raw::c_long,
    pub tm_zone: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_tm() {
    assert_eq!(
        ::std::mem::size_of::<tm>(),
        56usize,
        concat!("Size of: ", stringify!(tm))
    );
    assert_eq!(
        ::std::mem::align_of::<tm>(),
        8usize,
        concat!("Alignment of ", stringify!(tm))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_sec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_sec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_min as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_min)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_hour as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_hour)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_mday as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_mday)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_mon as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_mon)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_year as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_year)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_wday as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_wday)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_yday as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_yday)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_isdst as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_isdst)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_gmtoff as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_gmtoff)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_zone as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_zone)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_tzname"]
    pub static mut tzname: [*mut ::std::os::raw::c_char; 0usize];
}
extern "C" {
    #[link_name = "\u{1}_getdate_err"]
    pub static mut getdate_err: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_timezone"]
    pub static mut timezone: ::std::os::raw::c_long;
}
extern "C" {
    #[link_name = "\u{1}_daylight"]
    pub static mut daylight: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_asctime"]
    pub fn asctime(arg1: *const tm) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_clock"]
    pub fn clock() -> clock_t;
}
extern "C" {
    #[link_name = "\u{1}_ctime"]
    pub fn ctime(arg1: *const time_t) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_difftime"]
    pub fn difftime(arg1: time_t, arg2: time_t) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_getdate"]
    pub fn getdate(arg1: *const ::std::os::raw::c_char) -> *mut tm;
}
extern "C" {
    #[link_name = "\u{1}_gmtime"]
    pub fn gmtime(arg1: *const time_t) -> *mut tm;
}
extern "C" {
    #[link_name = "\u{1}_localtime"]
    pub fn localtime(arg1: *const time_t) -> *mut tm;
}
extern "C" {
    #[link_name = "\u{1}_mktime"]
    pub fn mktime(arg1: *mut tm) -> time_t;
}
extern "C" {
    #[link_name = "\u{1}_strftime"]
    pub fn strftime(
        arg1: *mut ::std::os::raw::c_char,
        arg2: usize,
        arg3: *const ::std::os::raw::c_char,
        arg4: *const tm,
    ) -> usize;
}
extern "C" {
    #[link_name = "\u{1}_strptime"]
    pub fn strptime(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut tm,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_time"]
    pub fn time(arg1: *mut time_t) -> time_t;
}
extern "C" {
    #[link_name = "\u{1}_tzset"]
    pub fn tzset();
}
extern "C" {
    #[link_name = "\u{1}_asctime_r"]
    pub fn asctime_r(
        arg1: *const tm,
        arg2: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_ctime_r"]
    pub fn ctime_r(
        arg1: *const time_t,
        arg2: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_gmtime_r"]
    pub fn gmtime_r(arg1: *const time_t, arg2: *mut tm) -> *mut tm;
}
extern "C" {
    #[link_name = "\u{1}_localtime_r"]
    pub fn localtime_r(arg1: *const time_t, arg2: *mut tm) -> *mut tm;
}
extern "C" {
    #[link_name = "\u{1}_posix2time"]
    pub fn posix2time(arg1: time_t) -> time_t;
}
extern "C" {
    #[link_name = "\u{1}_tzsetwall"]
    pub fn tzsetwall();
}
extern "C" {
    #[link_name = "\u{1}_time2posix"]
    pub fn time2posix(arg1: time_t) -> time_t;
}
extern "C" {
    #[link_name = "\u{1}_timelocal"]
    pub fn timelocal(arg1: *const tm) -> time_t;
}
extern "C" {
    #[link_name = "\u{1}_timegm"]
    pub fn timegm(arg1: *const tm) -> time_t;
}
extern "C" {
    #[link_name = "\u{1}_nanosleep"]
    pub fn nanosleep(__rqtp: *const timespec, __rmtp: *mut timespec) -> ::std::os::raw::c_int;
}
pub const clockid_t__CLOCK_REALTIME: clockid_t = 0;
pub const clockid_t__CLOCK_MONOTONIC: clockid_t = 6;
pub const clockid_t__CLOCK_MONOTONIC_RAW: clockid_t = 4;
pub const clockid_t__CLOCK_MONOTONIC_RAW_APPROX: clockid_t = 5;
pub const clockid_t__CLOCK_UPTIME_RAW: clockid_t = 8;
pub const clockid_t__CLOCK_UPTIME_RAW_APPROX: clockid_t = 9;
pub const clockid_t__CLOCK_PROCESS_CPUTIME_ID: clockid_t = 12;
pub const clockid_t__CLOCK_THREAD_CPUTIME_ID: clockid_t = 16;
pub type clockid_t = u32;
extern "C" {
    #[link_name = "\u{1}_clock_getres"]
    pub fn clock_getres(__clock_id: clockid_t, __res: *mut timespec) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_clock_gettime"]
    pub fn clock_gettime(__clock_id: clockid_t, __tp: *mut timespec) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_clock_gettime_nsec_np"]
    pub fn clock_gettime_nsec_np(__clock_id: clockid_t) -> __uint64_t;
}
extern "C" {
    #[link_name = "\u{1}_clock_settime"]
    pub fn clock_settime(__clock_id: clockid_t, __tp: *const timespec) -> ::std::os::raw::c_int;
}
pub type gchar = ::std::os::raw::c_char;
pub type gshort = ::std::os::raw::c_short;
pub type glong = ::std::os::raw::c_long;
pub type gint = ::std::os::raw::c_int;
pub type gboolean = gint;
pub type guchar = ::std::os::raw::c_uchar;
pub type gushort = ::std::os::raw::c_ushort;
pub type gulong = ::std::os::raw::c_ulong;
pub type guint = ::std::os::raw::c_uint;
pub type gfloat = f32;
pub type gdouble = f64;
pub type gpointer = *mut ::std::os::raw::c_void;
pub type gconstpointer = *const ::std::os::raw::c_void;
pub type GCompareFunc =
    ::std::option::Option<unsafe extern "C" fn(a: gconstpointer, b: gconstpointer) -> gint>;
pub type GCompareDataFunc = ::std::option::Option<
    unsafe extern "C" fn(a: gconstpointer, b: gconstpointer, user_data: gpointer) -> gint,
>;
pub type GEqualFunc =
    ::std::option::Option<unsafe extern "C" fn(a: gconstpointer, b: gconstpointer) -> gboolean>;
pub type GDestroyNotify = ::std::option::Option<unsafe extern "C" fn(data: gpointer)>;
pub type GFunc = ::std::option::Option<unsafe extern "C" fn(data: gpointer, user_data: gpointer)>;
pub type GHashFunc = ::std::option::Option<unsafe extern "C" fn(key: gconstpointer) -> guint>;
pub type GHFunc = ::std::option::Option<
    unsafe extern "C" fn(key: gpointer, value: gpointer, user_data: gpointer),
>;
/// GFreeFunc:
/// @data: a data pointer
///
/// Declares a type of function which takes an arbitrary
/// data pointer argument and has no return value. It is
/// not currently used in GLib or GTK+.
pub type GFreeFunc = ::std::option::Option<unsafe extern "C" fn(data: gpointer)>;
/// GTranslateFunc:
/// @str: the untranslated string
/// @data: user data specified when installing the function, e.g.
/// in g_option_group_set_translate_func()
///
/// The type of functions which are used to translate user-visible
/// strings, for <option>--help</option> output.
///
/// Returns: a translation of the string for the current locale.
/// The returned string is owned by GLib and must not be freed.
pub type GTranslateFunc =
    ::std::option::Option<unsafe extern "C" fn(str: *const gchar, data: gpointer) -> *const gchar>;
pub type GDoubleIEEE754 = _GDoubleIEEE754;
pub type GFloatIEEE754 = _GFloatIEEE754;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _GFloatIEEE754 {
    pub v_float: gfloat,
    pub mpn: _GFloatIEEE754__bindgen_ty_1,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GFloatIEEE754__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
    pub __bindgen_align: [u32; 0usize],
}
#[test]
fn bindgen_test_layout__GFloatIEEE754__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<_GFloatIEEE754__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(_GFloatIEEE754__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<_GFloatIEEE754__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(_GFloatIEEE754__bindgen_ty_1))
    );
}
impl _GFloatIEEE754__bindgen_ty_1 {
    #[inline]
    pub fn mantissa(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 23u8) as u32) }
    }
    #[inline]
    pub fn set_mantissa(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 23u8, val as u64)
        }
    }
    #[inline]
    pub fn biased_exponent(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(23usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_biased_exponent(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(23usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn sign(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sign(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        mantissa: guint,
        biased_exponent: guint,
        sign: guint,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 23u8, {
            let mantissa: u32 = unsafe { ::std::mem::transmute(mantissa) };
            mantissa as u64
        });
        __bindgen_bitfield_unit.set(23usize, 8u8, {
            let biased_exponent: u32 = unsafe { ::std::mem::transmute(biased_exponent) };
            biased_exponent as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let sign: u32 = unsafe { ::std::mem::transmute(sign) };
            sign as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout__GFloatIEEE754() {
    assert_eq!(
        ::std::mem::size_of::<_GFloatIEEE754>(),
        4usize,
        concat!("Size of: ", stringify!(_GFloatIEEE754))
    );
    assert_eq!(
        ::std::mem::align_of::<_GFloatIEEE754>(),
        4usize,
        concat!("Alignment of ", stringify!(_GFloatIEEE754))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GFloatIEEE754>())).v_float as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFloatIEEE754),
            "::",
            stringify!(v_float)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GFloatIEEE754>())).mpn as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFloatIEEE754),
            "::",
            stringify!(mpn)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _GDoubleIEEE754 {
    pub v_double: gdouble,
    pub mpn: _GDoubleIEEE754__bindgen_ty_1,
    _bindgen_union_align: u64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GDoubleIEEE754__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize], u32>,
    pub __bindgen_align: [u32; 0usize],
}
#[test]
fn bindgen_test_layout__GDoubleIEEE754__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<_GDoubleIEEE754__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(_GDoubleIEEE754__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<_GDoubleIEEE754__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(_GDoubleIEEE754__bindgen_ty_1))
    );
}
impl _GDoubleIEEE754__bindgen_ty_1 {
    #[inline]
    pub fn mantissa_low(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 32u8) as u32) }
    }
    #[inline]
    pub fn set_mantissa_low(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 32u8, val as u64)
        }
    }
    #[inline]
    pub fn mantissa_high(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(32usize, 20u8) as u32) }
    }
    #[inline]
    pub fn set_mantissa_high(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(32usize, 20u8, val as u64)
        }
    }
    #[inline]
    pub fn biased_exponent(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(52usize, 11u8) as u32) }
    }
    #[inline]
    pub fn set_biased_exponent(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(52usize, 11u8, val as u64)
        }
    }
    #[inline]
    pub fn sign(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(63usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_sign(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(63usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        mantissa_low: guint,
        mantissa_high: guint,
        biased_exponent: guint,
        sign: guint,
    ) -> __BindgenBitfieldUnit<[u8; 8usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 32u8, {
            let mantissa_low: u32 = unsafe { ::std::mem::transmute(mantissa_low) };
            mantissa_low as u64
        });
        __bindgen_bitfield_unit.set(32usize, 20u8, {
            let mantissa_high: u32 = unsafe { ::std::mem::transmute(mantissa_high) };
            mantissa_high as u64
        });
        __bindgen_bitfield_unit.set(52usize, 11u8, {
            let biased_exponent: u32 = unsafe { ::std::mem::transmute(biased_exponent) };
            biased_exponent as u64
        });
        __bindgen_bitfield_unit.set(63usize, 1u8, {
            let sign: u32 = unsafe { ::std::mem::transmute(sign) };
            sign as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout__GDoubleIEEE754() {
    assert_eq!(
        ::std::mem::size_of::<_GDoubleIEEE754>(),
        8usize,
        concat!("Size of: ", stringify!(_GDoubleIEEE754))
    );
    assert_eq!(
        ::std::mem::align_of::<_GDoubleIEEE754>(),
        8usize,
        concat!("Alignment of ", stringify!(_GDoubleIEEE754))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GDoubleIEEE754>())).v_double as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDoubleIEEE754),
            "::",
            stringify!(v_double)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GDoubleIEEE754>())).mpn as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDoubleIEEE754),
            "::",
            stringify!(mpn)
        )
    );
}
pub type GTimeVal = _GTimeVal;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GTimeVal {
    pub tv_sec: glong,
    pub tv_usec: glong,
}
#[test]
fn bindgen_test_layout__GTimeVal() {
    assert_eq!(
        ::std::mem::size_of::<_GTimeVal>(),
        16usize,
        concat!("Size of: ", stringify!(_GTimeVal))
    );
    assert_eq!(
        ::std::mem::align_of::<_GTimeVal>(),
        8usize,
        concat!("Alignment of ", stringify!(_GTimeVal))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GTimeVal>())).tv_sec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTimeVal),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GTimeVal>())).tv_usec as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTimeVal),
            "::",
            stringify!(tv_usec)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GBytes {
    _unused: [u8; 0],
}
pub type GBytes = _GBytes;
pub type GArray = _GArray;
pub type GByteArray = _GByteArray;
pub type GPtrArray = _GPtrArray;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GArray {
    pub data: *mut gchar,
    pub len: guint,
}
#[test]
fn bindgen_test_layout__GArray() {
    assert_eq!(
        ::std::mem::size_of::<_GArray>(),
        16usize,
        concat!("Size of: ", stringify!(_GArray))
    );
    assert_eq!(
        ::std::mem::align_of::<_GArray>(),
        8usize,
        concat!("Alignment of ", stringify!(_GArray))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GArray>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GArray),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GArray>())).len as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GArray),
            "::",
            stringify!(len)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GByteArray {
    pub data: *mut guint8,
    pub len: guint,
}
#[test]
fn bindgen_test_layout__GByteArray() {
    assert_eq!(
        ::std::mem::size_of::<_GByteArray>(),
        16usize,
        concat!("Size of: ", stringify!(_GByteArray))
    );
    assert_eq!(
        ::std::mem::align_of::<_GByteArray>(),
        8usize,
        concat!("Alignment of ", stringify!(_GByteArray))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GByteArray>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GByteArray),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GByteArray>())).len as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GByteArray),
            "::",
            stringify!(len)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GPtrArray {
    pub pdata: *mut gpointer,
    pub len: guint,
}
#[test]
fn bindgen_test_layout__GPtrArray() {
    assert_eq!(
        ::std::mem::size_of::<_GPtrArray>(),
        16usize,
        concat!("Size of: ", stringify!(_GPtrArray))
    );
    assert_eq!(
        ::std::mem::align_of::<_GPtrArray>(),
        8usize,
        concat!("Alignment of ", stringify!(_GPtrArray))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GPtrArray>())).pdata as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GPtrArray),
            "::",
            stringify!(pdata)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GPtrArray>())).len as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GPtrArray),
            "::",
            stringify!(len)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_g_array_new"]
    pub fn g_array_new(
        zero_terminated: gboolean,
        clear_: gboolean,
        element_size: guint,
    ) -> *mut GArray;
}
extern "C" {
    #[link_name = "\u{1}_g_array_sized_new"]
    pub fn g_array_sized_new(
        zero_terminated: gboolean,
        clear_: gboolean,
        element_size: guint,
        reserved_size: guint,
    ) -> *mut GArray;
}
extern "C" {
    #[link_name = "\u{1}_g_array_free"]
    pub fn g_array_free(array: *mut GArray, free_segment: gboolean) -> *mut gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_array_ref"]
    pub fn g_array_ref(array: *mut GArray) -> *mut GArray;
}
extern "C" {
    #[link_name = "\u{1}_g_array_unref"]
    pub fn g_array_unref(array: *mut GArray);
}
extern "C" {
    #[link_name = "\u{1}_g_array_get_element_size"]
    pub fn g_array_get_element_size(array: *mut GArray) -> guint;
}
extern "C" {
    #[link_name = "\u{1}_g_array_append_vals"]
    pub fn g_array_append_vals(array: *mut GArray, data: gconstpointer, len: guint) -> *mut GArray;
}
extern "C" {
    #[link_name = "\u{1}_g_array_prepend_vals"]
    pub fn g_array_prepend_vals(array: *mut GArray, data: gconstpointer, len: guint)
        -> *mut GArray;
}
extern "C" {
    #[link_name = "\u{1}_g_array_insert_vals"]
    pub fn g_array_insert_vals(
        array: *mut GArray,
        index_: guint,
        data: gconstpointer,
        len: guint,
    ) -> *mut GArray;
}
extern "C" {
    #[link_name = "\u{1}_g_array_set_size"]
    pub fn g_array_set_size(array: *mut GArray, length: guint) -> *mut GArray;
}
extern "C" {
    #[link_name = "\u{1}_g_array_remove_index"]
    pub fn g_array_remove_index(array: *mut GArray, index_: guint) -> *mut GArray;
}
extern "C" {
    #[link_name = "\u{1}_g_array_remove_index_fast"]
    pub fn g_array_remove_index_fast(array: *mut GArray, index_: guint) -> *mut GArray;
}
extern "C" {
    #[link_name = "\u{1}_g_array_remove_range"]
    pub fn g_array_remove_range(array: *mut GArray, index_: guint, length: guint) -> *mut GArray;
}
extern "C" {
    #[link_name = "\u{1}_g_array_sort"]
    pub fn g_array_sort(array: *mut GArray, compare_func: GCompareFunc);
}
extern "C" {
    #[link_name = "\u{1}_g_array_sort_with_data"]
    pub fn g_array_sort_with_data(
        array: *mut GArray,
        compare_func: GCompareDataFunc,
        user_data: gpointer,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_array_set_clear_func"]
    pub fn g_array_set_clear_func(array: *mut GArray, clear_func: GDestroyNotify);
}
extern "C" {
    #[link_name = "\u{1}_g_ptr_array_new"]
    pub fn g_ptr_array_new() -> *mut GPtrArray;
}
extern "C" {
    #[link_name = "\u{1}_g_ptr_array_new_with_free_func"]
    pub fn g_ptr_array_new_with_free_func(element_free_func: GDestroyNotify) -> *mut GPtrArray;
}
extern "C" {
    #[link_name = "\u{1}_g_ptr_array_sized_new"]
    pub fn g_ptr_array_sized_new(reserved_size: guint) -> *mut GPtrArray;
}
extern "C" {
    #[link_name = "\u{1}_g_ptr_array_new_full"]
    pub fn g_ptr_array_new_full(
        reserved_size: guint,
        element_free_func: GDestroyNotify,
    ) -> *mut GPtrArray;
}
extern "C" {
    #[link_name = "\u{1}_g_ptr_array_free"]
    pub fn g_ptr_array_free(array: *mut GPtrArray, free_seg: gboolean) -> *mut gpointer;
}
extern "C" {
    #[link_name = "\u{1}_g_ptr_array_ref"]
    pub fn g_ptr_array_ref(array: *mut GPtrArray) -> *mut GPtrArray;
}
extern "C" {
    #[link_name = "\u{1}_g_ptr_array_unref"]
    pub fn g_ptr_array_unref(array: *mut GPtrArray);
}
extern "C" {
    #[link_name = "\u{1}_g_ptr_array_set_free_func"]
    pub fn g_ptr_array_set_free_func(array: *mut GPtrArray, element_free_func: GDestroyNotify);
}
extern "C" {
    #[link_name = "\u{1}_g_ptr_array_set_size"]
    pub fn g_ptr_array_set_size(array: *mut GPtrArray, length: gint);
}
extern "C" {
    #[link_name = "\u{1}_g_ptr_array_remove_index"]
    pub fn g_ptr_array_remove_index(array: *mut GPtrArray, index_: guint) -> gpointer;
}
extern "C" {
    #[link_name = "\u{1}_g_ptr_array_remove_index_fast"]
    pub fn g_ptr_array_remove_index_fast(array: *mut GPtrArray, index_: guint) -> gpointer;
}
extern "C" {
    #[link_name = "\u{1}_g_ptr_array_remove"]
    pub fn g_ptr_array_remove(array: *mut GPtrArray, data: gpointer) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_ptr_array_remove_fast"]
    pub fn g_ptr_array_remove_fast(array: *mut GPtrArray, data: gpointer) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_ptr_array_remove_range"]
    pub fn g_ptr_array_remove_range(
        array: *mut GPtrArray,
        index_: guint,
        length: guint,
    ) -> *mut GPtrArray;
}
extern "C" {
    #[link_name = "\u{1}_g_ptr_array_add"]
    pub fn g_ptr_array_add(array: *mut GPtrArray, data: gpointer);
}
extern "C" {
    #[link_name = "\u{1}_g_ptr_array_insert"]
    pub fn g_ptr_array_insert(array: *mut GPtrArray, index_: gint, data: gpointer);
}
extern "C" {
    #[link_name = "\u{1}_g_ptr_array_sort"]
    pub fn g_ptr_array_sort(array: *mut GPtrArray, compare_func: GCompareFunc);
}
extern "C" {
    #[link_name = "\u{1}_g_ptr_array_sort_with_data"]
    pub fn g_ptr_array_sort_with_data(
        array: *mut GPtrArray,
        compare_func: GCompareDataFunc,
        user_data: gpointer,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_ptr_array_foreach"]
    pub fn g_ptr_array_foreach(array: *mut GPtrArray, func: GFunc, user_data: gpointer);
}
extern "C" {
    #[link_name = "\u{1}_g_ptr_array_find"]
    pub fn g_ptr_array_find(
        haystack: *mut GPtrArray,
        needle: gconstpointer,
        index_: *mut guint,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_ptr_array_find_with_equal_func"]
    pub fn g_ptr_array_find_with_equal_func(
        haystack: *mut GPtrArray,
        needle: gconstpointer,
        equal_func: GEqualFunc,
        index_: *mut guint,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_byte_array_new"]
    pub fn g_byte_array_new() -> *mut GByteArray;
}
extern "C" {
    #[link_name = "\u{1}_g_byte_array_new_take"]
    pub fn g_byte_array_new_take(data: *mut guint8, len: gsize) -> *mut GByteArray;
}
extern "C" {
    #[link_name = "\u{1}_g_byte_array_sized_new"]
    pub fn g_byte_array_sized_new(reserved_size: guint) -> *mut GByteArray;
}
extern "C" {
    #[link_name = "\u{1}_g_byte_array_free"]
    pub fn g_byte_array_free(array: *mut GByteArray, free_segment: gboolean) -> *mut guint8;
}
extern "C" {
    #[link_name = "\u{1}_g_byte_array_free_to_bytes"]
    pub fn g_byte_array_free_to_bytes(array: *mut GByteArray) -> *mut GBytes;
}
extern "C" {
    #[link_name = "\u{1}_g_byte_array_ref"]
    pub fn g_byte_array_ref(array: *mut GByteArray) -> *mut GByteArray;
}
extern "C" {
    #[link_name = "\u{1}_g_byte_array_unref"]
    pub fn g_byte_array_unref(array: *mut GByteArray);
}
extern "C" {
    #[link_name = "\u{1}_g_byte_array_append"]
    pub fn g_byte_array_append(
        array: *mut GByteArray,
        data: *const guint8,
        len: guint,
    ) -> *mut GByteArray;
}
extern "C" {
    #[link_name = "\u{1}_g_byte_array_prepend"]
    pub fn g_byte_array_prepend(
        array: *mut GByteArray,
        data: *const guint8,
        len: guint,
    ) -> *mut GByteArray;
}
extern "C" {
    #[link_name = "\u{1}_g_byte_array_set_size"]
    pub fn g_byte_array_set_size(array: *mut GByteArray, length: guint) -> *mut GByteArray;
}
extern "C" {
    #[link_name = "\u{1}_g_byte_array_remove_index"]
    pub fn g_byte_array_remove_index(array: *mut GByteArray, index_: guint) -> *mut GByteArray;
}
extern "C" {
    #[link_name = "\u{1}_g_byte_array_remove_index_fast"]
    pub fn g_byte_array_remove_index_fast(array: *mut GByteArray, index_: guint)
        -> *mut GByteArray;
}
extern "C" {
    #[link_name = "\u{1}_g_byte_array_remove_range"]
    pub fn g_byte_array_remove_range(
        array: *mut GByteArray,
        index_: guint,
        length: guint,
    ) -> *mut GByteArray;
}
extern "C" {
    #[link_name = "\u{1}_g_byte_array_sort"]
    pub fn g_byte_array_sort(array: *mut GByteArray, compare_func: GCompareFunc);
}
extern "C" {
    #[link_name = "\u{1}_g_byte_array_sort_with_data"]
    pub fn g_byte_array_sort_with_data(
        array: *mut GByteArray,
        compare_func: GCompareDataFunc,
        user_data: gpointer,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_atomic_int_get"]
    pub fn g_atomic_int_get(atomic: *const gint) -> gint;
}
extern "C" {
    #[link_name = "\u{1}_g_atomic_int_set"]
    pub fn g_atomic_int_set(atomic: *mut gint, newval: gint);
}
extern "C" {
    #[link_name = "\u{1}_g_atomic_int_inc"]
    pub fn g_atomic_int_inc(atomic: *mut gint);
}
extern "C" {
    #[link_name = "\u{1}_g_atomic_int_dec_and_test"]
    pub fn g_atomic_int_dec_and_test(atomic: *mut gint) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_atomic_int_compare_and_exchange"]
    pub fn g_atomic_int_compare_and_exchange(
        atomic: *mut gint,
        oldval: gint,
        newval: gint,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_atomic_int_add"]
    pub fn g_atomic_int_add(atomic: *mut gint, val: gint) -> gint;
}
extern "C" {
    #[link_name = "\u{1}_g_atomic_int_and"]
    pub fn g_atomic_int_and(atomic: *mut guint, val: guint) -> guint;
}
extern "C" {
    #[link_name = "\u{1}_g_atomic_int_or"]
    pub fn g_atomic_int_or(atomic: *mut guint, val: guint) -> guint;
}
extern "C" {
    #[link_name = "\u{1}_g_atomic_int_xor"]
    pub fn g_atomic_int_xor(atomic: *mut guint, val: guint) -> guint;
}
extern "C" {
    #[link_name = "\u{1}_g_atomic_pointer_get"]
    pub fn g_atomic_pointer_get(atomic: *const ::std::os::raw::c_void) -> gpointer;
}
extern "C" {
    #[link_name = "\u{1}_g_atomic_pointer_set"]
    pub fn g_atomic_pointer_set(atomic: *mut ::std::os::raw::c_void, newval: gpointer);
}
extern "C" {
    #[link_name = "\u{1}_g_atomic_pointer_compare_and_exchange"]
    pub fn g_atomic_pointer_compare_and_exchange(
        atomic: *mut ::std::os::raw::c_void,
        oldval: gpointer,
        newval: gpointer,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_atomic_pointer_add"]
    pub fn g_atomic_pointer_add(atomic: *mut ::std::os::raw::c_void, val: gssize) -> gssize;
}
extern "C" {
    #[link_name = "\u{1}_g_atomic_pointer_and"]
    pub fn g_atomic_pointer_and(atomic: *mut ::std::os::raw::c_void, val: gsize) -> gsize;
}
extern "C" {
    #[link_name = "\u{1}_g_atomic_pointer_or"]
    pub fn g_atomic_pointer_or(atomic: *mut ::std::os::raw::c_void, val: gsize) -> gsize;
}
extern "C" {
    #[link_name = "\u{1}_g_atomic_pointer_xor"]
    pub fn g_atomic_pointer_xor(atomic: *mut ::std::os::raw::c_void, val: gsize) -> gsize;
}
extern "C" {
    #[link_name = "\u{1}_g_atomic_int_exchange_and_add"]
    pub fn g_atomic_int_exchange_and_add(atomic: *mut gint, val: gint) -> gint;
}
pub type va_list = __builtin_va_list;
pub type __gnuc_va_list = __builtin_va_list;
pub type GQuark = guint32;
extern "C" {
    #[link_name = "\u{1}_g_quark_try_string"]
    pub fn g_quark_try_string(string: *const gchar) -> GQuark;
}
extern "C" {
    #[link_name = "\u{1}_g_quark_from_static_string"]
    pub fn g_quark_from_static_string(string: *const gchar) -> GQuark;
}
extern "C" {
    #[link_name = "\u{1}_g_quark_from_string"]
    pub fn g_quark_from_string(string: *const gchar) -> GQuark;
}
extern "C" {
    #[link_name = "\u{1}_g_quark_to_string"]
    pub fn g_quark_to_string(quark: GQuark) -> *const gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_intern_string"]
    pub fn g_intern_string(string: *const gchar) -> *const gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_intern_static_string"]
    pub fn g_intern_static_string(string: *const gchar) -> *const gchar;
}
/// GError:
/// @domain: error domain, e.g. #G_FILE_ERROR
/// @code: error code, e.g. %G_FILE_ERROR_NOENT
/// @message: human-readable informative error message
///
/// The `GError` structure contains information about
/// an error that has occurred.
pub type GError = _GError;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GError {
    pub domain: GQuark,
    pub code: gint,
    pub message: *mut gchar,
}
#[test]
fn bindgen_test_layout__GError() {
    assert_eq!(
        ::std::mem::size_of::<_GError>(),
        16usize,
        concat!("Size of: ", stringify!(_GError))
    );
    assert_eq!(
        ::std::mem::align_of::<_GError>(),
        8usize,
        concat!("Alignment of ", stringify!(_GError))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GError>())).domain as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GError),
            "::",
            stringify!(domain)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GError>())).code as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_GError),
            "::",
            stringify!(code)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GError>())).message as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GError),
            "::",
            stringify!(message)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_g_error_new"]
    pub fn g_error_new(domain: GQuark, code: gint, format: *const gchar, ...) -> *mut GError;
}
extern "C" {
    #[link_name = "\u{1}_g_error_new_literal"]
    pub fn g_error_new_literal(domain: GQuark, code: gint, message: *const gchar) -> *mut GError;
}
extern "C" {
    #[link_name = "\u{1}_g_error_new_valist"]
    pub fn g_error_new_valist(
        domain: GQuark,
        code: gint,
        format: *const gchar,
        args: *mut __va_list_tag,
    ) -> *mut GError;
}
extern "C" {
    #[link_name = "\u{1}_g_error_free"]
    pub fn g_error_free(error: *mut GError);
}
extern "C" {
    #[link_name = "\u{1}_g_error_copy"]
    pub fn g_error_copy(error: *const GError) -> *mut GError;
}
extern "C" {
    #[link_name = "\u{1}_g_error_matches"]
    pub fn g_error_matches(error: *const GError, domain: GQuark, code: gint) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_set_error"]
    pub fn g_set_error(
        err: *mut *mut GError,
        domain: GQuark,
        code: gint,
        format: *const gchar,
        ...
    );
}
extern "C" {
    #[link_name = "\u{1}_g_set_error_literal"]
    pub fn g_set_error_literal(
        err: *mut *mut GError,
        domain: GQuark,
        code: gint,
        message: *const gchar,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_propagate_error"]
    pub fn g_propagate_error(dest: *mut *mut GError, src: *mut GError);
}
extern "C" {
    #[link_name = "\u{1}_g_clear_error"]
    pub fn g_clear_error(err: *mut *mut GError);
}
extern "C" {
    #[link_name = "\u{1}_g_prefix_error"]
    pub fn g_prefix_error(err: *mut *mut GError, format: *const gchar, ...);
}
extern "C" {
    #[link_name = "\u{1}_g_propagate_prefixed_error"]
    pub fn g_propagate_prefixed_error(
        dest: *mut *mut GError,
        src: *mut GError,
        format: *const gchar,
        ...
    );
}
extern "C" {
    #[link_name = "\u{1}_g_get_user_name"]
    pub fn g_get_user_name() -> *const gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_get_real_name"]
    pub fn g_get_real_name() -> *const gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_get_home_dir"]
    pub fn g_get_home_dir() -> *const gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_get_tmp_dir"]
    pub fn g_get_tmp_dir() -> *const gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_get_host_name"]
    pub fn g_get_host_name() -> *const gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_get_prgname"]
    pub fn g_get_prgname() -> *const gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_set_prgname"]
    pub fn g_set_prgname(prgname: *const gchar);
}
extern "C" {
    #[link_name = "\u{1}_g_get_application_name"]
    pub fn g_get_application_name() -> *const gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_set_application_name"]
    pub fn g_set_application_name(application_name: *const gchar);
}
extern "C" {
    #[link_name = "\u{1}_g_reload_user_special_dirs_cache"]
    pub fn g_reload_user_special_dirs_cache();
}
extern "C" {
    #[link_name = "\u{1}_g_get_user_data_dir"]
    pub fn g_get_user_data_dir() -> *const gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_get_user_config_dir"]
    pub fn g_get_user_config_dir() -> *const gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_get_user_cache_dir"]
    pub fn g_get_user_cache_dir() -> *const gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_get_system_data_dirs"]
    pub fn g_get_system_data_dirs() -> *const *const gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_get_system_config_dirs"]
    pub fn g_get_system_config_dirs() -> *const *const gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_get_user_runtime_dir"]
    pub fn g_get_user_runtime_dir() -> *const gchar;
}
pub const GUserDirectory_G_USER_DIRECTORY_DESKTOP: GUserDirectory = 0;
pub const GUserDirectory_G_USER_DIRECTORY_DOCUMENTS: GUserDirectory = 1;
pub const GUserDirectory_G_USER_DIRECTORY_DOWNLOAD: GUserDirectory = 2;
pub const GUserDirectory_G_USER_DIRECTORY_MUSIC: GUserDirectory = 3;
pub const GUserDirectory_G_USER_DIRECTORY_PICTURES: GUserDirectory = 4;
pub const GUserDirectory_G_USER_DIRECTORY_PUBLIC_SHARE: GUserDirectory = 5;
pub const GUserDirectory_G_USER_DIRECTORY_TEMPLATES: GUserDirectory = 6;
pub const GUserDirectory_G_USER_DIRECTORY_VIDEOS: GUserDirectory = 7;
pub const GUserDirectory_G_USER_N_DIRECTORIES: GUserDirectory = 8;
/// GUserDirectory:
/// @G_USER_DIRECTORY_DESKTOP: the user's Desktop directory
/// @G_USER_DIRECTORY_DOCUMENTS: the user's Documents directory
/// @G_USER_DIRECTORY_DOWNLOAD: the user's Downloads directory
/// @G_USER_DIRECTORY_MUSIC: the user's Music directory
/// @G_USER_DIRECTORY_PICTURES: the user's Pictures directory
/// @G_USER_DIRECTORY_PUBLIC_SHARE: the user's shared directory
/// @G_USER_DIRECTORY_TEMPLATES: the user's Templates directory
/// @G_USER_DIRECTORY_VIDEOS: the user's Movies directory
/// @G_USER_N_DIRECTORIES: the number of enum values
///
/// These are logical ids for special directories which are defined
/// depending on the platform used. You should use g_get_user_special_dir()
/// to retrieve the full path associated to the logical id.
///
/// The #GUserDirectory enumeration can be extended at later date. Not
/// every platform has a directory for every logical id in this
/// enumeration.
///
/// Since: 2.14
pub type GUserDirectory = u32;
extern "C" {
    #[link_name = "\u{1}_g_get_user_special_dir"]
    pub fn g_get_user_special_dir(directory: GUserDirectory) -> *const gchar;
}
/// GDebugKey:
/// @key: the string
/// @value: the flag
///
/// Associates a string with a bit flag.
/// Used in g_parse_debug_string().
pub type GDebugKey = _GDebugKey;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GDebugKey {
    pub key: *const gchar,
    pub value: guint,
}
#[test]
fn bindgen_test_layout__GDebugKey() {
    assert_eq!(
        ::std::mem::size_of::<_GDebugKey>(),
        16usize,
        concat!("Size of: ", stringify!(_GDebugKey))
    );
    assert_eq!(
        ::std::mem::align_of::<_GDebugKey>(),
        8usize,
        concat!("Alignment of ", stringify!(_GDebugKey))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GDebugKey>())).key as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDebugKey),
            "::",
            stringify!(key)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GDebugKey>())).value as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDebugKey),
            "::",
            stringify!(value)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_g_parse_debug_string"]
    pub fn g_parse_debug_string(
        string: *const gchar,
        keys: *const GDebugKey,
        nkeys: guint,
    ) -> guint;
}
extern "C" {
    #[link_name = "\u{1}_g_snprintf"]
    pub fn g_snprintf(string: *mut gchar, n: gulong, format: *const gchar, ...) -> gint;
}
extern "C" {
    #[link_name = "\u{1}_g_vsnprintf"]
    pub fn g_vsnprintf(
        string: *mut gchar,
        n: gulong,
        format: *const gchar,
        args: *mut __va_list_tag,
    ) -> gint;
}
extern "C" {
    #[link_name = "\u{1}_g_nullify_pointer"]
    pub fn g_nullify_pointer(nullify_location: *mut gpointer);
}
pub const GFormatSizeFlags_G_FORMAT_SIZE_DEFAULT: GFormatSizeFlags = 0;
pub const GFormatSizeFlags_G_FORMAT_SIZE_LONG_FORMAT: GFormatSizeFlags = 1;
pub const GFormatSizeFlags_G_FORMAT_SIZE_IEC_UNITS: GFormatSizeFlags = 2;
pub type GFormatSizeFlags = u32;
extern "C" {
    #[link_name = "\u{1}_g_format_size_full"]
    pub fn g_format_size_full(size: guint64, flags: GFormatSizeFlags) -> *mut gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_format_size"]
    pub fn g_format_size(size: guint64) -> *mut gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_format_size_for_display"]
    pub fn g_format_size_for_display(size: goffset) -> *mut gchar;
}
/// GVoidFunc:
///
/// Declares a type of function which takes no arguments
/// and has no return value. It is used to specify the type
/// function passed to g_atexit().
pub type GVoidFunc = ::std::option::Option<unsafe extern "C" fn()>;
extern "C" {
    #[link_name = "\u{1}_g_atexit"]
    pub fn g_atexit(func: GVoidFunc);
}
extern "C" {
    #[link_name = "\u{1}_g_find_program_in_path"]
    pub fn g_find_program_in_path(program: *const gchar) -> *mut gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_bit_nth_lsf"]
    pub fn g_bit_nth_lsf(mask: gulong, nth_bit: gint) -> gint;
}
extern "C" {
    #[link_name = "\u{1}_g_bit_nth_msf"]
    pub fn g_bit_nth_msf(mask: gulong, nth_bit: gint) -> gint;
}
extern "C" {
    #[link_name = "\u{1}_g_bit_storage"]
    pub fn g_bit_storage(number: gulong) -> guint;
}
extern "C" {
    #[link_name = "\u{1}_g_thread_error_quark"]
    pub fn g_thread_error_quark() -> GQuark;
}
pub const GThreadError_G_THREAD_ERROR_AGAIN: GThreadError = 0;
pub type GThreadError = u32;
pub type GThreadFunc = ::std::option::Option<unsafe extern "C" fn(data: gpointer) -> gpointer>;
pub type GThread = _GThread;
pub type GMutex = _GMutex;
pub type GRecMutex = _GRecMutex;
pub type GRWLock = _GRWLock;
pub type GCond = _GCond;
pub type GPrivate = _GPrivate;
pub type GOnce = _GOnce;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _GMutex {
    pub p: gpointer,
    pub i: [guint; 2usize],
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout__GMutex() {
    assert_eq!(
        ::std::mem::size_of::<_GMutex>(),
        8usize,
        concat!("Size of: ", stringify!(_GMutex))
    );
    assert_eq!(
        ::std::mem::align_of::<_GMutex>(),
        8usize,
        concat!("Alignment of ", stringify!(_GMutex))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GMutex>())).p as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMutex),
            "::",
            stringify!(p)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GMutex>())).i as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMutex),
            "::",
            stringify!(i)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GRWLock {
    pub p: gpointer,
    pub i: [guint; 2usize],
}
#[test]
fn bindgen_test_layout__GRWLock() {
    assert_eq!(
        ::std::mem::size_of::<_GRWLock>(),
        16usize,
        concat!("Size of: ", stringify!(_GRWLock))
    );
    assert_eq!(
        ::std::mem::align_of::<_GRWLock>(),
        8usize,
        concat!("Alignment of ", stringify!(_GRWLock))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GRWLock>())).p as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GRWLock),
            "::",
            stringify!(p)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GRWLock>())).i as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GRWLock),
            "::",
            stringify!(i)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GCond {
    pub p: gpointer,
    pub i: [guint; 2usize],
}
#[test]
fn bindgen_test_layout__GCond() {
    assert_eq!(
        ::std::mem::size_of::<_GCond>(),
        16usize,
        concat!("Size of: ", stringify!(_GCond))
    );
    assert_eq!(
        ::std::mem::align_of::<_GCond>(),
        8usize,
        concat!("Alignment of ", stringify!(_GCond))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GCond>())).p as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(_GCond), "::", stringify!(p))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GCond>())).i as *const _ as usize },
        8usize,
        concat!("Offset of field: ", stringify!(_GCond), "::", stringify!(i))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GRecMutex {
    pub p: gpointer,
    pub i: [guint; 2usize],
}
#[test]
fn bindgen_test_layout__GRecMutex() {
    assert_eq!(
        ::std::mem::size_of::<_GRecMutex>(),
        16usize,
        concat!("Size of: ", stringify!(_GRecMutex))
    );
    assert_eq!(
        ::std::mem::align_of::<_GRecMutex>(),
        8usize,
        concat!("Alignment of ", stringify!(_GRecMutex))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GRecMutex>())).p as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GRecMutex),
            "::",
            stringify!(p)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GRecMutex>())).i as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GRecMutex),
            "::",
            stringify!(i)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GPrivate {
    pub p: gpointer,
    pub notify: GDestroyNotify,
    pub future: [gpointer; 2usize],
}
#[test]
fn bindgen_test_layout__GPrivate() {
    assert_eq!(
        ::std::mem::size_of::<_GPrivate>(),
        32usize,
        concat!("Size of: ", stringify!(_GPrivate))
    );
    assert_eq!(
        ::std::mem::align_of::<_GPrivate>(),
        8usize,
        concat!("Alignment of ", stringify!(_GPrivate))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GPrivate>())).p as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GPrivate),
            "::",
            stringify!(p)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GPrivate>())).notify as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GPrivate),
            "::",
            stringify!(notify)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GPrivate>())).future as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GPrivate),
            "::",
            stringify!(future)
        )
    );
}
pub const GOnceStatus_G_ONCE_STATUS_NOTCALLED: GOnceStatus = 0;
pub const GOnceStatus_G_ONCE_STATUS_PROGRESS: GOnceStatus = 1;
pub const GOnceStatus_G_ONCE_STATUS_READY: GOnceStatus = 2;
pub type GOnceStatus = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GOnce {
    pub status: GOnceStatus,
    pub retval: gpointer,
}
#[test]
fn bindgen_test_layout__GOnce() {
    assert_eq!(
        ::std::mem::size_of::<_GOnce>(),
        16usize,
        concat!("Size of: ", stringify!(_GOnce))
    );
    assert_eq!(
        ::std::mem::align_of::<_GOnce>(),
        8usize,
        concat!("Alignment of ", stringify!(_GOnce))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GOnce>())).status as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GOnce),
            "::",
            stringify!(status)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GOnce>())).retval as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GOnce),
            "::",
            stringify!(retval)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_g_thread_ref"]
    pub fn g_thread_ref(thread: *mut GThread) -> *mut GThread;
}
extern "C" {
    #[link_name = "\u{1}_g_thread_unref"]
    pub fn g_thread_unref(thread: *mut GThread);
}
extern "C" {
    #[link_name = "\u{1}_g_thread_new"]
    pub fn g_thread_new(name: *const gchar, func: GThreadFunc, data: gpointer) -> *mut GThread;
}
extern "C" {
    #[link_name = "\u{1}_g_thread_try_new"]
    pub fn g_thread_try_new(
        name: *const gchar,
        func: GThreadFunc,
        data: gpointer,
        error: *mut *mut GError,
    ) -> *mut GThread;
}
extern "C" {
    #[link_name = "\u{1}_g_thread_self"]
    pub fn g_thread_self() -> *mut GThread;
}
extern "C" {
    #[link_name = "\u{1}_g_thread_exit"]
    pub fn g_thread_exit(retval: gpointer);
}
extern "C" {
    #[link_name = "\u{1}_g_thread_join"]
    pub fn g_thread_join(thread: *mut GThread) -> gpointer;
}
extern "C" {
    #[link_name = "\u{1}_g_thread_yield"]
    pub fn g_thread_yield();
}
extern "C" {
    #[link_name = "\u{1}_g_mutex_init"]
    pub fn g_mutex_init(mutex: *mut GMutex);
}
extern "C" {
    #[link_name = "\u{1}_g_mutex_clear"]
    pub fn g_mutex_clear(mutex: *mut GMutex);
}
extern "C" {
    #[link_name = "\u{1}_g_mutex_lock"]
    pub fn g_mutex_lock(mutex: *mut GMutex);
}
extern "C" {
    #[link_name = "\u{1}_g_mutex_trylock"]
    pub fn g_mutex_trylock(mutex: *mut GMutex) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_mutex_unlock"]
    pub fn g_mutex_unlock(mutex: *mut GMutex);
}
extern "C" {
    #[link_name = "\u{1}_g_rw_lock_init"]
    pub fn g_rw_lock_init(rw_lock: *mut GRWLock);
}
extern "C" {
    #[link_name = "\u{1}_g_rw_lock_clear"]
    pub fn g_rw_lock_clear(rw_lock: *mut GRWLock);
}
extern "C" {
    #[link_name = "\u{1}_g_rw_lock_writer_lock"]
    pub fn g_rw_lock_writer_lock(rw_lock: *mut GRWLock);
}
extern "C" {
    #[link_name = "\u{1}_g_rw_lock_writer_trylock"]
    pub fn g_rw_lock_writer_trylock(rw_lock: *mut GRWLock) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_rw_lock_writer_unlock"]
    pub fn g_rw_lock_writer_unlock(rw_lock: *mut GRWLock);
}
extern "C" {
    #[link_name = "\u{1}_g_rw_lock_reader_lock"]
    pub fn g_rw_lock_reader_lock(rw_lock: *mut GRWLock);
}
extern "C" {
    #[link_name = "\u{1}_g_rw_lock_reader_trylock"]
    pub fn g_rw_lock_reader_trylock(rw_lock: *mut GRWLock) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_rw_lock_reader_unlock"]
    pub fn g_rw_lock_reader_unlock(rw_lock: *mut GRWLock);
}
extern "C" {
    #[link_name = "\u{1}_g_rec_mutex_init"]
    pub fn g_rec_mutex_init(rec_mutex: *mut GRecMutex);
}
extern "C" {
    #[link_name = "\u{1}_g_rec_mutex_clear"]
    pub fn g_rec_mutex_clear(rec_mutex: *mut GRecMutex);
}
extern "C" {
    #[link_name = "\u{1}_g_rec_mutex_lock"]
    pub fn g_rec_mutex_lock(rec_mutex: *mut GRecMutex);
}
extern "C" {
    #[link_name = "\u{1}_g_rec_mutex_trylock"]
    pub fn g_rec_mutex_trylock(rec_mutex: *mut GRecMutex) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_rec_mutex_unlock"]
    pub fn g_rec_mutex_unlock(rec_mutex: *mut GRecMutex);
}
extern "C" {
    #[link_name = "\u{1}_g_cond_init"]
    pub fn g_cond_init(cond: *mut GCond);
}
extern "C" {
    #[link_name = "\u{1}_g_cond_clear"]
    pub fn g_cond_clear(cond: *mut GCond);
}
extern "C" {
    #[link_name = "\u{1}_g_cond_wait"]
    pub fn g_cond_wait(cond: *mut GCond, mutex: *mut GMutex);
}
extern "C" {
    #[link_name = "\u{1}_g_cond_signal"]
    pub fn g_cond_signal(cond: *mut GCond);
}
extern "C" {
    #[link_name = "\u{1}_g_cond_broadcast"]
    pub fn g_cond_broadcast(cond: *mut GCond);
}
extern "C" {
    #[link_name = "\u{1}_g_cond_wait_until"]
    pub fn g_cond_wait_until(cond: *mut GCond, mutex: *mut GMutex, end_time: gint64) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_private_get"]
    pub fn g_private_get(key: *mut GPrivate) -> gpointer;
}
extern "C" {
    #[link_name = "\u{1}_g_private_set"]
    pub fn g_private_set(key: *mut GPrivate, value: gpointer);
}
extern "C" {
    #[link_name = "\u{1}_g_private_replace"]
    pub fn g_private_replace(key: *mut GPrivate, value: gpointer);
}
extern "C" {
    #[link_name = "\u{1}_g_once_impl"]
    pub fn g_once_impl(once: *mut GOnce, func: GThreadFunc, arg: gpointer) -> gpointer;
}
extern "C" {
    #[link_name = "\u{1}_g_once_init_enter"]
    pub fn g_once_init_enter(location: *mut ::std::os::raw::c_void) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_once_init_leave"]
    pub fn g_once_init_leave(location: *mut ::std::os::raw::c_void, result: gsize);
}
extern "C" {
    #[link_name = "\u{1}_g_get_num_processors"]
    pub fn g_get_num_processors() -> guint;
}
/// GMutexLocker:
///
/// Opaque type. See g_mutex_locker_new() for details.
/// Since: 2.44
pub type GMutexLocker = ::std::os::raw::c_void;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GAsyncQueue {
    _unused: [u8; 0],
}
pub type GAsyncQueue = _GAsyncQueue;
extern "C" {
    #[link_name = "\u{1}_g_async_queue_new"]
    pub fn g_async_queue_new() -> *mut GAsyncQueue;
}
extern "C" {
    #[link_name = "\u{1}_g_async_queue_new_full"]
    pub fn g_async_queue_new_full(item_free_func: GDestroyNotify) -> *mut GAsyncQueue;
}
extern "C" {
    #[link_name = "\u{1}_g_async_queue_lock"]
    pub fn g_async_queue_lock(queue: *mut GAsyncQueue);
}
extern "C" {
    #[link_name = "\u{1}_g_async_queue_unlock"]
    pub fn g_async_queue_unlock(queue: *mut GAsyncQueue);
}
extern "C" {
    #[link_name = "\u{1}_g_async_queue_ref"]
    pub fn g_async_queue_ref(queue: *mut GAsyncQueue) -> *mut GAsyncQueue;
}
extern "C" {
    #[link_name = "\u{1}_g_async_queue_unref"]
    pub fn g_async_queue_unref(queue: *mut GAsyncQueue);
}
extern "C" {
    #[link_name = "\u{1}_g_async_queue_ref_unlocked"]
    pub fn g_async_queue_ref_unlocked(queue: *mut GAsyncQueue);
}
extern "C" {
    #[link_name = "\u{1}_g_async_queue_unref_and_unlock"]
    pub fn g_async_queue_unref_and_unlock(queue: *mut GAsyncQueue);
}
extern "C" {
    #[link_name = "\u{1}_g_async_queue_push"]
    pub fn g_async_queue_push(queue: *mut GAsyncQueue, data: gpointer);
}
extern "C" {
    #[link_name = "\u{1}_g_async_queue_push_unlocked"]
    pub fn g_async_queue_push_unlocked(queue: *mut GAsyncQueue, data: gpointer);
}
extern "C" {
    #[link_name = "\u{1}_g_async_queue_push_sorted"]
    pub fn g_async_queue_push_sorted(
        queue: *mut GAsyncQueue,
        data: gpointer,
        func: GCompareDataFunc,
        user_data: gpointer,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_async_queue_push_sorted_unlocked"]
    pub fn g_async_queue_push_sorted_unlocked(
        queue: *mut GAsyncQueue,
        data: gpointer,
        func: GCompareDataFunc,
        user_data: gpointer,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_async_queue_pop"]
    pub fn g_async_queue_pop(queue: *mut GAsyncQueue) -> gpointer;
}
extern "C" {
    #[link_name = "\u{1}_g_async_queue_pop_unlocked"]
    pub fn g_async_queue_pop_unlocked(queue: *mut GAsyncQueue) -> gpointer;
}
extern "C" {
    #[link_name = "\u{1}_g_async_queue_try_pop"]
    pub fn g_async_queue_try_pop(queue: *mut GAsyncQueue) -> gpointer;
}
extern "C" {
    #[link_name = "\u{1}_g_async_queue_try_pop_unlocked"]
    pub fn g_async_queue_try_pop_unlocked(queue: *mut GAsyncQueue) -> gpointer;
}
extern "C" {
    #[link_name = "\u{1}_g_async_queue_timeout_pop"]
    pub fn g_async_queue_timeout_pop(queue: *mut GAsyncQueue, timeout: guint64) -> gpointer;
}
extern "C" {
    #[link_name = "\u{1}_g_async_queue_timeout_pop_unlocked"]
    pub fn g_async_queue_timeout_pop_unlocked(
        queue: *mut GAsyncQueue,
        timeout: guint64,
    ) -> gpointer;
}
extern "C" {
    #[link_name = "\u{1}_g_async_queue_length"]
    pub fn g_async_queue_length(queue: *mut GAsyncQueue) -> gint;
}
extern "C" {
    #[link_name = "\u{1}_g_async_queue_length_unlocked"]
    pub fn g_async_queue_length_unlocked(queue: *mut GAsyncQueue) -> gint;
}
extern "C" {
    #[link_name = "\u{1}_g_async_queue_sort"]
    pub fn g_async_queue_sort(queue: *mut GAsyncQueue, func: GCompareDataFunc, user_data: gpointer);
}
extern "C" {
    #[link_name = "\u{1}_g_async_queue_sort_unlocked"]
    pub fn g_async_queue_sort_unlocked(
        queue: *mut GAsyncQueue,
        func: GCompareDataFunc,
        user_data: gpointer,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_async_queue_remove"]
    pub fn g_async_queue_remove(queue: *mut GAsyncQueue, item: gpointer) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_async_queue_remove_unlocked"]
    pub fn g_async_queue_remove_unlocked(queue: *mut GAsyncQueue, item: gpointer) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_async_queue_push_front"]
    pub fn g_async_queue_push_front(queue: *mut GAsyncQueue, item: gpointer);
}
extern "C" {
    #[link_name = "\u{1}_g_async_queue_push_front_unlocked"]
    pub fn g_async_queue_push_front_unlocked(queue: *mut GAsyncQueue, item: gpointer);
}
extern "C" {
    #[link_name = "\u{1}_g_async_queue_timed_pop"]
    pub fn g_async_queue_timed_pop(queue: *mut GAsyncQueue, end_time: *mut GTimeVal) -> gpointer;
}
extern "C" {
    #[link_name = "\u{1}_g_async_queue_timed_pop_unlocked"]
    pub fn g_async_queue_timed_pop_unlocked(
        queue: *mut GAsyncQueue,
        end_time: *mut GTimeVal,
    ) -> gpointer;
}
pub type sig_atomic_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_i386_thread_state {
    pub __eax: ::std::os::raw::c_uint,
    pub __ebx: ::std::os::raw::c_uint,
    pub __ecx: ::std::os::raw::c_uint,
    pub __edx: ::std::os::raw::c_uint,
    pub __edi: ::std::os::raw::c_uint,
    pub __esi: ::std::os::raw::c_uint,
    pub __ebp: ::std::os::raw::c_uint,
    pub __esp: ::std::os::raw::c_uint,
    pub __ss: ::std::os::raw::c_uint,
    pub __eflags: ::std::os::raw::c_uint,
    pub __eip: ::std::os::raw::c_uint,
    pub __cs: ::std::os::raw::c_uint,
    pub __ds: ::std::os::raw::c_uint,
    pub __es: ::std::os::raw::c_uint,
    pub __fs: ::std::os::raw::c_uint,
    pub __gs: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout___darwin_i386_thread_state() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_i386_thread_state>(),
        64usize,
        concat!("Size of: ", stringify!(__darwin_i386_thread_state))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_i386_thread_state>(),
        4usize,
        concat!("Alignment of ", stringify!(__darwin_i386_thread_state))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_thread_state>())).__eax as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_thread_state),
            "::",
            stringify!(__eax)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_thread_state>())).__ebx as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_thread_state),
            "::",
            stringify!(__ebx)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_thread_state>())).__ecx as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_thread_state),
            "::",
            stringify!(__ecx)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_thread_state>())).__edx as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_thread_state),
            "::",
            stringify!(__edx)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_thread_state>())).__edi as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_thread_state),
            "::",
            stringify!(__edi)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_thread_state>())).__esi as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_thread_state),
            "::",
            stringify!(__esi)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_thread_state>())).__ebp as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_thread_state),
            "::",
            stringify!(__ebp)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_thread_state>())).__esp as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_thread_state),
            "::",
            stringify!(__esp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__darwin_i386_thread_state>())).__ss as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_thread_state),
            "::",
            stringify!(__ss)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_thread_state>())).__eflags as *const _ as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_thread_state),
            "::",
            stringify!(__eflags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_thread_state>())).__eip as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_thread_state),
            "::",
            stringify!(__eip)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__darwin_i386_thread_state>())).__cs as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_thread_state),
            "::",
            stringify!(__cs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__darwin_i386_thread_state>())).__ds as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_thread_state),
            "::",
            stringify!(__ds)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__darwin_i386_thread_state>())).__es as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_thread_state),
            "::",
            stringify!(__es)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__darwin_i386_thread_state>())).__fs as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_thread_state),
            "::",
            stringify!(__fs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__darwin_i386_thread_state>())).__gs as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_thread_state),
            "::",
            stringify!(__gs)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_fp_control {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize], u8>,
    pub __bindgen_align: [u16; 0usize],
}
#[test]
fn bindgen_test_layout___darwin_fp_control() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_fp_control>(),
        2usize,
        concat!("Size of: ", stringify!(__darwin_fp_control))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_fp_control>(),
        2usize,
        concat!("Alignment of ", stringify!(__darwin_fp_control))
    );
}
impl __darwin_fp_control {
    #[inline]
    pub fn __invalid(&self) -> ::std::os::raw::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set___invalid(&mut self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn __denorm(&self) -> ::std::os::raw::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set___denorm(&mut self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn __zdiv(&self) -> ::std::os::raw::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set___zdiv(&mut self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn __ovrfl(&self) -> ::std::os::raw::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set___ovrfl(&mut self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn __undfl(&self) -> ::std::os::raw::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set___undfl(&mut self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn __precis(&self) -> ::std::os::raw::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set___precis(&mut self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn __pc(&self) -> ::std::os::raw::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 2u8) as u16) }
    }
    #[inline]
    pub fn set___pc(&mut self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn __rc(&self) -> ::std::os::raw::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 2u8) as u16) }
    }
    #[inline]
    pub fn set___rc(&mut self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        __invalid: ::std::os::raw::c_ushort,
        __denorm: ::std::os::raw::c_ushort,
        __zdiv: ::std::os::raw::c_ushort,
        __ovrfl: ::std::os::raw::c_ushort,
        __undfl: ::std::os::raw::c_ushort,
        __precis: ::std::os::raw::c_ushort,
        __pc: ::std::os::raw::c_ushort,
        __rc: ::std::os::raw::c_ushort,
    ) -> __BindgenBitfieldUnit<[u8; 2usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let __invalid: u16 = unsafe { ::std::mem::transmute(__invalid) };
            __invalid as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let __denorm: u16 = unsafe { ::std::mem::transmute(__denorm) };
            __denorm as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let __zdiv: u16 = unsafe { ::std::mem::transmute(__zdiv) };
            __zdiv as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let __ovrfl: u16 = unsafe { ::std::mem::transmute(__ovrfl) };
            __ovrfl as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let __undfl: u16 = unsafe { ::std::mem::transmute(__undfl) };
            __undfl as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let __precis: u16 = unsafe { ::std::mem::transmute(__precis) };
            __precis as u64
        });
        __bindgen_bitfield_unit.set(8usize, 2u8, {
            let __pc: u16 = unsafe { ::std::mem::transmute(__pc) };
            __pc as u64
        });
        __bindgen_bitfield_unit.set(10usize, 2u8, {
            let __rc: u16 = unsafe { ::std::mem::transmute(__rc) };
            __rc as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type __darwin_fp_control_t = __darwin_fp_control;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_fp_status {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize], u8>,
    pub __bindgen_align: [u16; 0usize],
}
#[test]
fn bindgen_test_layout___darwin_fp_status() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_fp_status>(),
        2usize,
        concat!("Size of: ", stringify!(__darwin_fp_status))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_fp_status>(),
        2usize,
        concat!("Alignment of ", stringify!(__darwin_fp_status))
    );
}
impl __darwin_fp_status {
    #[inline]
    pub fn __invalid(&self) -> ::std::os::raw::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set___invalid(&mut self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn __denorm(&self) -> ::std::os::raw::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set___denorm(&mut self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn __zdiv(&self) -> ::std::os::raw::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set___zdiv(&mut self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn __ovrfl(&self) -> ::std::os::raw::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set___ovrfl(&mut self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn __undfl(&self) -> ::std::os::raw::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set___undfl(&mut self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn __precis(&self) -> ::std::os::raw::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set___precis(&mut self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn __stkflt(&self) -> ::std::os::raw::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set___stkflt(&mut self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn __errsumm(&self) -> ::std::os::raw::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set___errsumm(&mut self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn __c0(&self) -> ::std::os::raw::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set___c0(&mut self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn __c1(&self) -> ::std::os::raw::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set___c1(&mut self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn __c2(&self) -> ::std::os::raw::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set___c2(&mut self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn __tos(&self) -> ::std::os::raw::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 3u8) as u16) }
    }
    #[inline]
    pub fn set___tos(&mut self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn __c3(&self) -> ::std::os::raw::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set___c3(&mut self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn __busy(&self) -> ::std::os::raw::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set___busy(&mut self, val: ::std::os::raw::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        __invalid: ::std::os::raw::c_ushort,
        __denorm: ::std::os::raw::c_ushort,
        __zdiv: ::std::os::raw::c_ushort,
        __ovrfl: ::std::os::raw::c_ushort,
        __undfl: ::std::os::raw::c_ushort,
        __precis: ::std::os::raw::c_ushort,
        __stkflt: ::std::os::raw::c_ushort,
        __errsumm: ::std::os::raw::c_ushort,
        __c0: ::std::os::raw::c_ushort,
        __c1: ::std::os::raw::c_ushort,
        __c2: ::std::os::raw::c_ushort,
        __tos: ::std::os::raw::c_ushort,
        __c3: ::std::os::raw::c_ushort,
        __busy: ::std::os::raw::c_ushort,
    ) -> __BindgenBitfieldUnit<[u8; 2usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let __invalid: u16 = unsafe { ::std::mem::transmute(__invalid) };
            __invalid as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let __denorm: u16 = unsafe { ::std::mem::transmute(__denorm) };
            __denorm as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let __zdiv: u16 = unsafe { ::std::mem::transmute(__zdiv) };
            __zdiv as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let __ovrfl: u16 = unsafe { ::std::mem::transmute(__ovrfl) };
            __ovrfl as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let __undfl: u16 = unsafe { ::std::mem::transmute(__undfl) };
            __undfl as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let __precis: u16 = unsafe { ::std::mem::transmute(__precis) };
            __precis as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let __stkflt: u16 = unsafe { ::std::mem::transmute(__stkflt) };
            __stkflt as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let __errsumm: u16 = unsafe { ::std::mem::transmute(__errsumm) };
            __errsumm as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let __c0: u16 = unsafe { ::std::mem::transmute(__c0) };
            __c0 as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let __c1: u16 = unsafe { ::std::mem::transmute(__c1) };
            __c1 as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let __c2: u16 = unsafe { ::std::mem::transmute(__c2) };
            __c2 as u64
        });
        __bindgen_bitfield_unit.set(11usize, 3u8, {
            let __tos: u16 = unsafe { ::std::mem::transmute(__tos) };
            __tos as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let __c3: u16 = unsafe { ::std::mem::transmute(__c3) };
            __c3 as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let __busy: u16 = unsafe { ::std::mem::transmute(__busy) };
            __busy as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type __darwin_fp_status_t = __darwin_fp_status;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_mmst_reg {
    pub __mmst_reg: [::std::os::raw::c_char; 10usize],
    pub __mmst_rsrv: [::std::os::raw::c_char; 6usize],
}
#[test]
fn bindgen_test_layout___darwin_mmst_reg() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_mmst_reg>(),
        16usize,
        concat!("Size of: ", stringify!(__darwin_mmst_reg))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_mmst_reg>(),
        1usize,
        concat!("Alignment of ", stringify!(__darwin_mmst_reg))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__darwin_mmst_reg>())).__mmst_reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_mmst_reg),
            "::",
            stringify!(__mmst_reg)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__darwin_mmst_reg>())).__mmst_rsrv as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_mmst_reg),
            "::",
            stringify!(__mmst_rsrv)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_xmm_reg {
    pub __xmm_reg: [::std::os::raw::c_char; 16usize],
}
#[test]
fn bindgen_test_layout___darwin_xmm_reg() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_xmm_reg>(),
        16usize,
        concat!("Size of: ", stringify!(__darwin_xmm_reg))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_xmm_reg>(),
        1usize,
        concat!("Alignment of ", stringify!(__darwin_xmm_reg))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__darwin_xmm_reg>())).__xmm_reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_xmm_reg),
            "::",
            stringify!(__xmm_reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __darwin_i386_float_state {
    pub __fpu_reserved: [::std::os::raw::c_int; 2usize],
    pub __fpu_fcw: __darwin_fp_control,
    pub __fpu_fsw: __darwin_fp_status,
    pub __fpu_ftw: __uint8_t,
    pub __fpu_rsrv1: __uint8_t,
    pub __fpu_fop: __uint16_t,
    pub __fpu_ip: __uint32_t,
    pub __fpu_cs: __uint16_t,
    pub __fpu_rsrv2: __uint16_t,
    pub __fpu_dp: __uint32_t,
    pub __fpu_ds: __uint16_t,
    pub __fpu_rsrv3: __uint16_t,
    pub __fpu_mxcsr: __uint32_t,
    pub __fpu_mxcsrmask: __uint32_t,
    pub __fpu_stmm0: __darwin_mmst_reg,
    pub __fpu_stmm1: __darwin_mmst_reg,
    pub __fpu_stmm2: __darwin_mmst_reg,
    pub __fpu_stmm3: __darwin_mmst_reg,
    pub __fpu_stmm4: __darwin_mmst_reg,
    pub __fpu_stmm5: __darwin_mmst_reg,
    pub __fpu_stmm6: __darwin_mmst_reg,
    pub __fpu_stmm7: __darwin_mmst_reg,
    pub __fpu_xmm0: __darwin_xmm_reg,
    pub __fpu_xmm1: __darwin_xmm_reg,
    pub __fpu_xmm2: __darwin_xmm_reg,
    pub __fpu_xmm3: __darwin_xmm_reg,
    pub __fpu_xmm4: __darwin_xmm_reg,
    pub __fpu_xmm5: __darwin_xmm_reg,
    pub __fpu_xmm6: __darwin_xmm_reg,
    pub __fpu_xmm7: __darwin_xmm_reg,
    pub __fpu_rsrv4: [::std::os::raw::c_char; 224usize],
    pub __fpu_reserved1: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout___darwin_i386_float_state() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_i386_float_state>(),
        524usize,
        concat!("Size of: ", stringify!(__darwin_i386_float_state))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_i386_float_state>(),
        4usize,
        concat!("Alignment of ", stringify!(__darwin_i386_float_state))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_float_state>())).__fpu_reserved as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_float_state),
            "::",
            stringify!(__fpu_reserved)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_float_state>())).__fpu_fcw as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_float_state),
            "::",
            stringify!(__fpu_fcw)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_float_state>())).__fpu_fsw as *const _ as usize
        },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_float_state),
            "::",
            stringify!(__fpu_fsw)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_float_state>())).__fpu_ftw as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_float_state),
            "::",
            stringify!(__fpu_ftw)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_float_state>())).__fpu_rsrv1 as *const _ as usize
        },
        13usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_float_state),
            "::",
            stringify!(__fpu_rsrv1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_float_state>())).__fpu_fop as *const _ as usize
        },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_float_state),
            "::",
            stringify!(__fpu_fop)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_float_state>())).__fpu_ip as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_float_state),
            "::",
            stringify!(__fpu_ip)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_float_state>())).__fpu_cs as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_float_state),
            "::",
            stringify!(__fpu_cs)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_float_state>())).__fpu_rsrv2 as *const _ as usize
        },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_float_state),
            "::",
            stringify!(__fpu_rsrv2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_float_state>())).__fpu_dp as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_float_state),
            "::",
            stringify!(__fpu_dp)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_float_state>())).__fpu_ds as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_float_state),
            "::",
            stringify!(__fpu_ds)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_float_state>())).__fpu_rsrv3 as *const _ as usize
        },
        30usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_float_state),
            "::",
            stringify!(__fpu_rsrv3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_float_state>())).__fpu_mxcsr as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_float_state),
            "::",
            stringify!(__fpu_mxcsr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_float_state>())).__fpu_mxcsrmask as *const _
                as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_float_state),
            "::",
            stringify!(__fpu_mxcsrmask)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_float_state>())).__fpu_stmm0 as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_float_state),
            "::",
            stringify!(__fpu_stmm0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_float_state>())).__fpu_stmm1 as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_float_state),
            "::",
            stringify!(__fpu_stmm1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_float_state>())).__fpu_stmm2 as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_float_state),
            "::",
            stringify!(__fpu_stmm2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_float_state>())).__fpu_stmm3 as *const _ as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_float_state),
            "::",
            stringify!(__fpu_stmm3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_float_state>())).__fpu_stmm4 as *const _ as usize
        },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_float_state),
            "::",
            stringify!(__fpu_stmm4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_float_state>())).__fpu_stmm5 as *const _ as usize
        },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_float_state),
            "::",
            stringify!(__fpu_stmm5)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_float_state>())).__fpu_stmm6 as *const _ as usize
        },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_float_state),
            "::",
            stringify!(__fpu_stmm6)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_float_state>())).__fpu_stmm7 as *const _ as usize
        },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_float_state),
            "::",
            stringify!(__fpu_stmm7)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_float_state>())).__fpu_xmm0 as *const _ as usize
        },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_float_state),
            "::",
            stringify!(__fpu_xmm0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_float_state>())).__fpu_xmm1 as *const _ as usize
        },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_float_state),
            "::",
            stringify!(__fpu_xmm1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_float_state>())).__fpu_xmm2 as *const _ as usize
        },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_float_state),
            "::",
            stringify!(__fpu_xmm2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_float_state>())).__fpu_xmm3 as *const _ as usize
        },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_float_state),
            "::",
            stringify!(__fpu_xmm3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_float_state>())).__fpu_xmm4 as *const _ as usize
        },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_float_state),
            "::",
            stringify!(__fpu_xmm4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_float_state>())).__fpu_xmm5 as *const _ as usize
        },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_float_state),
            "::",
            stringify!(__fpu_xmm5)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_float_state>())).__fpu_xmm6 as *const _ as usize
        },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_float_state),
            "::",
            stringify!(__fpu_xmm6)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_float_state>())).__fpu_xmm7 as *const _ as usize
        },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_float_state),
            "::",
            stringify!(__fpu_xmm7)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_float_state>())).__fpu_rsrv4 as *const _ as usize
        },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_float_state),
            "::",
            stringify!(__fpu_rsrv4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_float_state>())).__fpu_reserved1 as *const _
                as usize
        },
        520usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_float_state),
            "::",
            stringify!(__fpu_reserved1)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __darwin_i386_avx_state {
    pub __fpu_reserved: [::std::os::raw::c_int; 2usize],
    pub __fpu_fcw: __darwin_fp_control,
    pub __fpu_fsw: __darwin_fp_status,
    pub __fpu_ftw: __uint8_t,
    pub __fpu_rsrv1: __uint8_t,
    pub __fpu_fop: __uint16_t,
    pub __fpu_ip: __uint32_t,
    pub __fpu_cs: __uint16_t,
    pub __fpu_rsrv2: __uint16_t,
    pub __fpu_dp: __uint32_t,
    pub __fpu_ds: __uint16_t,
    pub __fpu_rsrv3: __uint16_t,
    pub __fpu_mxcsr: __uint32_t,
    pub __fpu_mxcsrmask: __uint32_t,
    pub __fpu_stmm0: __darwin_mmst_reg,
    pub __fpu_stmm1: __darwin_mmst_reg,
    pub __fpu_stmm2: __darwin_mmst_reg,
    pub __fpu_stmm3: __darwin_mmst_reg,
    pub __fpu_stmm4: __darwin_mmst_reg,
    pub __fpu_stmm5: __darwin_mmst_reg,
    pub __fpu_stmm6: __darwin_mmst_reg,
    pub __fpu_stmm7: __darwin_mmst_reg,
    pub __fpu_xmm0: __darwin_xmm_reg,
    pub __fpu_xmm1: __darwin_xmm_reg,
    pub __fpu_xmm2: __darwin_xmm_reg,
    pub __fpu_xmm3: __darwin_xmm_reg,
    pub __fpu_xmm4: __darwin_xmm_reg,
    pub __fpu_xmm5: __darwin_xmm_reg,
    pub __fpu_xmm6: __darwin_xmm_reg,
    pub __fpu_xmm7: __darwin_xmm_reg,
    pub __fpu_rsrv4: [::std::os::raw::c_char; 224usize],
    pub __fpu_reserved1: ::std::os::raw::c_int,
    pub __avx_reserved1: [::std::os::raw::c_char; 64usize],
    pub __fpu_ymmh0: __darwin_xmm_reg,
    pub __fpu_ymmh1: __darwin_xmm_reg,
    pub __fpu_ymmh2: __darwin_xmm_reg,
    pub __fpu_ymmh3: __darwin_xmm_reg,
    pub __fpu_ymmh4: __darwin_xmm_reg,
    pub __fpu_ymmh5: __darwin_xmm_reg,
    pub __fpu_ymmh6: __darwin_xmm_reg,
    pub __fpu_ymmh7: __darwin_xmm_reg,
}
#[test]
fn bindgen_test_layout___darwin_i386_avx_state() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_i386_avx_state>(),
        716usize,
        concat!("Size of: ", stringify!(__darwin_i386_avx_state))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_i386_avx_state>(),
        4usize,
        concat!("Alignment of ", stringify!(__darwin_i386_avx_state))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__fpu_reserved as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_reserved)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__fpu_fcw as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_fcw)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__fpu_fsw as *const _ as usize
        },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_fsw)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__fpu_ftw as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_ftw)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__fpu_rsrv1 as *const _ as usize
        },
        13usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_rsrv1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__fpu_fop as *const _ as usize
        },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_fop)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__fpu_ip as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_ip)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__fpu_cs as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_cs)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__fpu_rsrv2 as *const _ as usize
        },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_rsrv2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__fpu_dp as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_dp)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__fpu_ds as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_ds)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__fpu_rsrv3 as *const _ as usize
        },
        30usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_rsrv3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__fpu_mxcsr as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_mxcsr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__fpu_mxcsrmask as *const _ as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_mxcsrmask)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__fpu_stmm0 as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_stmm0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__fpu_stmm1 as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_stmm1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__fpu_stmm2 as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_stmm2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__fpu_stmm3 as *const _ as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_stmm3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__fpu_stmm4 as *const _ as usize
        },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_stmm4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__fpu_stmm5 as *const _ as usize
        },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_stmm5)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__fpu_stmm6 as *const _ as usize
        },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_stmm6)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__fpu_stmm7 as *const _ as usize
        },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_stmm7)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__fpu_xmm0 as *const _ as usize
        },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_xmm0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__fpu_xmm1 as *const _ as usize
        },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_xmm1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__fpu_xmm2 as *const _ as usize
        },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_xmm2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__fpu_xmm3 as *const _ as usize
        },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_xmm3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__fpu_xmm4 as *const _ as usize
        },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_xmm4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__fpu_xmm5 as *const _ as usize
        },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_xmm5)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__fpu_xmm6 as *const _ as usize
        },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_xmm6)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__fpu_xmm7 as *const _ as usize
        },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_xmm7)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__fpu_rsrv4 as *const _ as usize
        },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_rsrv4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__fpu_reserved1 as *const _ as usize
        },
        520usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_reserved1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__avx_reserved1 as *const _ as usize
        },
        524usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__avx_reserved1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__fpu_ymmh0 as *const _ as usize
        },
        588usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_ymmh0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__fpu_ymmh1 as *const _ as usize
        },
        604usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_ymmh1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__fpu_ymmh2 as *const _ as usize
        },
        620usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_ymmh2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__fpu_ymmh3 as *const _ as usize
        },
        636usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_ymmh3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__fpu_ymmh4 as *const _ as usize
        },
        652usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_ymmh4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__fpu_ymmh5 as *const _ as usize
        },
        668usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_ymmh5)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__fpu_ymmh6 as *const _ as usize
        },
        684usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_ymmh6)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__fpu_ymmh7 as *const _ as usize
        },
        700usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_ymmh7)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_i386_exception_state {
    pub __trapno: __uint16_t,
    pub __cpu: __uint16_t,
    pub __err: __uint32_t,
    pub __faultvaddr: __uint32_t,
}
#[test]
fn bindgen_test_layout___darwin_i386_exception_state() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_i386_exception_state>(),
        12usize,
        concat!("Size of: ", stringify!(__darwin_i386_exception_state))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_i386_exception_state>(),
        4usize,
        concat!("Alignment of ", stringify!(__darwin_i386_exception_state))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_exception_state>())).__trapno as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_exception_state),
            "::",
            stringify!(__trapno)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_exception_state>())).__cpu as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_exception_state),
            "::",
            stringify!(__cpu)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_exception_state>())).__err as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_exception_state),
            "::",
            stringify!(__err)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_exception_state>())).__faultvaddr as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_exception_state),
            "::",
            stringify!(__faultvaddr)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_x86_debug_state32 {
    pub __dr0: ::std::os::raw::c_uint,
    pub __dr1: ::std::os::raw::c_uint,
    pub __dr2: ::std::os::raw::c_uint,
    pub __dr3: ::std::os::raw::c_uint,
    pub __dr4: ::std::os::raw::c_uint,
    pub __dr5: ::std::os::raw::c_uint,
    pub __dr6: ::std::os::raw::c_uint,
    pub __dr7: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout___darwin_x86_debug_state32() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_x86_debug_state32>(),
        32usize,
        concat!("Size of: ", stringify!(__darwin_x86_debug_state32))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_x86_debug_state32>(),
        4usize,
        concat!("Alignment of ", stringify!(__darwin_x86_debug_state32))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_debug_state32>())).__dr0 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_debug_state32),
            "::",
            stringify!(__dr0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_debug_state32>())).__dr1 as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_debug_state32),
            "::",
            stringify!(__dr1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_debug_state32>())).__dr2 as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_debug_state32),
            "::",
            stringify!(__dr2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_debug_state32>())).__dr3 as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_debug_state32),
            "::",
            stringify!(__dr3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_debug_state32>())).__dr4 as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_debug_state32),
            "::",
            stringify!(__dr4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_debug_state32>())).__dr5 as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_debug_state32),
            "::",
            stringify!(__dr5)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_debug_state32>())).__dr6 as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_debug_state32),
            "::",
            stringify!(__dr6)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_debug_state32>())).__dr7 as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_debug_state32),
            "::",
            stringify!(__dr7)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_x86_thread_state64 {
    pub __rax: __uint64_t,
    pub __rbx: __uint64_t,
    pub __rcx: __uint64_t,
    pub __rdx: __uint64_t,
    pub __rdi: __uint64_t,
    pub __rsi: __uint64_t,
    pub __rbp: __uint64_t,
    pub __rsp: __uint64_t,
    pub __r8: __uint64_t,
    pub __r9: __uint64_t,
    pub __r10: __uint64_t,
    pub __r11: __uint64_t,
    pub __r12: __uint64_t,
    pub __r13: __uint64_t,
    pub __r14: __uint64_t,
    pub __r15: __uint64_t,
    pub __rip: __uint64_t,
    pub __rflags: __uint64_t,
    pub __cs: __uint64_t,
    pub __fs: __uint64_t,
    pub __gs: __uint64_t,
}
#[test]
fn bindgen_test_layout___darwin_x86_thread_state64() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_x86_thread_state64>(),
        168usize,
        concat!("Size of: ", stringify!(__darwin_x86_thread_state64))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_x86_thread_state64>(),
        8usize,
        concat!("Alignment of ", stringify!(__darwin_x86_thread_state64))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_thread_state64>())).__rax as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_thread_state64),
            "::",
            stringify!(__rax)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_thread_state64>())).__rbx as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_thread_state64),
            "::",
            stringify!(__rbx)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_thread_state64>())).__rcx as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_thread_state64),
            "::",
            stringify!(__rcx)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_thread_state64>())).__rdx as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_thread_state64),
            "::",
            stringify!(__rdx)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_thread_state64>())).__rdi as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_thread_state64),
            "::",
            stringify!(__rdi)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_thread_state64>())).__rsi as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_thread_state64),
            "::",
            stringify!(__rsi)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_thread_state64>())).__rbp as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_thread_state64),
            "::",
            stringify!(__rbp)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_thread_state64>())).__rsp as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_thread_state64),
            "::",
            stringify!(__rsp)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_thread_state64>())).__r8 as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_thread_state64),
            "::",
            stringify!(__r8)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_thread_state64>())).__r9 as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_thread_state64),
            "::",
            stringify!(__r9)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_thread_state64>())).__r10 as *const _ as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_thread_state64),
            "::",
            stringify!(__r10)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_thread_state64>())).__r11 as *const _ as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_thread_state64),
            "::",
            stringify!(__r11)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_thread_state64>())).__r12 as *const _ as usize
        },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_thread_state64),
            "::",
            stringify!(__r12)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_thread_state64>())).__r13 as *const _ as usize
        },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_thread_state64),
            "::",
            stringify!(__r13)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_thread_state64>())).__r14 as *const _ as usize
        },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_thread_state64),
            "::",
            stringify!(__r14)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_thread_state64>())).__r15 as *const _ as usize
        },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_thread_state64),
            "::",
            stringify!(__r15)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_thread_state64>())).__rip as *const _ as usize
        },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_thread_state64),
            "::",
            stringify!(__rip)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_thread_state64>())).__rflags as *const _ as usize
        },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_thread_state64),
            "::",
            stringify!(__rflags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_thread_state64>())).__cs as *const _ as usize
        },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_thread_state64),
            "::",
            stringify!(__cs)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_thread_state64>())).__fs as *const _ as usize
        },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_thread_state64),
            "::",
            stringify!(__fs)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_thread_state64>())).__gs as *const _ as usize
        },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_thread_state64),
            "::",
            stringify!(__gs)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __darwin_x86_float_state64 {
    pub __fpu_reserved: [::std::os::raw::c_int; 2usize],
    pub __fpu_fcw: __darwin_fp_control,
    pub __fpu_fsw: __darwin_fp_status,
    pub __fpu_ftw: __uint8_t,
    pub __fpu_rsrv1: __uint8_t,
    pub __fpu_fop: __uint16_t,
    pub __fpu_ip: __uint32_t,
    pub __fpu_cs: __uint16_t,
    pub __fpu_rsrv2: __uint16_t,
    pub __fpu_dp: __uint32_t,
    pub __fpu_ds: __uint16_t,
    pub __fpu_rsrv3: __uint16_t,
    pub __fpu_mxcsr: __uint32_t,
    pub __fpu_mxcsrmask: __uint32_t,
    pub __fpu_stmm0: __darwin_mmst_reg,
    pub __fpu_stmm1: __darwin_mmst_reg,
    pub __fpu_stmm2: __darwin_mmst_reg,
    pub __fpu_stmm3: __darwin_mmst_reg,
    pub __fpu_stmm4: __darwin_mmst_reg,
    pub __fpu_stmm5: __darwin_mmst_reg,
    pub __fpu_stmm6: __darwin_mmst_reg,
    pub __fpu_stmm7: __darwin_mmst_reg,
    pub __fpu_xmm0: __darwin_xmm_reg,
    pub __fpu_xmm1: __darwin_xmm_reg,
    pub __fpu_xmm2: __darwin_xmm_reg,
    pub __fpu_xmm3: __darwin_xmm_reg,
    pub __fpu_xmm4: __darwin_xmm_reg,
    pub __fpu_xmm5: __darwin_xmm_reg,
    pub __fpu_xmm6: __darwin_xmm_reg,
    pub __fpu_xmm7: __darwin_xmm_reg,
    pub __fpu_xmm8: __darwin_xmm_reg,
    pub __fpu_xmm9: __darwin_xmm_reg,
    pub __fpu_xmm10: __darwin_xmm_reg,
    pub __fpu_xmm11: __darwin_xmm_reg,
    pub __fpu_xmm12: __darwin_xmm_reg,
    pub __fpu_xmm13: __darwin_xmm_reg,
    pub __fpu_xmm14: __darwin_xmm_reg,
    pub __fpu_xmm15: __darwin_xmm_reg,
    pub __fpu_rsrv4: [::std::os::raw::c_char; 96usize],
    pub __fpu_reserved1: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout___darwin_x86_float_state64() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_x86_float_state64>(),
        524usize,
        concat!("Size of: ", stringify!(__darwin_x86_float_state64))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_x86_float_state64>(),
        4usize,
        concat!("Alignment of ", stringify!(__darwin_x86_float_state64))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_float_state64>())).__fpu_reserved as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_reserved)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_float_state64>())).__fpu_fcw as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_fcw)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_float_state64>())).__fpu_fsw as *const _ as usize
        },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_fsw)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_float_state64>())).__fpu_ftw as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_ftw)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_float_state64>())).__fpu_rsrv1 as *const _ as usize
        },
        13usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_rsrv1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_float_state64>())).__fpu_fop as *const _ as usize
        },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_fop)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_float_state64>())).__fpu_ip as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_ip)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_float_state64>())).__fpu_cs as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_cs)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_float_state64>())).__fpu_rsrv2 as *const _ as usize
        },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_rsrv2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_float_state64>())).__fpu_dp as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_dp)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_float_state64>())).__fpu_ds as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_ds)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_float_state64>())).__fpu_rsrv3 as *const _ as usize
        },
        30usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_rsrv3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_float_state64>())).__fpu_mxcsr as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_mxcsr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_float_state64>())).__fpu_mxcsrmask as *const _
                as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_mxcsrmask)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_float_state64>())).__fpu_stmm0 as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_stmm0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_float_state64>())).__fpu_stmm1 as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_stmm1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_float_state64>())).__fpu_stmm2 as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_stmm2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_float_state64>())).__fpu_stmm3 as *const _ as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_stmm3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_float_state64>())).__fpu_stmm4 as *const _ as usize
        },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_stmm4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_float_state64>())).__fpu_stmm5 as *const _ as usize
        },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_stmm5)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_float_state64>())).__fpu_stmm6 as *const _ as usize
        },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_stmm6)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_float_state64>())).__fpu_stmm7 as *const _ as usize
        },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_stmm7)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_float_state64>())).__fpu_xmm0 as *const _ as usize
        },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_xmm0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_float_state64>())).__fpu_xmm1 as *const _ as usize
        },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_xmm1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_float_state64>())).__fpu_xmm2 as *const _ as usize
        },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_xmm2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_float_state64>())).__fpu_xmm3 as *const _ as usize
        },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_xmm3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_float_state64>())).__fpu_xmm4 as *const _ as usize
        },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_xmm4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_float_state64>())).__fpu_xmm5 as *const _ as usize
        },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_xmm5)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_float_state64>())).__fpu_xmm6 as *const _ as usize
        },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_xmm6)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_float_state64>())).__fpu_xmm7 as *const _ as usize
        },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_xmm7)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_float_state64>())).__fpu_xmm8 as *const _ as usize
        },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_xmm8)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_float_state64>())).__fpu_xmm9 as *const _ as usize
        },
        312usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_xmm9)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_float_state64>())).__fpu_xmm10 as *const _ as usize
        },
        328usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_xmm10)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_float_state64>())).__fpu_xmm11 as *const _ as usize
        },
        344usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_xmm11)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_float_state64>())).__fpu_xmm12 as *const _ as usize
        },
        360usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_xmm12)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_float_state64>())).__fpu_xmm13 as *const _ as usize
        },
        376usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_xmm13)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_float_state64>())).__fpu_xmm14 as *const _ as usize
        },
        392usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_xmm14)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_float_state64>())).__fpu_xmm15 as *const _ as usize
        },
        408usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_xmm15)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_float_state64>())).__fpu_rsrv4 as *const _ as usize
        },
        424usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_rsrv4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_float_state64>())).__fpu_reserved1 as *const _
                as usize
        },
        520usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_reserved1)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __darwin_x86_avx_state64 {
    pub __fpu_reserved: [::std::os::raw::c_int; 2usize],
    pub __fpu_fcw: __darwin_fp_control,
    pub __fpu_fsw: __darwin_fp_status,
    pub __fpu_ftw: __uint8_t,
    pub __fpu_rsrv1: __uint8_t,
    pub __fpu_fop: __uint16_t,
    pub __fpu_ip: __uint32_t,
    pub __fpu_cs: __uint16_t,
    pub __fpu_rsrv2: __uint16_t,
    pub __fpu_dp: __uint32_t,
    pub __fpu_ds: __uint16_t,
    pub __fpu_rsrv3: __uint16_t,
    pub __fpu_mxcsr: __uint32_t,
    pub __fpu_mxcsrmask: __uint32_t,
    pub __fpu_stmm0: __darwin_mmst_reg,
    pub __fpu_stmm1: __darwin_mmst_reg,
    pub __fpu_stmm2: __darwin_mmst_reg,
    pub __fpu_stmm3: __darwin_mmst_reg,
    pub __fpu_stmm4: __darwin_mmst_reg,
    pub __fpu_stmm5: __darwin_mmst_reg,
    pub __fpu_stmm6: __darwin_mmst_reg,
    pub __fpu_stmm7: __darwin_mmst_reg,
    pub __fpu_xmm0: __darwin_xmm_reg,
    pub __fpu_xmm1: __darwin_xmm_reg,
    pub __fpu_xmm2: __darwin_xmm_reg,
    pub __fpu_xmm3: __darwin_xmm_reg,
    pub __fpu_xmm4: __darwin_xmm_reg,
    pub __fpu_xmm5: __darwin_xmm_reg,
    pub __fpu_xmm6: __darwin_xmm_reg,
    pub __fpu_xmm7: __darwin_xmm_reg,
    pub __fpu_xmm8: __darwin_xmm_reg,
    pub __fpu_xmm9: __darwin_xmm_reg,
    pub __fpu_xmm10: __darwin_xmm_reg,
    pub __fpu_xmm11: __darwin_xmm_reg,
    pub __fpu_xmm12: __darwin_xmm_reg,
    pub __fpu_xmm13: __darwin_xmm_reg,
    pub __fpu_xmm14: __darwin_xmm_reg,
    pub __fpu_xmm15: __darwin_xmm_reg,
    pub __fpu_rsrv4: [::std::os::raw::c_char; 96usize],
    pub __fpu_reserved1: ::std::os::raw::c_int,
    pub __avx_reserved1: [::std::os::raw::c_char; 64usize],
    pub __fpu_ymmh0: __darwin_xmm_reg,
    pub __fpu_ymmh1: __darwin_xmm_reg,
    pub __fpu_ymmh2: __darwin_xmm_reg,
    pub __fpu_ymmh3: __darwin_xmm_reg,
    pub __fpu_ymmh4: __darwin_xmm_reg,
    pub __fpu_ymmh5: __darwin_xmm_reg,
    pub __fpu_ymmh6: __darwin_xmm_reg,
    pub __fpu_ymmh7: __darwin_xmm_reg,
    pub __fpu_ymmh8: __darwin_xmm_reg,
    pub __fpu_ymmh9: __darwin_xmm_reg,
    pub __fpu_ymmh10: __darwin_xmm_reg,
    pub __fpu_ymmh11: __darwin_xmm_reg,
    pub __fpu_ymmh12: __darwin_xmm_reg,
    pub __fpu_ymmh13: __darwin_xmm_reg,
    pub __fpu_ymmh14: __darwin_xmm_reg,
    pub __fpu_ymmh15: __darwin_xmm_reg,
}
#[test]
fn bindgen_test_layout___darwin_x86_avx_state64() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_x86_avx_state64>(),
        844usize,
        concat!("Size of: ", stringify!(__darwin_x86_avx_state64))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_x86_avx_state64>(),
        4usize,
        concat!("Alignment of ", stringify!(__darwin_x86_avx_state64))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_reserved as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_reserved)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_fcw as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_fcw)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_fsw as *const _ as usize
        },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_fsw)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_ftw as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_ftw)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_rsrv1 as *const _ as usize
        },
        13usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_rsrv1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_fop as *const _ as usize
        },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_fop)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_ip as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_ip)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_cs as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_cs)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_rsrv2 as *const _ as usize
        },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_rsrv2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_dp as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_dp)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_ds as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_ds)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_rsrv3 as *const _ as usize
        },
        30usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_rsrv3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_mxcsr as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_mxcsr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_mxcsrmask as *const _
                as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_mxcsrmask)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_stmm0 as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_stmm0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_stmm1 as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_stmm1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_stmm2 as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_stmm2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_stmm3 as *const _ as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_stmm3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_stmm4 as *const _ as usize
        },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_stmm4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_stmm5 as *const _ as usize
        },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_stmm5)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_stmm6 as *const _ as usize
        },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_stmm6)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_stmm7 as *const _ as usize
        },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_stmm7)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_xmm0 as *const _ as usize
        },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_xmm0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_xmm1 as *const _ as usize
        },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_xmm1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_xmm2 as *const _ as usize
        },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_xmm2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_xmm3 as *const _ as usize
        },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_xmm3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_xmm4 as *const _ as usize
        },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_xmm4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_xmm5 as *const _ as usize
        },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_xmm5)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_xmm6 as *const _ as usize
        },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_xmm6)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_xmm7 as *const _ as usize
        },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_xmm7)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_xmm8 as *const _ as usize
        },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_xmm8)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_xmm9 as *const _ as usize
        },
        312usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_xmm9)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_xmm10 as *const _ as usize
        },
        328usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_xmm10)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_xmm11 as *const _ as usize
        },
        344usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_xmm11)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_xmm12 as *const _ as usize
        },
        360usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_xmm12)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_xmm13 as *const _ as usize
        },
        376usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_xmm13)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_xmm14 as *const _ as usize
        },
        392usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_xmm14)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_xmm15 as *const _ as usize
        },
        408usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_xmm15)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_rsrv4 as *const _ as usize
        },
        424usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_rsrv4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_reserved1 as *const _
                as usize
        },
        520usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_reserved1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__avx_reserved1 as *const _
                as usize
        },
        524usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__avx_reserved1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_ymmh0 as *const _ as usize
        },
        588usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_ymmh0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_ymmh1 as *const _ as usize
        },
        604usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_ymmh1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_ymmh2 as *const _ as usize
        },
        620usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_ymmh2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_ymmh3 as *const _ as usize
        },
        636usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_ymmh3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_ymmh4 as *const _ as usize
        },
        652usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_ymmh4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_ymmh5 as *const _ as usize
        },
        668usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_ymmh5)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_ymmh6 as *const _ as usize
        },
        684usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_ymmh6)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_ymmh7 as *const _ as usize
        },
        700usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_ymmh7)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_ymmh8 as *const _ as usize
        },
        716usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_ymmh8)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_ymmh9 as *const _ as usize
        },
        732usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_ymmh9)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_ymmh10 as *const _ as usize
        },
        748usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_ymmh10)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_ymmh11 as *const _ as usize
        },
        764usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_ymmh11)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_ymmh12 as *const _ as usize
        },
        780usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_ymmh12)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_ymmh13 as *const _ as usize
        },
        796usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_ymmh13)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_ymmh14 as *const _ as usize
        },
        812usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_ymmh14)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_ymmh15 as *const _ as usize
        },
        828usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_ymmh15)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_x86_exception_state64 {
    pub __trapno: __uint16_t,
    pub __cpu: __uint16_t,
    pub __err: __uint32_t,
    pub __faultvaddr: __uint64_t,
}
#[test]
fn bindgen_test_layout___darwin_x86_exception_state64() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_x86_exception_state64>(),
        16usize,
        concat!("Size of: ", stringify!(__darwin_x86_exception_state64))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_x86_exception_state64>(),
        8usize,
        concat!("Alignment of ", stringify!(__darwin_x86_exception_state64))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_exception_state64>())).__trapno as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_exception_state64),
            "::",
            stringify!(__trapno)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_exception_state64>())).__cpu as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_exception_state64),
            "::",
            stringify!(__cpu)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_exception_state64>())).__err as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_exception_state64),
            "::",
            stringify!(__err)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_exception_state64>())).__faultvaddr as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_exception_state64),
            "::",
            stringify!(__faultvaddr)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_x86_debug_state64 {
    pub __dr0: __uint64_t,
    pub __dr1: __uint64_t,
    pub __dr2: __uint64_t,
    pub __dr3: __uint64_t,
    pub __dr4: __uint64_t,
    pub __dr5: __uint64_t,
    pub __dr6: __uint64_t,
    pub __dr7: __uint64_t,
}
#[test]
fn bindgen_test_layout___darwin_x86_debug_state64() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_x86_debug_state64>(),
        64usize,
        concat!("Size of: ", stringify!(__darwin_x86_debug_state64))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_x86_debug_state64>(),
        8usize,
        concat!("Alignment of ", stringify!(__darwin_x86_debug_state64))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_debug_state64>())).__dr0 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_debug_state64),
            "::",
            stringify!(__dr0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_debug_state64>())).__dr1 as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_debug_state64),
            "::",
            stringify!(__dr1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_debug_state64>())).__dr2 as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_debug_state64),
            "::",
            stringify!(__dr2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_debug_state64>())).__dr3 as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_debug_state64),
            "::",
            stringify!(__dr3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_debug_state64>())).__dr4 as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_debug_state64),
            "::",
            stringify!(__dr4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_debug_state64>())).__dr5 as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_debug_state64),
            "::",
            stringify!(__dr5)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_debug_state64>())).__dr6 as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_debug_state64),
            "::",
            stringify!(__dr6)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_debug_state64>())).__dr7 as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_debug_state64),
            "::",
            stringify!(__dr7)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __darwin_mcontext32 {
    pub __es: __darwin_i386_exception_state,
    pub __ss: __darwin_i386_thread_state,
    pub __fs: __darwin_i386_float_state,
}
#[test]
fn bindgen_test_layout___darwin_mcontext32() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_mcontext32>(),
        600usize,
        concat!("Size of: ", stringify!(__darwin_mcontext32))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_mcontext32>(),
        4usize,
        concat!("Alignment of ", stringify!(__darwin_mcontext32))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__darwin_mcontext32>())).__es as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_mcontext32),
            "::",
            stringify!(__es)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__darwin_mcontext32>())).__ss as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_mcontext32),
            "::",
            stringify!(__ss)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__darwin_mcontext32>())).__fs as *const _ as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_mcontext32),
            "::",
            stringify!(__fs)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __darwin_mcontext_avx32 {
    pub __es: __darwin_i386_exception_state,
    pub __ss: __darwin_i386_thread_state,
    pub __fs: __darwin_i386_avx_state,
}
#[test]
fn bindgen_test_layout___darwin_mcontext_avx32() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_mcontext_avx32>(),
        792usize,
        concat!("Size of: ", stringify!(__darwin_mcontext_avx32))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_mcontext_avx32>(),
        4usize,
        concat!("Alignment of ", stringify!(__darwin_mcontext_avx32))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__darwin_mcontext_avx32>())).__es as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_mcontext_avx32),
            "::",
            stringify!(__es)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__darwin_mcontext_avx32>())).__ss as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_mcontext_avx32),
            "::",
            stringify!(__ss)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__darwin_mcontext_avx32>())).__fs as *const _ as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_mcontext_avx32),
            "::",
            stringify!(__fs)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __darwin_mcontext64 {
    pub __es: __darwin_x86_exception_state64,
    pub __ss: __darwin_x86_thread_state64,
    pub __fs: __darwin_x86_float_state64,
}
#[test]
fn bindgen_test_layout___darwin_mcontext64() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_mcontext64>(),
        712usize,
        concat!("Size of: ", stringify!(__darwin_mcontext64))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_mcontext64>(),
        8usize,
        concat!("Alignment of ", stringify!(__darwin_mcontext64))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__darwin_mcontext64>())).__es as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_mcontext64),
            "::",
            stringify!(__es)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__darwin_mcontext64>())).__ss as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_mcontext64),
            "::",
            stringify!(__ss)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__darwin_mcontext64>())).__fs as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_mcontext64),
            "::",
            stringify!(__fs)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __darwin_mcontext_avx64 {
    pub __es: __darwin_x86_exception_state64,
    pub __ss: __darwin_x86_thread_state64,
    pub __fs: __darwin_x86_avx_state64,
}
#[test]
fn bindgen_test_layout___darwin_mcontext_avx64() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_mcontext_avx64>(),
        1032usize,
        concat!("Size of: ", stringify!(__darwin_mcontext_avx64))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_mcontext_avx64>(),
        8usize,
        concat!("Alignment of ", stringify!(__darwin_mcontext_avx64))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__darwin_mcontext_avx64>())).__es as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_mcontext_avx64),
            "::",
            stringify!(__es)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__darwin_mcontext_avx64>())).__ss as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_mcontext_avx64),
            "::",
            stringify!(__ss)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__darwin_mcontext_avx64>())).__fs as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_mcontext_avx64),
            "::",
            stringify!(__fs)
        )
    );
}
pub type mcontext_t = *mut __darwin_mcontext64;
pub type pthread_attr_t = __darwin_pthread_attr_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_sigaltstack {
    pub ss_sp: *mut ::std::os::raw::c_void,
    pub ss_size: __darwin_size_t,
    pub ss_flags: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout___darwin_sigaltstack() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_sigaltstack>(),
        24usize,
        concat!("Size of: ", stringify!(__darwin_sigaltstack))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_sigaltstack>(),
        8usize,
        concat!("Alignment of ", stringify!(__darwin_sigaltstack))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__darwin_sigaltstack>())).ss_sp as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_sigaltstack),
            "::",
            stringify!(ss_sp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__darwin_sigaltstack>())).ss_size as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_sigaltstack),
            "::",
            stringify!(ss_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__darwin_sigaltstack>())).ss_flags as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_sigaltstack),
            "::",
            stringify!(ss_flags)
        )
    );
}
pub type stack_t = __darwin_sigaltstack;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_ucontext {
    pub uc_onstack: ::std::os::raw::c_int,
    pub uc_sigmask: __darwin_sigset_t,
    pub uc_stack: __darwin_sigaltstack,
    pub uc_link: *mut __darwin_ucontext,
    pub uc_mcsize: __darwin_size_t,
    pub uc_mcontext: *mut __darwin_mcontext64,
}
#[test]
fn bindgen_test_layout___darwin_ucontext() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_ucontext>(),
        56usize,
        concat!("Size of: ", stringify!(__darwin_ucontext))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_ucontext>(),
        8usize,
        concat!("Alignment of ", stringify!(__darwin_ucontext))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__darwin_ucontext>())).uc_onstack as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_ucontext),
            "::",
            stringify!(uc_onstack)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__darwin_ucontext>())).uc_sigmask as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_ucontext),
            "::",
            stringify!(uc_sigmask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__darwin_ucontext>())).uc_stack as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_ucontext),
            "::",
            stringify!(uc_stack)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__darwin_ucontext>())).uc_link as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_ucontext),
            "::",
            stringify!(uc_link)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__darwin_ucontext>())).uc_mcsize as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_ucontext),
            "::",
            stringify!(uc_mcsize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__darwin_ucontext>())).uc_mcontext as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_ucontext),
            "::",
            stringify!(uc_mcontext)
        )
    );
}
pub type ucontext_t = __darwin_ucontext;
pub type pid_t = __darwin_pid_t;
pub type sigset_t = __darwin_sigset_t;
pub type uid_t = __darwin_uid_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub union sigval {
    pub sival_int: ::std::os::raw::c_int,
    pub sival_ptr: *mut ::std::os::raw::c_void,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_sigval() {
    assert_eq!(
        ::std::mem::size_of::<sigval>(),
        8usize,
        concat!("Size of: ", stringify!(sigval))
    );
    assert_eq!(
        ::std::mem::align_of::<sigval>(),
        8usize,
        concat!("Alignment of ", stringify!(sigval))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigval>())).sival_int as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigval),
            "::",
            stringify!(sival_int)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigval>())).sival_ptr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigval),
            "::",
            stringify!(sival_ptr)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sigevent {
    pub sigev_notify: ::std::os::raw::c_int,
    pub sigev_signo: ::std::os::raw::c_int,
    pub sigev_value: sigval,
    pub sigev_notify_function: ::std::option::Option<unsafe extern "C" fn(arg1: sigval)>,
    pub sigev_notify_attributes: *mut pthread_attr_t,
}
#[test]
fn bindgen_test_layout_sigevent() {
    assert_eq!(
        ::std::mem::size_of::<sigevent>(),
        32usize,
        concat!("Size of: ", stringify!(sigevent))
    );
    assert_eq!(
        ::std::mem::align_of::<sigevent>(),
        8usize,
        concat!("Alignment of ", stringify!(sigevent))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigevent>())).sigev_notify as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigevent),
            "::",
            stringify!(sigev_notify)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigevent>())).sigev_signo as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sigevent),
            "::",
            stringify!(sigev_signo)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigevent>())).sigev_value as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sigevent),
            "::",
            stringify!(sigev_value)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigevent>())).sigev_notify_function as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(sigevent),
            "::",
            stringify!(sigev_notify_function)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sigevent>())).sigev_notify_attributes as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(sigevent),
            "::",
            stringify!(sigev_notify_attributes)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __siginfo {
    pub si_signo: ::std::os::raw::c_int,
    pub si_errno: ::std::os::raw::c_int,
    pub si_code: ::std::os::raw::c_int,
    pub si_pid: pid_t,
    pub si_uid: uid_t,
    pub si_status: ::std::os::raw::c_int,
    pub si_addr: *mut ::std::os::raw::c_void,
    pub si_value: sigval,
    pub si_band: ::std::os::raw::c_long,
    pub __pad: [::std::os::raw::c_ulong; 7usize],
}
#[test]
fn bindgen_test_layout___siginfo() {
    assert_eq!(
        ::std::mem::size_of::<__siginfo>(),
        104usize,
        concat!("Size of: ", stringify!(__siginfo))
    );
    assert_eq!(
        ::std::mem::align_of::<__siginfo>(),
        8usize,
        concat!("Alignment of ", stringify!(__siginfo))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__siginfo>())).si_signo as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__siginfo),
            "::",
            stringify!(si_signo)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__siginfo>())).si_errno as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__siginfo),
            "::",
            stringify!(si_errno)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__siginfo>())).si_code as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__siginfo),
            "::",
            stringify!(si_code)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__siginfo>())).si_pid as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__siginfo),
            "::",
            stringify!(si_pid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__siginfo>())).si_uid as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__siginfo),
            "::",
            stringify!(si_uid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__siginfo>())).si_status as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__siginfo),
            "::",
            stringify!(si_status)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__siginfo>())).si_addr as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__siginfo),
            "::",
            stringify!(si_addr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__siginfo>())).si_value as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__siginfo),
            "::",
            stringify!(si_value)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__siginfo>())).si_band as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__siginfo),
            "::",
            stringify!(si_band)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__siginfo>())).__pad as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(__siginfo),
            "::",
            stringify!(__pad)
        )
    );
}
pub type siginfo_t = __siginfo;
#[repr(C)]
#[derive(Copy, Clone)]
pub union __sigaction_u {
    pub __sa_handler: ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_int)>,
    pub __sa_sigaction: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: ::std::os::raw::c_int,
            arg2: *mut __siginfo,
            arg3: *mut ::std::os::raw::c_void,
        ),
    >,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout___sigaction_u() {
    assert_eq!(
        ::std::mem::size_of::<__sigaction_u>(),
        8usize,
        concat!("Size of: ", stringify!(__sigaction_u))
    );
    assert_eq!(
        ::std::mem::align_of::<__sigaction_u>(),
        8usize,
        concat!("Alignment of ", stringify!(__sigaction_u))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sigaction_u>())).__sa_handler as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sigaction_u),
            "::",
            stringify!(__sa_handler)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sigaction_u>())).__sa_sigaction as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sigaction_u),
            "::",
            stringify!(__sa_sigaction)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __sigaction {
    pub __sigaction_u: __sigaction_u,
    pub sa_tramp: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::std::os::raw::c_void,
            arg2: ::std::os::raw::c_int,
            arg3: ::std::os::raw::c_int,
            arg4: *mut siginfo_t,
            arg5: *mut ::std::os::raw::c_void,
        ),
    >,
    pub sa_mask: sigset_t,
    pub sa_flags: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout___sigaction() {
    assert_eq!(
        ::std::mem::size_of::<__sigaction>(),
        24usize,
        concat!("Size of: ", stringify!(__sigaction))
    );
    assert_eq!(
        ::std::mem::align_of::<__sigaction>(),
        8usize,
        concat!("Alignment of ", stringify!(__sigaction))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sigaction>())).__sigaction_u as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sigaction),
            "::",
            stringify!(__sigaction_u)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sigaction>())).sa_tramp as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__sigaction),
            "::",
            stringify!(sa_tramp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sigaction>())).sa_mask as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__sigaction),
            "::",
            stringify!(sa_mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sigaction>())).sa_flags as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__sigaction),
            "::",
            stringify!(sa_flags)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sigaction {
    pub __sigaction_u: __sigaction_u,
    pub sa_mask: sigset_t,
    pub sa_flags: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_sigaction() {
    assert_eq!(
        ::std::mem::size_of::<sigaction>(),
        16usize,
        concat!("Size of: ", stringify!(sigaction))
    );
    assert_eq!(
        ::std::mem::align_of::<sigaction>(),
        8usize,
        concat!("Alignment of ", stringify!(sigaction))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigaction>())).__sigaction_u as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigaction),
            "::",
            stringify!(__sigaction_u)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigaction>())).sa_mask as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sigaction),
            "::",
            stringify!(sa_mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigaction>())).sa_flags as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(sigaction),
            "::",
            stringify!(sa_flags)
        )
    );
}
pub type sig_t = ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_int)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sigvec {
    pub sv_handler: ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_int)>,
    pub sv_mask: ::std::os::raw::c_int,
    pub sv_flags: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_sigvec() {
    assert_eq!(
        ::std::mem::size_of::<sigvec>(),
        16usize,
        concat!("Size of: ", stringify!(sigvec))
    );
    assert_eq!(
        ::std::mem::align_of::<sigvec>(),
        8usize,
        concat!("Alignment of ", stringify!(sigvec))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigvec>())).sv_handler as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigvec),
            "::",
            stringify!(sv_handler)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigvec>())).sv_mask as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sigvec),
            "::",
            stringify!(sv_mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigvec>())).sv_flags as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(sigvec),
            "::",
            stringify!(sv_flags)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sigstack {
    pub ss_sp: *mut ::std::os::raw::c_char,
    pub ss_onstack: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_sigstack() {
    assert_eq!(
        ::std::mem::size_of::<sigstack>(),
        16usize,
        concat!("Size of: ", stringify!(sigstack))
    );
    assert_eq!(
        ::std::mem::align_of::<sigstack>(),
        8usize,
        concat!("Alignment of ", stringify!(sigstack))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigstack>())).ss_sp as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigstack),
            "::",
            stringify!(ss_sp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigstack>())).ss_onstack as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sigstack),
            "::",
            stringify!(ss_onstack)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_signal"]
    pub fn signal(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_int)>,
    ) -> ::std::option::Option<
        unsafe extern "C" fn(
            arg1: ::std::os::raw::c_int,
            arg2: ::std::option::Option<
                unsafe extern "C" fn(arg1: ::std::os::raw::c_int),
            >,
        ),
    >;
}
pub type pthread_t = __darwin_pthread_t;
extern "C" {
    #[link_name = "\u{1}_sys_signame"]
    pub static mut sys_signame: [*const ::std::os::raw::c_char; 32usize];
}
extern "C" {
    #[link_name = "\u{1}_sys_siglist"]
    pub static mut sys_siglist: [*const ::std::os::raw::c_char; 32usize];
}
extern "C" {
    #[link_name = "\u{1}_raise"]
    pub fn raise(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_bsd_signal"]
    pub fn bsd_signal(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_int)>,
    ) -> ::std::option::Option<
        unsafe extern "C" fn(
            arg1: ::std::os::raw::c_int,
            arg2: ::std::option::Option<
                unsafe extern "C" fn(arg1: ::std::os::raw::c_int),
            >,
        ),
    >;
}
extern "C" {
    #[link_name = "\u{1}_kill"]
    pub fn kill(arg1: pid_t, arg2: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_killpg"]
    pub fn killpg(arg1: pid_t, arg2: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_pthread_kill"]
    pub fn pthread_kill(arg1: pthread_t, arg2: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_pthread_sigmask"]
    pub fn pthread_sigmask(
        arg1: ::std::os::raw::c_int,
        arg2: *const sigset_t,
        arg3: *mut sigset_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_sigaction"]
    pub fn sigaction(
        arg1: ::std::os::raw::c_int,
        arg2: *const sigaction,
        arg3: *mut sigaction,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_sigaddset"]
    pub fn sigaddset(arg1: *mut sigset_t, arg2: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_sigaltstack"]
    pub fn sigaltstack(arg1: *const stack_t, arg2: *mut stack_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_sigdelset"]
    pub fn sigdelset(arg1: *mut sigset_t, arg2: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_sigemptyset"]
    pub fn sigemptyset(arg1: *mut sigset_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_sigfillset"]
    pub fn sigfillset(arg1: *mut sigset_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_sighold"]
    pub fn sighold(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_sigignore"]
    pub fn sigignore(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_siginterrupt"]
    pub fn siginterrupt(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_sigismember"]
    pub fn sigismember(arg1: *const sigset_t, arg2: ::std::os::raw::c_int)
        -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_sigpause"]
    pub fn sigpause(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_sigpending"]
    pub fn sigpending(arg1: *mut sigset_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_sigprocmask"]
    pub fn sigprocmask(
        arg1: ::std::os::raw::c_int,
        arg2: *const sigset_t,
        arg3: *mut sigset_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_sigrelse"]
    pub fn sigrelse(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_sigset"]
    pub fn sigset(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_int)>,
    ) -> ::std::option::Option<
        unsafe extern "C" fn(
            arg1: ::std::os::raw::c_int,
            arg2: ::std::option::Option<
                unsafe extern "C" fn(arg1: ::std::os::raw::c_int),
            >,
        ),
    >;
}
extern "C" {
    #[link_name = "\u{1}_sigsuspend"]
    pub fn sigsuspend(arg1: *const sigset_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_sigwait"]
    pub fn sigwait(
        arg1: *const sigset_t,
        arg2: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_psignal"]
    pub fn psignal(arg1: ::std::os::raw::c_uint, arg2: *const ::std::os::raw::c_char);
}
extern "C" {
    #[link_name = "\u{1}_sigblock"]
    pub fn sigblock(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_sigsetmask"]
    pub fn sigsetmask(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_sigvec"]
    pub fn sigvec(
        arg1: ::std::os::raw::c_int,
        arg2: *mut sigvec,
        arg3: *mut sigvec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_g_on_error_query"]
    pub fn g_on_error_query(prg_name: *const gchar);
}
extern "C" {
    #[link_name = "\u{1}_g_on_error_stack_trace"]
    pub fn g_on_error_stack_trace(prg_name: *const gchar);
}
extern "C" {
    #[link_name = "\u{1}_g_base64_encode_step"]
    pub fn g_base64_encode_step(
        in_: *const guchar,
        len: gsize,
        break_lines: gboolean,
        out: *mut gchar,
        state: *mut gint,
        save: *mut gint,
    ) -> gsize;
}
extern "C" {
    #[link_name = "\u{1}_g_base64_encode_close"]
    pub fn g_base64_encode_close(
        break_lines: gboolean,
        out: *mut gchar,
        state: *mut gint,
        save: *mut gint,
    ) -> gsize;
}
extern "C" {
    #[link_name = "\u{1}_g_base64_encode"]
    pub fn g_base64_encode(data: *const guchar, len: gsize) -> *mut gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_base64_decode_step"]
    pub fn g_base64_decode_step(
        in_: *const gchar,
        len: gsize,
        out: *mut guchar,
        state: *mut gint,
        save: *mut guint,
    ) -> gsize;
}
extern "C" {
    #[link_name = "\u{1}_g_base64_decode"]
    pub fn g_base64_decode(text: *const gchar, out_len: *mut gsize) -> *mut guchar;
}
extern "C" {
    #[link_name = "\u{1}_g_base64_decode_inplace"]
    pub fn g_base64_decode_inplace(text: *mut gchar, out_len: *mut gsize) -> *mut guchar;
}
extern "C" {
    #[link_name = "\u{1}_g_bit_lock"]
    pub fn g_bit_lock(address: *mut gint, lock_bit: gint);
}
extern "C" {
    #[link_name = "\u{1}_g_bit_trylock"]
    pub fn g_bit_trylock(address: *mut gint, lock_bit: gint) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_bit_unlock"]
    pub fn g_bit_unlock(address: *mut gint, lock_bit: gint);
}
extern "C" {
    #[link_name = "\u{1}_g_pointer_bit_lock"]
    pub fn g_pointer_bit_lock(address: *mut ::std::os::raw::c_void, lock_bit: gint);
}
extern "C" {
    #[link_name = "\u{1}_g_pointer_bit_trylock"]
    pub fn g_pointer_bit_trylock(address: *mut ::std::os::raw::c_void, lock_bit: gint) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_pointer_bit_unlock"]
    pub fn g_pointer_bit_unlock(address: *mut ::std::os::raw::c_void, lock_bit: gint);
}
pub const GBookmarkFileError_G_BOOKMARK_FILE_ERROR_INVALID_URI: GBookmarkFileError = 0;
pub const GBookmarkFileError_G_BOOKMARK_FILE_ERROR_INVALID_VALUE: GBookmarkFileError = 1;
pub const GBookmarkFileError_G_BOOKMARK_FILE_ERROR_APP_NOT_REGISTERED: GBookmarkFileError = 2;
pub const GBookmarkFileError_G_BOOKMARK_FILE_ERROR_URI_NOT_FOUND: GBookmarkFileError = 3;
pub const GBookmarkFileError_G_BOOKMARK_FILE_ERROR_READ: GBookmarkFileError = 4;
pub const GBookmarkFileError_G_BOOKMARK_FILE_ERROR_UNKNOWN_ENCODING: GBookmarkFileError = 5;
pub const GBookmarkFileError_G_BOOKMARK_FILE_ERROR_WRITE: GBookmarkFileError = 6;
pub const GBookmarkFileError_G_BOOKMARK_FILE_ERROR_FILE_NOT_FOUND: GBookmarkFileError = 7;
/// GBookmarkFileError:
/// @G_BOOKMARK_FILE_ERROR_INVALID_URI: URI was ill-formed
/// @G_BOOKMARK_FILE_ERROR_INVALID_VALUE: a requested field was not found
/// @G_BOOKMARK_FILE_ERROR_APP_NOT_REGISTERED: a requested application did
/// not register a bookmark
/// @G_BOOKMARK_FILE_ERROR_URI_NOT_FOUND: a requested URI was not found
/// @G_BOOKMARK_FILE_ERROR_READ: document was ill formed
/// @G_BOOKMARK_FILE_ERROR_UNKNOWN_ENCODING: the text being parsed was
/// in an unknown encoding
/// @G_BOOKMARK_FILE_ERROR_WRITE: an error occurred while writing
/// @G_BOOKMARK_FILE_ERROR_FILE_NOT_FOUND: requested file was not found
///
/// Error codes returned by bookmark file parsing.
pub type GBookmarkFileError = u32;
extern "C" {
    #[link_name = "\u{1}_g_bookmark_file_error_quark"]
    pub fn g_bookmark_file_error_quark() -> GQuark;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GBookmarkFile {
    _unused: [u8; 0],
}
/// GBookmarkFile:
///
/// The `GBookmarkFile` structure contains only
/// private data and should not be directly accessed.
pub type GBookmarkFile = _GBookmarkFile;
extern "C" {
    #[link_name = "\u{1}_g_bookmark_file_new"]
    pub fn g_bookmark_file_new() -> *mut GBookmarkFile;
}
extern "C" {
    #[link_name = "\u{1}_g_bookmark_file_free"]
    pub fn g_bookmark_file_free(bookmark: *mut GBookmarkFile);
}
extern "C" {
    #[link_name = "\u{1}_g_bookmark_file_load_from_file"]
    pub fn g_bookmark_file_load_from_file(
        bookmark: *mut GBookmarkFile,
        filename: *const gchar,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_bookmark_file_load_from_data"]
    pub fn g_bookmark_file_load_from_data(
        bookmark: *mut GBookmarkFile,
        data: *const gchar,
        length: gsize,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_bookmark_file_load_from_data_dirs"]
    pub fn g_bookmark_file_load_from_data_dirs(
        bookmark: *mut GBookmarkFile,
        file: *const gchar,
        full_path: *mut *mut gchar,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_bookmark_file_to_data"]
    pub fn g_bookmark_file_to_data(
        bookmark: *mut GBookmarkFile,
        length: *mut gsize,
        error: *mut *mut GError,
    ) -> *mut gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_bookmark_file_to_file"]
    pub fn g_bookmark_file_to_file(
        bookmark: *mut GBookmarkFile,
        filename: *const gchar,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_bookmark_file_set_title"]
    pub fn g_bookmark_file_set_title(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        title: *const gchar,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_bookmark_file_get_title"]
    pub fn g_bookmark_file_get_title(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        error: *mut *mut GError,
    ) -> *mut gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_bookmark_file_set_description"]
    pub fn g_bookmark_file_set_description(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        description: *const gchar,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_bookmark_file_get_description"]
    pub fn g_bookmark_file_get_description(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        error: *mut *mut GError,
    ) -> *mut gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_bookmark_file_set_mime_type"]
    pub fn g_bookmark_file_set_mime_type(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        mime_type: *const gchar,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_bookmark_file_get_mime_type"]
    pub fn g_bookmark_file_get_mime_type(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        error: *mut *mut GError,
    ) -> *mut gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_bookmark_file_set_groups"]
    pub fn g_bookmark_file_set_groups(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        groups: *mut *const gchar,
        length: gsize,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_bookmark_file_add_group"]
    pub fn g_bookmark_file_add_group(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        group: *const gchar,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_bookmark_file_has_group"]
    pub fn g_bookmark_file_has_group(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        group: *const gchar,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_bookmark_file_get_groups"]
    pub fn g_bookmark_file_get_groups(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        length: *mut gsize,
        error: *mut *mut GError,
    ) -> *mut *mut gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_bookmark_file_add_application"]
    pub fn g_bookmark_file_add_application(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        name: *const gchar,
        exec: *const gchar,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_bookmark_file_has_application"]
    pub fn g_bookmark_file_has_application(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        name: *const gchar,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_bookmark_file_get_applications"]
    pub fn g_bookmark_file_get_applications(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        length: *mut gsize,
        error: *mut *mut GError,
    ) -> *mut *mut gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_bookmark_file_set_app_info"]
    pub fn g_bookmark_file_set_app_info(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        name: *const gchar,
        exec: *const gchar,
        count: gint,
        stamp: time_t,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_bookmark_file_get_app_info"]
    pub fn g_bookmark_file_get_app_info(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        name: *const gchar,
        exec: *mut *mut gchar,
        count: *mut guint,
        stamp: *mut time_t,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_bookmark_file_set_is_private"]
    pub fn g_bookmark_file_set_is_private(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        is_private: gboolean,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_bookmark_file_get_is_private"]
    pub fn g_bookmark_file_get_is_private(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_bookmark_file_set_icon"]
    pub fn g_bookmark_file_set_icon(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        href: *const gchar,
        mime_type: *const gchar,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_bookmark_file_get_icon"]
    pub fn g_bookmark_file_get_icon(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        href: *mut *mut gchar,
        mime_type: *mut *mut gchar,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_bookmark_file_set_added"]
    pub fn g_bookmark_file_set_added(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        added: time_t,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_bookmark_file_get_added"]
    pub fn g_bookmark_file_get_added(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        error: *mut *mut GError,
    ) -> time_t;
}
extern "C" {
    #[link_name = "\u{1}_g_bookmark_file_set_modified"]
    pub fn g_bookmark_file_set_modified(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        modified: time_t,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_bookmark_file_get_modified"]
    pub fn g_bookmark_file_get_modified(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        error: *mut *mut GError,
    ) -> time_t;
}
extern "C" {
    #[link_name = "\u{1}_g_bookmark_file_set_visited"]
    pub fn g_bookmark_file_set_visited(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        visited: time_t,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_bookmark_file_get_visited"]
    pub fn g_bookmark_file_get_visited(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        error: *mut *mut GError,
    ) -> time_t;
}
extern "C" {
    #[link_name = "\u{1}_g_bookmark_file_has_item"]
    pub fn g_bookmark_file_has_item(bookmark: *mut GBookmarkFile, uri: *const gchar) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_bookmark_file_get_size"]
    pub fn g_bookmark_file_get_size(bookmark: *mut GBookmarkFile) -> gint;
}
extern "C" {
    #[link_name = "\u{1}_g_bookmark_file_get_uris"]
    pub fn g_bookmark_file_get_uris(
        bookmark: *mut GBookmarkFile,
        length: *mut gsize,
    ) -> *mut *mut gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_bookmark_file_remove_group"]
    pub fn g_bookmark_file_remove_group(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        group: *const gchar,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_bookmark_file_remove_application"]
    pub fn g_bookmark_file_remove_application(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        name: *const gchar,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_bookmark_file_remove_item"]
    pub fn g_bookmark_file_remove_item(
        bookmark: *mut GBookmarkFile,
        uri: *const gchar,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_bookmark_file_move_item"]
    pub fn g_bookmark_file_move_item(
        bookmark: *mut GBookmarkFile,
        old_uri: *const gchar,
        new_uri: *const gchar,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_bytes_new"]
    pub fn g_bytes_new(data: gconstpointer, size: gsize) -> *mut GBytes;
}
extern "C" {
    #[link_name = "\u{1}_g_bytes_new_take"]
    pub fn g_bytes_new_take(data: gpointer, size: gsize) -> *mut GBytes;
}
extern "C" {
    #[link_name = "\u{1}_g_bytes_new_static"]
    pub fn g_bytes_new_static(data: gconstpointer, size: gsize) -> *mut GBytes;
}
extern "C" {
    #[link_name = "\u{1}_g_bytes_new_with_free_func"]
    pub fn g_bytes_new_with_free_func(
        data: gconstpointer,
        size: gsize,
        free_func: GDestroyNotify,
        user_data: gpointer,
    ) -> *mut GBytes;
}
extern "C" {
    #[link_name = "\u{1}_g_bytes_new_from_bytes"]
    pub fn g_bytes_new_from_bytes(bytes: *mut GBytes, offset: gsize, length: gsize) -> *mut GBytes;
}
extern "C" {
    #[link_name = "\u{1}_g_bytes_get_data"]
    pub fn g_bytes_get_data(bytes: *mut GBytes, size: *mut gsize) -> gconstpointer;
}
extern "C" {
    #[link_name = "\u{1}_g_bytes_get_size"]
    pub fn g_bytes_get_size(bytes: *mut GBytes) -> gsize;
}
extern "C" {
    #[link_name = "\u{1}_g_bytes_ref"]
    pub fn g_bytes_ref(bytes: *mut GBytes) -> *mut GBytes;
}
extern "C" {
    #[link_name = "\u{1}_g_bytes_unref"]
    pub fn g_bytes_unref(bytes: *mut GBytes);
}
extern "C" {
    #[link_name = "\u{1}_g_bytes_unref_to_data"]
    pub fn g_bytes_unref_to_data(bytes: *mut GBytes, size: *mut gsize) -> gpointer;
}
extern "C" {
    #[link_name = "\u{1}_g_bytes_unref_to_array"]
    pub fn g_bytes_unref_to_array(bytes: *mut GBytes) -> *mut GByteArray;
}
extern "C" {
    #[link_name = "\u{1}_g_bytes_hash"]
    pub fn g_bytes_hash(bytes: gconstpointer) -> guint;
}
extern "C" {
    #[link_name = "\u{1}_g_bytes_equal"]
    pub fn g_bytes_equal(bytes1: gconstpointer, bytes2: gconstpointer) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_bytes_compare"]
    pub fn g_bytes_compare(bytes1: gconstpointer, bytes2: gconstpointer) -> gint;
}
extern "C" {
    #[link_name = "\u{1}_g_get_charset"]
    pub fn g_get_charset(charset: *mut *const ::std::os::raw::c_char) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_get_codeset"]
    pub fn g_get_codeset() -> *mut gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_get_language_names"]
    pub fn g_get_language_names() -> *const *const gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_get_locale_variants"]
    pub fn g_get_locale_variants(locale: *const gchar) -> *mut *mut gchar;
}
pub const GChecksumType_G_CHECKSUM_MD5: GChecksumType = 0;
pub const GChecksumType_G_CHECKSUM_SHA1: GChecksumType = 1;
pub const GChecksumType_G_CHECKSUM_SHA256: GChecksumType = 2;
pub const GChecksumType_G_CHECKSUM_SHA512: GChecksumType = 3;
pub const GChecksumType_G_CHECKSUM_SHA384: GChecksumType = 4;
/// GChecksumType:
/// @G_CHECKSUM_MD5: Use the MD5 hashing algorithm
/// @G_CHECKSUM_SHA1: Use the SHA-1 hashing algorithm
/// @G_CHECKSUM_SHA256: Use the SHA-256 hashing algorithm
/// @G_CHECKSUM_SHA384: Use the SHA-384 hashing algorithm (Since: 2.51)
/// @G_CHECKSUM_SHA512: Use the SHA-512 hashing algorithm (Since: 2.36)
///
/// The hashing algorithm to be used by #GChecksum when performing the
/// digest of some data.
///
/// Note that the #GChecksumType enumeration may be extended at a later
/// date to include new hashing algorithm types.
///
/// Since: 2.16
pub type GChecksumType = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GChecksum {
    _unused: [u8; 0],
}
/// GChecksum:
///
/// An opaque structure representing a checksumming operation.
/// To create a new GChecksum, use g_checksum_new(). To free
/// a GChecksum, use g_checksum_free().
///
/// Since: 2.16
pub type GChecksum = _GChecksum;
extern "C" {
    #[link_name = "\u{1}_g_checksum_type_get_length"]
    pub fn g_checksum_type_get_length(checksum_type: GChecksumType) -> gssize;
}
extern "C" {
    #[link_name = "\u{1}_g_checksum_new"]
    pub fn g_checksum_new(checksum_type: GChecksumType) -> *mut GChecksum;
}
extern "C" {
    #[link_name = "\u{1}_g_checksum_reset"]
    pub fn g_checksum_reset(checksum: *mut GChecksum);
}
extern "C" {
    #[link_name = "\u{1}_g_checksum_copy"]
    pub fn g_checksum_copy(checksum: *const GChecksum) -> *mut GChecksum;
}
extern "C" {
    #[link_name = "\u{1}_g_checksum_free"]
    pub fn g_checksum_free(checksum: *mut GChecksum);
}
extern "C" {
    #[link_name = "\u{1}_g_checksum_update"]
    pub fn g_checksum_update(checksum: *mut GChecksum, data: *const guchar, length: gssize);
}
extern "C" {
    #[link_name = "\u{1}_g_checksum_get_string"]
    pub fn g_checksum_get_string(checksum: *mut GChecksum) -> *const gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_checksum_get_digest"]
    pub fn g_checksum_get_digest(
        checksum: *mut GChecksum,
        buffer: *mut guint8,
        digest_len: *mut gsize,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_compute_checksum_for_data"]
    pub fn g_compute_checksum_for_data(
        checksum_type: GChecksumType,
        data: *const guchar,
        length: gsize,
    ) -> *mut gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_compute_checksum_for_string"]
    pub fn g_compute_checksum_for_string(
        checksum_type: GChecksumType,
        str: *const gchar,
        length: gssize,
    ) -> *mut gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_compute_checksum_for_bytes"]
    pub fn g_compute_checksum_for_bytes(
        checksum_type: GChecksumType,
        data: *mut GBytes,
    ) -> *mut gchar;
}
pub const GConvertError_G_CONVERT_ERROR_NO_CONVERSION: GConvertError = 0;
pub const GConvertError_G_CONVERT_ERROR_ILLEGAL_SEQUENCE: GConvertError = 1;
pub const GConvertError_G_CONVERT_ERROR_FAILED: GConvertError = 2;
pub const GConvertError_G_CONVERT_ERROR_PARTIAL_INPUT: GConvertError = 3;
pub const GConvertError_G_CONVERT_ERROR_BAD_URI: GConvertError = 4;
pub const GConvertError_G_CONVERT_ERROR_NOT_ABSOLUTE_PATH: GConvertError = 5;
pub const GConvertError_G_CONVERT_ERROR_NO_MEMORY: GConvertError = 6;
/// GConvertError:
/// @G_CONVERT_ERROR_NO_CONVERSION: Conversion between the requested character
/// sets is not supported.
/// @G_CONVERT_ERROR_ILLEGAL_SEQUENCE: Invalid byte sequence in conversion input.
/// @G_CONVERT_ERROR_FAILED: Conversion failed for some reason.
/// @G_CONVERT_ERROR_PARTIAL_INPUT: Partial character sequence at end of input.
/// @G_CONVERT_ERROR_BAD_URI: URI is invalid.
/// @G_CONVERT_ERROR_NOT_ABSOLUTE_PATH: Pathname is not an absolute path.
/// @G_CONVERT_ERROR_NO_MEMORY: No memory available. Since: 2.40
///
/// Error codes returned by character set conversion routines.
pub type GConvertError = u32;
extern "C" {
    #[link_name = "\u{1}_g_convert_error_quark"]
    pub fn g_convert_error_quark() -> GQuark;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GIConv {
    _unused: [u8; 0],
}
/// GIConv:
///
/// The GIConv struct wraps an iconv() conversion descriptor. It contains
/// private data and should only be accessed using the following functions.
pub type GIConv = *mut _GIConv;
extern "C" {
    #[link_name = "\u{1}_g_iconv_open"]
    pub fn g_iconv_open(to_codeset: *const gchar, from_codeset: *const gchar) -> GIConv;
}
extern "C" {
    #[link_name = "\u{1}_g_iconv"]
    pub fn g_iconv(
        converter: GIConv,
        inbuf: *mut *mut gchar,
        inbytes_left: *mut gsize,
        outbuf: *mut *mut gchar,
        outbytes_left: *mut gsize,
    ) -> gsize;
}
extern "C" {
    #[link_name = "\u{1}_g_iconv_close"]
    pub fn g_iconv_close(converter: GIConv) -> gint;
}
extern "C" {
    #[link_name = "\u{1}_g_convert"]
    pub fn g_convert(
        str: *const gchar,
        len: gssize,
        to_codeset: *const gchar,
        from_codeset: *const gchar,
        bytes_read: *mut gsize,
        bytes_written: *mut gsize,
        error: *mut *mut GError,
    ) -> *mut gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_convert_with_iconv"]
    pub fn g_convert_with_iconv(
        str: *const gchar,
        len: gssize,
        converter: GIConv,
        bytes_read: *mut gsize,
        bytes_written: *mut gsize,
        error: *mut *mut GError,
    ) -> *mut gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_convert_with_fallback"]
    pub fn g_convert_with_fallback(
        str: *const gchar,
        len: gssize,
        to_codeset: *const gchar,
        from_codeset: *const gchar,
        fallback: *const gchar,
        bytes_read: *mut gsize,
        bytes_written: *mut gsize,
        error: *mut *mut GError,
    ) -> *mut gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_locale_to_utf8"]
    pub fn g_locale_to_utf8(
        opsysstring: *const gchar,
        len: gssize,
        bytes_read: *mut gsize,
        bytes_written: *mut gsize,
        error: *mut *mut GError,
    ) -> *mut gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_locale_from_utf8"]
    pub fn g_locale_from_utf8(
        utf8string: *const gchar,
        len: gssize,
        bytes_read: *mut gsize,
        bytes_written: *mut gsize,
        error: *mut *mut GError,
    ) -> *mut gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_filename_to_utf8"]
    pub fn g_filename_to_utf8(
        opsysstring: *const gchar,
        len: gssize,
        bytes_read: *mut gsize,
        bytes_written: *mut gsize,
        error: *mut *mut GError,
    ) -> *mut gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_filename_from_utf8"]
    pub fn g_filename_from_utf8(
        utf8string: *const gchar,
        len: gssize,
        bytes_read: *mut gsize,
        bytes_written: *mut gsize,
        error: *mut *mut GError,
    ) -> *mut gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_filename_from_uri"]
    pub fn g_filename_from_uri(
        uri: *const gchar,
        hostname: *mut *mut gchar,
        error: *mut *mut GError,
    ) -> *mut gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_filename_to_uri"]
    pub fn g_filename_to_uri(
        filename: *const gchar,
        hostname: *const gchar,
        error: *mut *mut GError,
    ) -> *mut gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_filename_display_name"]
    pub fn g_filename_display_name(filename: *const gchar) -> *mut gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_get_filename_charsets"]
    pub fn g_get_filename_charsets(charsets: *mut *mut *const gchar) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_filename_display_basename"]
    pub fn g_filename_display_basename(filename: *const gchar) -> *mut gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_uri_list_extract_uris"]
    pub fn g_uri_list_extract_uris(uri_list: *const gchar) -> *mut *mut gchar;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GData {
    _unused: [u8; 0],
}
pub type GData = _GData;
pub type GDataForeachFunc = ::std::option::Option<
    unsafe extern "C" fn(key_id: GQuark, data: gpointer, user_data: gpointer),
>;
extern "C" {
    #[link_name = "\u{1}_g_datalist_init"]
    pub fn g_datalist_init(datalist: *mut *mut GData);
}
extern "C" {
    #[link_name = "\u{1}_g_datalist_clear"]
    pub fn g_datalist_clear(datalist: *mut *mut GData);
}
extern "C" {
    #[link_name = "\u{1}_g_datalist_id_get_data"]
    pub fn g_datalist_id_get_data(datalist: *mut *mut GData, key_id: GQuark) -> gpointer;
}
extern "C" {
    #[link_name = "\u{1}_g_datalist_id_set_data_full"]
    pub fn g_datalist_id_set_data_full(
        datalist: *mut *mut GData,
        key_id: GQuark,
        data: gpointer,
        destroy_func: GDestroyNotify,
    );
}
pub type GDuplicateFunc =
    ::std::option::Option<unsafe extern "C" fn(data: gpointer, user_data: gpointer) -> gpointer>;
extern "C" {
    #[link_name = "\u{1}_g_datalist_id_dup_data"]
    pub fn g_datalist_id_dup_data(
        datalist: *mut *mut GData,
        key_id: GQuark,
        dup_func: GDuplicateFunc,
        user_data: gpointer,
    ) -> gpointer;
}
extern "C" {
    #[link_name = "\u{1}_g_datalist_id_replace_data"]
    pub fn g_datalist_id_replace_data(
        datalist: *mut *mut GData,
        key_id: GQuark,
        oldval: gpointer,
        newval: gpointer,
        destroy: GDestroyNotify,
        old_destroy: *mut GDestroyNotify,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_datalist_id_remove_no_notify"]
    pub fn g_datalist_id_remove_no_notify(datalist: *mut *mut GData, key_id: GQuark) -> gpointer;
}
extern "C" {
    #[link_name = "\u{1}_g_datalist_foreach"]
    pub fn g_datalist_foreach(
        datalist: *mut *mut GData,
        func: GDataForeachFunc,
        user_data: gpointer,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_datalist_set_flags"]
    pub fn g_datalist_set_flags(datalist: *mut *mut GData, flags: guint);
}
extern "C" {
    #[link_name = "\u{1}_g_datalist_unset_flags"]
    pub fn g_datalist_unset_flags(datalist: *mut *mut GData, flags: guint);
}
extern "C" {
    #[link_name = "\u{1}_g_datalist_get_flags"]
    pub fn g_datalist_get_flags(datalist: *mut *mut GData) -> guint;
}
extern "C" {
    #[link_name = "\u{1}_g_dataset_destroy"]
    pub fn g_dataset_destroy(dataset_location: gconstpointer);
}
extern "C" {
    #[link_name = "\u{1}_g_dataset_id_get_data"]
    pub fn g_dataset_id_get_data(dataset_location: gconstpointer, key_id: GQuark) -> gpointer;
}
extern "C" {
    #[link_name = "\u{1}_g_datalist_get_data"]
    pub fn g_datalist_get_data(datalist: *mut *mut GData, key: *const gchar) -> gpointer;
}
extern "C" {
    #[link_name = "\u{1}_g_dataset_id_set_data_full"]
    pub fn g_dataset_id_set_data_full(
        dataset_location: gconstpointer,
        key_id: GQuark,
        data: gpointer,
        destroy_func: GDestroyNotify,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_dataset_id_remove_no_notify"]
    pub fn g_dataset_id_remove_no_notify(
        dataset_location: gconstpointer,
        key_id: GQuark,
    ) -> gpointer;
}
extern "C" {
    #[link_name = "\u{1}_g_dataset_foreach"]
    pub fn g_dataset_foreach(
        dataset_location: gconstpointer,
        func: GDataForeachFunc,
        user_data: gpointer,
    );
}
pub type GTime = gint32;
pub type GDateYear = guint16;
pub type GDateDay = guint8;
pub type GDate = _GDate;
pub const GDateDMY_G_DATE_DAY: GDateDMY = 0;
pub const GDateDMY_G_DATE_MONTH: GDateDMY = 1;
pub const GDateDMY_G_DATE_YEAR: GDateDMY = 2;
pub type GDateDMY = u32;
pub const GDateWeekday_G_DATE_BAD_WEEKDAY: GDateWeekday = 0;
pub const GDateWeekday_G_DATE_MONDAY: GDateWeekday = 1;
pub const GDateWeekday_G_DATE_TUESDAY: GDateWeekday = 2;
pub const GDateWeekday_G_DATE_WEDNESDAY: GDateWeekday = 3;
pub const GDateWeekday_G_DATE_THURSDAY: GDateWeekday = 4;
pub const GDateWeekday_G_DATE_FRIDAY: GDateWeekday = 5;
pub const GDateWeekday_G_DATE_SATURDAY: GDateWeekday = 6;
pub const GDateWeekday_G_DATE_SUNDAY: GDateWeekday = 7;
pub type GDateWeekday = u32;
pub const GDateMonth_G_DATE_BAD_MONTH: GDateMonth = 0;
pub const GDateMonth_G_DATE_JANUARY: GDateMonth = 1;
pub const GDateMonth_G_DATE_FEBRUARY: GDateMonth = 2;
pub const GDateMonth_G_DATE_MARCH: GDateMonth = 3;
pub const GDateMonth_G_DATE_APRIL: GDateMonth = 4;
pub const GDateMonth_G_DATE_MAY: GDateMonth = 5;
pub const GDateMonth_G_DATE_JUNE: GDateMonth = 6;
pub const GDateMonth_G_DATE_JULY: GDateMonth = 7;
pub const GDateMonth_G_DATE_AUGUST: GDateMonth = 8;
pub const GDateMonth_G_DATE_SEPTEMBER: GDateMonth = 9;
pub const GDateMonth_G_DATE_OCTOBER: GDateMonth = 10;
pub const GDateMonth_G_DATE_NOVEMBER: GDateMonth = 11;
pub const GDateMonth_G_DATE_DECEMBER: GDateMonth = 12;
pub type GDateMonth = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GDate {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize], u32>,
    pub __bindgen_align: [u32; 0usize],
}
#[test]
fn bindgen_test_layout__GDate() {
    assert_eq!(
        ::std::mem::size_of::<_GDate>(),
        8usize,
        concat!("Size of: ", stringify!(_GDate))
    );
    assert_eq!(
        ::std::mem::align_of::<_GDate>(),
        4usize,
        concat!("Alignment of ", stringify!(_GDate))
    );
}
impl _GDate {
    #[inline]
    pub fn julian_days(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 32u8) as u32) }
    }
    #[inline]
    pub fn set_julian_days(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 32u8, val as u64)
        }
    }
    #[inline]
    pub fn julian(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(32usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_julian(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(32usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn dmy(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(33usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_dmy(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(33usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn day(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(34usize, 6u8) as u32) }
    }
    #[inline]
    pub fn set_day(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(34usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn month(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(40usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_month(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(40usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn year(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(44usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_year(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(44usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        julian_days: guint,
        julian: guint,
        dmy: guint,
        day: guint,
        month: guint,
        year: guint,
    ) -> __BindgenBitfieldUnit<[u8; 8usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 32u8, {
            let julian_days: u32 = unsafe { ::std::mem::transmute(julian_days) };
            julian_days as u64
        });
        __bindgen_bitfield_unit.set(32usize, 1u8, {
            let julian: u32 = unsafe { ::std::mem::transmute(julian) };
            julian as u64
        });
        __bindgen_bitfield_unit.set(33usize, 1u8, {
            let dmy: u32 = unsafe { ::std::mem::transmute(dmy) };
            dmy as u64
        });
        __bindgen_bitfield_unit.set(34usize, 6u8, {
            let day: u32 = unsafe { ::std::mem::transmute(day) };
            day as u64
        });
        __bindgen_bitfield_unit.set(40usize, 4u8, {
            let month: u32 = unsafe { ::std::mem::transmute(month) };
            month as u64
        });
        __bindgen_bitfield_unit.set(44usize, 16u8, {
            let year: u32 = unsafe { ::std::mem::transmute(year) };
            year as u64
        });
        __bindgen_bitfield_unit
    }
}
extern "C" {
    #[link_name = "\u{1}_g_date_new"]
    pub fn g_date_new() -> *mut GDate;
}
extern "C" {
    #[link_name = "\u{1}_g_date_new_dmy"]
    pub fn g_date_new_dmy(day: GDateDay, month: GDateMonth, year: GDateYear) -> *mut GDate;
}
extern "C" {
    #[link_name = "\u{1}_g_date_new_julian"]
    pub fn g_date_new_julian(julian_day: guint32) -> *mut GDate;
}
extern "C" {
    #[link_name = "\u{1}_g_date_free"]
    pub fn g_date_free(date: *mut GDate);
}
extern "C" {
    #[link_name = "\u{1}_g_date_valid"]
    pub fn g_date_valid(date: *const GDate) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_date_valid_day"]
    pub fn g_date_valid_day(day: GDateDay) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_date_valid_month"]
    pub fn g_date_valid_month(month: GDateMonth) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_date_valid_year"]
    pub fn g_date_valid_year(year: GDateYear) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_date_valid_weekday"]
    pub fn g_date_valid_weekday(weekday: GDateWeekday) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_date_valid_julian"]
    pub fn g_date_valid_julian(julian_date: guint32) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_date_valid_dmy"]
    pub fn g_date_valid_dmy(day: GDateDay, month: GDateMonth, year: GDateYear) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_date_get_weekday"]
    pub fn g_date_get_weekday(date: *const GDate) -> GDateWeekday;
}
extern "C" {
    #[link_name = "\u{1}_g_date_get_month"]
    pub fn g_date_get_month(date: *const GDate) -> GDateMonth;
}
extern "C" {
    #[link_name = "\u{1}_g_date_get_year"]
    pub fn g_date_get_year(date: *const GDate) -> GDateYear;
}
extern "C" {
    #[link_name = "\u{1}_g_date_get_day"]
    pub fn g_date_get_day(date: *const GDate) -> GDateDay;
}
extern "C" {
    #[link_name = "\u{1}_g_date_get_julian"]
    pub fn g_date_get_julian(date: *const GDate) -> guint32;
}
extern "C" {
    #[link_name = "\u{1}_g_date_get_day_of_year"]
    pub fn g_date_get_day_of_year(date: *const GDate) -> guint;
}
extern "C" {
    #[link_name = "\u{1}_g_date_get_monday_week_of_year"]
    pub fn g_date_get_monday_week_of_year(date: *const GDate) -> guint;
}
extern "C" {
    #[link_name = "\u{1}_g_date_get_sunday_week_of_year"]
    pub fn g_date_get_sunday_week_of_year(date: *const GDate) -> guint;
}
extern "C" {
    #[link_name = "\u{1}_g_date_get_iso8601_week_of_year"]
    pub fn g_date_get_iso8601_week_of_year(date: *const GDate) -> guint;
}
extern "C" {
    #[link_name = "\u{1}_g_date_clear"]
    pub fn g_date_clear(date: *mut GDate, n_dates: guint);
}
extern "C" {
    #[link_name = "\u{1}_g_date_set_parse"]
    pub fn g_date_set_parse(date: *mut GDate, str: *const gchar);
}
extern "C" {
    #[link_name = "\u{1}_g_date_set_time_t"]
    pub fn g_date_set_time_t(date: *mut GDate, timet: time_t);
}
extern "C" {
    #[link_name = "\u{1}_g_date_set_time_val"]
    pub fn g_date_set_time_val(date: *mut GDate, timeval: *mut GTimeVal);
}
extern "C" {
    #[link_name = "\u{1}_g_date_set_time"]
    pub fn g_date_set_time(date: *mut GDate, time_: GTime);
}
extern "C" {
    #[link_name = "\u{1}_g_date_set_month"]
    pub fn g_date_set_month(date: *mut GDate, month: GDateMonth);
}
extern "C" {
    #[link_name = "\u{1}_g_date_set_day"]
    pub fn g_date_set_day(date: *mut GDate, day: GDateDay);
}
extern "C" {
    #[link_name = "\u{1}_g_date_set_year"]
    pub fn g_date_set_year(date: *mut GDate, year: GDateYear);
}
extern "C" {
    #[link_name = "\u{1}_g_date_set_dmy"]
    pub fn g_date_set_dmy(date: *mut GDate, day: GDateDay, month: GDateMonth, y: GDateYear);
}
extern "C" {
    #[link_name = "\u{1}_g_date_set_julian"]
    pub fn g_date_set_julian(date: *mut GDate, julian_date: guint32);
}
extern "C" {
    #[link_name = "\u{1}_g_date_is_first_of_month"]
    pub fn g_date_is_first_of_month(date: *const GDate) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_date_is_last_of_month"]
    pub fn g_date_is_last_of_month(date: *const GDate) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_date_add_days"]
    pub fn g_date_add_days(date: *mut GDate, n_days: guint);
}
extern "C" {
    #[link_name = "\u{1}_g_date_subtract_days"]
    pub fn g_date_subtract_days(date: *mut GDate, n_days: guint);
}
extern "C" {
    #[link_name = "\u{1}_g_date_add_months"]
    pub fn g_date_add_months(date: *mut GDate, n_months: guint);
}
extern "C" {
    #[link_name = "\u{1}_g_date_subtract_months"]
    pub fn g_date_subtract_months(date: *mut GDate, n_months: guint);
}
extern "C" {
    #[link_name = "\u{1}_g_date_add_years"]
    pub fn g_date_add_years(date: *mut GDate, n_years: guint);
}
extern "C" {
    #[link_name = "\u{1}_g_date_subtract_years"]
    pub fn g_date_subtract_years(date: *mut GDate, n_years: guint);
}
extern "C" {
    #[link_name = "\u{1}_g_date_is_leap_year"]
    pub fn g_date_is_leap_year(year: GDateYear) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_date_get_days_in_month"]
    pub fn g_date_get_days_in_month(month: GDateMonth, year: GDateYear) -> guint8;
}
extern "C" {
    #[link_name = "\u{1}_g_date_get_monday_weeks_in_year"]
    pub fn g_date_get_monday_weeks_in_year(year: GDateYear) -> guint8;
}
extern "C" {
    #[link_name = "\u{1}_g_date_get_sunday_weeks_in_year"]
    pub fn g_date_get_sunday_weeks_in_year(year: GDateYear) -> guint8;
}
extern "C" {
    #[link_name = "\u{1}_g_date_days_between"]
    pub fn g_date_days_between(date1: *const GDate, date2: *const GDate) -> gint;
}
extern "C" {
    #[link_name = "\u{1}_g_date_compare"]
    pub fn g_date_compare(lhs: *const GDate, rhs: *const GDate) -> gint;
}
extern "C" {
    #[link_name = "\u{1}_g_date_to_struct_tm"]
    pub fn g_date_to_struct_tm(date: *const GDate, tm: *mut tm);
}
extern "C" {
    #[link_name = "\u{1}_g_date_clamp"]
    pub fn g_date_clamp(date: *mut GDate, min_date: *const GDate, max_date: *const GDate);
}
extern "C" {
    #[link_name = "\u{1}_g_date_order"]
    pub fn g_date_order(date1: *mut GDate, date2: *mut GDate);
}
extern "C" {
    #[link_name = "\u{1}_g_date_strftime"]
    pub fn g_date_strftime(
        s: *mut gchar,
        slen: gsize,
        format: *const gchar,
        date: *const GDate,
    ) -> gsize;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GTimeZone {
    _unused: [u8; 0],
}
pub type GTimeZone = _GTimeZone;
pub const GTimeType_G_TIME_TYPE_STANDARD: GTimeType = 0;
pub const GTimeType_G_TIME_TYPE_DAYLIGHT: GTimeType = 1;
pub const GTimeType_G_TIME_TYPE_UNIVERSAL: GTimeType = 2;
/// GTimeType:
/// @G_TIME_TYPE_STANDARD: the time is in local standard time
/// @G_TIME_TYPE_DAYLIGHT: the time is in local daylight time
/// @G_TIME_TYPE_UNIVERSAL: the time is in UTC
///
/// Disambiguates a given time in two ways.
///
/// First, specifies if the given time is in universal or local time.
///
/// Second, if the time is in local time, specifies if it is local
/// standard time or local daylight time.  This is important for the case
/// where the same local time occurs twice (during daylight savings time
/// transitions, for example).
pub type GTimeType = u32;
extern "C" {
    #[link_name = "\u{1}_g_time_zone_new"]
    pub fn g_time_zone_new(identifier: *const gchar) -> *mut GTimeZone;
}
extern "C" {
    #[link_name = "\u{1}_g_time_zone_new_utc"]
    pub fn g_time_zone_new_utc() -> *mut GTimeZone;
}
extern "C" {
    #[link_name = "\u{1}_g_time_zone_new_local"]
    pub fn g_time_zone_new_local() -> *mut GTimeZone;
}
extern "C" {
    #[link_name = "\u{1}_g_time_zone_ref"]
    pub fn g_time_zone_ref(tz: *mut GTimeZone) -> *mut GTimeZone;
}
extern "C" {
    #[link_name = "\u{1}_g_time_zone_unref"]
    pub fn g_time_zone_unref(tz: *mut GTimeZone);
}
extern "C" {
    #[link_name = "\u{1}_g_time_zone_find_interval"]
    pub fn g_time_zone_find_interval(tz: *mut GTimeZone, type_: GTimeType, time_: gint64) -> gint;
}
extern "C" {
    #[link_name = "\u{1}_g_time_zone_adjust_time"]
    pub fn g_time_zone_adjust_time(
        tz: *mut GTimeZone,
        type_: GTimeType,
        time_: *mut gint64,
    ) -> gint;
}
extern "C" {
    #[link_name = "\u{1}_g_time_zone_get_abbreviation"]
    pub fn g_time_zone_get_abbreviation(tz: *mut GTimeZone, interval: gint) -> *const gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_time_zone_get_offset"]
    pub fn g_time_zone_get_offset(tz: *mut GTimeZone, interval: gint) -> gint32;
}
extern "C" {
    #[link_name = "\u{1}_g_time_zone_is_dst"]
    pub fn g_time_zone_is_dst(tz: *mut GTimeZone, interval: gint) -> gboolean;
}
/// GTimeSpan:
///
/// A value representing an interval of time, in microseconds.
///
/// Since: 2.26
pub type GTimeSpan = gint64;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GDateTime {
    _unused: [u8; 0],
}
/// GDateTime:
///
/// `GDateTime` is an opaque structure whose members
/// cannot be accessed directly.
///
/// Since: 2.26
pub type GDateTime = _GDateTime;
extern "C" {
    #[link_name = "\u{1}_g_date_time_unref"]
    pub fn g_date_time_unref(datetime: *mut GDateTime);
}
extern "C" {
    #[link_name = "\u{1}_g_date_time_ref"]
    pub fn g_date_time_ref(datetime: *mut GDateTime) -> *mut GDateTime;
}
extern "C" {
    #[link_name = "\u{1}_g_date_time_new_now"]
    pub fn g_date_time_new_now(tz: *mut GTimeZone) -> *mut GDateTime;
}
extern "C" {
    #[link_name = "\u{1}_g_date_time_new_now_local"]
    pub fn g_date_time_new_now_local() -> *mut GDateTime;
}
extern "C" {
    #[link_name = "\u{1}_g_date_time_new_now_utc"]
    pub fn g_date_time_new_now_utc() -> *mut GDateTime;
}
extern "C" {
    #[link_name = "\u{1}_g_date_time_new_from_unix_local"]
    pub fn g_date_time_new_from_unix_local(t: gint64) -> *mut GDateTime;
}
extern "C" {
    #[link_name = "\u{1}_g_date_time_new_from_unix_utc"]
    pub fn g_date_time_new_from_unix_utc(t: gint64) -> *mut GDateTime;
}
extern "C" {
    #[link_name = "\u{1}_g_date_time_new_from_timeval_local"]
    pub fn g_date_time_new_from_timeval_local(tv: *const GTimeVal) -> *mut GDateTime;
}
extern "C" {
    #[link_name = "\u{1}_g_date_time_new_from_timeval_utc"]
    pub fn g_date_time_new_from_timeval_utc(tv: *const GTimeVal) -> *mut GDateTime;
}
extern "C" {
    #[link_name = "\u{1}_g_date_time_new"]
    pub fn g_date_time_new(
        tz: *mut GTimeZone,
        year: gint,
        month: gint,
        day: gint,
        hour: gint,
        minute: gint,
        seconds: gdouble,
    ) -> *mut GDateTime;
}
extern "C" {
    #[link_name = "\u{1}_g_date_time_new_local"]
    pub fn g_date_time_new_local(
        year: gint,
        month: gint,
        day: gint,
        hour: gint,
        minute: gint,
        seconds: gdouble,
    ) -> *mut GDateTime;
}
extern "C" {
    #[link_name = "\u{1}_g_date_time_new_utc"]
    pub fn g_date_time_new_utc(
        year: gint,
        month: gint,
        day: gint,
        hour: gint,
        minute: gint,
        seconds: gdouble,
    ) -> *mut GDateTime;
}
extern "C" {
    #[link_name = "\u{1}_g_date_time_add"]
    pub fn g_date_time_add(datetime: *mut GDateTime, timespan: GTimeSpan) -> *mut GDateTime;
}
extern "C" {
    #[link_name = "\u{1}_g_date_time_add_years"]
    pub fn g_date_time_add_years(datetime: *mut GDateTime, years: gint) -> *mut GDateTime;
}
extern "C" {
    #[link_name = "\u{1}_g_date_time_add_months"]
    pub fn g_date_time_add_months(datetime: *mut GDateTime, months: gint) -> *mut GDateTime;
}
extern "C" {
    #[link_name = "\u{1}_g_date_time_add_weeks"]
    pub fn g_date_time_add_weeks(datetime: *mut GDateTime, weeks: gint) -> *mut GDateTime;
}
extern "C" {
    #[link_name = "\u{1}_g_date_time_add_days"]
    pub fn g_date_time_add_days(datetime: *mut GDateTime, days: gint) -> *mut GDateTime;
}
extern "C" {
    #[link_name = "\u{1}_g_date_time_add_hours"]
    pub fn g_date_time_add_hours(datetime: *mut GDateTime, hours: gint) -> *mut GDateTime;
}
extern "C" {
    #[link_name = "\u{1}_g_date_time_add_minutes"]
    pub fn g_date_time_add_minutes(datetime: *mut GDateTime, minutes: gint) -> *mut GDateTime;
}
extern "C" {
    #[link_name = "\u{1}_g_date_time_add_seconds"]
    pub fn g_date_time_add_seconds(datetime: *mut GDateTime, seconds: gdouble) -> *mut GDateTime;
}
extern "C" {
    #[link_name = "\u{1}_g_date_time_add_full"]
    pub fn g_date_time_add_full(
        datetime: *mut GDateTime,
        years: gint,
        months: gint,
        days: gint,
        hours: gint,
        minutes: gint,
        seconds: gdouble,
    ) -> *mut GDateTime;
}
extern "C" {
    #[link_name = "\u{1}_g_date_time_compare"]
    pub fn g_date_time_compare(dt1: gconstpointer, dt2: gconstpointer) -> gint;
}
extern "C" {
    #[link_name = "\u{1}_g_date_time_difference"]
    pub fn g_date_time_difference(end: *mut GDateTime, begin: *mut GDateTime) -> GTimeSpan;
}
extern "C" {
    #[link_name = "\u{1}_g_date_time_hash"]
    pub fn g_date_time_hash(datetime: gconstpointer) -> guint;
}
extern "C" {
    #[link_name = "\u{1}_g_date_time_equal"]
    pub fn g_date_time_equal(dt1: gconstpointer, dt2: gconstpointer) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_date_time_get_ymd"]
    pub fn g_date_time_get_ymd(
        datetime: *mut GDateTime,
        year: *mut gint,
        month: *mut gint,
        day: *mut gint,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_date_time_get_year"]
    pub fn g_date_time_get_year(datetime: *mut GDateTime) -> gint;
}
extern "C" {
    #[link_name = "\u{1}_g_date_time_get_month"]
    pub fn g_date_time_get_month(datetime: *mut GDateTime) -> gint;
}
extern "C" {
    #[link_name = "\u{1}_g_date_time_get_day_of_month"]
    pub fn g_date_time_get_day_of_month(datetime: *mut GDateTime) -> gint;
}
extern "C" {
    #[link_name = "\u{1}_g_date_time_get_week_numbering_year"]
    pub fn g_date_time_get_week_numbering_year(datetime: *mut GDateTime) -> gint;
}
extern "C" {
    #[link_name = "\u{1}_g_date_time_get_week_of_year"]
    pub fn g_date_time_get_week_of_year(datetime: *mut GDateTime) -> gint;
}
extern "C" {
    #[link_name = "\u{1}_g_date_time_get_day_of_week"]
    pub fn g_date_time_get_day_of_week(datetime: *mut GDateTime) -> gint;
}
extern "C" {
    #[link_name = "\u{1}_g_date_time_get_day_of_year"]
    pub fn g_date_time_get_day_of_year(datetime: *mut GDateTime) -> gint;
}
extern "C" {
    #[link_name = "\u{1}_g_date_time_get_hour"]
    pub fn g_date_time_get_hour(datetime: *mut GDateTime) -> gint;
}
extern "C" {
    #[link_name = "\u{1}_g_date_time_get_minute"]
    pub fn g_date_time_get_minute(datetime: *mut GDateTime) -> gint;
}
extern "C" {
    #[link_name = "\u{1}_g_date_time_get_second"]
    pub fn g_date_time_get_second(datetime: *mut GDateTime) -> gint;
}
extern "C" {
    #[link_name = "\u{1}_g_date_time_get_microsecond"]
    pub fn g_date_time_get_microsecond(datetime: *mut GDateTime) -> gint;
}
extern "C" {
    #[link_name = "\u{1}_g_date_time_get_seconds"]
    pub fn g_date_time_get_seconds(datetime: *mut GDateTime) -> gdouble;
}
extern "C" {
    #[link_name = "\u{1}_g_date_time_to_unix"]
    pub fn g_date_time_to_unix(datetime: *mut GDateTime) -> gint64;
}
extern "C" {
    #[link_name = "\u{1}_g_date_time_to_timeval"]
    pub fn g_date_time_to_timeval(datetime: *mut GDateTime, tv: *mut GTimeVal) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_date_time_get_utc_offset"]
    pub fn g_date_time_get_utc_offset(datetime: *mut GDateTime) -> GTimeSpan;
}
extern "C" {
    #[link_name = "\u{1}_g_date_time_get_timezone_abbreviation"]
    pub fn g_date_time_get_timezone_abbreviation(datetime: *mut GDateTime) -> *const gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_date_time_is_daylight_savings"]
    pub fn g_date_time_is_daylight_savings(datetime: *mut GDateTime) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_date_time_to_timezone"]
    pub fn g_date_time_to_timezone(datetime: *mut GDateTime, tz: *mut GTimeZone) -> *mut GDateTime;
}
extern "C" {
    #[link_name = "\u{1}_g_date_time_to_local"]
    pub fn g_date_time_to_local(datetime: *mut GDateTime) -> *mut GDateTime;
}
extern "C" {
    #[link_name = "\u{1}_g_date_time_to_utc"]
    pub fn g_date_time_to_utc(datetime: *mut GDateTime) -> *mut GDateTime;
}
extern "C" {
    #[link_name = "\u{1}_g_date_time_format"]
    pub fn g_date_time_format(datetime: *mut GDateTime, format: *const gchar) -> *mut gchar;
}
pub type ino_t = __darwin_ino_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct dirent {
    pub d_ino: ino_t,
    pub d_reclen: __uint16_t,
    pub d_type: __uint8_t,
    pub d_namlen: __uint8_t,
    pub d_name: [::std::os::raw::c_char; 256usize],
}
#[test]
fn bindgen_test_layout_dirent() {
    assert_eq!(
        ::std::mem::size_of::<dirent>(),
        264usize,
        concat!("Size of: ", stringify!(dirent))
    );
    assert_eq!(
        ::std::mem::align_of::<dirent>(),
        4usize,
        concat!("Alignment of ", stringify!(dirent))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dirent>())).d_ino as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(dirent),
            "::",
            stringify!(d_ino)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dirent>())).d_reclen as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(dirent),
            "::",
            stringify!(d_reclen)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dirent>())).d_type as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(dirent),
            "::",
            stringify!(d_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dirent>())).d_namlen as *const _ as usize },
        7usize,
        concat!(
            "Offset of field: ",
            stringify!(dirent),
            "::",
            stringify!(d_namlen)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<dirent>())).d_name as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(dirent),
            "::",
            stringify!(d_name)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _telldir {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct DIR {
    pub __dd_fd: ::std::os::raw::c_int,
    pub __dd_loc: ::std::os::raw::c_long,
    pub __dd_size: ::std::os::raw::c_long,
    pub __dd_buf: *mut ::std::os::raw::c_char,
    pub __dd_len: ::std::os::raw::c_int,
    pub __dd_seek: ::std::os::raw::c_long,
    pub __dd_rewind: ::std::os::raw::c_long,
    pub __dd_flags: ::std::os::raw::c_int,
    pub __dd_lock: __darwin_pthread_mutex_t,
    pub __dd_td: *mut _telldir,
}
#[test]
fn bindgen_test_layout_DIR() {
    assert_eq!(
        ::std::mem::size_of::<DIR>(),
        136usize,
        concat!("Size of: ", stringify!(DIR))
    );
    assert_eq!(
        ::std::mem::align_of::<DIR>(),
        8usize,
        concat!("Alignment of ", stringify!(DIR))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DIR>())).__dd_fd as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DIR),
            "::",
            stringify!(__dd_fd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DIR>())).__dd_loc as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(DIR),
            "::",
            stringify!(__dd_loc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DIR>())).__dd_size as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(DIR),
            "::",
            stringify!(__dd_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DIR>())).__dd_buf as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(DIR),
            "::",
            stringify!(__dd_buf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DIR>())).__dd_len as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(DIR),
            "::",
            stringify!(__dd_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DIR>())).__dd_seek as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(DIR),
            "::",
            stringify!(__dd_seek)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DIR>())).__dd_rewind as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(DIR),
            "::",
            stringify!(__dd_rewind)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DIR>())).__dd_flags as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(DIR),
            "::",
            stringify!(__dd_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DIR>())).__dd_lock as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(DIR),
            "::",
            stringify!(__dd_lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DIR>())).__dd_td as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(DIR),
            "::",
            stringify!(__dd_td)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_closedir"]
    pub fn closedir(arg1: *mut DIR) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_opendir"]
    pub fn opendir(arg1: *const ::std::os::raw::c_char) -> *mut DIR;
}
extern "C" {
    #[link_name = "\u{1}_readdir"]
    pub fn readdir(arg1: *mut DIR) -> *mut dirent;
}
extern "C" {
    #[link_name = "\u{1}_readdir_r"]
    pub fn readdir_r(
        arg1: *mut DIR,
        arg2: *mut dirent,
        arg3: *mut *mut dirent,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_rewinddir"]
    pub fn rewinddir(arg1: *mut DIR);
}
extern "C" {
    #[link_name = "\u{1}_seekdir"]
    pub fn seekdir(arg1: *mut DIR, arg2: ::std::os::raw::c_long);
}
extern "C" {
    #[link_name = "\u{1}_telldir"]
    pub fn telldir(arg1: *mut DIR) -> ::std::os::raw::c_long;
}
extern "C" {
    #[link_name = "\u{1}_fdopendir"]
    pub fn fdopendir(arg1: ::std::os::raw::c_int) -> *mut DIR;
}
extern "C" {
    #[link_name = "\u{1}_alphasort"]
    pub fn alphasort(arg1: *mut *const dirent, arg2: *mut *const dirent) -> ::std::os::raw::c_int;
}
pub type errno_t = ::std::os::raw::c_int;
extern "C" {
    #[link_name = "\u{1}___error"]
    pub fn __error() -> *mut ::std::os::raw::c_int;
}
pub const idtype_t_P_ALL: idtype_t = 0;
pub const idtype_t_P_PID: idtype_t = 1;
pub const idtype_t_P_PGID: idtype_t = 2;
pub type idtype_t = u32;
pub type id_t = __darwin_id_t;
pub type int_least8_t = i8;
pub type int_least16_t = i16;
pub type int_least32_t = i32;
pub type int_least64_t = i64;
pub type uint_least8_t = u8;
pub type uint_least16_t = u16;
pub type uint_least32_t = u32;
pub type uint_least64_t = u64;
pub type int_fast8_t = i8;
pub type int_fast16_t = i16;
pub type int_fast32_t = i32;
pub type int_fast64_t = i64;
pub type uint_fast8_t = u8;
pub type uint_fast16_t = u16;
pub type uint_fast32_t = u32;
pub type uint_fast64_t = u64;
pub type intmax_t = ::std::os::raw::c_long;
pub type uintmax_t = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timeval {
    pub tv_sec: __darwin_time_t,
    pub tv_usec: __darwin_suseconds_t,
}
#[test]
fn bindgen_test_layout_timeval() {
    assert_eq!(
        ::std::mem::size_of::<timeval>(),
        16usize,
        concat!("Size of: ", stringify!(timeval))
    );
    assert_eq!(
        ::std::mem::align_of::<timeval>(),
        8usize,
        concat!("Alignment of ", stringify!(timeval))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timeval>())).tv_sec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timeval),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timeval>())).tv_usec as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(timeval),
            "::",
            stringify!(tv_usec)
        )
    );
}
pub type rlim_t = __uint64_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rusage {
    pub ru_utime: timeval,
    pub ru_stime: timeval,
    pub ru_maxrss: ::std::os::raw::c_long,
    pub ru_ixrss: ::std::os::raw::c_long,
    pub ru_idrss: ::std::os::raw::c_long,
    pub ru_isrss: ::std::os::raw::c_long,
    pub ru_minflt: ::std::os::raw::c_long,
    pub ru_majflt: ::std::os::raw::c_long,
    pub ru_nswap: ::std::os::raw::c_long,
    pub ru_inblock: ::std::os::raw::c_long,
    pub ru_oublock: ::std::os::raw::c_long,
    pub ru_msgsnd: ::std::os::raw::c_long,
    pub ru_msgrcv: ::std::os::raw::c_long,
    pub ru_nsignals: ::std::os::raw::c_long,
    pub ru_nvcsw: ::std::os::raw::c_long,
    pub ru_nivcsw: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_rusage() {
    assert_eq!(
        ::std::mem::size_of::<rusage>(),
        144usize,
        concat!("Size of: ", stringify!(rusage))
    );
    assert_eq!(
        ::std::mem::align_of::<rusage>(),
        8usize,
        concat!("Alignment of ", stringify!(rusage))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage>())).ru_utime as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_utime)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage>())).ru_stime as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_stime)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage>())).ru_maxrss as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_maxrss)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage>())).ru_ixrss as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_ixrss)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage>())).ru_idrss as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_idrss)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage>())).ru_isrss as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_isrss)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage>())).ru_minflt as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_minflt)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage>())).ru_majflt as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_majflt)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage>())).ru_nswap as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_nswap)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage>())).ru_inblock as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_inblock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage>())).ru_oublock as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_oublock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage>())).ru_msgsnd as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_msgsnd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage>())).ru_msgrcv as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_msgrcv)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage>())).ru_nsignals as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_nsignals)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage>())).ru_nvcsw as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_nvcsw)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage>())).ru_nivcsw as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_nivcsw)
        )
    );
}
pub type rusage_info_t = *mut ::std::os::raw::c_void;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rusage_info_v0 {
    pub ri_uuid: [u8; 16usize],
    pub ri_user_time: u64,
    pub ri_system_time: u64,
    pub ri_pkg_idle_wkups: u64,
    pub ri_interrupt_wkups: u64,
    pub ri_pageins: u64,
    pub ri_wired_size: u64,
    pub ri_resident_size: u64,
    pub ri_phys_footprint: u64,
    pub ri_proc_start_abstime: u64,
    pub ri_proc_exit_abstime: u64,
}
#[test]
fn bindgen_test_layout_rusage_info_v0() {
    assert_eq!(
        ::std::mem::size_of::<rusage_info_v0>(),
        96usize,
        concat!("Size of: ", stringify!(rusage_info_v0))
    );
    assert_eq!(
        ::std::mem::align_of::<rusage_info_v0>(),
        8usize,
        concat!("Alignment of ", stringify!(rusage_info_v0))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage_info_v0>())).ri_uuid as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v0),
            "::",
            stringify!(ri_uuid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage_info_v0>())).ri_user_time as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v0),
            "::",
            stringify!(ri_user_time)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage_info_v0>())).ri_system_time as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v0),
            "::",
            stringify!(ri_system_time)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v0>())).ri_pkg_idle_wkups as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v0),
            "::",
            stringify!(ri_pkg_idle_wkups)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v0>())).ri_interrupt_wkups as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v0),
            "::",
            stringify!(ri_interrupt_wkups)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage_info_v0>())).ri_pageins as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v0),
            "::",
            stringify!(ri_pageins)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage_info_v0>())).ri_wired_size as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v0),
            "::",
            stringify!(ri_wired_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage_info_v0>())).ri_resident_size as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v0),
            "::",
            stringify!(ri_resident_size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v0>())).ri_phys_footprint as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v0),
            "::",
            stringify!(ri_phys_footprint)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v0>())).ri_proc_start_abstime as *const _ as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v0),
            "::",
            stringify!(ri_proc_start_abstime)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v0>())).ri_proc_exit_abstime as *const _ as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v0),
            "::",
            stringify!(ri_proc_exit_abstime)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rusage_info_v1 {
    pub ri_uuid: [u8; 16usize],
    pub ri_user_time: u64,
    pub ri_system_time: u64,
    pub ri_pkg_idle_wkups: u64,
    pub ri_interrupt_wkups: u64,
    pub ri_pageins: u64,
    pub ri_wired_size: u64,
    pub ri_resident_size: u64,
    pub ri_phys_footprint: u64,
    pub ri_proc_start_abstime: u64,
    pub ri_proc_exit_abstime: u64,
    pub ri_child_user_time: u64,
    pub ri_child_system_time: u64,
    pub ri_child_pkg_idle_wkups: u64,
    pub ri_child_interrupt_wkups: u64,
    pub ri_child_pageins: u64,
    pub ri_child_elapsed_abstime: u64,
}
#[test]
fn bindgen_test_layout_rusage_info_v1() {
    assert_eq!(
        ::std::mem::size_of::<rusage_info_v1>(),
        144usize,
        concat!("Size of: ", stringify!(rusage_info_v1))
    );
    assert_eq!(
        ::std::mem::align_of::<rusage_info_v1>(),
        8usize,
        concat!("Alignment of ", stringify!(rusage_info_v1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage_info_v1>())).ri_uuid as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v1),
            "::",
            stringify!(ri_uuid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage_info_v1>())).ri_user_time as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v1),
            "::",
            stringify!(ri_user_time)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage_info_v1>())).ri_system_time as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v1),
            "::",
            stringify!(ri_system_time)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v1>())).ri_pkg_idle_wkups as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v1),
            "::",
            stringify!(ri_pkg_idle_wkups)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v1>())).ri_interrupt_wkups as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v1),
            "::",
            stringify!(ri_interrupt_wkups)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage_info_v1>())).ri_pageins as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v1),
            "::",
            stringify!(ri_pageins)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage_info_v1>())).ri_wired_size as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v1),
            "::",
            stringify!(ri_wired_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage_info_v1>())).ri_resident_size as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v1),
            "::",
            stringify!(ri_resident_size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v1>())).ri_phys_footprint as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v1),
            "::",
            stringify!(ri_phys_footprint)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v1>())).ri_proc_start_abstime as *const _ as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v1),
            "::",
            stringify!(ri_proc_start_abstime)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v1>())).ri_proc_exit_abstime as *const _ as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v1),
            "::",
            stringify!(ri_proc_exit_abstime)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v1>())).ri_child_user_time as *const _ as usize
        },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v1),
            "::",
            stringify!(ri_child_user_time)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v1>())).ri_child_system_time as *const _ as usize
        },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v1),
            "::",
            stringify!(ri_child_system_time)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v1>())).ri_child_pkg_idle_wkups as *const _ as usize
        },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v1),
            "::",
            stringify!(ri_child_pkg_idle_wkups)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v1>())).ri_child_interrupt_wkups as *const _ as usize
        },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v1),
            "::",
            stringify!(ri_child_interrupt_wkups)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage_info_v1>())).ri_child_pageins as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v1),
            "::",
            stringify!(ri_child_pageins)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v1>())).ri_child_elapsed_abstime as *const _ as usize
        },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v1),
            "::",
            stringify!(ri_child_elapsed_abstime)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rusage_info_v2 {
    pub ri_uuid: [u8; 16usize],
    pub ri_user_time: u64,
    pub ri_system_time: u64,
    pub ri_pkg_idle_wkups: u64,
    pub ri_interrupt_wkups: u64,
    pub ri_pageins: u64,
    pub ri_wired_size: u64,
    pub ri_resident_size: u64,
    pub ri_phys_footprint: u64,
    pub ri_proc_start_abstime: u64,
    pub ri_proc_exit_abstime: u64,
    pub ri_child_user_time: u64,
    pub ri_child_system_time: u64,
    pub ri_child_pkg_idle_wkups: u64,
    pub ri_child_interrupt_wkups: u64,
    pub ri_child_pageins: u64,
    pub ri_child_elapsed_abstime: u64,
    pub ri_diskio_bytesread: u64,
    pub ri_diskio_byteswritten: u64,
}
#[test]
fn bindgen_test_layout_rusage_info_v2() {
    assert_eq!(
        ::std::mem::size_of::<rusage_info_v2>(),
        160usize,
        concat!("Size of: ", stringify!(rusage_info_v2))
    );
    assert_eq!(
        ::std::mem::align_of::<rusage_info_v2>(),
        8usize,
        concat!("Alignment of ", stringify!(rusage_info_v2))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage_info_v2>())).ri_uuid as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_uuid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage_info_v2>())).ri_user_time as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_user_time)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage_info_v2>())).ri_system_time as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_system_time)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v2>())).ri_pkg_idle_wkups as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_pkg_idle_wkups)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v2>())).ri_interrupt_wkups as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_interrupt_wkups)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage_info_v2>())).ri_pageins as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_pageins)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage_info_v2>())).ri_wired_size as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_wired_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage_info_v2>())).ri_resident_size as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_resident_size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v2>())).ri_phys_footprint as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_phys_footprint)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v2>())).ri_proc_start_abstime as *const _ as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_proc_start_abstime)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v2>())).ri_proc_exit_abstime as *const _ as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_proc_exit_abstime)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v2>())).ri_child_user_time as *const _ as usize
        },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_child_user_time)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v2>())).ri_child_system_time as *const _ as usize
        },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_child_system_time)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v2>())).ri_child_pkg_idle_wkups as *const _ as usize
        },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_child_pkg_idle_wkups)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v2>())).ri_child_interrupt_wkups as *const _ as usize
        },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_child_interrupt_wkups)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage_info_v2>())).ri_child_pageins as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_child_pageins)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v2>())).ri_child_elapsed_abstime as *const _ as usize
        },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_child_elapsed_abstime)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v2>())).ri_diskio_bytesread as *const _ as usize
        },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_diskio_bytesread)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v2>())).ri_diskio_byteswritten as *const _ as usize
        },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_diskio_byteswritten)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rusage_info_v3 {
    pub ri_uuid: [u8; 16usize],
    pub ri_user_time: u64,
    pub ri_system_time: u64,
    pub ri_pkg_idle_wkups: u64,
    pub ri_interrupt_wkups: u64,
    pub ri_pageins: u64,
    pub ri_wired_size: u64,
    pub ri_resident_size: u64,
    pub ri_phys_footprint: u64,
    pub ri_proc_start_abstime: u64,
    pub ri_proc_exit_abstime: u64,
    pub ri_child_user_time: u64,
    pub ri_child_system_time: u64,
    pub ri_child_pkg_idle_wkups: u64,
    pub ri_child_interrupt_wkups: u64,
    pub ri_child_pageins: u64,
    pub ri_child_elapsed_abstime: u64,
    pub ri_diskio_bytesread: u64,
    pub ri_diskio_byteswritten: u64,
    pub ri_cpu_time_qos_default: u64,
    pub ri_cpu_time_qos_maintenance: u64,
    pub ri_cpu_time_qos_background: u64,
    pub ri_cpu_time_qos_utility: u64,
    pub ri_cpu_time_qos_legacy: u64,
    pub ri_cpu_time_qos_user_initiated: u64,
    pub ri_cpu_time_qos_user_interactive: u64,
    pub ri_billed_system_time: u64,
    pub ri_serviced_system_time: u64,
}
#[test]
fn bindgen_test_layout_rusage_info_v3() {
    assert_eq!(
        ::std::mem::size_of::<rusage_info_v3>(),
        232usize,
        concat!("Size of: ", stringify!(rusage_info_v3))
    );
    assert_eq!(
        ::std::mem::align_of::<rusage_info_v3>(),
        8usize,
        concat!("Alignment of ", stringify!(rusage_info_v3))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage_info_v3>())).ri_uuid as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_uuid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage_info_v3>())).ri_user_time as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_user_time)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage_info_v3>())).ri_system_time as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_system_time)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v3>())).ri_pkg_idle_wkups as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_pkg_idle_wkups)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v3>())).ri_interrupt_wkups as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_interrupt_wkups)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage_info_v3>())).ri_pageins as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_pageins)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage_info_v3>())).ri_wired_size as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_wired_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage_info_v3>())).ri_resident_size as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_resident_size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v3>())).ri_phys_footprint as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_phys_footprint)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v3>())).ri_proc_start_abstime as *const _ as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_proc_start_abstime)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v3>())).ri_proc_exit_abstime as *const _ as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_proc_exit_abstime)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v3>())).ri_child_user_time as *const _ as usize
        },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_child_user_time)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v3>())).ri_child_system_time as *const _ as usize
        },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_child_system_time)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v3>())).ri_child_pkg_idle_wkups as *const _ as usize
        },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_child_pkg_idle_wkups)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v3>())).ri_child_interrupt_wkups as *const _ as usize
        },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_child_interrupt_wkups)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage_info_v3>())).ri_child_pageins as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_child_pageins)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v3>())).ri_child_elapsed_abstime as *const _ as usize
        },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_child_elapsed_abstime)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v3>())).ri_diskio_bytesread as *const _ as usize
        },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_diskio_bytesread)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v3>())).ri_diskio_byteswritten as *const _ as usize
        },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_diskio_byteswritten)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v3>())).ri_cpu_time_qos_default as *const _ as usize
        },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_cpu_time_qos_default)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v3>())).ri_cpu_time_qos_maintenance as *const _
                as usize
        },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_cpu_time_qos_maintenance)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v3>())).ri_cpu_time_qos_background as *const _
                as usize
        },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_cpu_time_qos_background)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v3>())).ri_cpu_time_qos_utility as *const _ as usize
        },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_cpu_time_qos_utility)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v3>())).ri_cpu_time_qos_legacy as *const _ as usize
        },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_cpu_time_qos_legacy)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v3>())).ri_cpu_time_qos_user_initiated as *const _
                as usize
        },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_cpu_time_qos_user_initiated)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v3>())).ri_cpu_time_qos_user_interactive as *const _
                as usize
        },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_cpu_time_qos_user_interactive)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v3>())).ri_billed_system_time as *const _ as usize
        },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_billed_system_time)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v3>())).ri_serviced_system_time as *const _ as usize
        },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_serviced_system_time)
        )
    );
}
pub type rusage_info_current = rusage_info_v3;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rlimit {
    pub rlim_cur: rlim_t,
    pub rlim_max: rlim_t,
}
#[test]
fn bindgen_test_layout_rlimit() {
    assert_eq!(
        ::std::mem::size_of::<rlimit>(),
        16usize,
        concat!("Size of: ", stringify!(rlimit))
    );
    assert_eq!(
        ::std::mem::align_of::<rlimit>(),
        8usize,
        concat!("Alignment of ", stringify!(rlimit))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rlimit>())).rlim_cur as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rlimit),
            "::",
            stringify!(rlim_cur)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rlimit>())).rlim_max as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rlimit),
            "::",
            stringify!(rlim_max)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct proc_rlimit_control_wakeupmon {
    pub wm_flags: u32,
    pub wm_rate: i32,
}
#[test]
fn bindgen_test_layout_proc_rlimit_control_wakeupmon() {
    assert_eq!(
        ::std::mem::size_of::<proc_rlimit_control_wakeupmon>(),
        8usize,
        concat!("Size of: ", stringify!(proc_rlimit_control_wakeupmon))
    );
    assert_eq!(
        ::std::mem::align_of::<proc_rlimit_control_wakeupmon>(),
        4usize,
        concat!("Alignment of ", stringify!(proc_rlimit_control_wakeupmon))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<proc_rlimit_control_wakeupmon>())).wm_flags as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(proc_rlimit_control_wakeupmon),
            "::",
            stringify!(wm_flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<proc_rlimit_control_wakeupmon>())).wm_rate as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(proc_rlimit_control_wakeupmon),
            "::",
            stringify!(wm_rate)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_getpriority"]
    pub fn getpriority(arg1: ::std::os::raw::c_int, arg2: id_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_getiopolicy_np"]
    pub fn getiopolicy_np(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_getrlimit"]
    pub fn getrlimit(arg1: ::std::os::raw::c_int, arg2: *mut rlimit) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_getrusage"]
    pub fn getrusage(arg1: ::std::os::raw::c_int, arg2: *mut rusage) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_setpriority"]
    pub fn setpriority(
        arg1: ::std::os::raw::c_int,
        arg2: id_t,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_setiopolicy_np"]
    pub fn setiopolicy_np(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_int,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_setrlimit"]
    pub fn setrlimit(arg1: ::std::os::raw::c_int, arg2: *const rlimit) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union wait {
    pub w_status: ::std::os::raw::c_int,
    pub w_T: wait__bindgen_ty_1,
    pub w_S: wait__bindgen_ty_2,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wait__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u16>,
    pub __bindgen_align: [u32; 0usize],
}
#[test]
fn bindgen_test_layout_wait__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<wait__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(wait__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<wait__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(wait__bindgen_ty_1))
    );
}
impl wait__bindgen_ty_1 {
    #[inline]
    pub fn w_Termsig(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 7u8) as u32) }
    }
    #[inline]
    pub fn set_w_Termsig(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub fn w_Coredump(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_w_Coredump(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn w_Retcode(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_w_Retcode(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn w_Filler(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_w_Filler(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        w_Termsig: ::std::os::raw::c_uint,
        w_Coredump: ::std::os::raw::c_uint,
        w_Retcode: ::std::os::raw::c_uint,
        w_Filler: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 7u8, {
            let w_Termsig: u32 = unsafe { ::std::mem::transmute(w_Termsig) };
            w_Termsig as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let w_Coredump: u32 = unsafe { ::std::mem::transmute(w_Coredump) };
            w_Coredump as u64
        });
        __bindgen_bitfield_unit.set(8usize, 8u8, {
            let w_Retcode: u32 = unsafe { ::std::mem::transmute(w_Retcode) };
            w_Retcode as u64
        });
        __bindgen_bitfield_unit.set(16usize, 16u8, {
            let w_Filler: u32 = unsafe { ::std::mem::transmute(w_Filler) };
            w_Filler as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wait__bindgen_ty_2 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u16>,
    pub __bindgen_align: [u32; 0usize],
}
#[test]
fn bindgen_test_layout_wait__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<wait__bindgen_ty_2>(),
        4usize,
        concat!("Size of: ", stringify!(wait__bindgen_ty_2))
    );
    assert_eq!(
        ::std::mem::align_of::<wait__bindgen_ty_2>(),
        4usize,
        concat!("Alignment of ", stringify!(wait__bindgen_ty_2))
    );
}
impl wait__bindgen_ty_2 {
    #[inline]
    pub fn w_Stopval(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_w_Stopval(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn w_Stopsig(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_w_Stopsig(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn w_Filler(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_w_Filler(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        w_Stopval: ::std::os::raw::c_uint,
        w_Stopsig: ::std::os::raw::c_uint,
        w_Filler: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let w_Stopval: u32 = unsafe { ::std::mem::transmute(w_Stopval) };
            w_Stopval as u64
        });
        __bindgen_bitfield_unit.set(8usize, 8u8, {
            let w_Stopsig: u32 = unsafe { ::std::mem::transmute(w_Stopsig) };
            w_Stopsig as u64
        });
        __bindgen_bitfield_unit.set(16usize, 16u8, {
            let w_Filler: u32 = unsafe { ::std::mem::transmute(w_Filler) };
            w_Filler as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_wait() {
    assert_eq!(
        ::std::mem::size_of::<wait>(),
        4usize,
        concat!("Size of: ", stringify!(wait))
    );
    assert_eq!(
        ::std::mem::align_of::<wait>(),
        4usize,
        concat!("Alignment of ", stringify!(wait))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wait>())).w_status as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wait),
            "::",
            stringify!(w_status)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wait>())).w_T as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(wait), "::", stringify!(w_T))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wait>())).w_S as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(wait), "::", stringify!(w_S))
    );
}
extern "C" {
    #[link_name = "\u{1}_wait"]
    pub fn wait(arg1: *mut ::std::os::raw::c_int) -> pid_t;
}
extern "C" {
    #[link_name = "\u{1}_waitpid"]
    pub fn waitpid(
        arg1: pid_t,
        arg2: *mut ::std::os::raw::c_int,
        arg3: ::std::os::raw::c_int,
    ) -> pid_t;
}
extern "C" {
    #[link_name = "\u{1}_waitid"]
    pub fn waitid(
        arg1: idtype_t,
        arg2: id_t,
        arg3: *mut siginfo_t,
        arg4: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_wait3"]
    pub fn wait3(
        arg1: *mut ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_int,
        arg3: *mut rusage,
    ) -> pid_t;
}
extern "C" {
    #[link_name = "\u{1}_wait4"]
    pub fn wait4(
        arg1: pid_t,
        arg2: *mut ::std::os::raw::c_int,
        arg3: ::std::os::raw::c_int,
        arg4: *mut rusage,
    ) -> pid_t;
}
extern "C" {
    #[link_name = "\u{1}___builtin_alloca"]
    pub fn __builtin_alloca(arg1: usize) -> *mut ::std::os::raw::c_void;
}
pub type ct_rune_t = __darwin_ct_rune_t;
pub type rune_t = __darwin_rune_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct div_t {
    pub quot: ::std::os::raw::c_int,
    pub rem: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_div_t() {
    assert_eq!(
        ::std::mem::size_of::<div_t>(),
        8usize,
        concat!("Size of: ", stringify!(div_t))
    );
    assert_eq!(
        ::std::mem::align_of::<div_t>(),
        4usize,
        concat!("Alignment of ", stringify!(div_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<div_t>())).quot as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(div_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<div_t>())).rem as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(div_t),
            "::",
            stringify!(rem)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ldiv_t {
    pub quot: ::std::os::raw::c_long,
    pub rem: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_ldiv_t() {
    assert_eq!(
        ::std::mem::size_of::<ldiv_t>(),
        16usize,
        concat!("Size of: ", stringify!(ldiv_t))
    );
    assert_eq!(
        ::std::mem::align_of::<ldiv_t>(),
        8usize,
        concat!("Alignment of ", stringify!(ldiv_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ldiv_t>())).quot as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ldiv_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ldiv_t>())).rem as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ldiv_t),
            "::",
            stringify!(rem)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lldiv_t {
    pub quot: ::std::os::raw::c_longlong,
    pub rem: ::std::os::raw::c_longlong,
}
#[test]
fn bindgen_test_layout_lldiv_t() {
    assert_eq!(
        ::std::mem::size_of::<lldiv_t>(),
        16usize,
        concat!("Size of: ", stringify!(lldiv_t))
    );
    assert_eq!(
        ::std::mem::align_of::<lldiv_t>(),
        8usize,
        concat!("Alignment of ", stringify!(lldiv_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lldiv_t>())).quot as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lldiv_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lldiv_t>())).rem as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lldiv_t),
            "::",
            stringify!(rem)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}___mb_cur_max"]
    pub static mut __mb_cur_max: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_abort"]
    pub fn abort();
}
extern "C" {
    #[link_name = "\u{1}_abs"]
    pub fn abs(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_atexit"]
    pub fn atexit(arg1: ::std::option::Option<unsafe extern "C" fn()>) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_atof"]
    pub fn atof(arg1: *const ::std::os::raw::c_char) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_atoi"]
    pub fn atoi(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_atol"]
    pub fn atol(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_long;
}
extern "C" {
    #[link_name = "\u{1}_atoll"]
    pub fn atoll(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[link_name = "\u{1}_bsearch"]
    pub fn bsearch(
        __key: *const ::std::os::raw::c_void,
        __base: *const ::std::os::raw::c_void,
        __nel: usize,
        __width: usize,
        __compar: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *const ::std::os::raw::c_void,
                arg2: *const ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[link_name = "\u{1}_calloc"]
    pub fn calloc(__count: usize, __size: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[link_name = "\u{1}_div"]
    pub fn div(arg1: ::std::os::raw::c_int, arg2: ::std::os::raw::c_int) -> div_t;
}
extern "C" {
    #[link_name = "\u{1}_exit"]
    pub fn exit(arg1: ::std::os::raw::c_int);
}
extern "C" {
    #[link_name = "\u{1}_free"]
    pub fn free(arg1: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[link_name = "\u{1}_getenv"]
    pub fn getenv(arg1: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_labs"]
    pub fn labs(arg1: ::std::os::raw::c_long) -> ::std::os::raw::c_long;
}
extern "C" {
    #[link_name = "\u{1}_ldiv"]
    pub fn ldiv(arg1: ::std::os::raw::c_long, arg2: ::std::os::raw::c_long) -> ldiv_t;
}
extern "C" {
    #[link_name = "\u{1}_llabs"]
    pub fn llabs(arg1: ::std::os::raw::c_longlong) -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[link_name = "\u{1}_lldiv"]
    pub fn lldiv(arg1: ::std::os::raw::c_longlong, arg2: ::std::os::raw::c_longlong) -> lldiv_t;
}
extern "C" {
    #[link_name = "\u{1}_malloc"]
    pub fn malloc(__size: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[link_name = "\u{1}_mblen"]
    pub fn mblen(__s: *const ::std::os::raw::c_char, __n: usize) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_mbstowcs"]
    pub fn mbstowcs(arg1: *mut wchar_t, arg2: *const ::std::os::raw::c_char, arg3: usize) -> usize;
}
extern "C" {
    #[link_name = "\u{1}_mbtowc"]
    pub fn mbtowc(
        arg1: *mut wchar_t,
        arg2: *const ::std::os::raw::c_char,
        arg3: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_posix_memalign"]
    pub fn posix_memalign(
        __memptr: *mut *mut ::std::os::raw::c_void,
        __alignment: usize,
        __size: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_qsort"]
    pub fn qsort(
        __base: *mut ::std::os::raw::c_void,
        __nel: usize,
        __width: usize,
        __compar: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *const ::std::os::raw::c_void,
                arg2: *const ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
    );
}
extern "C" {
    #[link_name = "\u{1}_rand"]
    pub fn rand() -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_realloc"]
    pub fn realloc(
        __ptr: *mut ::std::os::raw::c_void,
        __size: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[link_name = "\u{1}_srand"]
    pub fn srand(arg1: ::std::os::raw::c_uint);
}
extern "C" {
    #[link_name = "\u{1}_strtod"]
    pub fn strtod(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut *mut ::std::os::raw::c_char,
    ) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_strtof"]
    pub fn strtof(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut *mut ::std::os::raw::c_char,
    ) -> f32;
}
extern "C" {
    #[link_name = "\u{1}_strtol"]
    pub fn strtol(
        __str: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    #[link_name = "\u{1}_strtold"]
    pub fn strtold(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut *mut ::std::os::raw::c_char,
    ) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_strtoll"]
    pub fn strtoll(
        __str: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[link_name = "\u{1}_strtoul"]
    pub fn strtoul(
        __str: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    #[link_name = "\u{1}_strtoull"]
    pub fn strtoull(
        __str: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    #[link_name = "\u{1}_system"]
    pub fn system(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_wcstombs"]
    pub fn wcstombs(arg1: *mut ::std::os::raw::c_char, arg2: *const wchar_t, arg3: usize) -> usize;
}
extern "C" {
    #[link_name = "\u{1}_wctomb"]
    pub fn wctomb(arg1: *mut ::std::os::raw::c_char, arg2: wchar_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__Exit"]
    pub fn _Exit(arg1: ::std::os::raw::c_int);
}
extern "C" {
    #[link_name = "\u{1}_a64l"]
    pub fn a64l(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_long;
}
extern "C" {
    #[link_name = "\u{1}_drand48"]
    pub fn drand48() -> f64;
}
extern "C" {
    #[link_name = "\u{1}_ecvt"]
    pub fn ecvt(
        arg1: f64,
        arg2: ::std::os::raw::c_int,
        arg3: *mut ::std::os::raw::c_int,
        arg4: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_erand48"]
    pub fn erand48(arg1: *mut ::std::os::raw::c_ushort) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_fcvt"]
    pub fn fcvt(
        arg1: f64,
        arg2: ::std::os::raw::c_int,
        arg3: *mut ::std::os::raw::c_int,
        arg4: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_gcvt"]
    pub fn gcvt(
        arg1: f64,
        arg2: ::std::os::raw::c_int,
        arg3: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_getsubopt"]
    pub fn getsubopt(
        arg1: *mut *mut ::std::os::raw::c_char,
        arg2: *const *const ::std::os::raw::c_char,
        arg3: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_grantpt"]
    pub fn grantpt(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_initstate"]
    pub fn initstate(
        arg1: ::std::os::raw::c_uint,
        arg2: *mut ::std::os::raw::c_char,
        arg3: usize,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_jrand48"]
    pub fn jrand48(arg1: *mut ::std::os::raw::c_ushort) -> ::std::os::raw::c_long;
}
extern "C" {
    #[link_name = "\u{1}_l64a"]
    pub fn l64a(arg1: ::std::os::raw::c_long) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_lcong48"]
    pub fn lcong48(arg1: *mut ::std::os::raw::c_ushort);
}
extern "C" {
    #[link_name = "\u{1}_lrand48"]
    pub fn lrand48() -> ::std::os::raw::c_long;
}
extern "C" {
    #[link_name = "\u{1}_mktemp"]
    pub fn mktemp(arg1: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_mkstemp"]
    pub fn mkstemp(arg1: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_mrand48"]
    pub fn mrand48() -> ::std::os::raw::c_long;
}
extern "C" {
    #[link_name = "\u{1}_nrand48"]
    pub fn nrand48(arg1: *mut ::std::os::raw::c_ushort) -> ::std::os::raw::c_long;
}
extern "C" {
    #[link_name = "\u{1}_posix_openpt"]
    pub fn posix_openpt(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ptsname"]
    pub fn ptsname(arg1: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_putenv"]
    pub fn putenv(arg1: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_random"]
    pub fn random() -> ::std::os::raw::c_long;
}
extern "C" {
    #[link_name = "\u{1}_rand_r"]
    pub fn rand_r(arg1: *mut ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_realpath$DARWIN_EXTSN"]
    pub fn realpath(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_seed48"]
    pub fn seed48(arg1: *mut ::std::os::raw::c_ushort) -> *mut ::std::os::raw::c_ushort;
}
extern "C" {
    #[link_name = "\u{1}_setenv"]
    pub fn setenv(
        __name: *const ::std::os::raw::c_char,
        __value: *const ::std::os::raw::c_char,
        __overwrite: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_setkey"]
    pub fn setkey(arg1: *const ::std::os::raw::c_char);
}
extern "C" {
    #[link_name = "\u{1}_setstate"]
    pub fn setstate(arg1: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_srand48"]
    pub fn srand48(arg1: ::std::os::raw::c_long);
}
extern "C" {
    #[link_name = "\u{1}_srandom"]
    pub fn srandom(arg1: ::std::os::raw::c_uint);
}
extern "C" {
    #[link_name = "\u{1}_unlockpt"]
    pub fn unlockpt(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_unsetenv"]
    pub fn unsetenv(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
pub type u_int8_t = ::std::os::raw::c_uchar;
pub type u_int16_t = ::std::os::raw::c_ushort;
pub type u_int32_t = ::std::os::raw::c_uint;
pub type u_int64_t = ::std::os::raw::c_ulonglong;
pub type register_t = i64;
pub type user_addr_t = u_int64_t;
pub type user_size_t = u_int64_t;
pub type user_ssize_t = i64;
pub type user_long_t = i64;
pub type user_ulong_t = u_int64_t;
pub type user_time_t = i64;
pub type user_off_t = i64;
pub type syscall_arg_t = u_int64_t;
pub type dev_t = __darwin_dev_t;
pub type mode_t = __darwin_mode_t;
extern "C" {
    #[link_name = "\u{1}_arc4random"]
    pub fn arc4random() -> u32;
}
extern "C" {
    #[link_name = "\u{1}_arc4random_addrandom"]
    pub fn arc4random_addrandom(arg1: *mut ::std::os::raw::c_uchar, arg2: ::std::os::raw::c_int);
}
extern "C" {
    #[link_name = "\u{1}_arc4random_buf"]
    pub fn arc4random_buf(__buf: *mut ::std::os::raw::c_void, __nbytes: usize);
}
extern "C" {
    #[link_name = "\u{1}_arc4random_stir"]
    pub fn arc4random_stir();
}
extern "C" {
    #[link_name = "\u{1}_arc4random_uniform"]
    pub fn arc4random_uniform(__upper_bound: u32) -> u32;
}
extern "C" {
    #[link_name = "\u{1}_atexit_b"]
    pub fn atexit_b(arg1: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_bsearch_b"]
    pub fn bsearch_b(
        __key: *const ::std::os::raw::c_void,
        __base: *const ::std::os::raw::c_void,
        __nel: usize,
        __width: usize,
        __compar: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[link_name = "\u{1}_cgetcap"]
    pub fn cgetcap(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_cgetclose"]
    pub fn cgetclose() -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_cgetent"]
    pub fn cgetent(
        arg1: *mut *mut ::std::os::raw::c_char,
        arg2: *mut *mut ::std::os::raw::c_char,
        arg3: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_cgetfirst"]
    pub fn cgetfirst(
        arg1: *mut *mut ::std::os::raw::c_char,
        arg2: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_cgetmatch"]
    pub fn cgetmatch(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_cgetnext"]
    pub fn cgetnext(
        arg1: *mut *mut ::std::os::raw::c_char,
        arg2: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_cgetnum"]
    pub fn cgetnum(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_cgetset"]
    pub fn cgetset(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_cgetstr"]
    pub fn cgetstr(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_cgetustr"]
    pub fn cgetustr(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_daemon"]
    pub fn daemon(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_devname"]
    pub fn devname(arg1: dev_t, arg2: mode_t) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_devname_r"]
    pub fn devname_r(
        arg1: dev_t,
        arg2: mode_t,
        buf: *mut ::std::os::raw::c_char,
        len: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_getbsize"]
    pub fn getbsize(
        arg1: *mut ::std::os::raw::c_int,
        arg2: *mut ::std::os::raw::c_long,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_getloadavg"]
    pub fn getloadavg(arg1: *mut f64, arg2: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_getprogname"]
    pub fn getprogname() -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_heapsort"]
    pub fn heapsort(
        __base: *mut ::std::os::raw::c_void,
        __nel: usize,
        __width: usize,
        __compar: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *const ::std::os::raw::c_void,
                arg2: *const ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_heapsort_b"]
    pub fn heapsort_b(
        __base: *mut ::std::os::raw::c_void,
        __nel: usize,
        __width: usize,
        __compar: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_mergesort"]
    pub fn mergesort(
        __base: *mut ::std::os::raw::c_void,
        __nel: usize,
        __width: usize,
        __compar: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *const ::std::os::raw::c_void,
                arg2: *const ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_mergesort_b"]
    pub fn mergesort_b(
        __base: *mut ::std::os::raw::c_void,
        __nel: usize,
        __width: usize,
        __compar: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_psort"]
    pub fn psort(
        __base: *mut ::std::os::raw::c_void,
        __nel: usize,
        __width: usize,
        __compar: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *const ::std::os::raw::c_void,
                arg2: *const ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
    );
}
extern "C" {
    #[link_name = "\u{1}_psort_b"]
    pub fn psort_b(
        __base: *mut ::std::os::raw::c_void,
        __nel: usize,
        __width: usize,
        __compar: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[link_name = "\u{1}_psort_r"]
    pub fn psort_r(
        __base: *mut ::std::os::raw::c_void,
        __nel: usize,
        __width: usize,
        arg1: *mut ::std::os::raw::c_void,
        __compar: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::std::os::raw::c_void,
                arg2: *const ::std::os::raw::c_void,
                arg3: *const ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
    );
}
extern "C" {
    #[link_name = "\u{1}_qsort_b"]
    pub fn qsort_b(
        __base: *mut ::std::os::raw::c_void,
        __nel: usize,
        __width: usize,
        __compar: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[link_name = "\u{1}_qsort_r"]
    pub fn qsort_r(
        __base: *mut ::std::os::raw::c_void,
        __nel: usize,
        __width: usize,
        arg1: *mut ::std::os::raw::c_void,
        __compar: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::std::os::raw::c_void,
                arg2: *const ::std::os::raw::c_void,
                arg3: *const ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
    );
}
extern "C" {
    #[link_name = "\u{1}_radixsort"]
    pub fn radixsort(
        __base: *mut *const ::std::os::raw::c_uchar,
        __nel: ::std::os::raw::c_int,
        __table: *const ::std::os::raw::c_uchar,
        __endbyte: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_setprogname"]
    pub fn setprogname(arg1: *const ::std::os::raw::c_char);
}
extern "C" {
    #[link_name = "\u{1}_sradixsort"]
    pub fn sradixsort(
        __base: *mut *const ::std::os::raw::c_uchar,
        __nel: ::std::os::raw::c_int,
        __table: *const ::std::os::raw::c_uchar,
        __endbyte: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_sranddev"]
    pub fn sranddev();
}
extern "C" {
    #[link_name = "\u{1}_srandomdev"]
    pub fn srandomdev();
}
extern "C" {
    #[link_name = "\u{1}_reallocf"]
    pub fn reallocf(
        __ptr: *mut ::std::os::raw::c_void,
        __size: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[link_name = "\u{1}_strtoq"]
    pub fn strtoq(
        __str: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    #[link_name = "\u{1}_strtouq"]
    pub fn strtouq(
        __str: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    #[link_name = "\u{1}_suboptarg"]
    pub static mut suboptarg: *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_valloc"]
    pub fn valloc(arg1: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[link_name = "\u{1}_scandir"]
    pub fn scandir(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut *mut *mut dirent,
        arg3: ::std::option::Option<
            unsafe extern "C" fn(arg1: *const dirent) -> ::std::os::raw::c_int,
        >,
        arg4: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut *const dirent, arg2: *mut *const dirent)
                -> ::std::os::raw::c_int,
        >,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_scandir_b"]
    pub fn scandir_b(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut *mut *mut dirent,
        arg3: *mut ::std::os::raw::c_void,
        arg4: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_getdirentries"]
    pub fn getdirentries(
        arg1: ::std::os::raw::c_int,
        arg2: *mut ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
        arg4: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}___opendir2"]
    pub fn __opendir2(arg1: *const ::std::os::raw::c_char, arg2: ::std::os::raw::c_int)
        -> *mut DIR;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GDir {
    _unused: [u8; 0],
}
pub type GDir = _GDir;
extern "C" {
    #[link_name = "\u{1}_g_dir_open"]
    pub fn g_dir_open(path: *const gchar, flags: guint, error: *mut *mut GError) -> *mut GDir;
}
extern "C" {
    #[link_name = "\u{1}_g_dir_read_name"]
    pub fn g_dir_read_name(dir: *mut GDir) -> *const gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_dir_rewind"]
    pub fn g_dir_rewind(dir: *mut GDir);
}
extern "C" {
    #[link_name = "\u{1}_g_dir_close"]
    pub fn g_dir_close(dir: *mut GDir);
}
extern "C" {
    #[link_name = "\u{1}_g_getenv"]
    pub fn g_getenv(variable: *const gchar) -> *const gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_setenv"]
    pub fn g_setenv(variable: *const gchar, value: *const gchar, overwrite: gboolean) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_unsetenv"]
    pub fn g_unsetenv(variable: *const gchar);
}
extern "C" {
    #[link_name = "\u{1}_g_listenv"]
    pub fn g_listenv() -> *mut *mut gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_get_environ"]
    pub fn g_get_environ() -> *mut *mut gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_environ_getenv"]
    pub fn g_environ_getenv(envp: *mut *mut gchar, variable: *const gchar) -> *const gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_environ_setenv"]
    pub fn g_environ_setenv(
        envp: *mut *mut gchar,
        variable: *const gchar,
        value: *const gchar,
        overwrite: gboolean,
    ) -> *mut *mut gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_environ_unsetenv"]
    pub fn g_environ_unsetenv(envp: *mut *mut gchar, variable: *const gchar) -> *mut *mut gchar;
}
pub const GFileError_G_FILE_ERROR_EXIST: GFileError = 0;
pub const GFileError_G_FILE_ERROR_ISDIR: GFileError = 1;
pub const GFileError_G_FILE_ERROR_ACCES: GFileError = 2;
pub const GFileError_G_FILE_ERROR_NAMETOOLONG: GFileError = 3;
pub const GFileError_G_FILE_ERROR_NOENT: GFileError = 4;
pub const GFileError_G_FILE_ERROR_NOTDIR: GFileError = 5;
pub const GFileError_G_FILE_ERROR_NXIO: GFileError = 6;
pub const GFileError_G_FILE_ERROR_NODEV: GFileError = 7;
pub const GFileError_G_FILE_ERROR_ROFS: GFileError = 8;
pub const GFileError_G_FILE_ERROR_TXTBSY: GFileError = 9;
pub const GFileError_G_FILE_ERROR_FAULT: GFileError = 10;
pub const GFileError_G_FILE_ERROR_LOOP: GFileError = 11;
pub const GFileError_G_FILE_ERROR_NOSPC: GFileError = 12;
pub const GFileError_G_FILE_ERROR_NOMEM: GFileError = 13;
pub const GFileError_G_FILE_ERROR_MFILE: GFileError = 14;
pub const GFileError_G_FILE_ERROR_NFILE: GFileError = 15;
pub const GFileError_G_FILE_ERROR_BADF: GFileError = 16;
pub const GFileError_G_FILE_ERROR_INVAL: GFileError = 17;
pub const GFileError_G_FILE_ERROR_PIPE: GFileError = 18;
pub const GFileError_G_FILE_ERROR_AGAIN: GFileError = 19;
pub const GFileError_G_FILE_ERROR_INTR: GFileError = 20;
pub const GFileError_G_FILE_ERROR_IO: GFileError = 21;
pub const GFileError_G_FILE_ERROR_PERM: GFileError = 22;
pub const GFileError_G_FILE_ERROR_NOSYS: GFileError = 23;
pub const GFileError_G_FILE_ERROR_FAILED: GFileError = 24;
pub type GFileError = u32;
pub const GFileTest_G_FILE_TEST_IS_REGULAR: GFileTest = 1;
pub const GFileTest_G_FILE_TEST_IS_SYMLINK: GFileTest = 2;
pub const GFileTest_G_FILE_TEST_IS_DIR: GFileTest = 4;
pub const GFileTest_G_FILE_TEST_IS_EXECUTABLE: GFileTest = 8;
pub const GFileTest_G_FILE_TEST_EXISTS: GFileTest = 16;
pub type GFileTest = u32;
extern "C" {
    #[link_name = "\u{1}_g_file_error_quark"]
    pub fn g_file_error_quark() -> GQuark;
}
extern "C" {
    #[link_name = "\u{1}_g_file_error_from_errno"]
    pub fn g_file_error_from_errno(err_no: gint) -> GFileError;
}
extern "C" {
    #[link_name = "\u{1}_g_file_test"]
    pub fn g_file_test(filename: *const gchar, test: GFileTest) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_file_get_contents"]
    pub fn g_file_get_contents(
        filename: *const gchar,
        contents: *mut *mut gchar,
        length: *mut gsize,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_file_set_contents"]
    pub fn g_file_set_contents(
        filename: *const gchar,
        contents: *const gchar,
        length: gssize,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_file_read_link"]
    pub fn g_file_read_link(filename: *const gchar, error: *mut *mut GError) -> *mut gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_mkdtemp"]
    pub fn g_mkdtemp(tmpl: *mut gchar) -> *mut gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_mkdtemp_full"]
    pub fn g_mkdtemp_full(tmpl: *mut gchar, mode: gint) -> *mut gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_mkstemp"]
    pub fn g_mkstemp(tmpl: *mut gchar) -> gint;
}
extern "C" {
    #[link_name = "\u{1}_g_mkstemp_full"]
    pub fn g_mkstemp_full(tmpl: *mut gchar, flags: gint, mode: gint) -> gint;
}
extern "C" {
    #[link_name = "\u{1}_g_file_open_tmp"]
    pub fn g_file_open_tmp(
        tmpl: *const gchar,
        name_used: *mut *mut gchar,
        error: *mut *mut GError,
    ) -> gint;
}
extern "C" {
    #[link_name = "\u{1}_g_dir_make_tmp"]
    pub fn g_dir_make_tmp(tmpl: *const gchar, error: *mut *mut GError) -> *mut gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_build_path"]
    pub fn g_build_path(separator: *const gchar, first_element: *const gchar, ...) -> *mut gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_build_pathv"]
    pub fn g_build_pathv(separator: *const gchar, args: *mut *mut gchar) -> *mut gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_build_filename"]
    pub fn g_build_filename(first_element: *const gchar, ...) -> *mut gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_build_filenamev"]
    pub fn g_build_filenamev(args: *mut *mut gchar) -> *mut gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_mkdir_with_parents"]
    pub fn g_mkdir_with_parents(pathname: *const gchar, mode: gint) -> gint;
}
extern "C" {
    #[link_name = "\u{1}_g_path_is_absolute"]
    pub fn g_path_is_absolute(file_name: *const gchar) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_path_skip_root"]
    pub fn g_path_skip_root(file_name: *const gchar) -> *const gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_basename"]
    pub fn g_basename(file_name: *const gchar) -> *const gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_get_current_dir"]
    pub fn g_get_current_dir() -> *mut gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_path_get_basename"]
    pub fn g_path_get_basename(file_name: *const gchar) -> *mut gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_path_get_dirname"]
    pub fn g_path_get_dirname(file_name: *const gchar) -> *mut gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_strip_context"]
    pub fn g_strip_context(msgid: *const gchar, msgval: *const gchar) -> *const gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_dgettext"]
    pub fn g_dgettext(domain: *const gchar, msgid: *const gchar) -> *const gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_dcgettext"]
    pub fn g_dcgettext(domain: *const gchar, msgid: *const gchar, category: gint) -> *const gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_dngettext"]
    pub fn g_dngettext(
        domain: *const gchar,
        msgid: *const gchar,
        msgid_plural: *const gchar,
        n: gulong,
    ) -> *const gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_dpgettext"]
    pub fn g_dpgettext(
        domain: *const gchar,
        msgctxtid: *const gchar,
        msgidoffset: gsize,
    ) -> *const gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_dpgettext2"]
    pub fn g_dpgettext2(
        domain: *const gchar,
        context: *const gchar,
        msgid: *const gchar,
    ) -> *const gchar;
}
/// GMemVTable:
/// @malloc: function to use for allocating memory.
/// @realloc: function to use for reallocating memory.
/// @free: function to use to free memory.
/// @calloc: function to use for allocating zero-filled memory.
/// @try_malloc: function to use for allocating memory without a default error handler.
/// @try_realloc: function to use for reallocating memory without a default error handler.
///
/// A set of functions used to perform memory allocation. The same #GMemVTable must
/// be used for all allocations in the same program; a call to g_mem_set_vtable(),
/// if it exists, should be prior to any use of GLib.
///
/// This functions related to this has been deprecated in 2.46, and no longer work.
pub type GMemVTable = _GMemVTable;
extern "C" {
    #[link_name = "\u{1}_g_free"]
    pub fn g_free(mem: gpointer);
}
extern "C" {
    #[link_name = "\u{1}_g_clear_pointer"]
    pub fn g_clear_pointer(pp: *mut gpointer, destroy: GDestroyNotify);
}
extern "C" {
    #[link_name = "\u{1}_g_malloc"]
    pub fn g_malloc(n_bytes: gsize) -> gpointer;
}
extern "C" {
    #[link_name = "\u{1}_g_malloc0"]
    pub fn g_malloc0(n_bytes: gsize) -> gpointer;
}
extern "C" {
    #[link_name = "\u{1}_g_realloc"]
    pub fn g_realloc(mem: gpointer, n_bytes: gsize) -> gpointer;
}
extern "C" {
    #[link_name = "\u{1}_g_try_malloc"]
    pub fn g_try_malloc(n_bytes: gsize) -> gpointer;
}
extern "C" {
    #[link_name = "\u{1}_g_try_malloc0"]
    pub fn g_try_malloc0(n_bytes: gsize) -> gpointer;
}
extern "C" {
    #[link_name = "\u{1}_g_try_realloc"]
    pub fn g_try_realloc(mem: gpointer, n_bytes: gsize) -> gpointer;
}
extern "C" {
    #[link_name = "\u{1}_g_malloc_n"]
    pub fn g_malloc_n(n_blocks: gsize, n_block_bytes: gsize) -> gpointer;
}
extern "C" {
    #[link_name = "\u{1}_g_malloc0_n"]
    pub fn g_malloc0_n(n_blocks: gsize, n_block_bytes: gsize) -> gpointer;
}
extern "C" {
    #[link_name = "\u{1}_g_realloc_n"]
    pub fn g_realloc_n(mem: gpointer, n_blocks: gsize, n_block_bytes: gsize) -> gpointer;
}
extern "C" {
    #[link_name = "\u{1}_g_try_malloc_n"]
    pub fn g_try_malloc_n(n_blocks: gsize, n_block_bytes: gsize) -> gpointer;
}
extern "C" {
    #[link_name = "\u{1}_g_try_malloc0_n"]
    pub fn g_try_malloc0_n(n_blocks: gsize, n_block_bytes: gsize) -> gpointer;
}
extern "C" {
    #[link_name = "\u{1}_g_try_realloc_n"]
    pub fn g_try_realloc_n(mem: gpointer, n_blocks: gsize, n_block_bytes: gsize) -> gpointer;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GMemVTable {
    pub malloc: ::std::option::Option<unsafe extern "C" fn(n_bytes: gsize) -> gpointer>,
    pub realloc:
        ::std::option::Option<unsafe extern "C" fn(mem: gpointer, n_bytes: gsize) -> gpointer>,
    pub free: ::std::option::Option<unsafe extern "C" fn(mem: gpointer)>,
    pub calloc: ::std::option::Option<
        unsafe extern "C" fn(n_blocks: gsize, n_block_bytes: gsize) -> gpointer,
    >,
    pub try_malloc: ::std::option::Option<unsafe extern "C" fn(n_bytes: gsize) -> gpointer>,
    pub try_realloc:
        ::std::option::Option<unsafe extern "C" fn(mem: gpointer, n_bytes: gsize) -> gpointer>,
}
#[test]
fn bindgen_test_layout__GMemVTable() {
    assert_eq!(
        ::std::mem::size_of::<_GMemVTable>(),
        48usize,
        concat!("Size of: ", stringify!(_GMemVTable))
    );
    assert_eq!(
        ::std::mem::align_of::<_GMemVTable>(),
        8usize,
        concat!("Alignment of ", stringify!(_GMemVTable))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GMemVTable>())).malloc as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMemVTable),
            "::",
            stringify!(malloc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GMemVTable>())).realloc as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMemVTable),
            "::",
            stringify!(realloc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GMemVTable>())).free as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMemVTable),
            "::",
            stringify!(free)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GMemVTable>())).calloc as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMemVTable),
            "::",
            stringify!(calloc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GMemVTable>())).try_malloc as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMemVTable),
            "::",
            stringify!(try_malloc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GMemVTable>())).try_realloc as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMemVTable),
            "::",
            stringify!(try_realloc)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_g_mem_set_vtable"]
    pub fn g_mem_set_vtable(vtable: *mut GMemVTable);
}
extern "C" {
    #[link_name = "\u{1}_g_mem_is_system_malloc"]
    pub fn g_mem_is_system_malloc() -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_mem_gc_friendly"]
    pub static mut g_mem_gc_friendly: gboolean;
}
extern "C" {
    #[link_name = "\u{1}_glib_mem_profiler_table"]
    pub static mut glib_mem_profiler_table: *mut GMemVTable;
}
extern "C" {
    #[link_name = "\u{1}_g_mem_profile"]
    pub fn g_mem_profile();
}
pub type GNode = _GNode;
pub const GTraverseFlags_G_TRAVERSE_LEAVES: GTraverseFlags = 1;
pub const GTraverseFlags_G_TRAVERSE_NON_LEAVES: GTraverseFlags = 2;
pub const GTraverseFlags_G_TRAVERSE_ALL: GTraverseFlags = 3;
pub const GTraverseFlags_G_TRAVERSE_MASK: GTraverseFlags = 3;
pub const GTraverseFlags_G_TRAVERSE_LEAFS: GTraverseFlags = 1;
pub const GTraverseFlags_G_TRAVERSE_NON_LEAFS: GTraverseFlags = 2;
pub type GTraverseFlags = u32;
pub const GTraverseType_G_IN_ORDER: GTraverseType = 0;
pub const GTraverseType_G_PRE_ORDER: GTraverseType = 1;
pub const GTraverseType_G_POST_ORDER: GTraverseType = 2;
pub const GTraverseType_G_LEVEL_ORDER: GTraverseType = 3;
pub type GTraverseType = u32;
pub type GNodeTraverseFunc =
    ::std::option::Option<unsafe extern "C" fn(node: *mut GNode, data: gpointer) -> gboolean>;
pub type GNodeForeachFunc =
    ::std::option::Option<unsafe extern "C" fn(node: *mut GNode, data: gpointer)>;
/// GCopyFunc:
/// @src: (not nullable): A pointer to the data which should be copied
/// @data: Additional data
///
/// A function of this signature is used to copy the node data
/// when doing a deep-copy of a tree.
///
/// Returns: (not nullable): A pointer to the copy
///
/// Since: 2.4
pub type GCopyFunc =
    ::std::option::Option<unsafe extern "C" fn(src: gconstpointer, data: gpointer) -> gpointer>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GNode {
    pub data: gpointer,
    pub next: *mut GNode,
    pub prev: *mut GNode,
    pub parent: *mut GNode,
    pub children: *mut GNode,
}
#[test]
fn bindgen_test_layout__GNode() {
    assert_eq!(
        ::std::mem::size_of::<_GNode>(),
        40usize,
        concat!("Size of: ", stringify!(_GNode))
    );
    assert_eq!(
        ::std::mem::align_of::<_GNode>(),
        8usize,
        concat!("Alignment of ", stringify!(_GNode))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GNode>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GNode),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GNode>())).next as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GNode),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GNode>())).prev as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GNode),
            "::",
            stringify!(prev)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GNode>())).parent as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GNode),
            "::",
            stringify!(parent)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GNode>())).children as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_GNode),
            "::",
            stringify!(children)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_g_node_new"]
    pub fn g_node_new(data: gpointer) -> *mut GNode;
}
extern "C" {
    #[link_name = "\u{1}_g_node_destroy"]
    pub fn g_node_destroy(root: *mut GNode);
}
extern "C" {
    #[link_name = "\u{1}_g_node_unlink"]
    pub fn g_node_unlink(node: *mut GNode);
}
extern "C" {
    #[link_name = "\u{1}_g_node_copy_deep"]
    pub fn g_node_copy_deep(node: *mut GNode, copy_func: GCopyFunc, data: gpointer) -> *mut GNode;
}
extern "C" {
    #[link_name = "\u{1}_g_node_copy"]
    pub fn g_node_copy(node: *mut GNode) -> *mut GNode;
}
extern "C" {
    #[link_name = "\u{1}_g_node_insert"]
    pub fn g_node_insert(parent: *mut GNode, position: gint, node: *mut GNode) -> *mut GNode;
}
extern "C" {
    #[link_name = "\u{1}_g_node_insert_before"]
    pub fn g_node_insert_before(
        parent: *mut GNode,
        sibling: *mut GNode,
        node: *mut GNode,
    ) -> *mut GNode;
}
extern "C" {
    #[link_name = "\u{1}_g_node_insert_after"]
    pub fn g_node_insert_after(
        parent: *mut GNode,
        sibling: *mut GNode,
        node: *mut GNode,
    ) -> *mut GNode;
}
extern "C" {
    #[link_name = "\u{1}_g_node_prepend"]
    pub fn g_node_prepend(parent: *mut GNode, node: *mut GNode) -> *mut GNode;
}
extern "C" {
    #[link_name = "\u{1}_g_node_n_nodes"]
    pub fn g_node_n_nodes(root: *mut GNode, flags: GTraverseFlags) -> guint;
}
extern "C" {
    #[link_name = "\u{1}_g_node_get_root"]
    pub fn g_node_get_root(node: *mut GNode) -> *mut GNode;
}
extern "C" {
    #[link_name = "\u{1}_g_node_is_ancestor"]
    pub fn g_node_is_ancestor(node: *mut GNode, descendant: *mut GNode) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_node_depth"]
    pub fn g_node_depth(node: *mut GNode) -> guint;
}
extern "C" {
    #[link_name = "\u{1}_g_node_find"]
    pub fn g_node_find(
        root: *mut GNode,
        order: GTraverseType,
        flags: GTraverseFlags,
        data: gpointer,
    ) -> *mut GNode;
}
extern "C" {
    #[link_name = "\u{1}_g_node_traverse"]
    pub fn g_node_traverse(
        root: *mut GNode,
        order: GTraverseType,
        flags: GTraverseFlags,
        max_depth: gint,
        func: GNodeTraverseFunc,
        data: gpointer,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_node_max_height"]
    pub fn g_node_max_height(root: *mut GNode) -> guint;
}
extern "C" {
    #[link_name = "\u{1}_g_node_children_foreach"]
    pub fn g_node_children_foreach(
        node: *mut GNode,
        flags: GTraverseFlags,
        func: GNodeForeachFunc,
        data: gpointer,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_node_reverse_children"]
    pub fn g_node_reverse_children(node: *mut GNode);
}
extern "C" {
    #[link_name = "\u{1}_g_node_n_children"]
    pub fn g_node_n_children(node: *mut GNode) -> guint;
}
extern "C" {
    #[link_name = "\u{1}_g_node_nth_child"]
    pub fn g_node_nth_child(node: *mut GNode, n: guint) -> *mut GNode;
}
extern "C" {
    #[link_name = "\u{1}_g_node_last_child"]
    pub fn g_node_last_child(node: *mut GNode) -> *mut GNode;
}
extern "C" {
    #[link_name = "\u{1}_g_node_find_child"]
    pub fn g_node_find_child(node: *mut GNode, flags: GTraverseFlags, data: gpointer)
        -> *mut GNode;
}
extern "C" {
    #[link_name = "\u{1}_g_node_child_position"]
    pub fn g_node_child_position(node: *mut GNode, child: *mut GNode) -> gint;
}
extern "C" {
    #[link_name = "\u{1}_g_node_child_index"]
    pub fn g_node_child_index(node: *mut GNode, data: gpointer) -> gint;
}
extern "C" {
    #[link_name = "\u{1}_g_node_first_sibling"]
    pub fn g_node_first_sibling(node: *mut GNode) -> *mut GNode;
}
extern "C" {
    #[link_name = "\u{1}_g_node_last_sibling"]
    pub fn g_node_last_sibling(node: *mut GNode) -> *mut GNode;
}
pub type GList = _GList;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GList {
    pub data: gpointer,
    pub next: *mut GList,
    pub prev: *mut GList,
}
#[test]
fn bindgen_test_layout__GList() {
    assert_eq!(
        ::std::mem::size_of::<_GList>(),
        24usize,
        concat!("Size of: ", stringify!(_GList))
    );
    assert_eq!(
        ::std::mem::align_of::<_GList>(),
        8usize,
        concat!("Alignment of ", stringify!(_GList))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GList>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GList),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GList>())).next as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GList),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GList>())).prev as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GList),
            "::",
            stringify!(prev)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_g_list_alloc"]
    pub fn g_list_alloc() -> *mut GList;
}
extern "C" {
    #[link_name = "\u{1}_g_list_free"]
    pub fn g_list_free(list: *mut GList);
}
extern "C" {
    #[link_name = "\u{1}_g_list_free_1"]
    pub fn g_list_free_1(list: *mut GList);
}
extern "C" {
    #[link_name = "\u{1}_g_list_free_full"]
    pub fn g_list_free_full(list: *mut GList, free_func: GDestroyNotify);
}
extern "C" {
    #[link_name = "\u{1}_g_list_append"]
    pub fn g_list_append(list: *mut GList, data: gpointer) -> *mut GList;
}
extern "C" {
    #[link_name = "\u{1}_g_list_prepend"]
    pub fn g_list_prepend(list: *mut GList, data: gpointer) -> *mut GList;
}
extern "C" {
    #[link_name = "\u{1}_g_list_insert"]
    pub fn g_list_insert(list: *mut GList, data: gpointer, position: gint) -> *mut GList;
}
extern "C" {
    #[link_name = "\u{1}_g_list_insert_sorted"]
    pub fn g_list_insert_sorted(list: *mut GList, data: gpointer, func: GCompareFunc)
        -> *mut GList;
}
extern "C" {
    #[link_name = "\u{1}_g_list_insert_sorted_with_data"]
    pub fn g_list_insert_sorted_with_data(
        list: *mut GList,
        data: gpointer,
        func: GCompareDataFunc,
        user_data: gpointer,
    ) -> *mut GList;
}
extern "C" {
    #[link_name = "\u{1}_g_list_insert_before"]
    pub fn g_list_insert_before(
        list: *mut GList,
        sibling: *mut GList,
        data: gpointer,
    ) -> *mut GList;
}
extern "C" {
    #[link_name = "\u{1}_g_list_concat"]
    pub fn g_list_concat(list1: *mut GList, list2: *mut GList) -> *mut GList;
}
extern "C" {
    #[link_name = "\u{1}_g_list_remove"]
    pub fn g_list_remove(list: *mut GList, data: gconstpointer) -> *mut GList;
}
extern "C" {
    #[link_name = "\u{1}_g_list_remove_all"]
    pub fn g_list_remove_all(list: *mut GList, data: gconstpointer) -> *mut GList;
}
extern "C" {
    #[link_name = "\u{1}_g_list_remove_link"]
    pub fn g_list_remove_link(list: *mut GList, llink: *mut GList) -> *mut GList;
}
extern "C" {
    #[link_name = "\u{1}_g_list_delete_link"]
    pub fn g_list_delete_link(list: *mut GList, link_: *mut GList) -> *mut GList;
}
extern "C" {
    #[link_name = "\u{1}_g_list_reverse"]
    pub fn g_list_reverse(list: *mut GList) -> *mut GList;
}
extern "C" {
    #[link_name = "\u{1}_g_list_copy"]
    pub fn g_list_copy(list: *mut GList) -> *mut GList;
}
extern "C" {
    #[link_name = "\u{1}_g_list_copy_deep"]
    pub fn g_list_copy_deep(list: *mut GList, func: GCopyFunc, user_data: gpointer) -> *mut GList;
}
extern "C" {
    #[link_name = "\u{1}_g_list_nth"]
    pub fn g_list_nth(list: *mut GList, n: guint) -> *mut GList;
}
extern "C" {
    #[link_name = "\u{1}_g_list_nth_prev"]
    pub fn g_list_nth_prev(list: *mut GList, n: guint) -> *mut GList;
}
extern "C" {
    #[link_name = "\u{1}_g_list_find"]
    pub fn g_list_find(list: *mut GList, data: gconstpointer) -> *mut GList;
}
extern "C" {
    #[link_name = "\u{1}_g_list_find_custom"]
    pub fn g_list_find_custom(
        list: *mut GList,
        data: gconstpointer,
        func: GCompareFunc,
    ) -> *mut GList;
}
extern "C" {
    #[link_name = "\u{1}_g_list_position"]
    pub fn g_list_position(list: *mut GList, llink: *mut GList) -> gint;
}
extern "C" {
    #[link_name = "\u{1}_g_list_index"]
    pub fn g_list_index(list: *mut GList, data: gconstpointer) -> gint;
}
extern "C" {
    #[link_name = "\u{1}_g_list_last"]
    pub fn g_list_last(list: *mut GList) -> *mut GList;
}
extern "C" {
    #[link_name = "\u{1}_g_list_first"]
    pub fn g_list_first(list: *mut GList) -> *mut GList;
}
extern "C" {
    #[link_name = "\u{1}_g_list_length"]
    pub fn g_list_length(list: *mut GList) -> guint;
}
extern "C" {
    #[link_name = "\u{1}_g_list_foreach"]
    pub fn g_list_foreach(list: *mut GList, func: GFunc, user_data: gpointer);
}
extern "C" {
    #[link_name = "\u{1}_g_list_sort"]
    pub fn g_list_sort(list: *mut GList, compare_func: GCompareFunc) -> *mut GList;
}
extern "C" {
    #[link_name = "\u{1}_g_list_sort_with_data"]
    pub fn g_list_sort_with_data(
        list: *mut GList,
        compare_func: GCompareDataFunc,
        user_data: gpointer,
    ) -> *mut GList;
}
extern "C" {
    #[link_name = "\u{1}_g_list_nth_data"]
    pub fn g_list_nth_data(list: *mut GList, n: guint) -> gpointer;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GHashTable {
    _unused: [u8; 0],
}
pub type GHashTable = _GHashTable;
pub type GHRFunc = ::std::option::Option<
    unsafe extern "C" fn(key: gpointer, value: gpointer, user_data: gpointer) -> gboolean,
>;
pub type GHashTableIter = _GHashTableIter;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GHashTableIter {
    pub dummy1: gpointer,
    pub dummy2: gpointer,
    pub dummy3: gpointer,
    pub dummy4: ::std::os::raw::c_int,
    pub dummy5: gboolean,
    pub dummy6: gpointer,
}
#[test]
fn bindgen_test_layout__GHashTableIter() {
    assert_eq!(
        ::std::mem::size_of::<_GHashTableIter>(),
        40usize,
        concat!("Size of: ", stringify!(_GHashTableIter))
    );
    assert_eq!(
        ::std::mem::align_of::<_GHashTableIter>(),
        8usize,
        concat!("Alignment of ", stringify!(_GHashTableIter))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GHashTableIter>())).dummy1 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GHashTableIter),
            "::",
            stringify!(dummy1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GHashTableIter>())).dummy2 as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GHashTableIter),
            "::",
            stringify!(dummy2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GHashTableIter>())).dummy3 as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GHashTableIter),
            "::",
            stringify!(dummy3)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GHashTableIter>())).dummy4 as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GHashTableIter),
            "::",
            stringify!(dummy4)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GHashTableIter>())).dummy5 as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_GHashTableIter),
            "::",
            stringify!(dummy5)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GHashTableIter>())).dummy6 as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_GHashTableIter),
            "::",
            stringify!(dummy6)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_g_hash_table_new"]
    pub fn g_hash_table_new(hash_func: GHashFunc, key_equal_func: GEqualFunc) -> *mut GHashTable;
}
extern "C" {
    #[link_name = "\u{1}_g_hash_table_new_full"]
    pub fn g_hash_table_new_full(
        hash_func: GHashFunc,
        key_equal_func: GEqualFunc,
        key_destroy_func: GDestroyNotify,
        value_destroy_func: GDestroyNotify,
    ) -> *mut GHashTable;
}
extern "C" {
    #[link_name = "\u{1}_g_hash_table_destroy"]
    pub fn g_hash_table_destroy(hash_table: *mut GHashTable);
}
extern "C" {
    #[link_name = "\u{1}_g_hash_table_insert"]
    pub fn g_hash_table_insert(
        hash_table: *mut GHashTable,
        key: gpointer,
        value: gpointer,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_hash_table_replace"]
    pub fn g_hash_table_replace(
        hash_table: *mut GHashTable,
        key: gpointer,
        value: gpointer,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_hash_table_add"]
    pub fn g_hash_table_add(hash_table: *mut GHashTable, key: gpointer) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_hash_table_remove"]
    pub fn g_hash_table_remove(hash_table: *mut GHashTable, key: gconstpointer) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_hash_table_remove_all"]
    pub fn g_hash_table_remove_all(hash_table: *mut GHashTable);
}
extern "C" {
    #[link_name = "\u{1}_g_hash_table_steal"]
    pub fn g_hash_table_steal(hash_table: *mut GHashTable, key: gconstpointer) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_hash_table_steal_all"]
    pub fn g_hash_table_steal_all(hash_table: *mut GHashTable);
}
extern "C" {
    #[link_name = "\u{1}_g_hash_table_lookup"]
    pub fn g_hash_table_lookup(hash_table: *mut GHashTable, key: gconstpointer) -> gpointer;
}
extern "C" {
    #[link_name = "\u{1}_g_hash_table_contains"]
    pub fn g_hash_table_contains(hash_table: *mut GHashTable, key: gconstpointer) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_hash_table_lookup_extended"]
    pub fn g_hash_table_lookup_extended(
        hash_table: *mut GHashTable,
        lookup_key: gconstpointer,
        orig_key: *mut gpointer,
        value: *mut gpointer,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_hash_table_foreach"]
    pub fn g_hash_table_foreach(hash_table: *mut GHashTable, func: GHFunc, user_data: gpointer);
}
extern "C" {
    #[link_name = "\u{1}_g_hash_table_find"]
    pub fn g_hash_table_find(
        hash_table: *mut GHashTable,
        predicate: GHRFunc,
        user_data: gpointer,
    ) -> gpointer;
}
extern "C" {
    #[link_name = "\u{1}_g_hash_table_foreach_remove"]
    pub fn g_hash_table_foreach_remove(
        hash_table: *mut GHashTable,
        func: GHRFunc,
        user_data: gpointer,
    ) -> guint;
}
extern "C" {
    #[link_name = "\u{1}_g_hash_table_foreach_steal"]
    pub fn g_hash_table_foreach_steal(
        hash_table: *mut GHashTable,
        func: GHRFunc,
        user_data: gpointer,
    ) -> guint;
}
extern "C" {
    #[link_name = "\u{1}_g_hash_table_size"]
    pub fn g_hash_table_size(hash_table: *mut GHashTable) -> guint;
}
extern "C" {
    #[link_name = "\u{1}_g_hash_table_get_keys"]
    pub fn g_hash_table_get_keys(hash_table: *mut GHashTable) -> *mut GList;
}
extern "C" {
    #[link_name = "\u{1}_g_hash_table_get_values"]
    pub fn g_hash_table_get_values(hash_table: *mut GHashTable) -> *mut GList;
}
extern "C" {
    #[link_name = "\u{1}_g_hash_table_get_keys_as_array"]
    pub fn g_hash_table_get_keys_as_array(
        hash_table: *mut GHashTable,
        length: *mut guint,
    ) -> *mut gpointer;
}
extern "C" {
    #[link_name = "\u{1}_g_hash_table_iter_init"]
    pub fn g_hash_table_iter_init(iter: *mut GHashTableIter, hash_table: *mut GHashTable);
}
extern "C" {
    #[link_name = "\u{1}_g_hash_table_iter_next"]
    pub fn g_hash_table_iter_next(
        iter: *mut GHashTableIter,
        key: *mut gpointer,
        value: *mut gpointer,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_hash_table_iter_get_hash_table"]
    pub fn g_hash_table_iter_get_hash_table(iter: *mut GHashTableIter) -> *mut GHashTable;
}
extern "C" {
    #[link_name = "\u{1}_g_hash_table_iter_remove"]
    pub fn g_hash_table_iter_remove(iter: *mut GHashTableIter);
}
extern "C" {
    #[link_name = "\u{1}_g_hash_table_iter_replace"]
    pub fn g_hash_table_iter_replace(iter: *mut GHashTableIter, value: gpointer);
}
extern "C" {
    #[link_name = "\u{1}_g_hash_table_iter_steal"]
    pub fn g_hash_table_iter_steal(iter: *mut GHashTableIter);
}
extern "C" {
    #[link_name = "\u{1}_g_hash_table_ref"]
    pub fn g_hash_table_ref(hash_table: *mut GHashTable) -> *mut GHashTable;
}
extern "C" {
    #[link_name = "\u{1}_g_hash_table_unref"]
    pub fn g_hash_table_unref(hash_table: *mut GHashTable);
}
extern "C" {
    #[link_name = "\u{1}_g_str_equal"]
    pub fn g_str_equal(v1: gconstpointer, v2: gconstpointer) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_str_hash"]
    pub fn g_str_hash(v: gconstpointer) -> guint;
}
extern "C" {
    #[link_name = "\u{1}_g_int_equal"]
    pub fn g_int_equal(v1: gconstpointer, v2: gconstpointer) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_int_hash"]
    pub fn g_int_hash(v: gconstpointer) -> guint;
}
extern "C" {
    #[link_name = "\u{1}_g_int64_equal"]
    pub fn g_int64_equal(v1: gconstpointer, v2: gconstpointer) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_int64_hash"]
    pub fn g_int64_hash(v: gconstpointer) -> guint;
}
extern "C" {
    #[link_name = "\u{1}_g_double_equal"]
    pub fn g_double_equal(v1: gconstpointer, v2: gconstpointer) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_double_hash"]
    pub fn g_double_hash(v: gconstpointer) -> guint;
}
extern "C" {
    #[link_name = "\u{1}_g_direct_hash"]
    pub fn g_direct_hash(v: gconstpointer) -> guint;
}
extern "C" {
    #[link_name = "\u{1}_g_direct_equal"]
    pub fn g_direct_equal(v1: gconstpointer, v2: gconstpointer) -> gboolean;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GHmac {
    _unused: [u8; 0],
}
/// GHmac:
///
/// An opaque structure representing a HMAC operation.
/// To create a new GHmac, use g_hmac_new(). To free
/// a GHmac, use g_hmac_unref().
///
/// Since: 2.30
pub type GHmac = _GHmac;
extern "C" {
    #[link_name = "\u{1}_g_hmac_new"]
    pub fn g_hmac_new(digest_type: GChecksumType, key: *const guchar, key_len: gsize)
        -> *mut GHmac;
}
extern "C" {
    #[link_name = "\u{1}_g_hmac_copy"]
    pub fn g_hmac_copy(hmac: *const GHmac) -> *mut GHmac;
}
extern "C" {
    #[link_name = "\u{1}_g_hmac_ref"]
    pub fn g_hmac_ref(hmac: *mut GHmac) -> *mut GHmac;
}
extern "C" {
    #[link_name = "\u{1}_g_hmac_unref"]
    pub fn g_hmac_unref(hmac: *mut GHmac);
}
extern "C" {
    #[link_name = "\u{1}_g_hmac_update"]
    pub fn g_hmac_update(hmac: *mut GHmac, data: *const guchar, length: gssize);
}
extern "C" {
    #[link_name = "\u{1}_g_hmac_get_string"]
    pub fn g_hmac_get_string(hmac: *mut GHmac) -> *const gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_hmac_get_digest"]
    pub fn g_hmac_get_digest(hmac: *mut GHmac, buffer: *mut guint8, digest_len: *mut gsize);
}
extern "C" {
    #[link_name = "\u{1}_g_compute_hmac_for_data"]
    pub fn g_compute_hmac_for_data(
        digest_type: GChecksumType,
        key: *const guchar,
        key_len: gsize,
        data: *const guchar,
        length: gsize,
    ) -> *mut gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_compute_hmac_for_string"]
    pub fn g_compute_hmac_for_string(
        digest_type: GChecksumType,
        key: *const guchar,
        key_len: gsize,
        str: *const gchar,
        length: gssize,
    ) -> *mut gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_compute_hmac_for_bytes"]
    pub fn g_compute_hmac_for_bytes(
        digest_type: GChecksumType,
        key: *mut GBytes,
        data: *mut GBytes,
    ) -> *mut gchar;
}
pub type GHook = _GHook;
pub type GHookList = _GHookList;
pub type GHookCompareFunc =
    ::std::option::Option<unsafe extern "C" fn(new_hook: *mut GHook, sibling: *mut GHook) -> gint>;
pub type GHookFindFunc =
    ::std::option::Option<unsafe extern "C" fn(hook: *mut GHook, data: gpointer) -> gboolean>;
pub type GHookMarshaller =
    ::std::option::Option<unsafe extern "C" fn(hook: *mut GHook, marshal_data: gpointer)>;
pub type GHookCheckMarshaller = ::std::option::Option<
    unsafe extern "C" fn(hook: *mut GHook, marshal_data: gpointer) -> gboolean,
>;
pub type GHookFunc = ::std::option::Option<unsafe extern "C" fn(data: gpointer)>;
pub type GHookCheckFunc = ::std::option::Option<unsafe extern "C" fn(data: gpointer) -> gboolean>;
pub type GHookFinalizeFunc =
    ::std::option::Option<unsafe extern "C" fn(hook_list: *mut GHookList, hook: *mut GHook)>;
pub const GHookFlagMask_G_HOOK_FLAG_ACTIVE: GHookFlagMask = 1;
pub const GHookFlagMask_G_HOOK_FLAG_IN_CALL: GHookFlagMask = 2;
pub const GHookFlagMask_G_HOOK_FLAG_MASK: GHookFlagMask = 15;
pub type GHookFlagMask = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GHookList {
    pub seq_id: gulong,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u16>,
    pub hooks: *mut GHook,
    pub dummy3: gpointer,
    pub finalize_hook: GHookFinalizeFunc,
    pub dummy: [gpointer; 2usize],
}
#[test]
fn bindgen_test_layout__GHookList() {
    assert_eq!(
        ::std::mem::size_of::<_GHookList>(),
        56usize,
        concat!("Size of: ", stringify!(_GHookList))
    );
    assert_eq!(
        ::std::mem::align_of::<_GHookList>(),
        8usize,
        concat!("Alignment of ", stringify!(_GHookList))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GHookList>())).seq_id as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GHookList),
            "::",
            stringify!(seq_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GHookList>())).hooks as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GHookList),
            "::",
            stringify!(hooks)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GHookList>())).dummy3 as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GHookList),
            "::",
            stringify!(dummy3)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GHookList>())).finalize_hook as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_GHookList),
            "::",
            stringify!(finalize_hook)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GHookList>())).dummy as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_GHookList),
            "::",
            stringify!(dummy)
        )
    );
}
impl _GHookList {
    #[inline]
    pub fn hook_size(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_hook_size(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn is_setup(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is_setup(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        hook_size: guint,
        is_setup: guint,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 16u8, {
            let hook_size: u32 = unsafe { ::std::mem::transmute(hook_size) };
            hook_size as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let is_setup: u32 = unsafe { ::std::mem::transmute(is_setup) };
            is_setup as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GHook {
    pub data: gpointer,
    pub next: *mut GHook,
    pub prev: *mut GHook,
    pub ref_count: guint,
    pub hook_id: gulong,
    pub flags: guint,
    pub func: gpointer,
    pub destroy: GDestroyNotify,
}
#[test]
fn bindgen_test_layout__GHook() {
    assert_eq!(
        ::std::mem::size_of::<_GHook>(),
        64usize,
        concat!("Size of: ", stringify!(_GHook))
    );
    assert_eq!(
        ::std::mem::align_of::<_GHook>(),
        8usize,
        concat!("Alignment of ", stringify!(_GHook))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GHook>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GHook),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GHook>())).next as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GHook),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GHook>())).prev as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GHook),
            "::",
            stringify!(prev)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GHook>())).ref_count as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GHook),
            "::",
            stringify!(ref_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GHook>())).hook_id as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_GHook),
            "::",
            stringify!(hook_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GHook>())).flags as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_GHook),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GHook>())).func as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_GHook),
            "::",
            stringify!(func)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GHook>())).destroy as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_GHook),
            "::",
            stringify!(destroy)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_g_hook_list_init"]
    pub fn g_hook_list_init(hook_list: *mut GHookList, hook_size: guint);
}
extern "C" {
    #[link_name = "\u{1}_g_hook_list_clear"]
    pub fn g_hook_list_clear(hook_list: *mut GHookList);
}
extern "C" {
    #[link_name = "\u{1}_g_hook_alloc"]
    pub fn g_hook_alloc(hook_list: *mut GHookList) -> *mut GHook;
}
extern "C" {
    #[link_name = "\u{1}_g_hook_free"]
    pub fn g_hook_free(hook_list: *mut GHookList, hook: *mut GHook);
}
extern "C" {
    #[link_name = "\u{1}_g_hook_ref"]
    pub fn g_hook_ref(hook_list: *mut GHookList, hook: *mut GHook) -> *mut GHook;
}
extern "C" {
    #[link_name = "\u{1}_g_hook_unref"]
    pub fn g_hook_unref(hook_list: *mut GHookList, hook: *mut GHook);
}
extern "C" {
    #[link_name = "\u{1}_g_hook_destroy"]
    pub fn g_hook_destroy(hook_list: *mut GHookList, hook_id: gulong) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_hook_destroy_link"]
    pub fn g_hook_destroy_link(hook_list: *mut GHookList, hook: *mut GHook);
}
extern "C" {
    #[link_name = "\u{1}_g_hook_prepend"]
    pub fn g_hook_prepend(hook_list: *mut GHookList, hook: *mut GHook);
}
extern "C" {
    #[link_name = "\u{1}_g_hook_insert_before"]
    pub fn g_hook_insert_before(hook_list: *mut GHookList, sibling: *mut GHook, hook: *mut GHook);
}
extern "C" {
    #[link_name = "\u{1}_g_hook_insert_sorted"]
    pub fn g_hook_insert_sorted(
        hook_list: *mut GHookList,
        hook: *mut GHook,
        func: GHookCompareFunc,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_hook_get"]
    pub fn g_hook_get(hook_list: *mut GHookList, hook_id: gulong) -> *mut GHook;
}
extern "C" {
    #[link_name = "\u{1}_g_hook_find"]
    pub fn g_hook_find(
        hook_list: *mut GHookList,
        need_valids: gboolean,
        func: GHookFindFunc,
        data: gpointer,
    ) -> *mut GHook;
}
extern "C" {
    #[link_name = "\u{1}_g_hook_find_data"]
    pub fn g_hook_find_data(
        hook_list: *mut GHookList,
        need_valids: gboolean,
        data: gpointer,
    ) -> *mut GHook;
}
extern "C" {
    #[link_name = "\u{1}_g_hook_find_func"]
    pub fn g_hook_find_func(
        hook_list: *mut GHookList,
        need_valids: gboolean,
        func: gpointer,
    ) -> *mut GHook;
}
extern "C" {
    #[link_name = "\u{1}_g_hook_find_func_data"]
    pub fn g_hook_find_func_data(
        hook_list: *mut GHookList,
        need_valids: gboolean,
        func: gpointer,
        data: gpointer,
    ) -> *mut GHook;
}
extern "C" {
    #[link_name = "\u{1}_g_hook_first_valid"]
    pub fn g_hook_first_valid(hook_list: *mut GHookList, may_be_in_call: gboolean) -> *mut GHook;
}
extern "C" {
    #[link_name = "\u{1}_g_hook_next_valid"]
    pub fn g_hook_next_valid(
        hook_list: *mut GHookList,
        hook: *mut GHook,
        may_be_in_call: gboolean,
    ) -> *mut GHook;
}
extern "C" {
    #[link_name = "\u{1}_g_hook_compare_ids"]
    pub fn g_hook_compare_ids(new_hook: *mut GHook, sibling: *mut GHook) -> gint;
}
extern "C" {
    #[link_name = "\u{1}_g_hook_list_invoke"]
    pub fn g_hook_list_invoke(hook_list: *mut GHookList, may_recurse: gboolean);
}
extern "C" {
    #[link_name = "\u{1}_g_hook_list_invoke_check"]
    pub fn g_hook_list_invoke_check(hook_list: *mut GHookList, may_recurse: gboolean);
}
extern "C" {
    #[link_name = "\u{1}_g_hook_list_marshal"]
    pub fn g_hook_list_marshal(
        hook_list: *mut GHookList,
        may_recurse: gboolean,
        marshaller: GHookMarshaller,
        marshal_data: gpointer,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_hook_list_marshal_check"]
    pub fn g_hook_list_marshal_check(
        hook_list: *mut GHookList,
        may_recurse: gboolean,
        marshaller: GHookCheckMarshaller,
        marshal_data: gpointer,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_hostname_is_non_ascii"]
    pub fn g_hostname_is_non_ascii(hostname: *const gchar) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_hostname_is_ascii_encoded"]
    pub fn g_hostname_is_ascii_encoded(hostname: *const gchar) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_hostname_is_ip_address"]
    pub fn g_hostname_is_ip_address(hostname: *const gchar) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_hostname_to_ascii"]
    pub fn g_hostname_to_ascii(hostname: *const gchar) -> *mut gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_hostname_to_unicode"]
    pub fn g_hostname_to_unicode(hostname: *const gchar) -> *mut gchar;
}
pub type GPollFD = _GPollFD;
/// GPollFunc:
/// @ufds: an array of #GPollFD elements
/// @nfsd: the number of elements in @ufds
/// @timeout_: the maximum time to wait for an event of the file descriptors.
/// A negative value indicates an infinite timeout.
///
/// Specifies the type of function passed to g_main_context_set_poll_func().
/// The semantics of the function should match those of the poll() system call.
///
/// Returns: the number of #GPollFD elements which have events or errors
/// reported, or -1 if an error occurred.
pub type GPollFunc = ::std::option::Option<
    unsafe extern "C" fn(ufds: *mut GPollFD, nfsd: guint, timeout_: gint) -> gint,
>;
/// GPollFD:
/// @fd: the file descriptor to poll (or a HANDLE on Win32)
/// @events: a bitwise combination from #GIOCondition, specifying which
/// events should be polled for. Typically for reading from a file
/// descriptor you would use %G_IO_IN | %G_IO_HUP | %G_IO_ERR, and
/// for writing you would use %G_IO_OUT | %G_IO_ERR.
/// @revents: a bitwise combination of flags from #GIOCondition, returned
/// from the poll() function to indicate which events occurred.
///
/// Represents a file descriptor, which events to poll for, and which events
/// occurred.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GPollFD {
    pub fd: gint,
    pub events: gushort,
    pub revents: gushort,
}
#[test]
fn bindgen_test_layout__GPollFD() {
    assert_eq!(
        ::std::mem::size_of::<_GPollFD>(),
        8usize,
        concat!("Size of: ", stringify!(_GPollFD))
    );
    assert_eq!(
        ::std::mem::align_of::<_GPollFD>(),
        4usize,
        concat!("Alignment of ", stringify!(_GPollFD))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GPollFD>())).fd as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GPollFD),
            "::",
            stringify!(fd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GPollFD>())).events as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_GPollFD),
            "::",
            stringify!(events)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GPollFD>())).revents as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(_GPollFD),
            "::",
            stringify!(revents)
        )
    );
}
extern "C" {
    /// G_POLLFD_FORMAT:
    ///
    /// A format specifier that can be used in printf()-style format strings
    /// when printing the @fd member of a #GPollFD.
    #[link_name = "\u{1}_g_poll"]
    pub fn g_poll(fds: *mut GPollFD, nfds: guint, timeout: gint) -> gint;
}
pub type GSList = _GSList;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GSList {
    pub data: gpointer,
    pub next: *mut GSList,
}
#[test]
fn bindgen_test_layout__GSList() {
    assert_eq!(
        ::std::mem::size_of::<_GSList>(),
        16usize,
        concat!("Size of: ", stringify!(_GSList))
    );
    assert_eq!(
        ::std::mem::align_of::<_GSList>(),
        8usize,
        concat!("Alignment of ", stringify!(_GSList))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GSList>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSList),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GSList>())).next as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSList),
            "::",
            stringify!(next)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_g_slist_alloc"]
    pub fn g_slist_alloc() -> *mut GSList;
}
extern "C" {
    #[link_name = "\u{1}_g_slist_free"]
    pub fn g_slist_free(list: *mut GSList);
}
extern "C" {
    #[link_name = "\u{1}_g_slist_free_1"]
    pub fn g_slist_free_1(list: *mut GSList);
}
extern "C" {
    #[link_name = "\u{1}_g_slist_free_full"]
    pub fn g_slist_free_full(list: *mut GSList, free_func: GDestroyNotify);
}
extern "C" {
    #[link_name = "\u{1}_g_slist_append"]
    pub fn g_slist_append(list: *mut GSList, data: gpointer) -> *mut GSList;
}
extern "C" {
    #[link_name = "\u{1}_g_slist_prepend"]
    pub fn g_slist_prepend(list: *mut GSList, data: gpointer) -> *mut GSList;
}
extern "C" {
    #[link_name = "\u{1}_g_slist_insert"]
    pub fn g_slist_insert(list: *mut GSList, data: gpointer, position: gint) -> *mut GSList;
}
extern "C" {
    #[link_name = "\u{1}_g_slist_insert_sorted"]
    pub fn g_slist_insert_sorted(
        list: *mut GSList,
        data: gpointer,
        func: GCompareFunc,
    ) -> *mut GSList;
}
extern "C" {
    #[link_name = "\u{1}_g_slist_insert_sorted_with_data"]
    pub fn g_slist_insert_sorted_with_data(
        list: *mut GSList,
        data: gpointer,
        func: GCompareDataFunc,
        user_data: gpointer,
    ) -> *mut GSList;
}
extern "C" {
    #[link_name = "\u{1}_g_slist_insert_before"]
    pub fn g_slist_insert_before(
        slist: *mut GSList,
        sibling: *mut GSList,
        data: gpointer,
    ) -> *mut GSList;
}
extern "C" {
    #[link_name = "\u{1}_g_slist_concat"]
    pub fn g_slist_concat(list1: *mut GSList, list2: *mut GSList) -> *mut GSList;
}
extern "C" {
    #[link_name = "\u{1}_g_slist_remove"]
    pub fn g_slist_remove(list: *mut GSList, data: gconstpointer) -> *mut GSList;
}
extern "C" {
    #[link_name = "\u{1}_g_slist_remove_all"]
    pub fn g_slist_remove_all(list: *mut GSList, data: gconstpointer) -> *mut GSList;
}
extern "C" {
    #[link_name = "\u{1}_g_slist_remove_link"]
    pub fn g_slist_remove_link(list: *mut GSList, link_: *mut GSList) -> *mut GSList;
}
extern "C" {
    #[link_name = "\u{1}_g_slist_delete_link"]
    pub fn g_slist_delete_link(list: *mut GSList, link_: *mut GSList) -> *mut GSList;
}
extern "C" {
    #[link_name = "\u{1}_g_slist_reverse"]
    pub fn g_slist_reverse(list: *mut GSList) -> *mut GSList;
}
extern "C" {
    #[link_name = "\u{1}_g_slist_copy"]
    pub fn g_slist_copy(list: *mut GSList) -> *mut GSList;
}
extern "C" {
    #[link_name = "\u{1}_g_slist_copy_deep"]
    pub fn g_slist_copy_deep(
        list: *mut GSList,
        func: GCopyFunc,
        user_data: gpointer,
    ) -> *mut GSList;
}
extern "C" {
    #[link_name = "\u{1}_g_slist_nth"]
    pub fn g_slist_nth(list: *mut GSList, n: guint) -> *mut GSList;
}
extern "C" {
    #[link_name = "\u{1}_g_slist_find"]
    pub fn g_slist_find(list: *mut GSList, data: gconstpointer) -> *mut GSList;
}
extern "C" {
    #[link_name = "\u{1}_g_slist_find_custom"]
    pub fn g_slist_find_custom(
        list: *mut GSList,
        data: gconstpointer,
        func: GCompareFunc,
    ) -> *mut GSList;
}
extern "C" {
    #[link_name = "\u{1}_g_slist_position"]
    pub fn g_slist_position(list: *mut GSList, llink: *mut GSList) -> gint;
}
extern "C" {
    #[link_name = "\u{1}_g_slist_index"]
    pub fn g_slist_index(list: *mut GSList, data: gconstpointer) -> gint;
}
extern "C" {
    #[link_name = "\u{1}_g_slist_last"]
    pub fn g_slist_last(list: *mut GSList) -> *mut GSList;
}
extern "C" {
    #[link_name = "\u{1}_g_slist_length"]
    pub fn g_slist_length(list: *mut GSList) -> guint;
}
extern "C" {
    #[link_name = "\u{1}_g_slist_foreach"]
    pub fn g_slist_foreach(list: *mut GSList, func: GFunc, user_data: gpointer);
}
extern "C" {
    #[link_name = "\u{1}_g_slist_sort"]
    pub fn g_slist_sort(list: *mut GSList, compare_func: GCompareFunc) -> *mut GSList;
}
extern "C" {
    #[link_name = "\u{1}_g_slist_sort_with_data"]
    pub fn g_slist_sort_with_data(
        list: *mut GSList,
        compare_func: GCompareDataFunc,
        user_data: gpointer,
    ) -> *mut GSList;
}
extern "C" {
    #[link_name = "\u{1}_g_slist_nth_data"]
    pub fn g_slist_nth_data(list: *mut GSList, n: guint) -> gpointer;
}
pub const GIOCondition_G_IO_IN: GIOCondition = 1;
pub const GIOCondition_G_IO_OUT: GIOCondition = 4;
pub const GIOCondition_G_IO_PRI: GIOCondition = 2;
pub const GIOCondition_G_IO_ERR: GIOCondition = 8;
pub const GIOCondition_G_IO_HUP: GIOCondition = 16;
pub const GIOCondition_G_IO_NVAL: GIOCondition = 32;
pub type GIOCondition = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GMainContext {
    _unused: [u8; 0],
}
/// GMainContext:
///
/// The `GMainContext` struct is an opaque data
/// type representing a set of sources to be handled in a main loop.
pub type GMainContext = _GMainContext;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GMainLoop {
    _unused: [u8; 0],
}
/// GMainLoop:
///
/// The `GMainLoop` struct is an opaque data type
/// representing the main event loop of a GLib or GTK+ application.
pub type GMainLoop = _GMainLoop;
/// GSource:
///
/// The `GSource` struct is an opaque data type
/// representing an event source.
pub type GSource = _GSource;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GSourcePrivate {
    _unused: [u8; 0],
}
pub type GSourcePrivate = _GSourcePrivate;
/// GSourceCallbackFuncs:
/// @ref: Called when a reference is added to the callback object
/// @unref: Called when a reference to the callback object is dropped
/// @get: Called to extract the callback function and data from the
/// callback object.
///
/// The `GSourceCallbackFuncs` struct contains
/// functions for managing callback objects.
pub type GSourceCallbackFuncs = _GSourceCallbackFuncs;
/// GSourceFuncs:
/// @prepare: Called before all the file descriptors are polled. If the
/// source can determine that it is ready here (without waiting for the
/// results of the poll() call) it should return %TRUE. It can also return
/// a @timeout_ value which should be the maximum timeout (in milliseconds)
/// which should be passed to the poll() call. The actual timeout used will
/// be -1 if all sources returned -1, or it will be the minimum of all
/// the @timeout_ values returned which were >= 0.  Since 2.36 this may
/// be %NULL, in which case the effect is as if the function always returns
/// %FALSE with a timeout of -1.  If @prepare returns a
/// timeout and the source also has a 'ready time' set then the
/// nearer of the two will be used.
/// @check: Called after all the file descriptors are polled. The source
/// should return %TRUE if it is ready to be dispatched. Note that some
/// time may have passed since the previous prepare function was called,
/// so the source should be checked again here.  Since 2.36 this may
/// be %NULL, in which case the effect is as if the function always returns
/// %FALSE.
/// @dispatch: Called to dispatch the event source, after it has returned
/// %TRUE in either its @prepare or its @check function. The @dispatch
/// function is passed in a callback function and data. The callback
/// function may be %NULL if the source was never connected to a callback
/// using g_source_set_callback(). The @dispatch function should call the
/// callback function with @user_data and whatever additional parameters
/// are needed for this type of event source. The return value of the
/// @dispatch function should be #G_SOURCE_REMOVE if the source should be
/// removed or #G_SOURCE_CONTINUE to keep it.
/// @finalize: Called when the source is finalized. At this point, the source
/// will have been destroyed, had its callback cleared, and have been removed
/// from its #GMainContext, but it will still have its final reference count;
/// so methods can be called on it from within this function.
///
/// The `GSourceFuncs` struct contains a table of
/// functions used to handle event sources in a generic manner.
///
/// For idle sources, the prepare and check functions always return %TRUE
/// to indicate that the source is always ready to be processed. The prepare
/// function also returns a timeout value of 0 to ensure that the poll() call
/// doesn't block (since that would be time wasted which could have been spent
/// running the idle function).
///
/// For timeout sources, the prepare and check functions both return %TRUE
/// if the timeout interval has expired. The prepare function also returns
/// a timeout value to ensure that the poll() call doesn't block too long
/// and miss the next timeout.
///
/// For file descriptor sources, the prepare function typically returns %FALSE,
/// since it must wait until poll() has been called before it knows whether
/// any events need to be processed. It sets the returned timeout to -1 to
/// indicate that it doesn't mind how long the poll() call blocks. In the
/// check function, it tests the results of the poll() call to see if the
/// required condition has been met, and returns %TRUE if so.
pub type GSourceFuncs = _GSourceFuncs;
/// GSourceFunc:
/// @user_data: data passed to the function, set when the source was
/// created with one of the above functions
///
/// Specifies the type of function passed to g_timeout_add(),
/// g_timeout_add_full(), g_idle_add(), and g_idle_add_full().
///
/// Returns: %FALSE if the source should be removed. #G_SOURCE_CONTINUE and
/// #G_SOURCE_REMOVE are more memorable names for the return value.
pub type GSourceFunc = ::std::option::Option<unsafe extern "C" fn(user_data: gpointer) -> gboolean>;
/// GChildWatchFunc:
/// @pid: the process id of the child process
/// @status: Status information about the child process, encoded
/// in a platform-specific manner
/// @user_data: user data passed to g_child_watch_add()
///
/// Prototype of a #GChildWatchSource callback, called when a child
/// process has exited.  To interpret @status, see the documentation
/// for g_spawn_check_exit_status().
pub type GChildWatchFunc =
    ::std::option::Option<unsafe extern "C" fn(pid: GPid, status: gint, user_data: gpointer)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GSource {
    pub callback_data: gpointer,
    pub callback_funcs: *mut GSourceCallbackFuncs,
    pub source_funcs: *const GSourceFuncs,
    pub ref_count: guint,
    pub context: *mut GMainContext,
    pub priority: gint,
    pub flags: guint,
    pub source_id: guint,
    pub poll_fds: *mut GSList,
    pub prev: *mut GSource,
    pub next: *mut GSource,
    pub name: *mut ::std::os::raw::c_char,
    pub priv_: *mut GSourcePrivate,
}
#[test]
fn bindgen_test_layout__GSource() {
    assert_eq!(
        ::std::mem::size_of::<_GSource>(),
        96usize,
        concat!("Size of: ", stringify!(_GSource))
    );
    assert_eq!(
        ::std::mem::align_of::<_GSource>(),
        8usize,
        concat!("Alignment of ", stringify!(_GSource))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GSource>())).callback_data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSource),
            "::",
            stringify!(callback_data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GSource>())).callback_funcs as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSource),
            "::",
            stringify!(callback_funcs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GSource>())).source_funcs as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSource),
            "::",
            stringify!(source_funcs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GSource>())).ref_count as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSource),
            "::",
            stringify!(ref_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GSource>())).context as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSource),
            "::",
            stringify!(context)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GSource>())).priority as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSource),
            "::",
            stringify!(priority)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GSource>())).flags as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSource),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GSource>())).source_id as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSource),
            "::",
            stringify!(source_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GSource>())).poll_fds as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSource),
            "::",
            stringify!(poll_fds)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GSource>())).prev as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSource),
            "::",
            stringify!(prev)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GSource>())).next as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSource),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GSource>())).name as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSource),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GSource>())).priv_ as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSource),
            "::",
            stringify!(priv_)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GSourceCallbackFuncs {
    pub ref_: ::std::option::Option<unsafe extern "C" fn(cb_data: gpointer)>,
    pub unref: ::std::option::Option<unsafe extern "C" fn(cb_data: gpointer)>,
    pub get: ::std::option::Option<
        unsafe extern "C" fn(
            cb_data: gpointer,
            source: *mut GSource,
            func: *mut GSourceFunc,
            data: *mut gpointer,
        ),
    >,
}
#[test]
fn bindgen_test_layout__GSourceCallbackFuncs() {
    assert_eq!(
        ::std::mem::size_of::<_GSourceCallbackFuncs>(),
        24usize,
        concat!("Size of: ", stringify!(_GSourceCallbackFuncs))
    );
    assert_eq!(
        ::std::mem::align_of::<_GSourceCallbackFuncs>(),
        8usize,
        concat!("Alignment of ", stringify!(_GSourceCallbackFuncs))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GSourceCallbackFuncs>())).ref_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSourceCallbackFuncs),
            "::",
            stringify!(ref_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GSourceCallbackFuncs>())).unref as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSourceCallbackFuncs),
            "::",
            stringify!(unref)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GSourceCallbackFuncs>())).get as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSourceCallbackFuncs),
            "::",
            stringify!(get)
        )
    );
}
/// GSourceDummyMarshal:
///
/// This is just a placeholder for #GClosureMarshal,
/// which cannot be used here for dependency reasons.
pub type GSourceDummyMarshal = ::std::option::Option<unsafe extern "C" fn()>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GSourceFuncs {
    pub prepare: ::std::option::Option<
        unsafe extern "C" fn(source: *mut GSource, timeout_: *mut gint) -> gboolean,
    >,
    pub check: ::std::option::Option<unsafe extern "C" fn(source: *mut GSource) -> gboolean>,
    pub dispatch: ::std::option::Option<
        unsafe extern "C" fn(source: *mut GSource, callback: GSourceFunc, user_data: gpointer)
            -> gboolean,
    >,
    pub finalize: ::std::option::Option<unsafe extern "C" fn(source: *mut GSource)>,
    pub closure_callback: GSourceFunc,
    pub closure_marshal: GSourceDummyMarshal,
}
#[test]
fn bindgen_test_layout__GSourceFuncs() {
    assert_eq!(
        ::std::mem::size_of::<_GSourceFuncs>(),
        48usize,
        concat!("Size of: ", stringify!(_GSourceFuncs))
    );
    assert_eq!(
        ::std::mem::align_of::<_GSourceFuncs>(),
        8usize,
        concat!("Alignment of ", stringify!(_GSourceFuncs))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GSourceFuncs>())).prepare as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSourceFuncs),
            "::",
            stringify!(prepare)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GSourceFuncs>())).check as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSourceFuncs),
            "::",
            stringify!(check)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GSourceFuncs>())).dispatch as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSourceFuncs),
            "::",
            stringify!(dispatch)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GSourceFuncs>())).finalize as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSourceFuncs),
            "::",
            stringify!(finalize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GSourceFuncs>())).closure_callback as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSourceFuncs),
            "::",
            stringify!(closure_callback)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GSourceFuncs>())).closure_marshal as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSourceFuncs),
            "::",
            stringify!(closure_marshal)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_g_main_context_new"]
    pub fn g_main_context_new() -> *mut GMainContext;
}
extern "C" {
    #[link_name = "\u{1}_g_main_context_ref"]
    pub fn g_main_context_ref(context: *mut GMainContext) -> *mut GMainContext;
}
extern "C" {
    #[link_name = "\u{1}_g_main_context_unref"]
    pub fn g_main_context_unref(context: *mut GMainContext);
}
extern "C" {
    #[link_name = "\u{1}_g_main_context_default"]
    pub fn g_main_context_default() -> *mut GMainContext;
}
extern "C" {
    #[link_name = "\u{1}_g_main_context_iteration"]
    pub fn g_main_context_iteration(context: *mut GMainContext, may_block: gboolean) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_main_context_pending"]
    pub fn g_main_context_pending(context: *mut GMainContext) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_main_context_find_source_by_id"]
    pub fn g_main_context_find_source_by_id(
        context: *mut GMainContext,
        source_id: guint,
    ) -> *mut GSource;
}
extern "C" {
    #[link_name = "\u{1}_g_main_context_find_source_by_user_data"]
    pub fn g_main_context_find_source_by_user_data(
        context: *mut GMainContext,
        user_data: gpointer,
    ) -> *mut GSource;
}
extern "C" {
    #[link_name = "\u{1}_g_main_context_find_source_by_funcs_user_data"]
    pub fn g_main_context_find_source_by_funcs_user_data(
        context: *mut GMainContext,
        funcs: *mut GSourceFuncs,
        user_data: gpointer,
    ) -> *mut GSource;
}
extern "C" {
    #[link_name = "\u{1}_g_main_context_wakeup"]
    pub fn g_main_context_wakeup(context: *mut GMainContext);
}
extern "C" {
    #[link_name = "\u{1}_g_main_context_acquire"]
    pub fn g_main_context_acquire(context: *mut GMainContext) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_main_context_release"]
    pub fn g_main_context_release(context: *mut GMainContext);
}
extern "C" {
    #[link_name = "\u{1}_g_main_context_is_owner"]
    pub fn g_main_context_is_owner(context: *mut GMainContext) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_main_context_wait"]
    pub fn g_main_context_wait(
        context: *mut GMainContext,
        cond: *mut GCond,
        mutex: *mut GMutex,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_main_context_prepare"]
    pub fn g_main_context_prepare(context: *mut GMainContext, priority: *mut gint) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_main_context_query"]
    pub fn g_main_context_query(
        context: *mut GMainContext,
        max_priority: gint,
        timeout_: *mut gint,
        fds: *mut GPollFD,
        n_fds: gint,
    ) -> gint;
}
extern "C" {
    #[link_name = "\u{1}_g_main_context_check"]
    pub fn g_main_context_check(
        context: *mut GMainContext,
        max_priority: gint,
        fds: *mut GPollFD,
        n_fds: gint,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_main_context_dispatch"]
    pub fn g_main_context_dispatch(context: *mut GMainContext);
}
extern "C" {
    #[link_name = "\u{1}_g_main_context_set_poll_func"]
    pub fn g_main_context_set_poll_func(context: *mut GMainContext, func: GPollFunc);
}
extern "C" {
    #[link_name = "\u{1}_g_main_context_get_poll_func"]
    pub fn g_main_context_get_poll_func(context: *mut GMainContext) -> GPollFunc;
}
extern "C" {
    #[link_name = "\u{1}_g_main_context_add_poll"]
    pub fn g_main_context_add_poll(context: *mut GMainContext, fd: *mut GPollFD, priority: gint);
}
extern "C" {
    #[link_name = "\u{1}_g_main_context_remove_poll"]
    pub fn g_main_context_remove_poll(context: *mut GMainContext, fd: *mut GPollFD);
}
extern "C" {
    #[link_name = "\u{1}_g_main_depth"]
    pub fn g_main_depth() -> gint;
}
extern "C" {
    #[link_name = "\u{1}_g_main_current_source"]
    pub fn g_main_current_source() -> *mut GSource;
}
extern "C" {
    #[link_name = "\u{1}_g_main_context_push_thread_default"]
    pub fn g_main_context_push_thread_default(context: *mut GMainContext);
}
extern "C" {
    #[link_name = "\u{1}_g_main_context_pop_thread_default"]
    pub fn g_main_context_pop_thread_default(context: *mut GMainContext);
}
extern "C" {
    #[link_name = "\u{1}_g_main_context_get_thread_default"]
    pub fn g_main_context_get_thread_default() -> *mut GMainContext;
}
extern "C" {
    #[link_name = "\u{1}_g_main_context_ref_thread_default"]
    pub fn g_main_context_ref_thread_default() -> *mut GMainContext;
}
extern "C" {
    #[link_name = "\u{1}_g_main_loop_new"]
    pub fn g_main_loop_new(context: *mut GMainContext, is_running: gboolean) -> *mut GMainLoop;
}
extern "C" {
    #[link_name = "\u{1}_g_main_loop_run"]
    pub fn g_main_loop_run(loop_: *mut GMainLoop);
}
extern "C" {
    #[link_name = "\u{1}_g_main_loop_quit"]
    pub fn g_main_loop_quit(loop_: *mut GMainLoop);
}
extern "C" {
    #[link_name = "\u{1}_g_main_loop_ref"]
    pub fn g_main_loop_ref(loop_: *mut GMainLoop) -> *mut GMainLoop;
}
extern "C" {
    #[link_name = "\u{1}_g_main_loop_unref"]
    pub fn g_main_loop_unref(loop_: *mut GMainLoop);
}
extern "C" {
    #[link_name = "\u{1}_g_main_loop_is_running"]
    pub fn g_main_loop_is_running(loop_: *mut GMainLoop) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_main_loop_get_context"]
    pub fn g_main_loop_get_context(loop_: *mut GMainLoop) -> *mut GMainContext;
}
extern "C" {
    #[link_name = "\u{1}_g_source_new"]
    pub fn g_source_new(source_funcs: *mut GSourceFuncs, struct_size: guint) -> *mut GSource;
}
extern "C" {
    #[link_name = "\u{1}_g_source_ref"]
    pub fn g_source_ref(source: *mut GSource) -> *mut GSource;
}
extern "C" {
    #[link_name = "\u{1}_g_source_unref"]
    pub fn g_source_unref(source: *mut GSource);
}
extern "C" {
    #[link_name = "\u{1}_g_source_attach"]
    pub fn g_source_attach(source: *mut GSource, context: *mut GMainContext) -> guint;
}
extern "C" {
    #[link_name = "\u{1}_g_source_destroy"]
    pub fn g_source_destroy(source: *mut GSource);
}
extern "C" {
    #[link_name = "\u{1}_g_source_set_priority"]
    pub fn g_source_set_priority(source: *mut GSource, priority: gint);
}
extern "C" {
    #[link_name = "\u{1}_g_source_get_priority"]
    pub fn g_source_get_priority(source: *mut GSource) -> gint;
}
extern "C" {
    #[link_name = "\u{1}_g_source_set_can_recurse"]
    pub fn g_source_set_can_recurse(source: *mut GSource, can_recurse: gboolean);
}
extern "C" {
    #[link_name = "\u{1}_g_source_get_can_recurse"]
    pub fn g_source_get_can_recurse(source: *mut GSource) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_source_get_id"]
    pub fn g_source_get_id(source: *mut GSource) -> guint;
}
extern "C" {
    #[link_name = "\u{1}_g_source_get_context"]
    pub fn g_source_get_context(source: *mut GSource) -> *mut GMainContext;
}
extern "C" {
    #[link_name = "\u{1}_g_source_set_callback"]
    pub fn g_source_set_callback(
        source: *mut GSource,
        func: GSourceFunc,
        data: gpointer,
        notify: GDestroyNotify,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_source_set_funcs"]
    pub fn g_source_set_funcs(source: *mut GSource, funcs: *mut GSourceFuncs);
}
extern "C" {
    #[link_name = "\u{1}_g_source_is_destroyed"]
    pub fn g_source_is_destroyed(source: *mut GSource) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_source_set_name"]
    pub fn g_source_set_name(source: *mut GSource, name: *const ::std::os::raw::c_char);
}
extern "C" {
    #[link_name = "\u{1}_g_source_get_name"]
    pub fn g_source_get_name(source: *mut GSource) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_g_source_set_name_by_id"]
    pub fn g_source_set_name_by_id(tag: guint, name: *const ::std::os::raw::c_char);
}
extern "C" {
    #[link_name = "\u{1}_g_source_set_ready_time"]
    pub fn g_source_set_ready_time(source: *mut GSource, ready_time: gint64);
}
extern "C" {
    #[link_name = "\u{1}_g_source_get_ready_time"]
    pub fn g_source_get_ready_time(source: *mut GSource) -> gint64;
}
extern "C" {
    #[link_name = "\u{1}_g_source_add_unix_fd"]
    pub fn g_source_add_unix_fd(source: *mut GSource, fd: gint, events: GIOCondition) -> gpointer;
}
extern "C" {
    #[link_name = "\u{1}_g_source_modify_unix_fd"]
    pub fn g_source_modify_unix_fd(source: *mut GSource, tag: gpointer, new_events: GIOCondition);
}
extern "C" {
    #[link_name = "\u{1}_g_source_remove_unix_fd"]
    pub fn g_source_remove_unix_fd(source: *mut GSource, tag: gpointer);
}
extern "C" {
    #[link_name = "\u{1}_g_source_query_unix_fd"]
    pub fn g_source_query_unix_fd(source: *mut GSource, tag: gpointer) -> GIOCondition;
}
extern "C" {
    #[link_name = "\u{1}_g_source_set_callback_indirect"]
    pub fn g_source_set_callback_indirect(
        source: *mut GSource,
        callback_data: gpointer,
        callback_funcs: *mut GSourceCallbackFuncs,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_source_add_poll"]
    pub fn g_source_add_poll(source: *mut GSource, fd: *mut GPollFD);
}
extern "C" {
    #[link_name = "\u{1}_g_source_remove_poll"]
    pub fn g_source_remove_poll(source: *mut GSource, fd: *mut GPollFD);
}
extern "C" {
    #[link_name = "\u{1}_g_source_add_child_source"]
    pub fn g_source_add_child_source(source: *mut GSource, child_source: *mut GSource);
}
extern "C" {
    #[link_name = "\u{1}_g_source_remove_child_source"]
    pub fn g_source_remove_child_source(source: *mut GSource, child_source: *mut GSource);
}
extern "C" {
    #[link_name = "\u{1}_g_source_get_current_time"]
    pub fn g_source_get_current_time(source: *mut GSource, timeval: *mut GTimeVal);
}
extern "C" {
    #[link_name = "\u{1}_g_source_get_time"]
    pub fn g_source_get_time(source: *mut GSource) -> gint64;
}
extern "C" {
    #[link_name = "\u{1}_g_idle_source_new"]
    pub fn g_idle_source_new() -> *mut GSource;
}
extern "C" {
    #[link_name = "\u{1}_g_child_watch_source_new"]
    pub fn g_child_watch_source_new(pid: GPid) -> *mut GSource;
}
extern "C" {
    #[link_name = "\u{1}_g_timeout_source_new"]
    pub fn g_timeout_source_new(interval: guint) -> *mut GSource;
}
extern "C" {
    #[link_name = "\u{1}_g_timeout_source_new_seconds"]
    pub fn g_timeout_source_new_seconds(interval: guint) -> *mut GSource;
}
extern "C" {
    #[link_name = "\u{1}_g_get_current_time"]
    pub fn g_get_current_time(result: *mut GTimeVal);
}
extern "C" {
    #[link_name = "\u{1}_g_get_monotonic_time"]
    pub fn g_get_monotonic_time() -> gint64;
}
extern "C" {
    #[link_name = "\u{1}_g_get_real_time"]
    pub fn g_get_real_time() -> gint64;
}
extern "C" {
    #[link_name = "\u{1}_g_source_remove"]
    pub fn g_source_remove(tag: guint) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_source_remove_by_user_data"]
    pub fn g_source_remove_by_user_data(user_data: gpointer) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_source_remove_by_funcs_user_data"]
    pub fn g_source_remove_by_funcs_user_data(
        funcs: *mut GSourceFuncs,
        user_data: gpointer,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_timeout_add_full"]
    pub fn g_timeout_add_full(
        priority: gint,
        interval: guint,
        function: GSourceFunc,
        data: gpointer,
        notify: GDestroyNotify,
    ) -> guint;
}
extern "C" {
    #[link_name = "\u{1}_g_timeout_add"]
    pub fn g_timeout_add(interval: guint, function: GSourceFunc, data: gpointer) -> guint;
}
extern "C" {
    #[link_name = "\u{1}_g_timeout_add_seconds_full"]
    pub fn g_timeout_add_seconds_full(
        priority: gint,
        interval: guint,
        function: GSourceFunc,
        data: gpointer,
        notify: GDestroyNotify,
    ) -> guint;
}
extern "C" {
    #[link_name = "\u{1}_g_timeout_add_seconds"]
    pub fn g_timeout_add_seconds(interval: guint, function: GSourceFunc, data: gpointer) -> guint;
}
extern "C" {
    #[link_name = "\u{1}_g_child_watch_add_full"]
    pub fn g_child_watch_add_full(
        priority: gint,
        pid: GPid,
        function: GChildWatchFunc,
        data: gpointer,
        notify: GDestroyNotify,
    ) -> guint;
}
extern "C" {
    #[link_name = "\u{1}_g_child_watch_add"]
    pub fn g_child_watch_add(pid: GPid, function: GChildWatchFunc, data: gpointer) -> guint;
}
extern "C" {
    #[link_name = "\u{1}_g_idle_add"]
    pub fn g_idle_add(function: GSourceFunc, data: gpointer) -> guint;
}
extern "C" {
    #[link_name = "\u{1}_g_idle_add_full"]
    pub fn g_idle_add_full(
        priority: gint,
        function: GSourceFunc,
        data: gpointer,
        notify: GDestroyNotify,
    ) -> guint;
}
extern "C" {
    #[link_name = "\u{1}_g_idle_remove_by_data"]
    pub fn g_idle_remove_by_data(data: gpointer) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_main_context_invoke_full"]
    pub fn g_main_context_invoke_full(
        context: *mut GMainContext,
        priority: gint,
        function: GSourceFunc,
        data: gpointer,
        notify: GDestroyNotify,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_main_context_invoke"]
    pub fn g_main_context_invoke(context: *mut GMainContext, function: GSourceFunc, data: gpointer);
}
extern "C" {
    #[link_name = "\u{1}_g_timeout_funcs"]
    pub static mut g_timeout_funcs: GSourceFuncs;
}
extern "C" {
    #[link_name = "\u{1}_g_child_watch_funcs"]
    pub static mut g_child_watch_funcs: GSourceFuncs;
}
extern "C" {
    #[link_name = "\u{1}_g_idle_funcs"]
    pub static mut g_idle_funcs: GSourceFuncs;
}
extern "C" {
    #[link_name = "\u{1}_g_unix_signal_funcs"]
    pub static mut g_unix_signal_funcs: GSourceFuncs;
}
extern "C" {
    #[link_name = "\u{1}_g_unix_fd_source_funcs"]
    pub static mut g_unix_fd_source_funcs: GSourceFuncs;
}
/// gunichar:
///
/// A type which can hold any UTF-32 or UCS-4 character code,
/// also known as a Unicode code point.
///
/// If you want to produce the UTF-8 representation of a #gunichar,
/// use g_ucs4_to_utf8(). See also g_utf8_to_ucs4() for the reverse
/// process.
///
/// To print/scan values of this type as integer, use
/// %G_GINT32_MODIFIER and/or %G_GUINT32_FORMAT.
///
/// The notation to express a Unicode code point in running text is
/// as a hexadecimal number with four to six digits and uppercase
/// letters, prefixed by the string "U+". Leading zeros are omitted,
/// unless the code point would have fewer than four hexadecimal digits.
/// For example, "U+0041 LATIN CAPITAL LETTER A". To print a code point
/// in the U+-notation, use the format string "U+\%04"G_GINT32_FORMAT"X".
/// To scan, use the format string "U+\%06"G_GINT32_FORMAT"X".
///
/// |[
/// gunichar c;
/// sscanf ("U+0041", "U+%06"G_GINT32_FORMAT"X", &amp;c)
/// g_print ("Read U+%04"G_GINT32_FORMAT"X", c);
/// ]|
pub type gunichar = guint32;
/// gunichar2:
///
/// A type which can hold any UTF-16 code
/// point<footnote id="utf16_surrogate_pairs">UTF-16 also has so called
/// <firstterm>surrogate pairs</firstterm> to encode characters beyond
/// the BMP as pairs of 16bit numbers. Surrogate pairs cannot be stored
/// in a single gunichar2 field, but all GLib functions accepting gunichar2
/// arrays will correctly interpret surrogate pairs.</footnote>.
///
/// To print/scan values of this type to/from text you need to convert
/// to/from UTF-8, using g_utf16_to_utf8()/g_utf8_to_utf16().
///
/// To print/scan values of this type as integer, use
/// %G_GINT16_MODIFIER and/or %G_GUINT16_FORMAT.
pub type gunichar2 = guint16;
pub const GUnicodeType_G_UNICODE_CONTROL: GUnicodeType = 0;
pub const GUnicodeType_G_UNICODE_FORMAT: GUnicodeType = 1;
pub const GUnicodeType_G_UNICODE_UNASSIGNED: GUnicodeType = 2;
pub const GUnicodeType_G_UNICODE_PRIVATE_USE: GUnicodeType = 3;
pub const GUnicodeType_G_UNICODE_SURROGATE: GUnicodeType = 4;
pub const GUnicodeType_G_UNICODE_LOWERCASE_LETTER: GUnicodeType = 5;
pub const GUnicodeType_G_UNICODE_MODIFIER_LETTER: GUnicodeType = 6;
pub const GUnicodeType_G_UNICODE_OTHER_LETTER: GUnicodeType = 7;
pub const GUnicodeType_G_UNICODE_TITLECASE_LETTER: GUnicodeType = 8;
pub const GUnicodeType_G_UNICODE_UPPERCASE_LETTER: GUnicodeType = 9;
pub const GUnicodeType_G_UNICODE_SPACING_MARK: GUnicodeType = 10;
pub const GUnicodeType_G_UNICODE_ENCLOSING_MARK: GUnicodeType = 11;
pub const GUnicodeType_G_UNICODE_NON_SPACING_MARK: GUnicodeType = 12;
pub const GUnicodeType_G_UNICODE_DECIMAL_NUMBER: GUnicodeType = 13;
pub const GUnicodeType_G_UNICODE_LETTER_NUMBER: GUnicodeType = 14;
pub const GUnicodeType_G_UNICODE_OTHER_NUMBER: GUnicodeType = 15;
pub const GUnicodeType_G_UNICODE_CONNECT_PUNCTUATION: GUnicodeType = 16;
pub const GUnicodeType_G_UNICODE_DASH_PUNCTUATION: GUnicodeType = 17;
pub const GUnicodeType_G_UNICODE_CLOSE_PUNCTUATION: GUnicodeType = 18;
pub const GUnicodeType_G_UNICODE_FINAL_PUNCTUATION: GUnicodeType = 19;
pub const GUnicodeType_G_UNICODE_INITIAL_PUNCTUATION: GUnicodeType = 20;
pub const GUnicodeType_G_UNICODE_OTHER_PUNCTUATION: GUnicodeType = 21;
pub const GUnicodeType_G_UNICODE_OPEN_PUNCTUATION: GUnicodeType = 22;
pub const GUnicodeType_G_UNICODE_CURRENCY_SYMBOL: GUnicodeType = 23;
pub const GUnicodeType_G_UNICODE_MODIFIER_SYMBOL: GUnicodeType = 24;
pub const GUnicodeType_G_UNICODE_MATH_SYMBOL: GUnicodeType = 25;
pub const GUnicodeType_G_UNICODE_OTHER_SYMBOL: GUnicodeType = 26;
pub const GUnicodeType_G_UNICODE_LINE_SEPARATOR: GUnicodeType = 27;
pub const GUnicodeType_G_UNICODE_PARAGRAPH_SEPARATOR: GUnicodeType = 28;
pub const GUnicodeType_G_UNICODE_SPACE_SEPARATOR: GUnicodeType = 29;
/// GUnicodeType:
/// @G_UNICODE_CONTROL: General category "Other, Control" (Cc)
/// @G_UNICODE_FORMAT: General category "Other, Format" (Cf)
/// @G_UNICODE_UNASSIGNED: General category "Other, Not Assigned" (Cn)
/// @G_UNICODE_PRIVATE_USE: General category "Other, Private Use" (Co)
/// @G_UNICODE_SURROGATE: General category "Other, Surrogate" (Cs)
/// @G_UNICODE_LOWERCASE_LETTER: General category "Letter, Lowercase" (Ll)
/// @G_UNICODE_MODIFIER_LETTER: General category "Letter, Modifier" (Lm)
/// @G_UNICODE_OTHER_LETTER: General category "Letter, Other" (Lo)
/// @G_UNICODE_TITLECASE_LETTER: General category "Letter, Titlecase" (Lt)
/// @G_UNICODE_UPPERCASE_LETTER: General category "Letter, Uppercase" (Lu)
/// @G_UNICODE_SPACING_MARK: General category "Mark, Spacing" (Mc)
/// @G_UNICODE_ENCLOSING_MARK: General category "Mark, Enclosing" (Me)
/// @G_UNICODE_NON_SPACING_MARK: General category "Mark, Nonspacing" (Mn)
/// @G_UNICODE_DECIMAL_NUMBER: General category "Number, Decimal Digit" (Nd)
/// @G_UNICODE_LETTER_NUMBER: General category "Number, Letter" (Nl)
/// @G_UNICODE_OTHER_NUMBER: General category "Number, Other" (No)
/// @G_UNICODE_CONNECT_PUNCTUATION: General category "Punctuation, Connector" (Pc)
/// @G_UNICODE_DASH_PUNCTUATION: General category "Punctuation, Dash" (Pd)
/// @G_UNICODE_CLOSE_PUNCTUATION: General category "Punctuation, Close" (Pe)
/// @G_UNICODE_FINAL_PUNCTUATION: General category "Punctuation, Final quote" (Pf)
/// @G_UNICODE_INITIAL_PUNCTUATION: General category "Punctuation, Initial quote" (Pi)
/// @G_UNICODE_OTHER_PUNCTUATION: General category "Punctuation, Other" (Po)
/// @G_UNICODE_OPEN_PUNCTUATION: General category "Punctuation, Open" (Ps)
/// @G_UNICODE_CURRENCY_SYMBOL: General category "Symbol, Currency" (Sc)
/// @G_UNICODE_MODIFIER_SYMBOL: General category "Symbol, Modifier" (Sk)
/// @G_UNICODE_MATH_SYMBOL: General category "Symbol, Math" (Sm)
/// @G_UNICODE_OTHER_SYMBOL: General category "Symbol, Other" (So)
/// @G_UNICODE_LINE_SEPARATOR: General category "Separator, Line" (Zl)
/// @G_UNICODE_PARAGRAPH_SEPARATOR: General category "Separator, Paragraph" (Zp)
/// @G_UNICODE_SPACE_SEPARATOR: General category "Separator, Space" (Zs)
///
/// These are the possible character classifications from the
/// Unicode specification.
/// See [Unicode Character Database](http://www.unicode.org/reports/tr44/#General_Category_Values).
pub type GUnicodeType = u32;
pub const GUnicodeBreakType_G_UNICODE_BREAK_MANDATORY: GUnicodeBreakType = 0;
pub const GUnicodeBreakType_G_UNICODE_BREAK_CARRIAGE_RETURN: GUnicodeBreakType = 1;
pub const GUnicodeBreakType_G_UNICODE_BREAK_LINE_FEED: GUnicodeBreakType = 2;
pub const GUnicodeBreakType_G_UNICODE_BREAK_COMBINING_MARK: GUnicodeBreakType = 3;
pub const GUnicodeBreakType_G_UNICODE_BREAK_SURROGATE: GUnicodeBreakType = 4;
pub const GUnicodeBreakType_G_UNICODE_BREAK_ZERO_WIDTH_SPACE: GUnicodeBreakType = 5;
pub const GUnicodeBreakType_G_UNICODE_BREAK_INSEPARABLE: GUnicodeBreakType = 6;
pub const GUnicodeBreakType_G_UNICODE_BREAK_NON_BREAKING_GLUE: GUnicodeBreakType = 7;
pub const GUnicodeBreakType_G_UNICODE_BREAK_CONTINGENT: GUnicodeBreakType = 8;
pub const GUnicodeBreakType_G_UNICODE_BREAK_SPACE: GUnicodeBreakType = 9;
pub const GUnicodeBreakType_G_UNICODE_BREAK_AFTER: GUnicodeBreakType = 10;
pub const GUnicodeBreakType_G_UNICODE_BREAK_BEFORE: GUnicodeBreakType = 11;
pub const GUnicodeBreakType_G_UNICODE_BREAK_BEFORE_AND_AFTER: GUnicodeBreakType = 12;
pub const GUnicodeBreakType_G_UNICODE_BREAK_HYPHEN: GUnicodeBreakType = 13;
pub const GUnicodeBreakType_G_UNICODE_BREAK_NON_STARTER: GUnicodeBreakType = 14;
pub const GUnicodeBreakType_G_UNICODE_BREAK_OPEN_PUNCTUATION: GUnicodeBreakType = 15;
pub const GUnicodeBreakType_G_UNICODE_BREAK_CLOSE_PUNCTUATION: GUnicodeBreakType = 16;
pub const GUnicodeBreakType_G_UNICODE_BREAK_QUOTATION: GUnicodeBreakType = 17;
pub const GUnicodeBreakType_G_UNICODE_BREAK_EXCLAMATION: GUnicodeBreakType = 18;
pub const GUnicodeBreakType_G_UNICODE_BREAK_IDEOGRAPHIC: GUnicodeBreakType = 19;
pub const GUnicodeBreakType_G_UNICODE_BREAK_NUMERIC: GUnicodeBreakType = 20;
pub const GUnicodeBreakType_G_UNICODE_BREAK_INFIX_SEPARATOR: GUnicodeBreakType = 21;
pub const GUnicodeBreakType_G_UNICODE_BREAK_SYMBOL: GUnicodeBreakType = 22;
pub const GUnicodeBreakType_G_UNICODE_BREAK_ALPHABETIC: GUnicodeBreakType = 23;
pub const GUnicodeBreakType_G_UNICODE_BREAK_PREFIX: GUnicodeBreakType = 24;
pub const GUnicodeBreakType_G_UNICODE_BREAK_POSTFIX: GUnicodeBreakType = 25;
pub const GUnicodeBreakType_G_UNICODE_BREAK_COMPLEX_CONTEXT: GUnicodeBreakType = 26;
pub const GUnicodeBreakType_G_UNICODE_BREAK_AMBIGUOUS: GUnicodeBreakType = 27;
pub const GUnicodeBreakType_G_UNICODE_BREAK_UNKNOWN: GUnicodeBreakType = 28;
pub const GUnicodeBreakType_G_UNICODE_BREAK_NEXT_LINE: GUnicodeBreakType = 29;
pub const GUnicodeBreakType_G_UNICODE_BREAK_WORD_JOINER: GUnicodeBreakType = 30;
pub const GUnicodeBreakType_G_UNICODE_BREAK_HANGUL_L_JAMO: GUnicodeBreakType = 31;
pub const GUnicodeBreakType_G_UNICODE_BREAK_HANGUL_V_JAMO: GUnicodeBreakType = 32;
pub const GUnicodeBreakType_G_UNICODE_BREAK_HANGUL_T_JAMO: GUnicodeBreakType = 33;
pub const GUnicodeBreakType_G_UNICODE_BREAK_HANGUL_LV_SYLLABLE: GUnicodeBreakType = 34;
pub const GUnicodeBreakType_G_UNICODE_BREAK_HANGUL_LVT_SYLLABLE: GUnicodeBreakType = 35;
pub const GUnicodeBreakType_G_UNICODE_BREAK_CLOSE_PARANTHESIS: GUnicodeBreakType = 36;
pub const GUnicodeBreakType_G_UNICODE_BREAK_CONDITIONAL_JAPANESE_STARTER: GUnicodeBreakType = 37;
pub const GUnicodeBreakType_G_UNICODE_BREAK_HEBREW_LETTER: GUnicodeBreakType = 38;
pub const GUnicodeBreakType_G_UNICODE_BREAK_REGIONAL_INDICATOR: GUnicodeBreakType = 39;
pub const GUnicodeBreakType_G_UNICODE_BREAK_EMOJI_BASE: GUnicodeBreakType = 40;
pub const GUnicodeBreakType_G_UNICODE_BREAK_EMOJI_MODIFIER: GUnicodeBreakType = 41;
pub const GUnicodeBreakType_G_UNICODE_BREAK_ZERO_WIDTH_JOINER: GUnicodeBreakType = 42;
/// GUnicodeBreakType:
/// @G_UNICODE_BREAK_MANDATORY: Mandatory Break (BK)
/// @G_UNICODE_BREAK_CARRIAGE_RETURN: Carriage Return (CR)
/// @G_UNICODE_BREAK_LINE_FEED: Line Feed (LF)
/// @G_UNICODE_BREAK_COMBINING_MARK: Attached Characters and Combining Marks (CM)
/// @G_UNICODE_BREAK_SURROGATE: Surrogates (SG)
/// @G_UNICODE_BREAK_ZERO_WIDTH_SPACE: Zero Width Space (ZW)
/// @G_UNICODE_BREAK_INSEPARABLE: Inseparable (IN)
/// @G_UNICODE_BREAK_NON_BREAKING_GLUE: Non-breaking ("Glue") (GL)
/// @G_UNICODE_BREAK_CONTINGENT: Contingent Break Opportunity (CB)
/// @G_UNICODE_BREAK_SPACE: Space (SP)
/// @G_UNICODE_BREAK_AFTER: Break Opportunity After (BA)
/// @G_UNICODE_BREAK_BEFORE: Break Opportunity Before (BB)
/// @G_UNICODE_BREAK_BEFORE_AND_AFTER: Break Opportunity Before and After (B2)
/// @G_UNICODE_BREAK_HYPHEN: Hyphen (HY)
/// @G_UNICODE_BREAK_NON_STARTER: Nonstarter (NS)
/// @G_UNICODE_BREAK_OPEN_PUNCTUATION: Opening Punctuation (OP)
/// @G_UNICODE_BREAK_CLOSE_PUNCTUATION: Closing Punctuation (CL)
/// @G_UNICODE_BREAK_QUOTATION: Ambiguous Quotation (QU)
/// @G_UNICODE_BREAK_EXCLAMATION: Exclamation/Interrogation (EX)
/// @G_UNICODE_BREAK_IDEOGRAPHIC: Ideographic (ID)
/// @G_UNICODE_BREAK_NUMERIC: Numeric (NU)
/// @G_UNICODE_BREAK_INFIX_SEPARATOR: Infix Separator (Numeric) (IS)
/// @G_UNICODE_BREAK_SYMBOL: Symbols Allowing Break After (SY)
/// @G_UNICODE_BREAK_ALPHABETIC: Ordinary Alphabetic and Symbol Characters (AL)
/// @G_UNICODE_BREAK_PREFIX: Prefix (Numeric) (PR)
/// @G_UNICODE_BREAK_POSTFIX: Postfix (Numeric) (PO)
/// @G_UNICODE_BREAK_COMPLEX_CONTEXT: Complex Content Dependent (South East Asian) (SA)
/// @G_UNICODE_BREAK_AMBIGUOUS: Ambiguous (Alphabetic or Ideographic) (AI)
/// @G_UNICODE_BREAK_UNKNOWN: Unknown (XX)
/// @G_UNICODE_BREAK_NEXT_LINE: Next Line (NL)
/// @G_UNICODE_BREAK_WORD_JOINER: Word Joiner (WJ)
/// @G_UNICODE_BREAK_HANGUL_L_JAMO: Hangul L Jamo (JL)
/// @G_UNICODE_BREAK_HANGUL_V_JAMO: Hangul V Jamo (JV)
/// @G_UNICODE_BREAK_HANGUL_T_JAMO: Hangul T Jamo (JT)
/// @G_UNICODE_BREAK_HANGUL_LV_SYLLABLE: Hangul LV Syllable (H2)
/// @G_UNICODE_BREAK_HANGUL_LVT_SYLLABLE: Hangul LVT Syllable (H3)
/// @G_UNICODE_BREAK_CLOSE_PARANTHESIS: Closing Parenthesis (CP). Since 2.28
/// @G_UNICODE_BREAK_CONDITIONAL_JAPANESE_STARTER: Conditional Japanese Starter (CJ). Since: 2.32
/// @G_UNICODE_BREAK_HEBREW_LETTER: Hebrew Letter (HL). Since: 2.32
/// @G_UNICODE_BREAK_REGIONAL_INDICATOR: Regional Indicator (RI). Since: 2.36
/// @G_UNICODE_BREAK_EMOJI_BASE: Emoji Base (EB). Since: 2.50
/// @G_UNICODE_BREAK_EMOJI_MODIFIER: Emoji Modifier (EM). Since: 2.50
/// @G_UNICODE_BREAK_ZERO_WIDTH_JOINER: Zero Width Joiner (ZWJ). Since: 2.50
///
/// These are the possible line break classifications.
///
/// Since new unicode versions may add new types here, applications should be ready
/// to handle unknown values. They may be regarded as %G_UNICODE_BREAK_UNKNOWN.
///
/// See [Unicode Line Breaking Algorithm](http://www.unicode.org/unicode/reports/tr14/).
pub type GUnicodeBreakType = u32;
pub const GUnicodeScript_G_UNICODE_SCRIPT_INVALID_CODE: GUnicodeScript = -1;
pub const GUnicodeScript_G_UNICODE_SCRIPT_COMMON: GUnicodeScript = 0;
pub const GUnicodeScript_G_UNICODE_SCRIPT_INHERITED: GUnicodeScript = 1;
pub const GUnicodeScript_G_UNICODE_SCRIPT_ARABIC: GUnicodeScript = 2;
pub const GUnicodeScript_G_UNICODE_SCRIPT_ARMENIAN: GUnicodeScript = 3;
pub const GUnicodeScript_G_UNICODE_SCRIPT_BENGALI: GUnicodeScript = 4;
pub const GUnicodeScript_G_UNICODE_SCRIPT_BOPOMOFO: GUnicodeScript = 5;
pub const GUnicodeScript_G_UNICODE_SCRIPT_CHEROKEE: GUnicodeScript = 6;
pub const GUnicodeScript_G_UNICODE_SCRIPT_COPTIC: GUnicodeScript = 7;
pub const GUnicodeScript_G_UNICODE_SCRIPT_CYRILLIC: GUnicodeScript = 8;
pub const GUnicodeScript_G_UNICODE_SCRIPT_DESERET: GUnicodeScript = 9;
pub const GUnicodeScript_G_UNICODE_SCRIPT_DEVANAGARI: GUnicodeScript = 10;
pub const GUnicodeScript_G_UNICODE_SCRIPT_ETHIOPIC: GUnicodeScript = 11;
pub const GUnicodeScript_G_UNICODE_SCRIPT_GEORGIAN: GUnicodeScript = 12;
pub const GUnicodeScript_G_UNICODE_SCRIPT_GOTHIC: GUnicodeScript = 13;
pub const GUnicodeScript_G_UNICODE_SCRIPT_GREEK: GUnicodeScript = 14;
pub const GUnicodeScript_G_UNICODE_SCRIPT_GUJARATI: GUnicodeScript = 15;
pub const GUnicodeScript_G_UNICODE_SCRIPT_GURMUKHI: GUnicodeScript = 16;
pub const GUnicodeScript_G_UNICODE_SCRIPT_HAN: GUnicodeScript = 17;
pub const GUnicodeScript_G_UNICODE_SCRIPT_HANGUL: GUnicodeScript = 18;
pub const GUnicodeScript_G_UNICODE_SCRIPT_HEBREW: GUnicodeScript = 19;
pub const GUnicodeScript_G_UNICODE_SCRIPT_HIRAGANA: GUnicodeScript = 20;
pub const GUnicodeScript_G_UNICODE_SCRIPT_KANNADA: GUnicodeScript = 21;
pub const GUnicodeScript_G_UNICODE_SCRIPT_KATAKANA: GUnicodeScript = 22;
pub const GUnicodeScript_G_UNICODE_SCRIPT_KHMER: GUnicodeScript = 23;
pub const GUnicodeScript_G_UNICODE_SCRIPT_LAO: GUnicodeScript = 24;
pub const GUnicodeScript_G_UNICODE_SCRIPT_LATIN: GUnicodeScript = 25;
pub const GUnicodeScript_G_UNICODE_SCRIPT_MALAYALAM: GUnicodeScript = 26;
pub const GUnicodeScript_G_UNICODE_SCRIPT_MONGOLIAN: GUnicodeScript = 27;
pub const GUnicodeScript_G_UNICODE_SCRIPT_MYANMAR: GUnicodeScript = 28;
pub const GUnicodeScript_G_UNICODE_SCRIPT_OGHAM: GUnicodeScript = 29;
pub const GUnicodeScript_G_UNICODE_SCRIPT_OLD_ITALIC: GUnicodeScript = 30;
pub const GUnicodeScript_G_UNICODE_SCRIPT_ORIYA: GUnicodeScript = 31;
pub const GUnicodeScript_G_UNICODE_SCRIPT_RUNIC: GUnicodeScript = 32;
pub const GUnicodeScript_G_UNICODE_SCRIPT_SINHALA: GUnicodeScript = 33;
pub const GUnicodeScript_G_UNICODE_SCRIPT_SYRIAC: GUnicodeScript = 34;
pub const GUnicodeScript_G_UNICODE_SCRIPT_TAMIL: GUnicodeScript = 35;
pub const GUnicodeScript_G_UNICODE_SCRIPT_TELUGU: GUnicodeScript = 36;
pub const GUnicodeScript_G_UNICODE_SCRIPT_THAANA: GUnicodeScript = 37;
pub const GUnicodeScript_G_UNICODE_SCRIPT_THAI: GUnicodeScript = 38;
pub const GUnicodeScript_G_UNICODE_SCRIPT_TIBETAN: GUnicodeScript = 39;
pub const GUnicodeScript_G_UNICODE_SCRIPT_CANADIAN_ABORIGINAL: GUnicodeScript = 40;
pub const GUnicodeScript_G_UNICODE_SCRIPT_YI: GUnicodeScript = 41;
pub const GUnicodeScript_G_UNICODE_SCRIPT_TAGALOG: GUnicodeScript = 42;
pub const GUnicodeScript_G_UNICODE_SCRIPT_HANUNOO: GUnicodeScript = 43;
pub const GUnicodeScript_G_UNICODE_SCRIPT_BUHID: GUnicodeScript = 44;
pub const GUnicodeScript_G_UNICODE_SCRIPT_TAGBANWA: GUnicodeScript = 45;
pub const GUnicodeScript_G_UNICODE_SCRIPT_BRAILLE: GUnicodeScript = 46;
pub const GUnicodeScript_G_UNICODE_SCRIPT_CYPRIOT: GUnicodeScript = 47;
pub const GUnicodeScript_G_UNICODE_SCRIPT_LIMBU: GUnicodeScript = 48;
pub const GUnicodeScript_G_UNICODE_SCRIPT_OSMANYA: GUnicodeScript = 49;
pub const GUnicodeScript_G_UNICODE_SCRIPT_SHAVIAN: GUnicodeScript = 50;
pub const GUnicodeScript_G_UNICODE_SCRIPT_LINEAR_B: GUnicodeScript = 51;
pub const GUnicodeScript_G_UNICODE_SCRIPT_TAI_LE: GUnicodeScript = 52;
pub const GUnicodeScript_G_UNICODE_SCRIPT_UGARITIC: GUnicodeScript = 53;
pub const GUnicodeScript_G_UNICODE_SCRIPT_NEW_TAI_LUE: GUnicodeScript = 54;
pub const GUnicodeScript_G_UNICODE_SCRIPT_BUGINESE: GUnicodeScript = 55;
pub const GUnicodeScript_G_UNICODE_SCRIPT_GLAGOLITIC: GUnicodeScript = 56;
pub const GUnicodeScript_G_UNICODE_SCRIPT_TIFINAGH: GUnicodeScript = 57;
pub const GUnicodeScript_G_UNICODE_SCRIPT_SYLOTI_NAGRI: GUnicodeScript = 58;
pub const GUnicodeScript_G_UNICODE_SCRIPT_OLD_PERSIAN: GUnicodeScript = 59;
pub const GUnicodeScript_G_UNICODE_SCRIPT_KHAROSHTHI: GUnicodeScript = 60;
pub const GUnicodeScript_G_UNICODE_SCRIPT_UNKNOWN: GUnicodeScript = 61;
pub const GUnicodeScript_G_UNICODE_SCRIPT_BALINESE: GUnicodeScript = 62;
pub const GUnicodeScript_G_UNICODE_SCRIPT_CUNEIFORM: GUnicodeScript = 63;
pub const GUnicodeScript_G_UNICODE_SCRIPT_PHOENICIAN: GUnicodeScript = 64;
pub const GUnicodeScript_G_UNICODE_SCRIPT_PHAGS_PA: GUnicodeScript = 65;
pub const GUnicodeScript_G_UNICODE_SCRIPT_NKO: GUnicodeScript = 66;
pub const GUnicodeScript_G_UNICODE_SCRIPT_KAYAH_LI: GUnicodeScript = 67;
pub const GUnicodeScript_G_UNICODE_SCRIPT_LEPCHA: GUnicodeScript = 68;
pub const GUnicodeScript_G_UNICODE_SCRIPT_REJANG: GUnicodeScript = 69;
pub const GUnicodeScript_G_UNICODE_SCRIPT_SUNDANESE: GUnicodeScript = 70;
pub const GUnicodeScript_G_UNICODE_SCRIPT_SAURASHTRA: GUnicodeScript = 71;
pub const GUnicodeScript_G_UNICODE_SCRIPT_CHAM: GUnicodeScript = 72;
pub const GUnicodeScript_G_UNICODE_SCRIPT_OL_CHIKI: GUnicodeScript = 73;
pub const GUnicodeScript_G_UNICODE_SCRIPT_VAI: GUnicodeScript = 74;
pub const GUnicodeScript_G_UNICODE_SCRIPT_CARIAN: GUnicodeScript = 75;
pub const GUnicodeScript_G_UNICODE_SCRIPT_LYCIAN: GUnicodeScript = 76;
pub const GUnicodeScript_G_UNICODE_SCRIPT_LYDIAN: GUnicodeScript = 77;
pub const GUnicodeScript_G_UNICODE_SCRIPT_AVESTAN: GUnicodeScript = 78;
pub const GUnicodeScript_G_UNICODE_SCRIPT_BAMUM: GUnicodeScript = 79;
pub const GUnicodeScript_G_UNICODE_SCRIPT_EGYPTIAN_HIEROGLYPHS: GUnicodeScript = 80;
pub const GUnicodeScript_G_UNICODE_SCRIPT_IMPERIAL_ARAMAIC: GUnicodeScript = 81;
pub const GUnicodeScript_G_UNICODE_SCRIPT_INSCRIPTIONAL_PAHLAVI: GUnicodeScript = 82;
pub const GUnicodeScript_G_UNICODE_SCRIPT_INSCRIPTIONAL_PARTHIAN: GUnicodeScript = 83;
pub const GUnicodeScript_G_UNICODE_SCRIPT_JAVANESE: GUnicodeScript = 84;
pub const GUnicodeScript_G_UNICODE_SCRIPT_KAITHI: GUnicodeScript = 85;
pub const GUnicodeScript_G_UNICODE_SCRIPT_LISU: GUnicodeScript = 86;
pub const GUnicodeScript_G_UNICODE_SCRIPT_MEETEI_MAYEK: GUnicodeScript = 87;
pub const GUnicodeScript_G_UNICODE_SCRIPT_OLD_SOUTH_ARABIAN: GUnicodeScript = 88;
pub const GUnicodeScript_G_UNICODE_SCRIPT_OLD_TURKIC: GUnicodeScript = 89;
pub const GUnicodeScript_G_UNICODE_SCRIPT_SAMARITAN: GUnicodeScript = 90;
pub const GUnicodeScript_G_UNICODE_SCRIPT_TAI_THAM: GUnicodeScript = 91;
pub const GUnicodeScript_G_UNICODE_SCRIPT_TAI_VIET: GUnicodeScript = 92;
pub const GUnicodeScript_G_UNICODE_SCRIPT_BATAK: GUnicodeScript = 93;
pub const GUnicodeScript_G_UNICODE_SCRIPT_BRAHMI: GUnicodeScript = 94;
pub const GUnicodeScript_G_UNICODE_SCRIPT_MANDAIC: GUnicodeScript = 95;
pub const GUnicodeScript_G_UNICODE_SCRIPT_CHAKMA: GUnicodeScript = 96;
pub const GUnicodeScript_G_UNICODE_SCRIPT_MEROITIC_CURSIVE: GUnicodeScript = 97;
pub const GUnicodeScript_G_UNICODE_SCRIPT_MEROITIC_HIEROGLYPHS: GUnicodeScript = 98;
pub const GUnicodeScript_G_UNICODE_SCRIPT_MIAO: GUnicodeScript = 99;
pub const GUnicodeScript_G_UNICODE_SCRIPT_SHARADA: GUnicodeScript = 100;
pub const GUnicodeScript_G_UNICODE_SCRIPT_SORA_SOMPENG: GUnicodeScript = 101;
pub const GUnicodeScript_G_UNICODE_SCRIPT_TAKRI: GUnicodeScript = 102;
pub const GUnicodeScript_G_UNICODE_SCRIPT_BASSA_VAH: GUnicodeScript = 103;
pub const GUnicodeScript_G_UNICODE_SCRIPT_CAUCASIAN_ALBANIAN: GUnicodeScript = 104;
pub const GUnicodeScript_G_UNICODE_SCRIPT_DUPLOYAN: GUnicodeScript = 105;
pub const GUnicodeScript_G_UNICODE_SCRIPT_ELBASAN: GUnicodeScript = 106;
pub const GUnicodeScript_G_UNICODE_SCRIPT_GRANTHA: GUnicodeScript = 107;
pub const GUnicodeScript_G_UNICODE_SCRIPT_KHOJKI: GUnicodeScript = 108;
pub const GUnicodeScript_G_UNICODE_SCRIPT_KHUDAWADI: GUnicodeScript = 109;
pub const GUnicodeScript_G_UNICODE_SCRIPT_LINEAR_A: GUnicodeScript = 110;
pub const GUnicodeScript_G_UNICODE_SCRIPT_MAHAJANI: GUnicodeScript = 111;
pub const GUnicodeScript_G_UNICODE_SCRIPT_MANICHAEAN: GUnicodeScript = 112;
pub const GUnicodeScript_G_UNICODE_SCRIPT_MENDE_KIKAKUI: GUnicodeScript = 113;
pub const GUnicodeScript_G_UNICODE_SCRIPT_MODI: GUnicodeScript = 114;
pub const GUnicodeScript_G_UNICODE_SCRIPT_MRO: GUnicodeScript = 115;
pub const GUnicodeScript_G_UNICODE_SCRIPT_NABATAEAN: GUnicodeScript = 116;
pub const GUnicodeScript_G_UNICODE_SCRIPT_OLD_NORTH_ARABIAN: GUnicodeScript = 117;
pub const GUnicodeScript_G_UNICODE_SCRIPT_OLD_PERMIC: GUnicodeScript = 118;
pub const GUnicodeScript_G_UNICODE_SCRIPT_PAHAWH_HMONG: GUnicodeScript = 119;
pub const GUnicodeScript_G_UNICODE_SCRIPT_PALMYRENE: GUnicodeScript = 120;
pub const GUnicodeScript_G_UNICODE_SCRIPT_PAU_CIN_HAU: GUnicodeScript = 121;
pub const GUnicodeScript_G_UNICODE_SCRIPT_PSALTER_PAHLAVI: GUnicodeScript = 122;
pub const GUnicodeScript_G_UNICODE_SCRIPT_SIDDHAM: GUnicodeScript = 123;
pub const GUnicodeScript_G_UNICODE_SCRIPT_TIRHUTA: GUnicodeScript = 124;
pub const GUnicodeScript_G_UNICODE_SCRIPT_WARANG_CITI: GUnicodeScript = 125;
pub const GUnicodeScript_G_UNICODE_SCRIPT_AHOM: GUnicodeScript = 126;
pub const GUnicodeScript_G_UNICODE_SCRIPT_ANATOLIAN_HIEROGLYPHS: GUnicodeScript = 127;
pub const GUnicodeScript_G_UNICODE_SCRIPT_HATRAN: GUnicodeScript = 128;
pub const GUnicodeScript_G_UNICODE_SCRIPT_MULTANI: GUnicodeScript = 129;
pub const GUnicodeScript_G_UNICODE_SCRIPT_OLD_HUNGARIAN: GUnicodeScript = 130;
pub const GUnicodeScript_G_UNICODE_SCRIPT_SIGNWRITING: GUnicodeScript = 131;
pub const GUnicodeScript_G_UNICODE_SCRIPT_ADLAM: GUnicodeScript = 132;
pub const GUnicodeScript_G_UNICODE_SCRIPT_BHAIKSUKI: GUnicodeScript = 133;
pub const GUnicodeScript_G_UNICODE_SCRIPT_MARCHEN: GUnicodeScript = 134;
pub const GUnicodeScript_G_UNICODE_SCRIPT_NEWA: GUnicodeScript = 135;
pub const GUnicodeScript_G_UNICODE_SCRIPT_OSAGE: GUnicodeScript = 136;
pub const GUnicodeScript_G_UNICODE_SCRIPT_TANGUT: GUnicodeScript = 137;
pub const GUnicodeScript_G_UNICODE_SCRIPT_MASARAM_GONDI: GUnicodeScript = 138;
pub const GUnicodeScript_G_UNICODE_SCRIPT_NUSHU: GUnicodeScript = 139;
pub const GUnicodeScript_G_UNICODE_SCRIPT_SOYOMBO: GUnicodeScript = 140;
pub const GUnicodeScript_G_UNICODE_SCRIPT_ZANABAZAR_SQUARE: GUnicodeScript = 141;
/// GUnicodeScript:
/// @G_UNICODE_SCRIPT_INVALID_CODE:
/// a value never returned from g_unichar_get_script()
/// @G_UNICODE_SCRIPT_COMMON:     a character used by multiple different scripts
/// @G_UNICODE_SCRIPT_INHERITED:  a mark glyph that takes its script from the
/// base glyph to which it is attached
/// @G_UNICODE_SCRIPT_ARABIC:     Arabic
/// @G_UNICODE_SCRIPT_ARMENIAN:   Armenian
/// @G_UNICODE_SCRIPT_BENGALI:    Bengali
/// @G_UNICODE_SCRIPT_BOPOMOFO:   Bopomofo
/// @G_UNICODE_SCRIPT_CHEROKEE:   Cherokee
/// @G_UNICODE_SCRIPT_COPTIC:     Coptic
/// @G_UNICODE_SCRIPT_CYRILLIC:   Cyrillic
/// @G_UNICODE_SCRIPT_DESERET:    Deseret
/// @G_UNICODE_SCRIPT_DEVANAGARI: Devanagari
/// @G_UNICODE_SCRIPT_ETHIOPIC:   Ethiopic
/// @G_UNICODE_SCRIPT_GEORGIAN:   Georgian
/// @G_UNICODE_SCRIPT_GOTHIC:     Gothic
/// @G_UNICODE_SCRIPT_GREEK:      Greek
/// @G_UNICODE_SCRIPT_GUJARATI:   Gujarati
/// @G_UNICODE_SCRIPT_GURMUKHI:   Gurmukhi
/// @G_UNICODE_SCRIPT_HAN:        Han
/// @G_UNICODE_SCRIPT_HANGUL:     Hangul
/// @G_UNICODE_SCRIPT_HEBREW:     Hebrew
/// @G_UNICODE_SCRIPT_HIRAGANA:   Hiragana
/// @G_UNICODE_SCRIPT_KANNADA:    Kannada
/// @G_UNICODE_SCRIPT_KATAKANA:   Katakana
/// @G_UNICODE_SCRIPT_KHMER:      Khmer
/// @G_UNICODE_SCRIPT_LAO:        Lao
/// @G_UNICODE_SCRIPT_LATIN:      Latin
/// @G_UNICODE_SCRIPT_MALAYALAM:  Malayalam
/// @G_UNICODE_SCRIPT_MONGOLIAN:  Mongolian
/// @G_UNICODE_SCRIPT_MYANMAR:    Myanmar
/// @G_UNICODE_SCRIPT_OGHAM:      Ogham
/// @G_UNICODE_SCRIPT_OLD_ITALIC: Old Italic
/// @G_UNICODE_SCRIPT_ORIYA:      Oriya
/// @G_UNICODE_SCRIPT_RUNIC:      Runic
/// @G_UNICODE_SCRIPT_SINHALA:    Sinhala
/// @G_UNICODE_SCRIPT_SYRIAC:     Syriac
/// @G_UNICODE_SCRIPT_TAMIL:      Tamil
/// @G_UNICODE_SCRIPT_TELUGU:     Telugu
/// @G_UNICODE_SCRIPT_THAANA:     Thaana
/// @G_UNICODE_SCRIPT_THAI:       Thai
/// @G_UNICODE_SCRIPT_TIBETAN:    Tibetan
/// @G_UNICODE_SCRIPT_CANADIAN_ABORIGINAL:
/// Canadian Aboriginal
/// @G_UNICODE_SCRIPT_YI:         Yi
/// @G_UNICODE_SCRIPT_TAGALOG:    Tagalog
/// @G_UNICODE_SCRIPT_HANUNOO:    Hanunoo
/// @G_UNICODE_SCRIPT_BUHID:      Buhid
/// @G_UNICODE_SCRIPT_TAGBANWA:   Tagbanwa
/// @G_UNICODE_SCRIPT_BRAILLE:    Braille
/// @G_UNICODE_SCRIPT_CYPRIOT:    Cypriot
/// @G_UNICODE_SCRIPT_LIMBU:      Limbu
/// @G_UNICODE_SCRIPT_OSMANYA:    Osmanya
/// @G_UNICODE_SCRIPT_SHAVIAN:    Shavian
/// @G_UNICODE_SCRIPT_LINEAR_B:   Linear B
/// @G_UNICODE_SCRIPT_TAI_LE:     Tai Le
/// @G_UNICODE_SCRIPT_UGARITIC:   Ugaritic
/// @G_UNICODE_SCRIPT_NEW_TAI_LUE:
/// New Tai Lue
/// @G_UNICODE_SCRIPT_BUGINESE:   Buginese
/// @G_UNICODE_SCRIPT_GLAGOLITIC: Glagolitic
/// @G_UNICODE_SCRIPT_TIFINAGH:   Tifinagh
/// @G_UNICODE_SCRIPT_SYLOTI_NAGRI:
/// Syloti Nagri
/// @G_UNICODE_SCRIPT_OLD_PERSIAN:
/// Old Persian
/// @G_UNICODE_SCRIPT_KHAROSHTHI: Kharoshthi
/// @G_UNICODE_SCRIPT_UNKNOWN:    an unassigned code point
/// @G_UNICODE_SCRIPT_BALINESE:   Balinese
/// @G_UNICODE_SCRIPT_CUNEIFORM:  Cuneiform
/// @G_UNICODE_SCRIPT_PHOENICIAN: Phoenician
/// @G_UNICODE_SCRIPT_PHAGS_PA:   Phags-pa
/// @G_UNICODE_SCRIPT_NKO:        N'Ko
/// @G_UNICODE_SCRIPT_KAYAH_LI:   Kayah Li. Since 2.16.3
/// @G_UNICODE_SCRIPT_LEPCHA:     Lepcha. Since 2.16.3
/// @G_UNICODE_SCRIPT_REJANG:     Rejang. Since 2.16.3
/// @G_UNICODE_SCRIPT_SUNDANESE:  Sundanese. Since 2.16.3
/// @G_UNICODE_SCRIPT_SAURASHTRA: Saurashtra. Since 2.16.3
/// @G_UNICODE_SCRIPT_CHAM:       Cham. Since 2.16.3
/// @G_UNICODE_SCRIPT_OL_CHIKI:   Ol Chiki. Since 2.16.3
/// @G_UNICODE_SCRIPT_VAI:        Vai. Since 2.16.3
/// @G_UNICODE_SCRIPT_CARIAN:     Carian. Since 2.16.3
/// @G_UNICODE_SCRIPT_LYCIAN:     Lycian. Since 2.16.3
/// @G_UNICODE_SCRIPT_LYDIAN:     Lydian. Since 2.16.3
/// @G_UNICODE_SCRIPT_AVESTAN:    Avestan. Since 2.26
/// @G_UNICODE_SCRIPT_BAMUM:      Bamum. Since 2.26
/// @G_UNICODE_SCRIPT_EGYPTIAN_HIEROGLYPHS:
/// Egyptian Hieroglpyhs. Since 2.26
/// @G_UNICODE_SCRIPT_IMPERIAL_ARAMAIC:
/// Imperial Aramaic. Since 2.26
/// @G_UNICODE_SCRIPT_INSCRIPTIONAL_PAHLAVI:
/// Inscriptional Pahlavi. Since 2.26
/// @G_UNICODE_SCRIPT_INSCRIPTIONAL_PARTHIAN:
/// Inscriptional Parthian. Since 2.26
/// @G_UNICODE_SCRIPT_JAVANESE:   Javanese. Since 2.26
/// @G_UNICODE_SCRIPT_KAITHI:     Kaithi. Since 2.26
/// @G_UNICODE_SCRIPT_LISU:       Lisu. Since 2.26
/// @G_UNICODE_SCRIPT_MEETEI_MAYEK:
/// Meetei Mayek. Since 2.26
/// @G_UNICODE_SCRIPT_OLD_SOUTH_ARABIAN:
/// Old South Arabian. Since 2.26
/// @G_UNICODE_SCRIPT_OLD_TURKIC: Old Turkic. Since 2.28
/// @G_UNICODE_SCRIPT_SAMARITAN:  Samaritan. Since 2.26
/// @G_UNICODE_SCRIPT_TAI_THAM:   Tai Tham. Since 2.26
/// @G_UNICODE_SCRIPT_TAI_VIET:   Tai Viet. Since 2.26
/// @G_UNICODE_SCRIPT_BATAK:      Batak. Since 2.28
/// @G_UNICODE_SCRIPT_BRAHMI:     Brahmi. Since 2.28
/// @G_UNICODE_SCRIPT_MANDAIC:    Mandaic. Since 2.28
/// @G_UNICODE_SCRIPT_CHAKMA:               Chakma. Since: 2.32
/// @G_UNICODE_SCRIPT_MEROITIC_CURSIVE:     Meroitic Cursive. Since: 2.32
/// @G_UNICODE_SCRIPT_MEROITIC_HIEROGLYPHS: Meroitic Hieroglyphs. Since: 2.32
/// @G_UNICODE_SCRIPT_MIAO:                 Miao. Since: 2.32
/// @G_UNICODE_SCRIPT_SHARADA:              Sharada. Since: 2.32
/// @G_UNICODE_SCRIPT_SORA_SOMPENG:         Sora Sompeng. Since: 2.32
/// @G_UNICODE_SCRIPT_TAKRI:                Takri. Since: 2.32
/// @G_UNICODE_SCRIPT_BASSA_VAH:            Bassa. Since: 2.42
/// @G_UNICODE_SCRIPT_CAUCASIAN_ALBANIAN:   Caucasian Albanian. Since: 2.42
/// @G_UNICODE_SCRIPT_DUPLOYAN:             Duployan. Since: 2.42
/// @G_UNICODE_SCRIPT_ELBASAN:              Elbasan. Since: 2.42
/// @G_UNICODE_SCRIPT_GRANTHA:              Grantha. Since: 2.42
/// @G_UNICODE_SCRIPT_KHOJKI:               Kjohki. Since: 2.42
/// @G_UNICODE_SCRIPT_KHUDAWADI:            Khudawadi, Sindhi. Since: 2.42
/// @G_UNICODE_SCRIPT_LINEAR_A:             Linear A. Since: 2.42
/// @G_UNICODE_SCRIPT_MAHAJANI:             Mahajani. Since: 2.42
/// @G_UNICODE_SCRIPT_MANICHAEAN:           Manichaean. Since: 2.42
/// @G_UNICODE_SCRIPT_MENDE_KIKAKUI:        Mende Kikakui. Since: 2.42
/// @G_UNICODE_SCRIPT_MODI:                 Modi. Since: 2.42
/// @G_UNICODE_SCRIPT_MRO:                  Mro. Since: 2.42
/// @G_UNICODE_SCRIPT_NABATAEAN:            Nabataean. Since: 2.42
/// @G_UNICODE_SCRIPT_OLD_NORTH_ARABIAN:    Old North Arabian. Since: 2.42
/// @G_UNICODE_SCRIPT_OLD_PERMIC:           Old Permic. Since: 2.42
/// @G_UNICODE_SCRIPT_PAHAWH_HMONG:         Pahawh Hmong. Since: 2.42
/// @G_UNICODE_SCRIPT_PALMYRENE:            Palmyrene. Since: 2.42
/// @G_UNICODE_SCRIPT_PAU_CIN_HAU:          Pau Cin Hau. Since: 2.42
/// @G_UNICODE_SCRIPT_PSALTER_PAHLAVI:      Psalter Pahlavi. Since: 2.42
/// @G_UNICODE_SCRIPT_SIDDHAM:              Siddham. Since: 2.42
/// @G_UNICODE_SCRIPT_TIRHUTA:              Tirhuta. Since: 2.42
/// @G_UNICODE_SCRIPT_WARANG_CITI:          Warang Citi. Since: 2.42
/// @G_UNICODE_SCRIPT_AHOM:                 Ahom. Since: 2.48
/// @G_UNICODE_SCRIPT_ANATOLIAN_HIEROGLYPHS: Anatolian Hieroglyphs. Since: 2.48
/// @G_UNICODE_SCRIPT_HATRAN:               Hatran. Since: 2.48
/// @G_UNICODE_SCRIPT_MULTANI:              Multani. Since: 2.48
/// @G_UNICODE_SCRIPT_OLD_HUNGARIAN:        Old Hungarian. Since: 2.48
/// @G_UNICODE_SCRIPT_SIGNWRITING:          Signwriting. Since: 2.48
/// @G_UNICODE_SCRIPT_ADLAM:                Adlam. Since: 2.50
/// @G_UNICODE_SCRIPT_BHAIKSUKI:            Bhaiksuki. Since: 2.50
/// @G_UNICODE_SCRIPT_MARCHEN:              Marchen. Since: 2.50
/// @G_UNICODE_SCRIPT_NEWA:                 Newa. Since: 2.50
/// @G_UNICODE_SCRIPT_OSAGE:                Osage. Since: 2.50
/// @G_UNICODE_SCRIPT_TANGUT:               Tangut. Since: 2.50
/// @G_UNICODE_SCRIPT_MASARAM_GONDI,        Masaram Gondi. Since: 2.54
/// @G_UNICODE_SCRIPT_NUSHU,                Nushu. Since: 2.54
/// @G_UNICODE_SCRIPT_SOYOMBO,              Soyombo. Since: 2.54
/// @G_UNICODE_SCRIPT_ZANABAZAR_SQUARE      Zanabazar Square. Since: 2.54
///
/// The #GUnicodeScript enumeration identifies different writing
/// systems. The values correspond to the names as defined in the
/// Unicode standard. The enumeration has been added in GLib 2.14,
/// and is interchangeable with #PangoScript.
///
/// Note that new types may be added in the future. Applications
/// should be ready to handle unknown values.
/// See [Unicode Standard Annex #24: Script names](http://www.unicode.org/reports/tr24/).
pub type GUnicodeScript = i32;
extern "C" {
    #[link_name = "\u{1}_g_unicode_script_to_iso15924"]
    pub fn g_unicode_script_to_iso15924(script: GUnicodeScript) -> guint32;
}
extern "C" {
    #[link_name = "\u{1}_g_unicode_script_from_iso15924"]
    pub fn g_unicode_script_from_iso15924(iso15924: guint32) -> GUnicodeScript;
}
extern "C" {
    #[link_name = "\u{1}_g_unichar_isalnum"]
    pub fn g_unichar_isalnum(c: gunichar) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_unichar_isalpha"]
    pub fn g_unichar_isalpha(c: gunichar) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_unichar_iscntrl"]
    pub fn g_unichar_iscntrl(c: gunichar) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_unichar_isdigit"]
    pub fn g_unichar_isdigit(c: gunichar) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_unichar_isgraph"]
    pub fn g_unichar_isgraph(c: gunichar) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_unichar_islower"]
    pub fn g_unichar_islower(c: gunichar) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_unichar_isprint"]
    pub fn g_unichar_isprint(c: gunichar) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_unichar_ispunct"]
    pub fn g_unichar_ispunct(c: gunichar) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_unichar_isspace"]
    pub fn g_unichar_isspace(c: gunichar) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_unichar_isupper"]
    pub fn g_unichar_isupper(c: gunichar) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_unichar_isxdigit"]
    pub fn g_unichar_isxdigit(c: gunichar) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_unichar_istitle"]
    pub fn g_unichar_istitle(c: gunichar) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_unichar_isdefined"]
    pub fn g_unichar_isdefined(c: gunichar) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_unichar_iswide"]
    pub fn g_unichar_iswide(c: gunichar) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_unichar_iswide_cjk"]
    pub fn g_unichar_iswide_cjk(c: gunichar) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_unichar_iszerowidth"]
    pub fn g_unichar_iszerowidth(c: gunichar) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_unichar_ismark"]
    pub fn g_unichar_ismark(c: gunichar) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_unichar_toupper"]
    pub fn g_unichar_toupper(c: gunichar) -> gunichar;
}
extern "C" {
    #[link_name = "\u{1}_g_unichar_tolower"]
    pub fn g_unichar_tolower(c: gunichar) -> gunichar;
}
extern "C" {
    #[link_name = "\u{1}_g_unichar_totitle"]
    pub fn g_unichar_totitle(c: gunichar) -> gunichar;
}
extern "C" {
    #[link_name = "\u{1}_g_unichar_digit_value"]
    pub fn g_unichar_digit_value(c: gunichar) -> gint;
}
extern "C" {
    #[link_name = "\u{1}_g_unichar_xdigit_value"]
    pub fn g_unichar_xdigit_value(c: gunichar) -> gint;
}
extern "C" {
    #[link_name = "\u{1}_g_unichar_type"]
    pub fn g_unichar_type(c: gunichar) -> GUnicodeType;
}
extern "C" {
    #[link_name = "\u{1}_g_unichar_break_type"]
    pub fn g_unichar_break_type(c: gunichar) -> GUnicodeBreakType;
}
extern "C" {
    #[link_name = "\u{1}_g_unichar_combining_class"]
    pub fn g_unichar_combining_class(uc: gunichar) -> gint;
}
extern "C" {
    #[link_name = "\u{1}_g_unichar_get_mirror_char"]
    pub fn g_unichar_get_mirror_char(ch: gunichar, mirrored_ch: *mut gunichar) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_unichar_get_script"]
    pub fn g_unichar_get_script(ch: gunichar) -> GUnicodeScript;
}
extern "C" {
    #[link_name = "\u{1}_g_unichar_validate"]
    pub fn g_unichar_validate(ch: gunichar) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_unichar_compose"]
    pub fn g_unichar_compose(a: gunichar, b: gunichar, ch: *mut gunichar) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_unichar_decompose"]
    pub fn g_unichar_decompose(ch: gunichar, a: *mut gunichar, b: *mut gunichar) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_unichar_fully_decompose"]
    pub fn g_unichar_fully_decompose(
        ch: gunichar,
        compat: gboolean,
        result: *mut gunichar,
        result_len: gsize,
    ) -> gsize;
}
extern "C" {
    #[link_name = "\u{1}_g_unicode_canonical_ordering"]
    pub fn g_unicode_canonical_ordering(string: *mut gunichar, len: gsize);
}
extern "C" {
    #[link_name = "\u{1}_g_unicode_canonical_decomposition"]
    pub fn g_unicode_canonical_decomposition(ch: gunichar, result_len: *mut gsize)
        -> *mut gunichar;
}
extern "C" {
    #[link_name = "\u{1}_g_utf8_skip"]
    pub static mut g_utf8_skip: *const gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_utf8_get_char"]
    pub fn g_utf8_get_char(p: *const gchar) -> gunichar;
}
extern "C" {
    #[link_name = "\u{1}_g_utf8_get_char_validated"]
    pub fn g_utf8_get_char_validated(p: *const gchar, max_len: gssize) -> gunichar;
}
extern "C" {
    #[link_name = "\u{1}_g_utf8_offset_to_pointer"]
    pub fn g_utf8_offset_to_pointer(str: *const gchar, offset: glong) -> *mut gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_utf8_pointer_to_offset"]
    pub fn g_utf8_pointer_to_offset(str: *const gchar, pos: *const gchar) -> glong;
}
extern "C" {
    #[link_name = "\u{1}_g_utf8_prev_char"]
    pub fn g_utf8_prev_char(p: *const gchar) -> *mut gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_utf8_find_next_char"]
    pub fn g_utf8_find_next_char(p: *const gchar, end: *const gchar) -> *mut gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_utf8_find_prev_char"]
    pub fn g_utf8_find_prev_char(str: *const gchar, p: *const gchar) -> *mut gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_utf8_strlen"]
    pub fn g_utf8_strlen(p: *const gchar, max: gssize) -> glong;
}
extern "C" {
    #[link_name = "\u{1}_g_utf8_substring"]
    pub fn g_utf8_substring(str: *const gchar, start_pos: glong, end_pos: glong) -> *mut gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_utf8_strncpy"]
    pub fn g_utf8_strncpy(dest: *mut gchar, src: *const gchar, n: gsize) -> *mut gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_utf8_strchr"]
    pub fn g_utf8_strchr(p: *const gchar, len: gssize, c: gunichar) -> *mut gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_utf8_strrchr"]
    pub fn g_utf8_strrchr(p: *const gchar, len: gssize, c: gunichar) -> *mut gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_utf8_strreverse"]
    pub fn g_utf8_strreverse(str: *const gchar, len: gssize) -> *mut gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_utf8_to_utf16"]
    pub fn g_utf8_to_utf16(
        str: *const gchar,
        len: glong,
        items_read: *mut glong,
        items_written: *mut glong,
        error: *mut *mut GError,
    ) -> *mut gunichar2;
}
extern "C" {
    #[link_name = "\u{1}_g_utf8_to_ucs4"]
    pub fn g_utf8_to_ucs4(
        str: *const gchar,
        len: glong,
        items_read: *mut glong,
        items_written: *mut glong,
        error: *mut *mut GError,
    ) -> *mut gunichar;
}
extern "C" {
    #[link_name = "\u{1}_g_utf8_to_ucs4_fast"]
    pub fn g_utf8_to_ucs4_fast(
        str: *const gchar,
        len: glong,
        items_written: *mut glong,
    ) -> *mut gunichar;
}
extern "C" {
    #[link_name = "\u{1}_g_utf16_to_ucs4"]
    pub fn g_utf16_to_ucs4(
        str: *const gunichar2,
        len: glong,
        items_read: *mut glong,
        items_written: *mut glong,
        error: *mut *mut GError,
    ) -> *mut gunichar;
}
extern "C" {
    #[link_name = "\u{1}_g_utf16_to_utf8"]
    pub fn g_utf16_to_utf8(
        str: *const gunichar2,
        len: glong,
        items_read: *mut glong,
        items_written: *mut glong,
        error: *mut *mut GError,
    ) -> *mut gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_ucs4_to_utf16"]
    pub fn g_ucs4_to_utf16(
        str: *const gunichar,
        len: glong,
        items_read: *mut glong,
        items_written: *mut glong,
        error: *mut *mut GError,
    ) -> *mut gunichar2;
}
extern "C" {
    #[link_name = "\u{1}_g_ucs4_to_utf8"]
    pub fn g_ucs4_to_utf8(
        str: *const gunichar,
        len: glong,
        items_read: *mut glong,
        items_written: *mut glong,
        error: *mut *mut GError,
    ) -> *mut gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_unichar_to_utf8"]
    pub fn g_unichar_to_utf8(c: gunichar, outbuf: *mut gchar) -> gint;
}
extern "C" {
    #[link_name = "\u{1}_g_utf8_validate"]
    pub fn g_utf8_validate(str: *const gchar, max_len: gssize, end: *mut *const gchar) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_utf8_strup"]
    pub fn g_utf8_strup(str: *const gchar, len: gssize) -> *mut gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_utf8_strdown"]
    pub fn g_utf8_strdown(str: *const gchar, len: gssize) -> *mut gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_utf8_casefold"]
    pub fn g_utf8_casefold(str: *const gchar, len: gssize) -> *mut gchar;
}
pub const GNormalizeMode_G_NORMALIZE_DEFAULT: GNormalizeMode = 0;
pub const GNormalizeMode_G_NORMALIZE_NFD: GNormalizeMode = 0;
pub const GNormalizeMode_G_NORMALIZE_DEFAULT_COMPOSE: GNormalizeMode = 1;
pub const GNormalizeMode_G_NORMALIZE_NFC: GNormalizeMode = 1;
pub const GNormalizeMode_G_NORMALIZE_ALL: GNormalizeMode = 2;
pub const GNormalizeMode_G_NORMALIZE_NFKD: GNormalizeMode = 2;
pub const GNormalizeMode_G_NORMALIZE_ALL_COMPOSE: GNormalizeMode = 3;
pub const GNormalizeMode_G_NORMALIZE_NFKC: GNormalizeMode = 3;
/// GNormalizeMode:
/// @G_NORMALIZE_DEFAULT: standardize differences that do not affect the
/// text content, such as the above-mentioned accent representation
/// @G_NORMALIZE_NFD: another name for %G_NORMALIZE_DEFAULT
/// @G_NORMALIZE_DEFAULT_COMPOSE: like %G_NORMALIZE_DEFAULT, but with
/// composed forms rather than a maximally decomposed form
/// @G_NORMALIZE_NFC: another name for %G_NORMALIZE_DEFAULT_COMPOSE
/// @G_NORMALIZE_ALL: beyond %G_NORMALIZE_DEFAULT also standardize the
/// "compatibility" characters in Unicode, such as SUPERSCRIPT THREE
/// to the standard forms (in this case DIGIT THREE). Formatting
/// information may be lost but for most text operations such
/// characters should be considered the same
/// @G_NORMALIZE_NFKD: another name for %G_NORMALIZE_ALL
/// @G_NORMALIZE_ALL_COMPOSE: like %G_NORMALIZE_ALL, but with composed
/// forms rather than a maximally decomposed form
/// @G_NORMALIZE_NFKC: another name for %G_NORMALIZE_ALL_COMPOSE
///
/// Defines how a Unicode string is transformed in a canonical
/// form, standardizing such issues as whether a character with
/// an accent is represented as a base character and combining
/// accent or as a single precomposed character. Unicode strings
/// should generally be normalized before comparing them.
pub type GNormalizeMode = u32;
extern "C" {
    #[link_name = "\u{1}_g_utf8_normalize"]
    pub fn g_utf8_normalize(str: *const gchar, len: gssize, mode: GNormalizeMode) -> *mut gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_utf8_collate"]
    pub fn g_utf8_collate(str1: *const gchar, str2: *const gchar) -> gint;
}
extern "C" {
    #[link_name = "\u{1}_g_utf8_collate_key"]
    pub fn g_utf8_collate_key(str: *const gchar, len: gssize) -> *mut gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_utf8_collate_key_for_filename"]
    pub fn g_utf8_collate_key_for_filename(str: *const gchar, len: gssize) -> *mut gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_utf8_make_valid"]
    pub fn g_utf8_make_valid(str: *const gchar, len: gssize) -> *mut gchar;
}
pub type GString = _GString;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GString {
    pub str: *mut gchar,
    pub len: gsize,
    pub allocated_len: gsize,
}
#[test]
fn bindgen_test_layout__GString() {
    assert_eq!(
        ::std::mem::size_of::<_GString>(),
        24usize,
        concat!("Size of: ", stringify!(_GString))
    );
    assert_eq!(
        ::std::mem::align_of::<_GString>(),
        8usize,
        concat!("Alignment of ", stringify!(_GString))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GString>())).str as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GString),
            "::",
            stringify!(str)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GString>())).len as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GString),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GString>())).allocated_len as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GString),
            "::",
            stringify!(allocated_len)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_g_string_new"]
    pub fn g_string_new(init: *const gchar) -> *mut GString;
}
extern "C" {
    #[link_name = "\u{1}_g_string_new_len"]
    pub fn g_string_new_len(init: *const gchar, len: gssize) -> *mut GString;
}
extern "C" {
    #[link_name = "\u{1}_g_string_sized_new"]
    pub fn g_string_sized_new(dfl_size: gsize) -> *mut GString;
}
extern "C" {
    #[link_name = "\u{1}_g_string_free"]
    pub fn g_string_free(string: *mut GString, free_segment: gboolean) -> *mut gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_string_free_to_bytes"]
    pub fn g_string_free_to_bytes(string: *mut GString) -> *mut GBytes;
}
extern "C" {
    #[link_name = "\u{1}_g_string_equal"]
    pub fn g_string_equal(v: *const GString, v2: *const GString) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_string_hash"]
    pub fn g_string_hash(str: *const GString) -> guint;
}
extern "C" {
    #[link_name = "\u{1}_g_string_assign"]
    pub fn g_string_assign(string: *mut GString, rval: *const gchar) -> *mut GString;
}
extern "C" {
    #[link_name = "\u{1}_g_string_truncate"]
    pub fn g_string_truncate(string: *mut GString, len: gsize) -> *mut GString;
}
extern "C" {
    #[link_name = "\u{1}_g_string_set_size"]
    pub fn g_string_set_size(string: *mut GString, len: gsize) -> *mut GString;
}
extern "C" {
    #[link_name = "\u{1}_g_string_insert_len"]
    pub fn g_string_insert_len(
        string: *mut GString,
        pos: gssize,
        val: *const gchar,
        len: gssize,
    ) -> *mut GString;
}
extern "C" {
    #[link_name = "\u{1}_g_string_append"]
    pub fn g_string_append(string: *mut GString, val: *const gchar) -> *mut GString;
}
extern "C" {
    #[link_name = "\u{1}_g_string_append_len"]
    pub fn g_string_append_len(
        string: *mut GString,
        val: *const gchar,
        len: gssize,
    ) -> *mut GString;
}
extern "C" {
    #[link_name = "\u{1}_g_string_append_c"]
    pub fn g_string_append_c(string: *mut GString, c: gchar) -> *mut GString;
}
extern "C" {
    #[link_name = "\u{1}_g_string_append_unichar"]
    pub fn g_string_append_unichar(string: *mut GString, wc: gunichar) -> *mut GString;
}
extern "C" {
    #[link_name = "\u{1}_g_string_prepend"]
    pub fn g_string_prepend(string: *mut GString, val: *const gchar) -> *mut GString;
}
extern "C" {
    #[link_name = "\u{1}_g_string_prepend_c"]
    pub fn g_string_prepend_c(string: *mut GString, c: gchar) -> *mut GString;
}
extern "C" {
    #[link_name = "\u{1}_g_string_prepend_unichar"]
    pub fn g_string_prepend_unichar(string: *mut GString, wc: gunichar) -> *mut GString;
}
extern "C" {
    #[link_name = "\u{1}_g_string_prepend_len"]
    pub fn g_string_prepend_len(
        string: *mut GString,
        val: *const gchar,
        len: gssize,
    ) -> *mut GString;
}
extern "C" {
    #[link_name = "\u{1}_g_string_insert"]
    pub fn g_string_insert(string: *mut GString, pos: gssize, val: *const gchar) -> *mut GString;
}
extern "C" {
    #[link_name = "\u{1}_g_string_insert_c"]
    pub fn g_string_insert_c(string: *mut GString, pos: gssize, c: gchar) -> *mut GString;
}
extern "C" {
    #[link_name = "\u{1}_g_string_insert_unichar"]
    pub fn g_string_insert_unichar(string: *mut GString, pos: gssize, wc: gunichar)
        -> *mut GString;
}
extern "C" {
    #[link_name = "\u{1}_g_string_overwrite"]
    pub fn g_string_overwrite(string: *mut GString, pos: gsize, val: *const gchar) -> *mut GString;
}
extern "C" {
    #[link_name = "\u{1}_g_string_overwrite_len"]
    pub fn g_string_overwrite_len(
        string: *mut GString,
        pos: gsize,
        val: *const gchar,
        len: gssize,
    ) -> *mut GString;
}
extern "C" {
    #[link_name = "\u{1}_g_string_erase"]
    pub fn g_string_erase(string: *mut GString, pos: gssize, len: gssize) -> *mut GString;
}
extern "C" {
    #[link_name = "\u{1}_g_string_ascii_down"]
    pub fn g_string_ascii_down(string: *mut GString) -> *mut GString;
}
extern "C" {
    #[link_name = "\u{1}_g_string_ascii_up"]
    pub fn g_string_ascii_up(string: *mut GString) -> *mut GString;
}
extern "C" {
    #[link_name = "\u{1}_g_string_vprintf"]
    pub fn g_string_vprintf(string: *mut GString, format: *const gchar, args: *mut __va_list_tag);
}
extern "C" {
    #[link_name = "\u{1}_g_string_printf"]
    pub fn g_string_printf(string: *mut GString, format: *const gchar, ...);
}
extern "C" {
    #[link_name = "\u{1}_g_string_append_vprintf"]
    pub fn g_string_append_vprintf(
        string: *mut GString,
        format: *const gchar,
        args: *mut __va_list_tag,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_string_append_printf"]
    pub fn g_string_append_printf(string: *mut GString, format: *const gchar, ...);
}
extern "C" {
    #[link_name = "\u{1}_g_string_append_uri_escaped"]
    pub fn g_string_append_uri_escaped(
        string: *mut GString,
        unescaped: *const gchar,
        reserved_chars_allowed: *const gchar,
        allow_utf8: gboolean,
    ) -> *mut GString;
}
extern "C" {
    #[link_name = "\u{1}_g_string_down"]
    pub fn g_string_down(string: *mut GString) -> *mut GString;
}
extern "C" {
    #[link_name = "\u{1}_g_string_up"]
    pub fn g_string_up(string: *mut GString) -> *mut GString;
}
pub type GIOChannel = _GIOChannel;
pub type GIOFuncs = _GIOFuncs;
pub const GIOError_G_IO_ERROR_NONE: GIOError = 0;
pub const GIOError_G_IO_ERROR_AGAIN: GIOError = 1;
pub const GIOError_G_IO_ERROR_INVAL: GIOError = 2;
pub const GIOError_G_IO_ERROR_UNKNOWN: GIOError = 3;
pub type GIOError = u32;
pub const GIOChannelError_G_IO_CHANNEL_ERROR_FBIG: GIOChannelError = 0;
pub const GIOChannelError_G_IO_CHANNEL_ERROR_INVAL: GIOChannelError = 1;
pub const GIOChannelError_G_IO_CHANNEL_ERROR_IO: GIOChannelError = 2;
pub const GIOChannelError_G_IO_CHANNEL_ERROR_ISDIR: GIOChannelError = 3;
pub const GIOChannelError_G_IO_CHANNEL_ERROR_NOSPC: GIOChannelError = 4;
pub const GIOChannelError_G_IO_CHANNEL_ERROR_NXIO: GIOChannelError = 5;
pub const GIOChannelError_G_IO_CHANNEL_ERROR_OVERFLOW: GIOChannelError = 6;
pub const GIOChannelError_G_IO_CHANNEL_ERROR_PIPE: GIOChannelError = 7;
pub const GIOChannelError_G_IO_CHANNEL_ERROR_FAILED: GIOChannelError = 8;
pub type GIOChannelError = u32;
pub const GIOStatus_G_IO_STATUS_ERROR: GIOStatus = 0;
pub const GIOStatus_G_IO_STATUS_NORMAL: GIOStatus = 1;
pub const GIOStatus_G_IO_STATUS_EOF: GIOStatus = 2;
pub const GIOStatus_G_IO_STATUS_AGAIN: GIOStatus = 3;
pub type GIOStatus = u32;
pub const GSeekType_G_SEEK_CUR: GSeekType = 0;
pub const GSeekType_G_SEEK_SET: GSeekType = 1;
pub const GSeekType_G_SEEK_END: GSeekType = 2;
pub type GSeekType = u32;
pub const GIOFlags_G_IO_FLAG_APPEND: GIOFlags = 1;
pub const GIOFlags_G_IO_FLAG_NONBLOCK: GIOFlags = 2;
pub const GIOFlags_G_IO_FLAG_IS_READABLE: GIOFlags = 4;
pub const GIOFlags_G_IO_FLAG_IS_WRITABLE: GIOFlags = 8;
pub const GIOFlags_G_IO_FLAG_IS_WRITEABLE: GIOFlags = 8;
pub const GIOFlags_G_IO_FLAG_IS_SEEKABLE: GIOFlags = 16;
pub const GIOFlags_G_IO_FLAG_MASK: GIOFlags = 31;
pub const GIOFlags_G_IO_FLAG_GET_MASK: GIOFlags = 31;
pub const GIOFlags_G_IO_FLAG_SET_MASK: GIOFlags = 3;
pub type GIOFlags = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GIOChannel {
    pub ref_count: gint,
    pub funcs: *mut GIOFuncs,
    pub encoding: *mut gchar,
    pub read_cd: GIConv,
    pub write_cd: GIConv,
    pub line_term: *mut gchar,
    pub line_term_len: guint,
    pub buf_size: gsize,
    pub read_buf: *mut GString,
    pub encoded_read_buf: *mut GString,
    pub write_buf: *mut GString,
    pub partial_write_buf: [gchar; 6usize],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub reserved1: gpointer,
    pub reserved2: gpointer,
}
#[test]
fn bindgen_test_layout__GIOChannel() {
    assert_eq!(
        ::std::mem::size_of::<_GIOChannel>(),
        112usize,
        concat!("Size of: ", stringify!(_GIOChannel))
    );
    assert_eq!(
        ::std::mem::align_of::<_GIOChannel>(),
        8usize,
        concat!("Alignment of ", stringify!(_GIOChannel))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GIOChannel>())).ref_count as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GIOChannel),
            "::",
            stringify!(ref_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GIOChannel>())).funcs as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GIOChannel),
            "::",
            stringify!(funcs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GIOChannel>())).encoding as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GIOChannel),
            "::",
            stringify!(encoding)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GIOChannel>())).read_cd as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GIOChannel),
            "::",
            stringify!(read_cd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GIOChannel>())).write_cd as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_GIOChannel),
            "::",
            stringify!(write_cd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GIOChannel>())).line_term as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_GIOChannel),
            "::",
            stringify!(line_term)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GIOChannel>())).line_term_len as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_GIOChannel),
            "::",
            stringify!(line_term_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GIOChannel>())).buf_size as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_GIOChannel),
            "::",
            stringify!(buf_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GIOChannel>())).read_buf as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_GIOChannel),
            "::",
            stringify!(read_buf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GIOChannel>())).encoded_read_buf as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_GIOChannel),
            "::",
            stringify!(encoded_read_buf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GIOChannel>())).write_buf as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_GIOChannel),
            "::",
            stringify!(write_buf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GIOChannel>())).partial_write_buf as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_GIOChannel),
            "::",
            stringify!(partial_write_buf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GIOChannel>())).reserved1 as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_GIOChannel),
            "::",
            stringify!(reserved1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GIOChannel>())).reserved2 as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_GIOChannel),
            "::",
            stringify!(reserved2)
        )
    );
}
impl _GIOChannel {
    #[inline]
    pub fn use_buffer(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_use_buffer(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn do_encode(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_do_encode(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn close_on_unref(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_close_on_unref(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn is_readable(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is_readable(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn is_writeable(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is_writeable(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn is_seekable(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is_seekable(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        use_buffer: guint,
        do_encode: guint,
        close_on_unref: guint,
        is_readable: guint,
        is_writeable: guint,
        is_seekable: guint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let use_buffer: u32 = unsafe { ::std::mem::transmute(use_buffer) };
            use_buffer as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let do_encode: u32 = unsafe { ::std::mem::transmute(do_encode) };
            do_encode as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let close_on_unref: u32 = unsafe { ::std::mem::transmute(close_on_unref) };
            close_on_unref as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let is_readable: u32 = unsafe { ::std::mem::transmute(is_readable) };
            is_readable as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let is_writeable: u32 = unsafe { ::std::mem::transmute(is_writeable) };
            is_writeable as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let is_seekable: u32 = unsafe { ::std::mem::transmute(is_seekable) };
            is_seekable as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type GIOFunc = ::std::option::Option<
    unsafe extern "C" fn(source: *mut GIOChannel, condition: GIOCondition, data: gpointer)
        -> gboolean,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GIOFuncs {
    pub io_read: ::std::option::Option<
        unsafe extern "C" fn(
            channel: *mut GIOChannel,
            buf: *mut gchar,
            count: gsize,
            bytes_read: *mut gsize,
            err: *mut *mut GError,
        ) -> GIOStatus,
    >,
    pub io_write: ::std::option::Option<
        unsafe extern "C" fn(
            channel: *mut GIOChannel,
            buf: *const gchar,
            count: gsize,
            bytes_written: *mut gsize,
            err: *mut *mut GError,
        ) -> GIOStatus,
    >,
    pub io_seek: ::std::option::Option<
        unsafe extern "C" fn(
            channel: *mut GIOChannel,
            offset: gint64,
            type_: GSeekType,
            err: *mut *mut GError,
        ) -> GIOStatus,
    >,
    pub io_close: ::std::option::Option<
        unsafe extern "C" fn(channel: *mut GIOChannel, err: *mut *mut GError) -> GIOStatus,
    >,
    pub io_create_watch: ::std::option::Option<
        unsafe extern "C" fn(channel: *mut GIOChannel, condition: GIOCondition) -> *mut GSource,
    >,
    pub io_free: ::std::option::Option<unsafe extern "C" fn(channel: *mut GIOChannel)>,
    pub io_set_flags: ::std::option::Option<
        unsafe extern "C" fn(channel: *mut GIOChannel, flags: GIOFlags, err: *mut *mut GError)
            -> GIOStatus,
    >,
    pub io_get_flags:
        ::std::option::Option<unsafe extern "C" fn(channel: *mut GIOChannel) -> GIOFlags>,
}
#[test]
fn bindgen_test_layout__GIOFuncs() {
    assert_eq!(
        ::std::mem::size_of::<_GIOFuncs>(),
        64usize,
        concat!("Size of: ", stringify!(_GIOFuncs))
    );
    assert_eq!(
        ::std::mem::align_of::<_GIOFuncs>(),
        8usize,
        concat!("Alignment of ", stringify!(_GIOFuncs))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GIOFuncs>())).io_read as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GIOFuncs),
            "::",
            stringify!(io_read)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GIOFuncs>())).io_write as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GIOFuncs),
            "::",
            stringify!(io_write)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GIOFuncs>())).io_seek as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GIOFuncs),
            "::",
            stringify!(io_seek)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GIOFuncs>())).io_close as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GIOFuncs),
            "::",
            stringify!(io_close)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GIOFuncs>())).io_create_watch as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_GIOFuncs),
            "::",
            stringify!(io_create_watch)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GIOFuncs>())).io_free as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_GIOFuncs),
            "::",
            stringify!(io_free)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GIOFuncs>())).io_set_flags as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_GIOFuncs),
            "::",
            stringify!(io_set_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GIOFuncs>())).io_get_flags as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_GIOFuncs),
            "::",
            stringify!(io_get_flags)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_g_io_channel_init"]
    pub fn g_io_channel_init(channel: *mut GIOChannel);
}
extern "C" {
    #[link_name = "\u{1}_g_io_channel_ref"]
    pub fn g_io_channel_ref(channel: *mut GIOChannel) -> *mut GIOChannel;
}
extern "C" {
    #[link_name = "\u{1}_g_io_channel_unref"]
    pub fn g_io_channel_unref(channel: *mut GIOChannel);
}
extern "C" {
    #[link_name = "\u{1}_g_io_channel_read"]
    pub fn g_io_channel_read(
        channel: *mut GIOChannel,
        buf: *mut gchar,
        count: gsize,
        bytes_read: *mut gsize,
    ) -> GIOError;
}
extern "C" {
    #[link_name = "\u{1}_g_io_channel_write"]
    pub fn g_io_channel_write(
        channel: *mut GIOChannel,
        buf: *const gchar,
        count: gsize,
        bytes_written: *mut gsize,
    ) -> GIOError;
}
extern "C" {
    #[link_name = "\u{1}_g_io_channel_seek"]
    pub fn g_io_channel_seek(
        channel: *mut GIOChannel,
        offset: gint64,
        type_: GSeekType,
    ) -> GIOError;
}
extern "C" {
    #[link_name = "\u{1}_g_io_channel_close"]
    pub fn g_io_channel_close(channel: *mut GIOChannel);
}
extern "C" {
    #[link_name = "\u{1}_g_io_channel_shutdown"]
    pub fn g_io_channel_shutdown(
        channel: *mut GIOChannel,
        flush: gboolean,
        err: *mut *mut GError,
    ) -> GIOStatus;
}
extern "C" {
    #[link_name = "\u{1}_g_io_add_watch_full"]
    pub fn g_io_add_watch_full(
        channel: *mut GIOChannel,
        priority: gint,
        condition: GIOCondition,
        func: GIOFunc,
        user_data: gpointer,
        notify: GDestroyNotify,
    ) -> guint;
}
extern "C" {
    #[link_name = "\u{1}_g_io_create_watch"]
    pub fn g_io_create_watch(channel: *mut GIOChannel, condition: GIOCondition) -> *mut GSource;
}
extern "C" {
    #[link_name = "\u{1}_g_io_add_watch"]
    pub fn g_io_add_watch(
        channel: *mut GIOChannel,
        condition: GIOCondition,
        func: GIOFunc,
        user_data: gpointer,
    ) -> guint;
}
extern "C" {
    #[link_name = "\u{1}_g_io_channel_set_buffer_size"]
    pub fn g_io_channel_set_buffer_size(channel: *mut GIOChannel, size: gsize);
}
extern "C" {
    #[link_name = "\u{1}_g_io_channel_get_buffer_size"]
    pub fn g_io_channel_get_buffer_size(channel: *mut GIOChannel) -> gsize;
}
extern "C" {
    #[link_name = "\u{1}_g_io_channel_get_buffer_condition"]
    pub fn g_io_channel_get_buffer_condition(channel: *mut GIOChannel) -> GIOCondition;
}
extern "C" {
    #[link_name = "\u{1}_g_io_channel_set_flags"]
    pub fn g_io_channel_set_flags(
        channel: *mut GIOChannel,
        flags: GIOFlags,
        error: *mut *mut GError,
    ) -> GIOStatus;
}
extern "C" {
    #[link_name = "\u{1}_g_io_channel_get_flags"]
    pub fn g_io_channel_get_flags(channel: *mut GIOChannel) -> GIOFlags;
}
extern "C" {
    #[link_name = "\u{1}_g_io_channel_set_line_term"]
    pub fn g_io_channel_set_line_term(
        channel: *mut GIOChannel,
        line_term: *const gchar,
        length: gint,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_io_channel_get_line_term"]
    pub fn g_io_channel_get_line_term(channel: *mut GIOChannel, length: *mut gint) -> *const gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_io_channel_set_buffered"]
    pub fn g_io_channel_set_buffered(channel: *mut GIOChannel, buffered: gboolean);
}
extern "C" {
    #[link_name = "\u{1}_g_io_channel_get_buffered"]
    pub fn g_io_channel_get_buffered(channel: *mut GIOChannel) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_io_channel_set_encoding"]
    pub fn g_io_channel_set_encoding(
        channel: *mut GIOChannel,
        encoding: *const gchar,
        error: *mut *mut GError,
    ) -> GIOStatus;
}
extern "C" {
    #[link_name = "\u{1}_g_io_channel_get_encoding"]
    pub fn g_io_channel_get_encoding(channel: *mut GIOChannel) -> *const gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_io_channel_set_close_on_unref"]
    pub fn g_io_channel_set_close_on_unref(channel: *mut GIOChannel, do_close: gboolean);
}
extern "C" {
    #[link_name = "\u{1}_g_io_channel_get_close_on_unref"]
    pub fn g_io_channel_get_close_on_unref(channel: *mut GIOChannel) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_io_channel_flush"]
    pub fn g_io_channel_flush(channel: *mut GIOChannel, error: *mut *mut GError) -> GIOStatus;
}
extern "C" {
    #[link_name = "\u{1}_g_io_channel_read_line"]
    pub fn g_io_channel_read_line(
        channel: *mut GIOChannel,
        str_return: *mut *mut gchar,
        length: *mut gsize,
        terminator_pos: *mut gsize,
        error: *mut *mut GError,
    ) -> GIOStatus;
}
extern "C" {
    #[link_name = "\u{1}_g_io_channel_read_line_string"]
    pub fn g_io_channel_read_line_string(
        channel: *mut GIOChannel,
        buffer: *mut GString,
        terminator_pos: *mut gsize,
        error: *mut *mut GError,
    ) -> GIOStatus;
}
extern "C" {
    #[link_name = "\u{1}_g_io_channel_read_to_end"]
    pub fn g_io_channel_read_to_end(
        channel: *mut GIOChannel,
        str_return: *mut *mut gchar,
        length: *mut gsize,
        error: *mut *mut GError,
    ) -> GIOStatus;
}
extern "C" {
    #[link_name = "\u{1}_g_io_channel_read_chars"]
    pub fn g_io_channel_read_chars(
        channel: *mut GIOChannel,
        buf: *mut gchar,
        count: gsize,
        bytes_read: *mut gsize,
        error: *mut *mut GError,
    ) -> GIOStatus;
}
extern "C" {
    #[link_name = "\u{1}_g_io_channel_read_unichar"]
    pub fn g_io_channel_read_unichar(
        channel: *mut GIOChannel,
        thechar: *mut gunichar,
        error: *mut *mut GError,
    ) -> GIOStatus;
}
extern "C" {
    #[link_name = "\u{1}_g_io_channel_write_chars"]
    pub fn g_io_channel_write_chars(
        channel: *mut GIOChannel,
        buf: *const gchar,
        count: gssize,
        bytes_written: *mut gsize,
        error: *mut *mut GError,
    ) -> GIOStatus;
}
extern "C" {
    #[link_name = "\u{1}_g_io_channel_write_unichar"]
    pub fn g_io_channel_write_unichar(
        channel: *mut GIOChannel,
        thechar: gunichar,
        error: *mut *mut GError,
    ) -> GIOStatus;
}
extern "C" {
    #[link_name = "\u{1}_g_io_channel_seek_position"]
    pub fn g_io_channel_seek_position(
        channel: *mut GIOChannel,
        offset: gint64,
        type_: GSeekType,
        error: *mut *mut GError,
    ) -> GIOStatus;
}
extern "C" {
    #[link_name = "\u{1}_g_io_channel_new_file"]
    pub fn g_io_channel_new_file(
        filename: *const gchar,
        mode: *const gchar,
        error: *mut *mut GError,
    ) -> *mut GIOChannel;
}
extern "C" {
    #[link_name = "\u{1}_g_io_channel_error_quark"]
    pub fn g_io_channel_error_quark() -> GQuark;
}
extern "C" {
    #[link_name = "\u{1}_g_io_channel_error_from_errno"]
    pub fn g_io_channel_error_from_errno(en: gint) -> GIOChannelError;
}
extern "C" {
    #[link_name = "\u{1}_g_io_channel_unix_new"]
    pub fn g_io_channel_unix_new(fd: ::std::os::raw::c_int) -> *mut GIOChannel;
}
extern "C" {
    #[link_name = "\u{1}_g_io_channel_unix_get_fd"]
    pub fn g_io_channel_unix_get_fd(channel: *mut GIOChannel) -> gint;
}
extern "C" {
    #[link_name = "\u{1}_g_io_watch_funcs"]
    pub static mut g_io_watch_funcs: GSourceFuncs;
}
pub const GKeyFileError_G_KEY_FILE_ERROR_UNKNOWN_ENCODING: GKeyFileError = 0;
pub const GKeyFileError_G_KEY_FILE_ERROR_PARSE: GKeyFileError = 1;
pub const GKeyFileError_G_KEY_FILE_ERROR_NOT_FOUND: GKeyFileError = 2;
pub const GKeyFileError_G_KEY_FILE_ERROR_KEY_NOT_FOUND: GKeyFileError = 3;
pub const GKeyFileError_G_KEY_FILE_ERROR_GROUP_NOT_FOUND: GKeyFileError = 4;
pub const GKeyFileError_G_KEY_FILE_ERROR_INVALID_VALUE: GKeyFileError = 5;
pub type GKeyFileError = u32;
extern "C" {
    #[link_name = "\u{1}_g_key_file_error_quark"]
    pub fn g_key_file_error_quark() -> GQuark;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GKeyFile {
    _unused: [u8; 0],
}
pub type GKeyFile = _GKeyFile;
pub const GKeyFileFlags_G_KEY_FILE_NONE: GKeyFileFlags = 0;
pub const GKeyFileFlags_G_KEY_FILE_KEEP_COMMENTS: GKeyFileFlags = 1;
pub const GKeyFileFlags_G_KEY_FILE_KEEP_TRANSLATIONS: GKeyFileFlags = 2;
pub type GKeyFileFlags = u32;
extern "C" {
    #[link_name = "\u{1}_g_key_file_new"]
    pub fn g_key_file_new() -> *mut GKeyFile;
}
extern "C" {
    #[link_name = "\u{1}_g_key_file_ref"]
    pub fn g_key_file_ref(key_file: *mut GKeyFile) -> *mut GKeyFile;
}
extern "C" {
    #[link_name = "\u{1}_g_key_file_unref"]
    pub fn g_key_file_unref(key_file: *mut GKeyFile);
}
extern "C" {
    #[link_name = "\u{1}_g_key_file_free"]
    pub fn g_key_file_free(key_file: *mut GKeyFile);
}
extern "C" {
    #[link_name = "\u{1}_g_key_file_set_list_separator"]
    pub fn g_key_file_set_list_separator(key_file: *mut GKeyFile, separator: gchar);
}
extern "C" {
    #[link_name = "\u{1}_g_key_file_load_from_file"]
    pub fn g_key_file_load_from_file(
        key_file: *mut GKeyFile,
        file: *const gchar,
        flags: GKeyFileFlags,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_key_file_load_from_data"]
    pub fn g_key_file_load_from_data(
        key_file: *mut GKeyFile,
        data: *const gchar,
        length: gsize,
        flags: GKeyFileFlags,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_key_file_load_from_bytes"]
    pub fn g_key_file_load_from_bytes(
        key_file: *mut GKeyFile,
        bytes: *mut GBytes,
        flags: GKeyFileFlags,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_key_file_load_from_dirs"]
    pub fn g_key_file_load_from_dirs(
        key_file: *mut GKeyFile,
        file: *const gchar,
        search_dirs: *mut *const gchar,
        full_path: *mut *mut gchar,
        flags: GKeyFileFlags,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_key_file_load_from_data_dirs"]
    pub fn g_key_file_load_from_data_dirs(
        key_file: *mut GKeyFile,
        file: *const gchar,
        full_path: *mut *mut gchar,
        flags: GKeyFileFlags,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_key_file_to_data"]
    pub fn g_key_file_to_data(
        key_file: *mut GKeyFile,
        length: *mut gsize,
        error: *mut *mut GError,
    ) -> *mut gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_key_file_save_to_file"]
    pub fn g_key_file_save_to_file(
        key_file: *mut GKeyFile,
        filename: *const gchar,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_key_file_get_start_group"]
    pub fn g_key_file_get_start_group(key_file: *mut GKeyFile) -> *mut gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_key_file_get_groups"]
    pub fn g_key_file_get_groups(key_file: *mut GKeyFile, length: *mut gsize) -> *mut *mut gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_key_file_get_keys"]
    pub fn g_key_file_get_keys(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        length: *mut gsize,
        error: *mut *mut GError,
    ) -> *mut *mut gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_key_file_has_group"]
    pub fn g_key_file_has_group(key_file: *mut GKeyFile, group_name: *const gchar) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_key_file_has_key"]
    pub fn g_key_file_has_key(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_key_file_get_value"]
    pub fn g_key_file_get_value(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        error: *mut *mut GError,
    ) -> *mut gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_key_file_set_value"]
    pub fn g_key_file_set_value(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        value: *const gchar,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_key_file_get_string"]
    pub fn g_key_file_get_string(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        error: *mut *mut GError,
    ) -> *mut gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_key_file_set_string"]
    pub fn g_key_file_set_string(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        string: *const gchar,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_key_file_get_locale_string"]
    pub fn g_key_file_get_locale_string(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        locale: *const gchar,
        error: *mut *mut GError,
    ) -> *mut gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_key_file_set_locale_string"]
    pub fn g_key_file_set_locale_string(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        locale: *const gchar,
        string: *const gchar,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_key_file_get_boolean"]
    pub fn g_key_file_get_boolean(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_key_file_set_boolean"]
    pub fn g_key_file_set_boolean(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        value: gboolean,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_key_file_get_integer"]
    pub fn g_key_file_get_integer(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        error: *mut *mut GError,
    ) -> gint;
}
extern "C" {
    #[link_name = "\u{1}_g_key_file_set_integer"]
    pub fn g_key_file_set_integer(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        value: gint,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_key_file_get_int64"]
    pub fn g_key_file_get_int64(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        error: *mut *mut GError,
    ) -> gint64;
}
extern "C" {
    #[link_name = "\u{1}_g_key_file_set_int64"]
    pub fn g_key_file_set_int64(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        value: gint64,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_key_file_get_uint64"]
    pub fn g_key_file_get_uint64(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        error: *mut *mut GError,
    ) -> guint64;
}
extern "C" {
    #[link_name = "\u{1}_g_key_file_set_uint64"]
    pub fn g_key_file_set_uint64(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        value: guint64,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_key_file_get_double"]
    pub fn g_key_file_get_double(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        error: *mut *mut GError,
    ) -> gdouble;
}
extern "C" {
    #[link_name = "\u{1}_g_key_file_set_double"]
    pub fn g_key_file_set_double(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        value: gdouble,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_key_file_get_string_list"]
    pub fn g_key_file_get_string_list(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        length: *mut gsize,
        error: *mut *mut GError,
    ) -> *mut *mut gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_key_file_set_string_list"]
    pub fn g_key_file_set_string_list(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        list: *const *const gchar,
        length: gsize,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_key_file_get_locale_string_list"]
    pub fn g_key_file_get_locale_string_list(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        locale: *const gchar,
        length: *mut gsize,
        error: *mut *mut GError,
    ) -> *mut *mut gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_key_file_set_locale_string_list"]
    pub fn g_key_file_set_locale_string_list(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        locale: *const gchar,
        list: *const *const gchar,
        length: gsize,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_key_file_get_boolean_list"]
    pub fn g_key_file_get_boolean_list(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        length: *mut gsize,
        error: *mut *mut GError,
    ) -> *mut gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_key_file_set_boolean_list"]
    pub fn g_key_file_set_boolean_list(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        list: *mut gboolean,
        length: gsize,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_key_file_get_integer_list"]
    pub fn g_key_file_get_integer_list(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        length: *mut gsize,
        error: *mut *mut GError,
    ) -> *mut gint;
}
extern "C" {
    #[link_name = "\u{1}_g_key_file_set_double_list"]
    pub fn g_key_file_set_double_list(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        list: *mut gdouble,
        length: gsize,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_key_file_get_double_list"]
    pub fn g_key_file_get_double_list(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        length: *mut gsize,
        error: *mut *mut GError,
    ) -> *mut gdouble;
}
extern "C" {
    #[link_name = "\u{1}_g_key_file_set_integer_list"]
    pub fn g_key_file_set_integer_list(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        list: *mut gint,
        length: gsize,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_key_file_set_comment"]
    pub fn g_key_file_set_comment(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        comment: *const gchar,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_key_file_get_comment"]
    pub fn g_key_file_get_comment(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        error: *mut *mut GError,
    ) -> *mut gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_key_file_remove_comment"]
    pub fn g_key_file_remove_comment(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_key_file_remove_key"]
    pub fn g_key_file_remove_key(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        key: *const gchar,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_key_file_remove_group"]
    pub fn g_key_file_remove_group(
        key_file: *mut GKeyFile,
        group_name: *const gchar,
        error: *mut *mut GError,
    ) -> gboolean;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GMappedFile {
    _unused: [u8; 0],
}
pub type GMappedFile = _GMappedFile;
extern "C" {
    #[link_name = "\u{1}_g_mapped_file_new"]
    pub fn g_mapped_file_new(
        filename: *const gchar,
        writable: gboolean,
        error: *mut *mut GError,
    ) -> *mut GMappedFile;
}
extern "C" {
    #[link_name = "\u{1}_g_mapped_file_new_from_fd"]
    pub fn g_mapped_file_new_from_fd(
        fd: gint,
        writable: gboolean,
        error: *mut *mut GError,
    ) -> *mut GMappedFile;
}
extern "C" {
    #[link_name = "\u{1}_g_mapped_file_get_length"]
    pub fn g_mapped_file_get_length(file: *mut GMappedFile) -> gsize;
}
extern "C" {
    #[link_name = "\u{1}_g_mapped_file_get_contents"]
    pub fn g_mapped_file_get_contents(file: *mut GMappedFile) -> *mut gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_mapped_file_get_bytes"]
    pub fn g_mapped_file_get_bytes(file: *mut GMappedFile) -> *mut GBytes;
}
extern "C" {
    #[link_name = "\u{1}_g_mapped_file_ref"]
    pub fn g_mapped_file_ref(file: *mut GMappedFile) -> *mut GMappedFile;
}
extern "C" {
    #[link_name = "\u{1}_g_mapped_file_unref"]
    pub fn g_mapped_file_unref(file: *mut GMappedFile);
}
extern "C" {
    #[link_name = "\u{1}_g_mapped_file_free"]
    pub fn g_mapped_file_free(file: *mut GMappedFile);
}
pub const GMarkupError_G_MARKUP_ERROR_BAD_UTF8: GMarkupError = 0;
pub const GMarkupError_G_MARKUP_ERROR_EMPTY: GMarkupError = 1;
pub const GMarkupError_G_MARKUP_ERROR_PARSE: GMarkupError = 2;
pub const GMarkupError_G_MARKUP_ERROR_UNKNOWN_ELEMENT: GMarkupError = 3;
pub const GMarkupError_G_MARKUP_ERROR_UNKNOWN_ATTRIBUTE: GMarkupError = 4;
pub const GMarkupError_G_MARKUP_ERROR_INVALID_CONTENT: GMarkupError = 5;
pub const GMarkupError_G_MARKUP_ERROR_MISSING_ATTRIBUTE: GMarkupError = 6;
/// GMarkupError:
/// @G_MARKUP_ERROR_BAD_UTF8: text being parsed was not valid UTF-8
/// @G_MARKUP_ERROR_EMPTY: document contained nothing, or only whitespace
/// @G_MARKUP_ERROR_PARSE: document was ill-formed
/// @G_MARKUP_ERROR_UNKNOWN_ELEMENT: error should be set by #GMarkupParser
/// functions; element wasn't known
/// @G_MARKUP_ERROR_UNKNOWN_ATTRIBUTE: error should be set by #GMarkupParser
/// functions; attribute wasn't known
/// @G_MARKUP_ERROR_INVALID_CONTENT: error should be set by #GMarkupParser
/// functions; content was invalid
/// @G_MARKUP_ERROR_MISSING_ATTRIBUTE: error should be set by #GMarkupParser
/// functions; a required attribute was missing
///
/// Error codes returned by markup parsing.
pub type GMarkupError = u32;
extern "C" {
    #[link_name = "\u{1}_g_markup_error_quark"]
    pub fn g_markup_error_quark() -> GQuark;
}
pub const GMarkupParseFlags_G_MARKUP_DO_NOT_USE_THIS_UNSUPPORTED_FLAG: GMarkupParseFlags = 1;
pub const GMarkupParseFlags_G_MARKUP_TREAT_CDATA_AS_TEXT: GMarkupParseFlags = 2;
pub const GMarkupParseFlags_G_MARKUP_PREFIX_ERROR_POSITION: GMarkupParseFlags = 4;
pub const GMarkupParseFlags_G_MARKUP_IGNORE_QUALIFIED: GMarkupParseFlags = 8;
/// GMarkupParseFlags:
/// @G_MARKUP_DO_NOT_USE_THIS_UNSUPPORTED_FLAG: flag you should not use
/// @G_MARKUP_TREAT_CDATA_AS_TEXT: When this flag is set, CDATA marked
/// sections are not passed literally to the @passthrough function of
/// the parser. Instead, the content of the section (without the
/// `<![CDATA[` and `]]>`) is
/// passed to the @text function. This flag was added in GLib 2.12
/// @G_MARKUP_PREFIX_ERROR_POSITION: Normally errors caught by GMarkup
/// itself have line/column information prefixed to them to let the
/// caller know the location of the error. When this flag is set the
/// location information is also prefixed to errors generated by the
/// #GMarkupParser implementation functions
/// @G_MARKUP_IGNORE_QUALIFIED: Ignore (don't report) qualified
/// attributes and tags, along with their contents.  A qualified
/// attribute or tag is one that contains ':' in its name (ie: is in
/// another namespace).  Since: 2.40.
///
/// Flags that affect the behaviour of the parser.
pub type GMarkupParseFlags = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GMarkupParseContext {
    _unused: [u8; 0],
}
/// GMarkupParseContext:
///
/// A parse context is used to parse a stream of bytes that
/// you expect to contain marked-up text.
///
/// See g_markup_parse_context_new(), #GMarkupParser, and so
/// on for more details.
pub type GMarkupParseContext = _GMarkupParseContext;
pub type GMarkupParser = _GMarkupParser;
/// GMarkupParser:
/// @start_element: Callback to invoke when the opening tag of an element
/// is seen. The callback's @attribute_names and @attribute_values parameters
/// are %NULL-terminated.
/// @end_element: Callback to invoke when the closing tag of an element
/// is seen. Note that this is also called for empty tags like
/// `<empty/>`.
/// @text: Callback to invoke when some text is seen (text is always
/// inside an element). Note that the text of an element may be spread
/// over multiple calls of this function. If the
/// %G_MARKUP_TREAT_CDATA_AS_TEXT flag is set, this function is also
/// called for the content of CDATA marked sections.
/// @passthrough: Callback to invoke for comments, processing instructions
/// and doctype declarations; if you're re-writing the parsed document,
/// write the passthrough text back out in the same position. If the
/// %G_MARKUP_TREAT_CDATA_AS_TEXT flag is not set, this function is also
/// called for CDATA marked sections.
/// @error: Callback to invoke when an error occurs.
///
/// Any of the fields in #GMarkupParser can be %NULL, in which case they
/// will be ignored. Except for the @error function, any of these callbacks
/// can set an error; in particular the %G_MARKUP_ERROR_UNKNOWN_ELEMENT,
/// %G_MARKUP_ERROR_UNKNOWN_ATTRIBUTE, and %G_MARKUP_ERROR_INVALID_CONTENT
/// errors are intended to be set from these callbacks. If you set an error
/// from a callback, g_markup_parse_context_parse() will report that error
/// back to its caller.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GMarkupParser {
    pub start_element: ::std::option::Option<
        unsafe extern "C" fn(
            context: *mut GMarkupParseContext,
            element_name: *const gchar,
            attribute_names: *mut *const gchar,
            attribute_values: *mut *const gchar,
            user_data: gpointer,
            error: *mut *mut GError,
        ),
    >,
    pub end_element: ::std::option::Option<
        unsafe extern "C" fn(
            context: *mut GMarkupParseContext,
            element_name: *const gchar,
            user_data: gpointer,
            error: *mut *mut GError,
        ),
    >,
    pub text: ::std::option::Option<
        unsafe extern "C" fn(
            context: *mut GMarkupParseContext,
            text: *const gchar,
            text_len: gsize,
            user_data: gpointer,
            error: *mut *mut GError,
        ),
    >,
    pub passthrough: ::std::option::Option<
        unsafe extern "C" fn(
            context: *mut GMarkupParseContext,
            passthrough_text: *const gchar,
            text_len: gsize,
            user_data: gpointer,
            error: *mut *mut GError,
        ),
    >,
    pub error: ::std::option::Option<
        unsafe extern "C" fn(
            context: *mut GMarkupParseContext,
            error: *mut GError,
            user_data: gpointer,
        ),
    >,
}
#[test]
fn bindgen_test_layout__GMarkupParser() {
    assert_eq!(
        ::std::mem::size_of::<_GMarkupParser>(),
        40usize,
        concat!("Size of: ", stringify!(_GMarkupParser))
    );
    assert_eq!(
        ::std::mem::align_of::<_GMarkupParser>(),
        8usize,
        concat!("Alignment of ", stringify!(_GMarkupParser))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GMarkupParser>())).start_element as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMarkupParser),
            "::",
            stringify!(start_element)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GMarkupParser>())).end_element as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMarkupParser),
            "::",
            stringify!(end_element)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GMarkupParser>())).text as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMarkupParser),
            "::",
            stringify!(text)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GMarkupParser>())).passthrough as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMarkupParser),
            "::",
            stringify!(passthrough)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GMarkupParser>())).error as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMarkupParser),
            "::",
            stringify!(error)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_g_markup_parse_context_new"]
    pub fn g_markup_parse_context_new(
        parser: *const GMarkupParser,
        flags: GMarkupParseFlags,
        user_data: gpointer,
        user_data_dnotify: GDestroyNotify,
    ) -> *mut GMarkupParseContext;
}
extern "C" {
    #[link_name = "\u{1}_g_markup_parse_context_ref"]
    pub fn g_markup_parse_context_ref(
        context: *mut GMarkupParseContext,
    ) -> *mut GMarkupParseContext;
}
extern "C" {
    #[link_name = "\u{1}_g_markup_parse_context_unref"]
    pub fn g_markup_parse_context_unref(context: *mut GMarkupParseContext);
}
extern "C" {
    #[link_name = "\u{1}_g_markup_parse_context_free"]
    pub fn g_markup_parse_context_free(context: *mut GMarkupParseContext);
}
extern "C" {
    #[link_name = "\u{1}_g_markup_parse_context_parse"]
    pub fn g_markup_parse_context_parse(
        context: *mut GMarkupParseContext,
        text: *const gchar,
        text_len: gssize,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_markup_parse_context_push"]
    pub fn g_markup_parse_context_push(
        context: *mut GMarkupParseContext,
        parser: *const GMarkupParser,
        user_data: gpointer,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_markup_parse_context_pop"]
    pub fn g_markup_parse_context_pop(context: *mut GMarkupParseContext) -> gpointer;
}
extern "C" {
    #[link_name = "\u{1}_g_markup_parse_context_end_parse"]
    pub fn g_markup_parse_context_end_parse(
        context: *mut GMarkupParseContext,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_markup_parse_context_get_element"]
    pub fn g_markup_parse_context_get_element(context: *mut GMarkupParseContext) -> *const gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_markup_parse_context_get_element_stack"]
    pub fn g_markup_parse_context_get_element_stack(
        context: *mut GMarkupParseContext,
    ) -> *const GSList;
}
extern "C" {
    #[link_name = "\u{1}_g_markup_parse_context_get_position"]
    pub fn g_markup_parse_context_get_position(
        context: *mut GMarkupParseContext,
        line_number: *mut gint,
        char_number: *mut gint,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_markup_parse_context_get_user_data"]
    pub fn g_markup_parse_context_get_user_data(context: *mut GMarkupParseContext) -> gpointer;
}
extern "C" {
    #[link_name = "\u{1}_g_markup_escape_text"]
    pub fn g_markup_escape_text(text: *const gchar, length: gssize) -> *mut gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_markup_printf_escaped"]
    pub fn g_markup_printf_escaped(format: *const ::std::os::raw::c_char, ...) -> *mut gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_markup_vprintf_escaped"]
    pub fn g_markup_vprintf_escaped(
        format: *const ::std::os::raw::c_char,
        args: *mut __va_list_tag,
    ) -> *mut gchar;
}
pub const GMarkupCollectType_G_MARKUP_COLLECT_INVALID: GMarkupCollectType = 0;
pub const GMarkupCollectType_G_MARKUP_COLLECT_STRING: GMarkupCollectType = 1;
pub const GMarkupCollectType_G_MARKUP_COLLECT_STRDUP: GMarkupCollectType = 2;
pub const GMarkupCollectType_G_MARKUP_COLLECT_BOOLEAN: GMarkupCollectType = 3;
pub const GMarkupCollectType_G_MARKUP_COLLECT_TRISTATE: GMarkupCollectType = 4;
pub const GMarkupCollectType_G_MARKUP_COLLECT_OPTIONAL: GMarkupCollectType = 65536;
pub type GMarkupCollectType = u32;
extern "C" {
    #[link_name = "\u{1}_g_markup_collect_attributes"]
    pub fn g_markup_collect_attributes(
        element_name: *const gchar,
        attribute_names: *mut *const gchar,
        attribute_values: *mut *const gchar,
        error: *mut *mut GError,
        first_type: GMarkupCollectType,
        first_attr: *const gchar,
        ...
    ) -> gboolean;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GVariantType {
    _unused: [u8; 0],
}
/// GVariantType:
///
/// A type in the GVariant type system.
///
/// Two types may not be compared by value; use g_variant_type_equal() or
/// g_variant_type_is_subtype_of().  May be copied using
/// g_variant_type_copy() and freed using g_variant_type_free().
pub type GVariantType = _GVariantType;
extern "C" {
    #[link_name = "\u{1}_g_variant_type_string_is_valid"]
    pub fn g_variant_type_string_is_valid(type_string: *const gchar) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_variant_type_string_scan"]
    pub fn g_variant_type_string_scan(
        string: *const gchar,
        limit: *const gchar,
        endptr: *mut *const gchar,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_variant_type_free"]
    pub fn g_variant_type_free(type_: *mut GVariantType);
}
extern "C" {
    #[link_name = "\u{1}_g_variant_type_copy"]
    pub fn g_variant_type_copy(type_: *const GVariantType) -> *mut GVariantType;
}
extern "C" {
    #[link_name = "\u{1}_g_variant_type_new"]
    pub fn g_variant_type_new(type_string: *const gchar) -> *mut GVariantType;
}
extern "C" {
    #[link_name = "\u{1}_g_variant_type_get_string_length"]
    pub fn g_variant_type_get_string_length(type_: *const GVariantType) -> gsize;
}
extern "C" {
    #[link_name = "\u{1}_g_variant_type_peek_string"]
    pub fn g_variant_type_peek_string(type_: *const GVariantType) -> *const gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_variant_type_dup_string"]
    pub fn g_variant_type_dup_string(type_: *const GVariantType) -> *mut gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_variant_type_is_definite"]
    pub fn g_variant_type_is_definite(type_: *const GVariantType) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_variant_type_is_container"]
    pub fn g_variant_type_is_container(type_: *const GVariantType) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_variant_type_is_basic"]
    pub fn g_variant_type_is_basic(type_: *const GVariantType) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_variant_type_is_maybe"]
    pub fn g_variant_type_is_maybe(type_: *const GVariantType) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_variant_type_is_array"]
    pub fn g_variant_type_is_array(type_: *const GVariantType) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_variant_type_is_tuple"]
    pub fn g_variant_type_is_tuple(type_: *const GVariantType) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_variant_type_is_dict_entry"]
    pub fn g_variant_type_is_dict_entry(type_: *const GVariantType) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_variant_type_is_variant"]
    pub fn g_variant_type_is_variant(type_: *const GVariantType) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_variant_type_hash"]
    pub fn g_variant_type_hash(type_: gconstpointer) -> guint;
}
extern "C" {
    #[link_name = "\u{1}_g_variant_type_equal"]
    pub fn g_variant_type_equal(type1: gconstpointer, type2: gconstpointer) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_variant_type_is_subtype_of"]
    pub fn g_variant_type_is_subtype_of(
        type_: *const GVariantType,
        supertype: *const GVariantType,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_variant_type_element"]
    pub fn g_variant_type_element(type_: *const GVariantType) -> *const GVariantType;
}
extern "C" {
    #[link_name = "\u{1}_g_variant_type_first"]
    pub fn g_variant_type_first(type_: *const GVariantType) -> *const GVariantType;
}
extern "C" {
    #[link_name = "\u{1}_g_variant_type_next"]
    pub fn g_variant_type_next(type_: *const GVariantType) -> *const GVariantType;
}
extern "C" {
    #[link_name = "\u{1}_g_variant_type_n_items"]
    pub fn g_variant_type_n_items(type_: *const GVariantType) -> gsize;
}
extern "C" {
    #[link_name = "\u{1}_g_variant_type_key"]
    pub fn g_variant_type_key(type_: *const GVariantType) -> *const GVariantType;
}
extern "C" {
    #[link_name = "\u{1}_g_variant_type_value"]
    pub fn g_variant_type_value(type_: *const GVariantType) -> *const GVariantType;
}
extern "C" {
    #[link_name = "\u{1}_g_variant_type_new_array"]
    pub fn g_variant_type_new_array(element: *const GVariantType) -> *mut GVariantType;
}
extern "C" {
    #[link_name = "\u{1}_g_variant_type_new_maybe"]
    pub fn g_variant_type_new_maybe(element: *const GVariantType) -> *mut GVariantType;
}
extern "C" {
    #[link_name = "\u{1}_g_variant_type_new_tuple"]
    pub fn g_variant_type_new_tuple(
        items: *const *const GVariantType,
        length: gint,
    ) -> *mut GVariantType;
}
extern "C" {
    #[link_name = "\u{1}_g_variant_type_new_dict_entry"]
    pub fn g_variant_type_new_dict_entry(
        key: *const GVariantType,
        value: *const GVariantType,
    ) -> *mut GVariantType;
}
extern "C" {
    #[link_name = "\u{1}_g_variant_type_checked_"]
    pub fn g_variant_type_checked_(arg1: *const gchar) -> *const GVariantType;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GVariant {
    _unused: [u8; 0],
}
pub type GVariant = _GVariant;
pub const GVariantClass_G_VARIANT_CLASS_BOOLEAN: GVariantClass = 98;
pub const GVariantClass_G_VARIANT_CLASS_BYTE: GVariantClass = 121;
pub const GVariantClass_G_VARIANT_CLASS_INT16: GVariantClass = 110;
pub const GVariantClass_G_VARIANT_CLASS_UINT16: GVariantClass = 113;
pub const GVariantClass_G_VARIANT_CLASS_INT32: GVariantClass = 105;
pub const GVariantClass_G_VARIANT_CLASS_UINT32: GVariantClass = 117;
pub const GVariantClass_G_VARIANT_CLASS_INT64: GVariantClass = 120;
pub const GVariantClass_G_VARIANT_CLASS_UINT64: GVariantClass = 116;
pub const GVariantClass_G_VARIANT_CLASS_HANDLE: GVariantClass = 104;
pub const GVariantClass_G_VARIANT_CLASS_DOUBLE: GVariantClass = 100;
pub const GVariantClass_G_VARIANT_CLASS_STRING: GVariantClass = 115;
pub const GVariantClass_G_VARIANT_CLASS_OBJECT_PATH: GVariantClass = 111;
pub const GVariantClass_G_VARIANT_CLASS_SIGNATURE: GVariantClass = 103;
pub const GVariantClass_G_VARIANT_CLASS_VARIANT: GVariantClass = 118;
pub const GVariantClass_G_VARIANT_CLASS_MAYBE: GVariantClass = 109;
pub const GVariantClass_G_VARIANT_CLASS_ARRAY: GVariantClass = 97;
pub const GVariantClass_G_VARIANT_CLASS_TUPLE: GVariantClass = 40;
pub const GVariantClass_G_VARIANT_CLASS_DICT_ENTRY: GVariantClass = 123;
pub type GVariantClass = u32;
extern "C" {
    #[link_name = "\u{1}_g_variant_unref"]
    pub fn g_variant_unref(value: *mut GVariant);
}
extern "C" {
    #[link_name = "\u{1}_g_variant_ref"]
    pub fn g_variant_ref(value: *mut GVariant) -> *mut GVariant;
}
extern "C" {
    #[link_name = "\u{1}_g_variant_ref_sink"]
    pub fn g_variant_ref_sink(value: *mut GVariant) -> *mut GVariant;
}
extern "C" {
    #[link_name = "\u{1}_g_variant_is_floating"]
    pub fn g_variant_is_floating(value: *mut GVariant) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_variant_take_ref"]
    pub fn g_variant_take_ref(value: *mut GVariant) -> *mut GVariant;
}
extern "C" {
    #[link_name = "\u{1}_g_variant_get_type"]
    pub fn g_variant_get_type(value: *mut GVariant) -> *const GVariantType;
}
extern "C" {
    #[link_name = "\u{1}_g_variant_get_type_string"]
    pub fn g_variant_get_type_string(value: *mut GVariant) -> *const gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_variant_is_of_type"]
    pub fn g_variant_is_of_type(value: *mut GVariant, type_: *const GVariantType) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_variant_is_container"]
    pub fn g_variant_is_container(value: *mut GVariant) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_variant_classify"]
    pub fn g_variant_classify(value: *mut GVariant) -> GVariantClass;
}
extern "C" {
    #[link_name = "\u{1}_g_variant_new_boolean"]
    pub fn g_variant_new_boolean(value: gboolean) -> *mut GVariant;
}
extern "C" {
    #[link_name = "\u{1}_g_variant_new_byte"]
    pub fn g_variant_new_byte(value: guchar) -> *mut GVariant;
}
extern "C" {
    #[link_name = "\u{1}_g_variant_new_int16"]
    pub fn g_variant_new_int16(value: gint16) -> *mut GVariant;
}
extern "C" {
    #[link_name = "\u{1}_g_variant_new_uint16"]
    pub fn g_variant_new_uint16(value: guint16) -> *mut GVariant;
}
extern "C" {
    #[link_name = "\u{1}_g_variant_new_int32"]
    pub fn g_variant_new_int32(value: gint32) -> *mut GVariant;
}
extern "C" {
    #[link_name = "\u{1}_g_variant_new_uint32"]
    pub fn g_variant_new_uint32(value: guint32) -> *mut GVariant;
}
extern "C" {
    #[link_name = "\u{1}_g_variant_new_int64"]
    pub fn g_variant_new_int64(value: gint64) -> *mut GVariant;
}
extern "C" {
    #[link_name = "\u{1}_g_variant_new_uint64"]
    pub fn g_variant_new_uint64(value: guint64) -> *mut GVariant;
}
extern "C" {
    #[link_name = "\u{1}_g_variant_new_handle"]
    pub fn g_variant_new_handle(value: gint32) -> *mut GVariant;
}
extern "C" {
    #[link_name = "\u{1}_g_variant_new_double"]
    pub fn g_variant_new_double(value: gdouble) -> *mut GVariant;
}
extern "C" {
    #[link_name = "\u{1}_g_variant_new_string"]
    pub fn g_variant_new_string(string: *const gchar) -> *mut GVariant;
}
extern "C" {
    #[link_name = "\u{1}_g_variant_new_take_string"]
    pub fn g_variant_new_take_string(string: *mut gchar) -> *mut GVariant;
}
extern "C" {
    #[link_name = "\u{1}_g_variant_new_printf"]
    pub fn g_variant_new_printf(format_string: *const gchar, ...) -> *mut GVariant;
}
extern "C" {
    #[link_name = "\u{1}_g_variant_new_object_path"]
    pub fn g_variant_new_object_path(object_path: *const gchar) -> *mut GVariant;
}
extern "C" {
    #[link_name = "\u{1}_g_variant_is_object_path"]
    pub fn g_variant_is_object_path(string: *const gchar) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_variant_new_signature"]
    pub fn g_variant_new_signature(signature: *const gchar) -> *mut GVariant;
}
extern "C" {
    #[link_name = "\u{1}_g_variant_is_signature"]
    pub fn g_variant_is_signature(string: *const gchar) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_variant_new_variant"]
    pub fn g_variant_new_variant(value: *mut GVariant) -> *mut GVariant;
}
extern "C" {
    #[link_name = "\u{1}_g_variant_new_strv"]
    pub fn g_variant_new_strv(strv: *const *const gchar, length: gssize) -> *mut GVariant;
}
extern "C" {
    #[link_name = "\u{1}_g_variant_new_objv"]
    pub fn g_variant_new_objv(strv: *const *const gchar, length: gssize) -> *mut GVariant;
}
extern "C" {
    #[link_name = "\u{1}_g_variant_new_bytestring"]
    pub fn g_variant_new_bytestring(string: *const gchar) -> *mut GVariant;
}
extern "C" {
    #[link_name = "\u{1}_g_variant_new_bytestring_array"]
    pub fn g_variant_new_bytestring_array(
        strv: *const *const gchar,
        length: gssize,
    ) -> *mut GVariant;
}
extern "C" {
    #[link_name = "\u{1}_g_variant_new_fixed_array"]
    pub fn g_variant_new_fixed_array(
        element_type: *const GVariantType,
        elements: gconstpointer,
        n_elements: gsize,
        element_size: gsize,
    ) -> *mut GVariant;
}
extern "C" {
    #[link_name = "\u{1}_g_variant_get_boolean"]
    pub fn g_variant_get_boolean(value: *mut GVariant) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_variant_get_byte"]
    pub fn g_variant_get_byte(value: *mut GVariant) -> guchar;
}
extern "C" {
    #[link_name = "\u{1}_g_variant_get_int16"]
    pub fn g_variant_get_int16(value: *mut GVariant) -> gint16;
}
extern "C" {
    #[link_name = "\u{1}_g_variant_get_uint16"]
    pub fn g_variant_get_uint16(value: *mut GVariant) -> guint16;
}
extern "C" {
    #[link_name = "\u{1}_g_variant_get_int32"]
    pub fn g_variant_get_int32(value: *mut GVariant) -> gint32;
}
extern "C" {
    #[link_name = "\u{1}_g_variant_get_uint32"]
    pub fn g_variant_get_uint32(value: *mut GVariant) -> guint32;
}
extern "C" {
    #[link_name = "\u{1}_g_variant_get_int64"]
    pub fn g_variant_get_int64(value: *mut GVariant) -> gint64;
}
extern "C" {
    #[link_name = "\u{1}_g_variant_get_uint64"]
    pub fn g_variant_get_uint64(value: *mut GVariant) -> guint64;
}
extern "C" {
    #[link_name = "\u{1}_g_variant_get_handle"]
    pub fn g_variant_get_handle(value: *mut GVariant) -> gint32;
}
extern "C" {
    #[link_name = "\u{1}_g_variant_get_double"]
    pub fn g_variant_get_double(value: *mut GVariant) -> gdouble;
}
extern "C" {
    #[link_name = "\u{1}_g_variant_get_variant"]
    pub fn g_variant_get_variant(value: *mut GVariant) -> *mut GVariant;
}
extern "C" {
    #[link_name = "\u{1}_g_variant_get_string"]
    pub fn g_variant_get_string(value: *mut GVariant, length: *mut gsize) -> *const gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_variant_dup_string"]
    pub fn g_variant_dup_string(value: *mut GVariant, length: *mut gsize) -> *mut gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_variant_get_strv"]
    pub fn g_variant_get_strv(value: *mut GVariant, length: *mut gsize) -> *mut *const gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_variant_dup_strv"]
    pub fn g_variant_dup_strv(value: *mut GVariant, length: *mut gsize) -> *mut *mut gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_variant_get_objv"]
    pub fn g_variant_get_objv(value: *mut GVariant, length: *mut gsize) -> *mut *const gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_variant_dup_objv"]
    pub fn g_variant_dup_objv(value: *mut GVariant, length: *mut gsize) -> *mut *mut gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_variant_get_bytestring"]
    pub fn g_variant_get_bytestring(value: *mut GVariant) -> *const gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_variant_dup_bytestring"]
    pub fn g_variant_dup_bytestring(value: *mut GVariant, length: *mut gsize) -> *mut gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_variant_get_bytestring_array"]
    pub fn g_variant_get_bytestring_array(
        value: *mut GVariant,
        length: *mut gsize,
    ) -> *mut *const gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_variant_dup_bytestring_array"]
    pub fn g_variant_dup_bytestring_array(
        value: *mut GVariant,
        length: *mut gsize,
    ) -> *mut *mut gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_variant_new_maybe"]
    pub fn g_variant_new_maybe(
        child_type: *const GVariantType,
        child: *mut GVariant,
    ) -> *mut GVariant;
}
extern "C" {
    #[link_name = "\u{1}_g_variant_new_array"]
    pub fn g_variant_new_array(
        child_type: *const GVariantType,
        children: *const *const GVariant,
        n_children: gsize,
    ) -> *mut GVariant;
}
extern "C" {
    #[link_name = "\u{1}_g_variant_new_tuple"]
    pub fn g_variant_new_tuple(
        children: *const *const GVariant,
        n_children: gsize,
    ) -> *mut GVariant;
}
extern "C" {
    #[link_name = "\u{1}_g_variant_new_dict_entry"]
    pub fn g_variant_new_dict_entry(key: *mut GVariant, value: *mut GVariant) -> *mut GVariant;
}
extern "C" {
    #[link_name = "\u{1}_g_variant_get_maybe"]
    pub fn g_variant_get_maybe(value: *mut GVariant) -> *mut GVariant;
}
extern "C" {
    #[link_name = "\u{1}_g_variant_n_children"]
    pub fn g_variant_n_children(value: *mut GVariant) -> gsize;
}
extern "C" {
    #[link_name = "\u{1}_g_variant_get_child"]
    pub fn g_variant_get_child(
        value: *mut GVariant,
        index_: gsize,
        format_string: *const gchar,
        ...
    );
}
extern "C" {
    #[link_name = "\u{1}_g_variant_get_child_value"]
    pub fn g_variant_get_child_value(value: *mut GVariant, index_: gsize) -> *mut GVariant;
}
extern "C" {
    #[link_name = "\u{1}_g_variant_lookup"]
    pub fn g_variant_lookup(
        dictionary: *mut GVariant,
        key: *const gchar,
        format_string: *const gchar,
        ...
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_variant_lookup_value"]
    pub fn g_variant_lookup_value(
        dictionary: *mut GVariant,
        key: *const gchar,
        expected_type: *const GVariantType,
    ) -> *mut GVariant;
}
extern "C" {
    #[link_name = "\u{1}_g_variant_get_fixed_array"]
    pub fn g_variant_get_fixed_array(
        value: *mut GVariant,
        n_elements: *mut gsize,
        element_size: gsize,
    ) -> gconstpointer;
}
extern "C" {
    #[link_name = "\u{1}_g_variant_get_size"]
    pub fn g_variant_get_size(value: *mut GVariant) -> gsize;
}
extern "C" {
    #[link_name = "\u{1}_g_variant_get_data"]
    pub fn g_variant_get_data(value: *mut GVariant) -> gconstpointer;
}
extern "C" {
    #[link_name = "\u{1}_g_variant_get_data_as_bytes"]
    pub fn g_variant_get_data_as_bytes(value: *mut GVariant) -> *mut GBytes;
}
extern "C" {
    #[link_name = "\u{1}_g_variant_store"]
    pub fn g_variant_store(value: *mut GVariant, data: gpointer);
}
extern "C" {
    #[link_name = "\u{1}_g_variant_print"]
    pub fn g_variant_print(value: *mut GVariant, type_annotate: gboolean) -> *mut gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_variant_print_string"]
    pub fn g_variant_print_string(
        value: *mut GVariant,
        string: *mut GString,
        type_annotate: gboolean,
    ) -> *mut GString;
}
extern "C" {
    #[link_name = "\u{1}_g_variant_hash"]
    pub fn g_variant_hash(value: gconstpointer) -> guint;
}
extern "C" {
    #[link_name = "\u{1}_g_variant_equal"]
    pub fn g_variant_equal(one: gconstpointer, two: gconstpointer) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_variant_get_normal_form"]
    pub fn g_variant_get_normal_form(value: *mut GVariant) -> *mut GVariant;
}
extern "C" {
    #[link_name = "\u{1}_g_variant_is_normal_form"]
    pub fn g_variant_is_normal_form(value: *mut GVariant) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_variant_byteswap"]
    pub fn g_variant_byteswap(value: *mut GVariant) -> *mut GVariant;
}
extern "C" {
    #[link_name = "\u{1}_g_variant_new_from_bytes"]
    pub fn g_variant_new_from_bytes(
        type_: *const GVariantType,
        bytes: *mut GBytes,
        trusted: gboolean,
    ) -> *mut GVariant;
}
extern "C" {
    #[link_name = "\u{1}_g_variant_new_from_data"]
    pub fn g_variant_new_from_data(
        type_: *const GVariantType,
        data: gconstpointer,
        size: gsize,
        trusted: gboolean,
        notify: GDestroyNotify,
        user_data: gpointer,
    ) -> *mut GVariant;
}
pub type GVariantIter = _GVariantIter;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GVariantIter {
    pub x: [gsize; 16usize],
}
#[test]
fn bindgen_test_layout__GVariantIter() {
    assert_eq!(
        ::std::mem::size_of::<_GVariantIter>(),
        128usize,
        concat!("Size of: ", stringify!(_GVariantIter))
    );
    assert_eq!(
        ::std::mem::align_of::<_GVariantIter>(),
        8usize,
        concat!("Alignment of ", stringify!(_GVariantIter))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GVariantIter>())).x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GVariantIter),
            "::",
            stringify!(x)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_g_variant_iter_new"]
    pub fn g_variant_iter_new(value: *mut GVariant) -> *mut GVariantIter;
}
extern "C" {
    #[link_name = "\u{1}_g_variant_iter_init"]
    pub fn g_variant_iter_init(iter: *mut GVariantIter, value: *mut GVariant) -> gsize;
}
extern "C" {
    #[link_name = "\u{1}_g_variant_iter_copy"]
    pub fn g_variant_iter_copy(iter: *mut GVariantIter) -> *mut GVariantIter;
}
extern "C" {
    #[link_name = "\u{1}_g_variant_iter_n_children"]
    pub fn g_variant_iter_n_children(iter: *mut GVariantIter) -> gsize;
}
extern "C" {
    #[link_name = "\u{1}_g_variant_iter_free"]
    pub fn g_variant_iter_free(iter: *mut GVariantIter);
}
extern "C" {
    #[link_name = "\u{1}_g_variant_iter_next_value"]
    pub fn g_variant_iter_next_value(iter: *mut GVariantIter) -> *mut GVariant;
}
extern "C" {
    #[link_name = "\u{1}_g_variant_iter_next"]
    pub fn g_variant_iter_next(
        iter: *mut GVariantIter,
        format_string: *const gchar,
        ...
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_variant_iter_loop"]
    pub fn g_variant_iter_loop(
        iter: *mut GVariantIter,
        format_string: *const gchar,
        ...
    ) -> gboolean;
}
pub type GVariantBuilder = _GVariantBuilder;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _GVariantBuilder {
    pub u: _GVariantBuilder__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _GVariantBuilder__bindgen_ty_1 {
    pub s: _GVariantBuilder__bindgen_ty_1__bindgen_ty_1,
    pub x: [gsize; 16usize],
    _bindgen_union_align: [u64; 16usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GVariantBuilder__bindgen_ty_1__bindgen_ty_1 {
    pub partial_magic: gsize,
    pub type_: *const GVariantType,
    pub y: [gsize; 14usize],
}
#[test]
fn bindgen_test_layout__GVariantBuilder__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<_GVariantBuilder__bindgen_ty_1__bindgen_ty_1>(),
        128usize,
        concat!(
            "Size of: ",
            stringify!(_GVariantBuilder__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_GVariantBuilder__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_GVariantBuilder__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GVariantBuilder__bindgen_ty_1__bindgen_ty_1>())).partial_magic
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GVariantBuilder__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(partial_magic)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GVariantBuilder__bindgen_ty_1__bindgen_ty_1>())).type_
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GVariantBuilder__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GVariantBuilder__bindgen_ty_1__bindgen_ty_1>())).y as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GVariantBuilder__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(y)
        )
    );
}
#[test]
fn bindgen_test_layout__GVariantBuilder__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<_GVariantBuilder__bindgen_ty_1>(),
        128usize,
        concat!("Size of: ", stringify!(_GVariantBuilder__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<_GVariantBuilder__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(_GVariantBuilder__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GVariantBuilder__bindgen_ty_1>())).s as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GVariantBuilder__bindgen_ty_1),
            "::",
            stringify!(s)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GVariantBuilder__bindgen_ty_1>())).x as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GVariantBuilder__bindgen_ty_1),
            "::",
            stringify!(x)
        )
    );
}
#[test]
fn bindgen_test_layout__GVariantBuilder() {
    assert_eq!(
        ::std::mem::size_of::<_GVariantBuilder>(),
        128usize,
        concat!("Size of: ", stringify!(_GVariantBuilder))
    );
    assert_eq!(
        ::std::mem::align_of::<_GVariantBuilder>(),
        8usize,
        concat!("Alignment of ", stringify!(_GVariantBuilder))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GVariantBuilder>())).u as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GVariantBuilder),
            "::",
            stringify!(u)
        )
    );
}
pub const GVariantParseError_G_VARIANT_PARSE_ERROR_FAILED: GVariantParseError = 0;
pub const GVariantParseError_G_VARIANT_PARSE_ERROR_BASIC_TYPE_EXPECTED: GVariantParseError = 1;
pub const GVariantParseError_G_VARIANT_PARSE_ERROR_CANNOT_INFER_TYPE: GVariantParseError = 2;
pub const GVariantParseError_G_VARIANT_PARSE_ERROR_DEFINITE_TYPE_EXPECTED: GVariantParseError = 3;
pub const GVariantParseError_G_VARIANT_PARSE_ERROR_INPUT_NOT_AT_END: GVariantParseError = 4;
pub const GVariantParseError_G_VARIANT_PARSE_ERROR_INVALID_CHARACTER: GVariantParseError = 5;
pub const GVariantParseError_G_VARIANT_PARSE_ERROR_INVALID_FORMAT_STRING: GVariantParseError = 6;
pub const GVariantParseError_G_VARIANT_PARSE_ERROR_INVALID_OBJECT_PATH: GVariantParseError = 7;
pub const GVariantParseError_G_VARIANT_PARSE_ERROR_INVALID_SIGNATURE: GVariantParseError = 8;
pub const GVariantParseError_G_VARIANT_PARSE_ERROR_INVALID_TYPE_STRING: GVariantParseError = 9;
pub const GVariantParseError_G_VARIANT_PARSE_ERROR_NO_COMMON_TYPE: GVariantParseError = 10;
pub const GVariantParseError_G_VARIANT_PARSE_ERROR_NUMBER_OUT_OF_RANGE: GVariantParseError = 11;
pub const GVariantParseError_G_VARIANT_PARSE_ERROR_NUMBER_TOO_BIG: GVariantParseError = 12;
pub const GVariantParseError_G_VARIANT_PARSE_ERROR_TYPE_ERROR: GVariantParseError = 13;
pub const GVariantParseError_G_VARIANT_PARSE_ERROR_UNEXPECTED_TOKEN: GVariantParseError = 14;
pub const GVariantParseError_G_VARIANT_PARSE_ERROR_UNKNOWN_KEYWORD: GVariantParseError = 15;
pub const GVariantParseError_G_VARIANT_PARSE_ERROR_UNTERMINATED_STRING_CONSTANT : GVariantParseError = 16 ;
pub const GVariantParseError_G_VARIANT_PARSE_ERROR_VALUE_EXPECTED: GVariantParseError = 17;
pub type GVariantParseError = u32;
extern "C" {
    #[link_name = "\u{1}_g_variant_parser_get_error_quark"]
    pub fn g_variant_parser_get_error_quark() -> GQuark;
}
extern "C" {
    #[link_name = "\u{1}_g_variant_parse_error_quark"]
    pub fn g_variant_parse_error_quark() -> GQuark;
}
extern "C" {
    #[link_name = "\u{1}_g_variant_builder_new"]
    pub fn g_variant_builder_new(type_: *const GVariantType) -> *mut GVariantBuilder;
}
extern "C" {
    #[link_name = "\u{1}_g_variant_builder_unref"]
    pub fn g_variant_builder_unref(builder: *mut GVariantBuilder);
}
extern "C" {
    #[link_name = "\u{1}_g_variant_builder_ref"]
    pub fn g_variant_builder_ref(builder: *mut GVariantBuilder) -> *mut GVariantBuilder;
}
extern "C" {
    #[link_name = "\u{1}_g_variant_builder_init"]
    pub fn g_variant_builder_init(builder: *mut GVariantBuilder, type_: *const GVariantType);
}
extern "C" {
    #[link_name = "\u{1}_g_variant_builder_end"]
    pub fn g_variant_builder_end(builder: *mut GVariantBuilder) -> *mut GVariant;
}
extern "C" {
    #[link_name = "\u{1}_g_variant_builder_clear"]
    pub fn g_variant_builder_clear(builder: *mut GVariantBuilder);
}
extern "C" {
    #[link_name = "\u{1}_g_variant_builder_open"]
    pub fn g_variant_builder_open(builder: *mut GVariantBuilder, type_: *const GVariantType);
}
extern "C" {
    #[link_name = "\u{1}_g_variant_builder_close"]
    pub fn g_variant_builder_close(builder: *mut GVariantBuilder);
}
extern "C" {
    #[link_name = "\u{1}_g_variant_builder_add_value"]
    pub fn g_variant_builder_add_value(builder: *mut GVariantBuilder, value: *mut GVariant);
}
extern "C" {
    #[link_name = "\u{1}_g_variant_builder_add"]
    pub fn g_variant_builder_add(builder: *mut GVariantBuilder, format_string: *const gchar, ...);
}
extern "C" {
    #[link_name = "\u{1}_g_variant_builder_add_parsed"]
    pub fn g_variant_builder_add_parsed(builder: *mut GVariantBuilder, format: *const gchar, ...);
}
extern "C" {
    #[link_name = "\u{1}_g_variant_new"]
    pub fn g_variant_new(format_string: *const gchar, ...) -> *mut GVariant;
}
extern "C" {
    #[link_name = "\u{1}_g_variant_get"]
    pub fn g_variant_get(value: *mut GVariant, format_string: *const gchar, ...);
}
extern "C" {
    #[link_name = "\u{1}_g_variant_new_va"]
    pub fn g_variant_new_va(
        format_string: *const gchar,
        endptr: *mut *const gchar,
        app: *mut va_list,
    ) -> *mut GVariant;
}
extern "C" {
    #[link_name = "\u{1}_g_variant_get_va"]
    pub fn g_variant_get_va(
        value: *mut GVariant,
        format_string: *const gchar,
        endptr: *mut *const gchar,
        app: *mut va_list,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_variant_check_format_string"]
    pub fn g_variant_check_format_string(
        value: *mut GVariant,
        format_string: *const gchar,
        copy_only: gboolean,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_variant_parse"]
    pub fn g_variant_parse(
        type_: *const GVariantType,
        text: *const gchar,
        limit: *const gchar,
        endptr: *mut *const gchar,
        error: *mut *mut GError,
    ) -> *mut GVariant;
}
extern "C" {
    #[link_name = "\u{1}_g_variant_new_parsed"]
    pub fn g_variant_new_parsed(format: *const gchar, ...) -> *mut GVariant;
}
extern "C" {
    #[link_name = "\u{1}_g_variant_new_parsed_va"]
    pub fn g_variant_new_parsed_va(format: *const gchar, app: *mut va_list) -> *mut GVariant;
}
extern "C" {
    #[link_name = "\u{1}_g_variant_parse_error_print_context"]
    pub fn g_variant_parse_error_print_context(
        error: *mut GError,
        source_str: *const gchar,
    ) -> *mut gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_variant_compare"]
    pub fn g_variant_compare(one: gconstpointer, two: gconstpointer) -> gint;
}
pub type GVariantDict = _GVariantDict;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _GVariantDict {
    pub u: _GVariantDict__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _GVariantDict__bindgen_ty_1 {
    pub s: _GVariantDict__bindgen_ty_1__bindgen_ty_1,
    pub x: [gsize; 16usize],
    _bindgen_union_align: [u64; 16usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GVariantDict__bindgen_ty_1__bindgen_ty_1 {
    pub asv: *mut GVariant,
    pub partial_magic: gsize,
    pub y: [gsize; 14usize],
}
#[test]
fn bindgen_test_layout__GVariantDict__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<_GVariantDict__bindgen_ty_1__bindgen_ty_1>(),
        128usize,
        concat!(
            "Size of: ",
            stringify!(_GVariantDict__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_GVariantDict__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_GVariantDict__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GVariantDict__bindgen_ty_1__bindgen_ty_1>())).asv as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GVariantDict__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(asv)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GVariantDict__bindgen_ty_1__bindgen_ty_1>())).partial_magic
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GVariantDict__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(partial_magic)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GVariantDict__bindgen_ty_1__bindgen_ty_1>())).y as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GVariantDict__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(y)
        )
    );
}
#[test]
fn bindgen_test_layout__GVariantDict__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<_GVariantDict__bindgen_ty_1>(),
        128usize,
        concat!("Size of: ", stringify!(_GVariantDict__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<_GVariantDict__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(_GVariantDict__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GVariantDict__bindgen_ty_1>())).s as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GVariantDict__bindgen_ty_1),
            "::",
            stringify!(s)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GVariantDict__bindgen_ty_1>())).x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GVariantDict__bindgen_ty_1),
            "::",
            stringify!(x)
        )
    );
}
#[test]
fn bindgen_test_layout__GVariantDict() {
    assert_eq!(
        ::std::mem::size_of::<_GVariantDict>(),
        128usize,
        concat!("Size of: ", stringify!(_GVariantDict))
    );
    assert_eq!(
        ::std::mem::align_of::<_GVariantDict>(),
        8usize,
        concat!("Alignment of ", stringify!(_GVariantDict))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GVariantDict>())).u as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GVariantDict),
            "::",
            stringify!(u)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_g_variant_dict_new"]
    pub fn g_variant_dict_new(from_asv: *mut GVariant) -> *mut GVariantDict;
}
extern "C" {
    #[link_name = "\u{1}_g_variant_dict_init"]
    pub fn g_variant_dict_init(dict: *mut GVariantDict, from_asv: *mut GVariant);
}
extern "C" {
    #[link_name = "\u{1}_g_variant_dict_lookup"]
    pub fn g_variant_dict_lookup(
        dict: *mut GVariantDict,
        key: *const gchar,
        format_string: *const gchar,
        ...
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_variant_dict_lookup_value"]
    pub fn g_variant_dict_lookup_value(
        dict: *mut GVariantDict,
        key: *const gchar,
        expected_type: *const GVariantType,
    ) -> *mut GVariant;
}
extern "C" {
    #[link_name = "\u{1}_g_variant_dict_contains"]
    pub fn g_variant_dict_contains(dict: *mut GVariantDict, key: *const gchar) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_variant_dict_insert"]
    pub fn g_variant_dict_insert(
        dict: *mut GVariantDict,
        key: *const gchar,
        format_string: *const gchar,
        ...
    );
}
extern "C" {
    #[link_name = "\u{1}_g_variant_dict_insert_value"]
    pub fn g_variant_dict_insert_value(
        dict: *mut GVariantDict,
        key: *const gchar,
        value: *mut GVariant,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_variant_dict_remove"]
    pub fn g_variant_dict_remove(dict: *mut GVariantDict, key: *const gchar) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_variant_dict_clear"]
    pub fn g_variant_dict_clear(dict: *mut GVariantDict);
}
extern "C" {
    #[link_name = "\u{1}_g_variant_dict_end"]
    pub fn g_variant_dict_end(dict: *mut GVariantDict) -> *mut GVariant;
}
extern "C" {
    #[link_name = "\u{1}_g_variant_dict_ref"]
    pub fn g_variant_dict_ref(dict: *mut GVariantDict) -> *mut GVariantDict;
}
extern "C" {
    #[link_name = "\u{1}_g_variant_dict_unref"]
    pub fn g_variant_dict_unref(dict: *mut GVariantDict);
}
extern "C" {
    #[link_name = "\u{1}_g_printf_string_upper_bound"]
    pub fn g_printf_string_upper_bound(format: *const gchar, args: *mut __va_list_tag) -> gsize;
}
pub const GLogLevelFlags_G_LOG_FLAG_RECURSION: GLogLevelFlags = 1;
pub const GLogLevelFlags_G_LOG_FLAG_FATAL: GLogLevelFlags = 2;
pub const GLogLevelFlags_G_LOG_LEVEL_ERROR: GLogLevelFlags = 4;
pub const GLogLevelFlags_G_LOG_LEVEL_CRITICAL: GLogLevelFlags = 8;
pub const GLogLevelFlags_G_LOG_LEVEL_WARNING: GLogLevelFlags = 16;
pub const GLogLevelFlags_G_LOG_LEVEL_MESSAGE: GLogLevelFlags = 32;
pub const GLogLevelFlags_G_LOG_LEVEL_INFO: GLogLevelFlags = 64;
pub const GLogLevelFlags_G_LOG_LEVEL_DEBUG: GLogLevelFlags = 128;
pub const GLogLevelFlags_G_LOG_LEVEL_MASK: GLogLevelFlags = -4;
pub type GLogLevelFlags = i32;
pub type GLogFunc = ::std::option::Option<
    unsafe extern "C" fn(
        log_domain: *const gchar,
        log_level: GLogLevelFlags,
        message: *const gchar,
        user_data: gpointer,
    ),
>;
extern "C" {
    #[link_name = "\u{1}_g_log_set_handler"]
    pub fn g_log_set_handler(
        log_domain: *const gchar,
        log_levels: GLogLevelFlags,
        log_func: GLogFunc,
        user_data: gpointer,
    ) -> guint;
}
extern "C" {
    #[link_name = "\u{1}_g_log_set_handler_full"]
    pub fn g_log_set_handler_full(
        log_domain: *const gchar,
        log_levels: GLogLevelFlags,
        log_func: GLogFunc,
        user_data: gpointer,
        destroy: GDestroyNotify,
    ) -> guint;
}
extern "C" {
    #[link_name = "\u{1}_g_log_remove_handler"]
    pub fn g_log_remove_handler(log_domain: *const gchar, handler_id: guint);
}
extern "C" {
    #[link_name = "\u{1}_g_log_default_handler"]
    pub fn g_log_default_handler(
        log_domain: *const gchar,
        log_level: GLogLevelFlags,
        message: *const gchar,
        unused_data: gpointer,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_log_set_default_handler"]
    pub fn g_log_set_default_handler(log_func: GLogFunc, user_data: gpointer) -> GLogFunc;
}
extern "C" {
    #[link_name = "\u{1}_g_log"]
    pub fn g_log(log_domain: *const gchar, log_level: GLogLevelFlags, format: *const gchar, ...);
}
extern "C" {
    #[link_name = "\u{1}_g_logv"]
    pub fn g_logv(
        log_domain: *const gchar,
        log_level: GLogLevelFlags,
        format: *const gchar,
        args: *mut __va_list_tag,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_log_set_fatal_mask"]
    pub fn g_log_set_fatal_mask(
        log_domain: *const gchar,
        fatal_mask: GLogLevelFlags,
    ) -> GLogLevelFlags;
}
extern "C" {
    #[link_name = "\u{1}_g_log_set_always_fatal"]
    pub fn g_log_set_always_fatal(fatal_mask: GLogLevelFlags) -> GLogLevelFlags;
}
pub const GLogWriterOutput_G_LOG_WRITER_HANDLED: GLogWriterOutput = 1;
pub const GLogWriterOutput_G_LOG_WRITER_UNHANDLED: GLogWriterOutput = 0;
/// GLogWriterOutput:
/// @G_LOG_WRITER_HANDLED: Log writer has handled the log entry.
/// @G_LOG_WRITER_UNHANDLED: Log writer could not handle the log entry.
///
/// Return values from #GLogWriterFuncs to indicate whether the given log entry
/// was successfully handled by the writer, or whether there was an error in
/// handling it (and hence a fallback writer should be used).
///
/// If a #GLogWriterFunc ignores a log entry, it should return
/// %G_LOG_WRITER_HANDLED.
///
/// Since: 2.50
pub type GLogWriterOutput = u32;
/// GLogField:
/// @key: field name (UTF-8 string)
/// @value: field value (arbitrary bytes)
/// @length: length of @value, in bytes, or -1 if it is nul-terminated
///
/// Structure representing a single field in a structured log entry. See
/// g_log_structured() for details.
///
/// Log fields may contain arbitrary values, including binary with embedded nul
/// bytes. If the field contains a string, the string must be UTF-8 encoded and
/// have a trailing nul byte. Otherwise, @length must be set to a non-negative
/// value.
///
/// Since: 2.50
pub type GLogField = _GLogField;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GLogField {
    pub key: *const gchar,
    pub value: gconstpointer,
    pub length: gssize,
}
#[test]
fn bindgen_test_layout__GLogField() {
    assert_eq!(
        ::std::mem::size_of::<_GLogField>(),
        24usize,
        concat!("Size of: ", stringify!(_GLogField))
    );
    assert_eq!(
        ::std::mem::align_of::<_GLogField>(),
        8usize,
        concat!("Alignment of ", stringify!(_GLogField))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GLogField>())).key as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GLogField),
            "::",
            stringify!(key)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GLogField>())).value as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GLogField),
            "::",
            stringify!(value)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GLogField>())).length as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GLogField),
            "::",
            stringify!(length)
        )
    );
}
/// GLogWriterFunc:
/// @log_level: log level of the message
/// @fields: (array length=n_fields): fields forming the message
/// @n_fields: number of @fields
/// @user_data: user data passed to g_log_set_writer_func()
///
/// Writer function for log entries. A log entry is a collection of one or more
/// #GLogFields, using the standard [field names from journal
/// specification](https://www.freedesktop.org/software/systemd/man/systemd.journal-fields.html).
/// See g_log_structured() for more information.
///
/// Writer functions must ignore fields which they do not recognise, unless they
/// can write arbitrary binary output, as field values may be arbitrary binary.
///
/// @log_level is guaranteed to be included in @fields as the `PRIORITY` field,
/// but is provided separately for convenience of deciding whether or where to
/// output the log entry.
///
/// Writer functions should return %G_LOG_WRITER_HANDLED if they handled the log
/// message successfully or if they deliberately ignored it. If there was an
/// error handling the message (for example, if the writer function is meant to
/// send messages to a remote logging server and there is a network error), it
/// should return %G_LOG_WRITER_UNHANDLED. This allows writer functions to be
/// chained and fall back to simpler handlers in case of failure.
///
/// Returns: %G_LOG_WRITER_HANDLED if the log entry was handled successfully;
/// %G_LOG_WRITER_UNHANDLED otherwise
/// Since: 2.50
pub type GLogWriterFunc = ::std::option::Option<
    unsafe extern "C" fn(
        log_level: GLogLevelFlags,
        fields: *const GLogField,
        n_fields: gsize,
        user_data: gpointer,
    ) -> GLogWriterOutput,
>;
extern "C" {
    #[link_name = "\u{1}_g_log_structured"]
    pub fn g_log_structured(log_domain: *const gchar, log_level: GLogLevelFlags, ...);
}
extern "C" {
    #[link_name = "\u{1}_g_log_structured_array"]
    pub fn g_log_structured_array(
        log_level: GLogLevelFlags,
        fields: *const GLogField,
        n_fields: gsize,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_log_variant"]
    pub fn g_log_variant(
        log_domain: *const gchar,
        log_level: GLogLevelFlags,
        fields: *mut GVariant,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_log_set_writer_func"]
    pub fn g_log_set_writer_func(
        func: GLogWriterFunc,
        user_data: gpointer,
        user_data_free: GDestroyNotify,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_log_writer_supports_color"]
    pub fn g_log_writer_supports_color(output_fd: gint) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_log_writer_is_journald"]
    pub fn g_log_writer_is_journald(output_fd: gint) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_log_writer_format_fields"]
    pub fn g_log_writer_format_fields(
        log_level: GLogLevelFlags,
        fields: *const GLogField,
        n_fields: gsize,
        use_color: gboolean,
    ) -> *mut gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_log_writer_journald"]
    pub fn g_log_writer_journald(
        log_level: GLogLevelFlags,
        fields: *const GLogField,
        n_fields: gsize,
        user_data: gpointer,
    ) -> GLogWriterOutput;
}
extern "C" {
    #[link_name = "\u{1}_g_log_writer_standard_streams"]
    pub fn g_log_writer_standard_streams(
        log_level: GLogLevelFlags,
        fields: *const GLogField,
        n_fields: gsize,
        user_data: gpointer,
    ) -> GLogWriterOutput;
}
extern "C" {
    #[link_name = "\u{1}_g_log_writer_default"]
    pub fn g_log_writer_default(
        log_level: GLogLevelFlags,
        fields: *const GLogField,
        n_fields: gsize,
        user_data: gpointer,
    ) -> GLogWriterOutput;
}
extern "C" {
    #[link_name = "\u{1}__g_log_fallback_handler"]
    pub fn _g_log_fallback_handler(
        log_domain: *const gchar,
        log_level: GLogLevelFlags,
        message: *const gchar,
        unused_data: gpointer,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_return_if_fail_warning"]
    pub fn g_return_if_fail_warning(
        log_domain: *const ::std::os::raw::c_char,
        pretty_function: *const ::std::os::raw::c_char,
        expression: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_warn_message"]
    pub fn g_warn_message(
        domain: *const ::std::os::raw::c_char,
        file: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
        func: *const ::std::os::raw::c_char,
        warnexpr: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_assert_warning"]
    pub fn g_assert_warning(
        log_domain: *const ::std::os::raw::c_char,
        file: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
        pretty_function: *const ::std::os::raw::c_char,
        expression: *const ::std::os::raw::c_char,
    );
}
/// GPrintFunc:
/// @string: the message to output
///
/// Specifies the type of the print handler functions.
/// These are called with the complete formatted string to output.
pub type GPrintFunc = ::std::option::Option<unsafe extern "C" fn(string: *const gchar)>;
extern "C" {
    #[link_name = "\u{1}_g_print"]
    pub fn g_print(format: *const gchar, ...);
}
extern "C" {
    #[link_name = "\u{1}_g_set_print_handler"]
    pub fn g_set_print_handler(func: GPrintFunc) -> GPrintFunc;
}
extern "C" {
    #[link_name = "\u{1}_g_printerr"]
    pub fn g_printerr(format: *const gchar, ...);
}
extern "C" {
    #[link_name = "\u{1}_g_set_printerr_handler"]
    pub fn g_set_printerr_handler(func: GPrintFunc) -> GPrintFunc;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GOptionContext {
    _unused: [u8; 0],
}
/// GOptionContext:
///
/// A `GOptionContext` struct defines which options
/// are accepted by the commandline option parser. The struct has only private
/// fields and should not be directly accessed.
pub type GOptionContext = _GOptionContext;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GOptionGroup {
    _unused: [u8; 0],
}
/// GOptionGroup:
///
/// A `GOptionGroup` struct defines the options in a single
/// group. The struct has only private fields and should not be directly accessed.
///
/// All options in a group share the same translation function. Libraries which
/// need to parse commandline options are expected to provide a function for
/// getting a `GOptionGroup` holding their options, which
/// the application can then add to its #GOptionContext.
pub type GOptionGroup = _GOptionGroup;
pub type GOptionEntry = _GOptionEntry;
pub const GOptionFlags_G_OPTION_FLAG_NONE: GOptionFlags = 0;
pub const GOptionFlags_G_OPTION_FLAG_HIDDEN: GOptionFlags = 1;
pub const GOptionFlags_G_OPTION_FLAG_IN_MAIN: GOptionFlags = 2;
pub const GOptionFlags_G_OPTION_FLAG_REVERSE: GOptionFlags = 4;
pub const GOptionFlags_G_OPTION_FLAG_NO_ARG: GOptionFlags = 8;
pub const GOptionFlags_G_OPTION_FLAG_FILENAME: GOptionFlags = 16;
pub const GOptionFlags_G_OPTION_FLAG_OPTIONAL_ARG: GOptionFlags = 32;
pub const GOptionFlags_G_OPTION_FLAG_NOALIAS: GOptionFlags = 64;
/// GOptionFlags:
/// @G_OPTION_FLAG_NONE: No flags. Since: 2.42.
/// @G_OPTION_FLAG_HIDDEN: The option doesn't appear in `--help` output.
/// @G_OPTION_FLAG_IN_MAIN: The option appears in the main section of the
/// `--help` output, even if it is defined in a group.
/// @G_OPTION_FLAG_REVERSE: For options of the %G_OPTION_ARG_NONE kind, this
/// flag indicates that the sense of the option is reversed.
/// @G_OPTION_FLAG_NO_ARG: For options of the %G_OPTION_ARG_CALLBACK kind,
/// this flag indicates that the callback does not take any argument
/// (like a %G_OPTION_ARG_NONE option). Since 2.8
/// @G_OPTION_FLAG_FILENAME: For options of the %G_OPTION_ARG_CALLBACK
/// kind, this flag indicates that the argument should be passed to the
/// callback in the GLib filename encoding rather than UTF-8. Since 2.8
/// @G_OPTION_FLAG_OPTIONAL_ARG: For options of the %G_OPTION_ARG_CALLBACK
/// kind, this flag indicates that the argument supply is optional.
/// If no argument is given then data of %GOptionParseFunc will be
/// set to NULL. Since 2.8
/// @G_OPTION_FLAG_NOALIAS: This flag turns off the automatic conflict
/// resolution which prefixes long option names with `groupname-` if
/// there is a conflict. This option should only be used in situations
/// where aliasing is necessary to model some legacy commandline interface.
/// It is not safe to use this option, unless all option groups are under
/// your direct control. Since 2.8.
///
/// Flags which modify individual options.
pub type GOptionFlags = u32;
pub const GOptionArg_G_OPTION_ARG_NONE: GOptionArg = 0;
pub const GOptionArg_G_OPTION_ARG_STRING: GOptionArg = 1;
pub const GOptionArg_G_OPTION_ARG_INT: GOptionArg = 2;
pub const GOptionArg_G_OPTION_ARG_CALLBACK: GOptionArg = 3;
pub const GOptionArg_G_OPTION_ARG_FILENAME: GOptionArg = 4;
pub const GOptionArg_G_OPTION_ARG_STRING_ARRAY: GOptionArg = 5;
pub const GOptionArg_G_OPTION_ARG_FILENAME_ARRAY: GOptionArg = 6;
pub const GOptionArg_G_OPTION_ARG_DOUBLE: GOptionArg = 7;
pub const GOptionArg_G_OPTION_ARG_INT64: GOptionArg = 8;
/// GOptionArg:
/// @G_OPTION_ARG_NONE: No extra argument. This is useful for simple flags.
/// @G_OPTION_ARG_STRING: The option takes a string argument.
/// @G_OPTION_ARG_INT: The option takes an integer argument.
/// @G_OPTION_ARG_CALLBACK: The option provides a callback (of type
/// #GOptionArgFunc) to parse the extra argument.
/// @G_OPTION_ARG_FILENAME: The option takes a filename as argument.
/// @G_OPTION_ARG_STRING_ARRAY: The option takes a string argument, multiple
/// uses of the option are collected into an array of strings.
/// @G_OPTION_ARG_FILENAME_ARRAY: The option takes a filename as argument,
/// multiple uses of the option are collected into an array of strings.
/// @G_OPTION_ARG_DOUBLE: The option takes a double argument. The argument
/// can be formatted either for the user's locale or for the "C" locale.
/// Since 2.12
/// @G_OPTION_ARG_INT64: The option takes a 64-bit integer. Like
/// %G_OPTION_ARG_INT but for larger numbers. The number can be in
/// decimal base, or in hexadecimal (when prefixed with `0x`, for
/// example, `0xffffffff`). Since 2.12
///
/// The #GOptionArg enum values determine which type of extra argument the
/// options expect to find. If an option expects an extra argument, it can
/// be specified in several ways; with a short option: `-x arg`, with a long
/// option: `--name arg` or combined in a single argument: `--name=arg`.
pub type GOptionArg = u32;
/// GOptionArgFunc:
/// @option_name: The name of the option being parsed. This will be either a
/// single dash followed by a single letter (for a short name) or two dashes
/// followed by a long option name.
/// @value: The value to be parsed.
/// @data: User data added to the #GOptionGroup containing the option when it
/// was created with g_option_group_new()
/// @error: A return location for errors. The error code %G_OPTION_ERROR_FAILED
/// is intended to be used for errors in #GOptionArgFunc callbacks.
///
/// The type of function to be passed as callback for %G_OPTION_ARG_CALLBACK
/// options.
///
/// Returns: %TRUE if the option was successfully parsed, %FALSE if an error
/// occurred, in which case @error should be set with g_set_error()
pub type GOptionArgFunc = ::std::option::Option<
    unsafe extern "C" fn(
        option_name: *const gchar,
        value: *const gchar,
        data: gpointer,
        error: *mut *mut GError,
    ) -> gboolean,
>;
/// GOptionParseFunc:
/// @context: The active #GOptionContext
/// @group: The group to which the function belongs
/// @data: User data added to the #GOptionGroup containing the option when it
/// was created with g_option_group_new()
/// @error: A return location for error details
///
/// The type of function that can be called before and after parsing.
///
/// Returns: %TRUE if the function completed successfully, %FALSE if an error
/// occurred, in which case @error should be set with g_set_error()
pub type GOptionParseFunc = ::std::option::Option<
    unsafe extern "C" fn(
        context: *mut GOptionContext,
        group: *mut GOptionGroup,
        data: gpointer,
        error: *mut *mut GError,
    ) -> gboolean,
>;
/// GOptionErrorFunc:
/// @context: The active #GOptionContext
/// @group: The group to which the function belongs
/// @data: User data added to the #GOptionGroup containing the option when it
/// was created with g_option_group_new()
/// @error: The #GError containing details about the parse error
///
/// The type of function to be used as callback when a parse error occurs.
pub type GOptionErrorFunc = ::std::option::Option<
    unsafe extern "C" fn(
        context: *mut GOptionContext,
        group: *mut GOptionGroup,
        data: gpointer,
        error: *mut *mut GError,
    ),
>;
pub const GOptionError_G_OPTION_ERROR_UNKNOWN_OPTION: GOptionError = 0;
pub const GOptionError_G_OPTION_ERROR_BAD_VALUE: GOptionError = 1;
pub const GOptionError_G_OPTION_ERROR_FAILED: GOptionError = 2;
/// GOptionError:
/// @G_OPTION_ERROR_UNKNOWN_OPTION: An option was not known to the parser.
/// This error will only be reported, if the parser hasn't been instructed
/// to ignore unknown options, see g_option_context_set_ignore_unknown_options().
/// @G_OPTION_ERROR_BAD_VALUE: A value couldn't be parsed.
/// @G_OPTION_ERROR_FAILED: A #GOptionArgFunc callback failed.
///
/// Error codes returned by option parsing.
pub type GOptionError = u32;
extern "C" {
    #[link_name = "\u{1}_g_option_error_quark"]
    pub fn g_option_error_quark() -> GQuark;
}
/// GOptionEntry:
/// @long_name: The long name of an option can be used to specify it
/// in a commandline as `--long_name`. Every option must have a
/// long name. To resolve conflicts if multiple option groups contain
/// the same long name, it is also possible to specify the option as
/// `--groupname-long_name`.
/// @short_name: If an option has a short name, it can be specified
/// `-short_name` in a commandline. @short_name must be  a printable
/// ASCII character different from '-', or zero if the option has no
/// short name.
/// @flags: Flags from #GOptionFlags
/// @arg: The type of the option, as a #GOptionArg
/// @arg_data: If the @arg type is %G_OPTION_ARG_CALLBACK, then @arg_data
/// must point to a #GOptionArgFunc callback function, which will be
/// called to handle the extra argument. Otherwise, @arg_data is a
/// pointer to a location to store the value, the required type of
/// the location depends on the @arg type:
/// - %G_OPTION_ARG_NONE: %gboolean
/// - %G_OPTION_ARG_STRING: %gchar*
/// - %G_OPTION_ARG_INT: %gint
/// - %G_OPTION_ARG_FILENAME: %gchar*
/// - %G_OPTION_ARG_STRING_ARRAY: %gchar**
/// - %G_OPTION_ARG_FILENAME_ARRAY: %gchar**
/// - %G_OPTION_ARG_DOUBLE: %gdouble
/// If @arg type is %G_OPTION_ARG_STRING or %G_OPTION_ARG_FILENAME,
/// the location will contain a newly allocated string if the option
/// was given. That string needs to be freed by the callee using g_free().
/// Likewise if @arg type is %G_OPTION_ARG_STRING_ARRAY or
/// %G_OPTION_ARG_FILENAME_ARRAY, the data should be freed using g_strfreev().
/// @description: the description for the option in `--help`
/// output. The @description is translated using the @translate_func
/// of the group, see g_option_group_set_translation_domain().
/// @arg_description: The placeholder to use for the extra argument parsed
/// by the option in `--help` output. The @arg_description is translated
/// using the @translate_func of the group, see
/// g_option_group_set_translation_domain().
///
/// A GOptionEntry struct defines a single option. To have an effect, they
/// must be added to a #GOptionGroup with g_option_context_add_main_entries()
/// or g_option_group_add_entries().
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GOptionEntry {
    pub long_name: *const gchar,
    pub short_name: gchar,
    pub flags: gint,
    pub arg: GOptionArg,
    pub arg_data: gpointer,
    pub description: *const gchar,
    pub arg_description: *const gchar,
}
#[test]
fn bindgen_test_layout__GOptionEntry() {
    assert_eq!(
        ::std::mem::size_of::<_GOptionEntry>(),
        48usize,
        concat!("Size of: ", stringify!(_GOptionEntry))
    );
    assert_eq!(
        ::std::mem::align_of::<_GOptionEntry>(),
        8usize,
        concat!("Alignment of ", stringify!(_GOptionEntry))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GOptionEntry>())).long_name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GOptionEntry),
            "::",
            stringify!(long_name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GOptionEntry>())).short_name as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GOptionEntry),
            "::",
            stringify!(short_name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GOptionEntry>())).flags as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_GOptionEntry),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GOptionEntry>())).arg as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GOptionEntry),
            "::",
            stringify!(arg)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GOptionEntry>())).arg_data as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GOptionEntry),
            "::",
            stringify!(arg_data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GOptionEntry>())).description as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_GOptionEntry),
            "::",
            stringify!(description)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GOptionEntry>())).arg_description as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_GOptionEntry),
            "::",
            stringify!(arg_description)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_g_option_context_new"]
    pub fn g_option_context_new(parameter_string: *const gchar) -> *mut GOptionContext;
}
extern "C" {
    #[link_name = "\u{1}_g_option_context_set_summary"]
    pub fn g_option_context_set_summary(context: *mut GOptionContext, summary: *const gchar);
}
extern "C" {
    #[link_name = "\u{1}_g_option_context_get_summary"]
    pub fn g_option_context_get_summary(context: *mut GOptionContext) -> *const gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_option_context_set_description"]
    pub fn g_option_context_set_description(
        context: *mut GOptionContext,
        description: *const gchar,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_option_context_get_description"]
    pub fn g_option_context_get_description(context: *mut GOptionContext) -> *const gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_option_context_free"]
    pub fn g_option_context_free(context: *mut GOptionContext);
}
extern "C" {
    #[link_name = "\u{1}_g_option_context_set_help_enabled"]
    pub fn g_option_context_set_help_enabled(context: *mut GOptionContext, help_enabled: gboolean);
}
extern "C" {
    #[link_name = "\u{1}_g_option_context_get_help_enabled"]
    pub fn g_option_context_get_help_enabled(context: *mut GOptionContext) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_option_context_set_ignore_unknown_options"]
    pub fn g_option_context_set_ignore_unknown_options(
        context: *mut GOptionContext,
        ignore_unknown: gboolean,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_option_context_get_ignore_unknown_options"]
    pub fn g_option_context_get_ignore_unknown_options(context: *mut GOptionContext) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_option_context_set_strict_posix"]
    pub fn g_option_context_set_strict_posix(context: *mut GOptionContext, strict_posix: gboolean);
}
extern "C" {
    #[link_name = "\u{1}_g_option_context_get_strict_posix"]
    pub fn g_option_context_get_strict_posix(context: *mut GOptionContext) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_option_context_add_main_entries"]
    pub fn g_option_context_add_main_entries(
        context: *mut GOptionContext,
        entries: *const GOptionEntry,
        translation_domain: *const gchar,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_option_context_parse"]
    pub fn g_option_context_parse(
        context: *mut GOptionContext,
        argc: *mut gint,
        argv: *mut *mut *mut gchar,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_option_context_parse_strv"]
    pub fn g_option_context_parse_strv(
        context: *mut GOptionContext,
        arguments: *mut *mut *mut gchar,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_option_context_set_translate_func"]
    pub fn g_option_context_set_translate_func(
        context: *mut GOptionContext,
        func: GTranslateFunc,
        data: gpointer,
        destroy_notify: GDestroyNotify,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_option_context_set_translation_domain"]
    pub fn g_option_context_set_translation_domain(
        context: *mut GOptionContext,
        domain: *const gchar,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_option_context_add_group"]
    pub fn g_option_context_add_group(context: *mut GOptionContext, group: *mut GOptionGroup);
}
extern "C" {
    #[link_name = "\u{1}_g_option_context_set_main_group"]
    pub fn g_option_context_set_main_group(context: *mut GOptionContext, group: *mut GOptionGroup);
}
extern "C" {
    #[link_name = "\u{1}_g_option_context_get_main_group"]
    pub fn g_option_context_get_main_group(context: *mut GOptionContext) -> *mut GOptionGroup;
}
extern "C" {
    #[link_name = "\u{1}_g_option_context_get_help"]
    pub fn g_option_context_get_help(
        context: *mut GOptionContext,
        main_help: gboolean,
        group: *mut GOptionGroup,
    ) -> *mut gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_option_group_new"]
    pub fn g_option_group_new(
        name: *const gchar,
        description: *const gchar,
        help_description: *const gchar,
        user_data: gpointer,
        destroy: GDestroyNotify,
    ) -> *mut GOptionGroup;
}
extern "C" {
    #[link_name = "\u{1}_g_option_group_set_parse_hooks"]
    pub fn g_option_group_set_parse_hooks(
        group: *mut GOptionGroup,
        pre_parse_func: GOptionParseFunc,
        post_parse_func: GOptionParseFunc,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_option_group_set_error_hook"]
    pub fn g_option_group_set_error_hook(group: *mut GOptionGroup, error_func: GOptionErrorFunc);
}
extern "C" {
    #[link_name = "\u{1}_g_option_group_free"]
    pub fn g_option_group_free(group: *mut GOptionGroup);
}
extern "C" {
    #[link_name = "\u{1}_g_option_group_ref"]
    pub fn g_option_group_ref(group: *mut GOptionGroup) -> *mut GOptionGroup;
}
extern "C" {
    #[link_name = "\u{1}_g_option_group_unref"]
    pub fn g_option_group_unref(group: *mut GOptionGroup);
}
extern "C" {
    #[link_name = "\u{1}_g_option_group_add_entries"]
    pub fn g_option_group_add_entries(group: *mut GOptionGroup, entries: *const GOptionEntry);
}
extern "C" {
    #[link_name = "\u{1}_g_option_group_set_translate_func"]
    pub fn g_option_group_set_translate_func(
        group: *mut GOptionGroup,
        func: GTranslateFunc,
        data: gpointer,
        destroy_notify: GDestroyNotify,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_option_group_set_translation_domain"]
    pub fn g_option_group_set_translation_domain(group: *mut GOptionGroup, domain: *const gchar);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GPatternSpec {
    _unused: [u8; 0],
}
pub type GPatternSpec = _GPatternSpec;
extern "C" {
    #[link_name = "\u{1}_g_pattern_spec_new"]
    pub fn g_pattern_spec_new(pattern: *const gchar) -> *mut GPatternSpec;
}
extern "C" {
    #[link_name = "\u{1}_g_pattern_spec_free"]
    pub fn g_pattern_spec_free(pspec: *mut GPatternSpec);
}
extern "C" {
    #[link_name = "\u{1}_g_pattern_spec_equal"]
    pub fn g_pattern_spec_equal(pspec1: *mut GPatternSpec, pspec2: *mut GPatternSpec) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_pattern_match"]
    pub fn g_pattern_match(
        pspec: *mut GPatternSpec,
        string_length: guint,
        string: *const gchar,
        string_reversed: *const gchar,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_pattern_match_string"]
    pub fn g_pattern_match_string(pspec: *mut GPatternSpec, string: *const gchar) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_pattern_match_simple"]
    pub fn g_pattern_match_simple(pattern: *const gchar, string: *const gchar) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_spaced_primes_closest"]
    pub fn g_spaced_primes_closest(num: guint) -> guint;
}
extern "C" {
    #[link_name = "\u{1}_g_qsort_with_data"]
    pub fn g_qsort_with_data(
        pbase: gconstpointer,
        total_elems: gint,
        size: gsize,
        compare_func: GCompareDataFunc,
        user_data: gpointer,
    );
}
pub type GQueue = _GQueue;
/// GQueue:
/// @head: a pointer to the first element of the queue
/// @tail: a pointer to the last element of the queue
/// @length: the number of elements in the queue
///
/// Contains the public fields of a
/// [Queue][glib-Double-ended-Queues].
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GQueue {
    pub head: *mut GList,
    pub tail: *mut GList,
    pub length: guint,
}
#[test]
fn bindgen_test_layout__GQueue() {
    assert_eq!(
        ::std::mem::size_of::<_GQueue>(),
        24usize,
        concat!("Size of: ", stringify!(_GQueue))
    );
    assert_eq!(
        ::std::mem::align_of::<_GQueue>(),
        8usize,
        concat!("Alignment of ", stringify!(_GQueue))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GQueue>())).head as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GQueue),
            "::",
            stringify!(head)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GQueue>())).tail as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GQueue),
            "::",
            stringify!(tail)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GQueue>())).length as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GQueue),
            "::",
            stringify!(length)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_g_queue_new"]
    pub fn g_queue_new() -> *mut GQueue;
}
extern "C" {
    #[link_name = "\u{1}_g_queue_free"]
    pub fn g_queue_free(queue: *mut GQueue);
}
extern "C" {
    #[link_name = "\u{1}_g_queue_free_full"]
    pub fn g_queue_free_full(queue: *mut GQueue, free_func: GDestroyNotify);
}
extern "C" {
    #[link_name = "\u{1}_g_queue_init"]
    pub fn g_queue_init(queue: *mut GQueue);
}
extern "C" {
    #[link_name = "\u{1}_g_queue_clear"]
    pub fn g_queue_clear(queue: *mut GQueue);
}
extern "C" {
    #[link_name = "\u{1}_g_queue_is_empty"]
    pub fn g_queue_is_empty(queue: *mut GQueue) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_queue_get_length"]
    pub fn g_queue_get_length(queue: *mut GQueue) -> guint;
}
extern "C" {
    #[link_name = "\u{1}_g_queue_reverse"]
    pub fn g_queue_reverse(queue: *mut GQueue);
}
extern "C" {
    #[link_name = "\u{1}_g_queue_copy"]
    pub fn g_queue_copy(queue: *mut GQueue) -> *mut GQueue;
}
extern "C" {
    #[link_name = "\u{1}_g_queue_foreach"]
    pub fn g_queue_foreach(queue: *mut GQueue, func: GFunc, user_data: gpointer);
}
extern "C" {
    #[link_name = "\u{1}_g_queue_find"]
    pub fn g_queue_find(queue: *mut GQueue, data: gconstpointer) -> *mut GList;
}
extern "C" {
    #[link_name = "\u{1}_g_queue_find_custom"]
    pub fn g_queue_find_custom(
        queue: *mut GQueue,
        data: gconstpointer,
        func: GCompareFunc,
    ) -> *mut GList;
}
extern "C" {
    #[link_name = "\u{1}_g_queue_sort"]
    pub fn g_queue_sort(queue: *mut GQueue, compare_func: GCompareDataFunc, user_data: gpointer);
}
extern "C" {
    #[link_name = "\u{1}_g_queue_push_head"]
    pub fn g_queue_push_head(queue: *mut GQueue, data: gpointer);
}
extern "C" {
    #[link_name = "\u{1}_g_queue_push_tail"]
    pub fn g_queue_push_tail(queue: *mut GQueue, data: gpointer);
}
extern "C" {
    #[link_name = "\u{1}_g_queue_push_nth"]
    pub fn g_queue_push_nth(queue: *mut GQueue, data: gpointer, n: gint);
}
extern "C" {
    #[link_name = "\u{1}_g_queue_pop_head"]
    pub fn g_queue_pop_head(queue: *mut GQueue) -> gpointer;
}
extern "C" {
    #[link_name = "\u{1}_g_queue_pop_tail"]
    pub fn g_queue_pop_tail(queue: *mut GQueue) -> gpointer;
}
extern "C" {
    #[link_name = "\u{1}_g_queue_pop_nth"]
    pub fn g_queue_pop_nth(queue: *mut GQueue, n: guint) -> gpointer;
}
extern "C" {
    #[link_name = "\u{1}_g_queue_peek_head"]
    pub fn g_queue_peek_head(queue: *mut GQueue) -> gpointer;
}
extern "C" {
    #[link_name = "\u{1}_g_queue_peek_tail"]
    pub fn g_queue_peek_tail(queue: *mut GQueue) -> gpointer;
}
extern "C" {
    #[link_name = "\u{1}_g_queue_peek_nth"]
    pub fn g_queue_peek_nth(queue: *mut GQueue, n: guint) -> gpointer;
}
extern "C" {
    #[link_name = "\u{1}_g_queue_index"]
    pub fn g_queue_index(queue: *mut GQueue, data: gconstpointer) -> gint;
}
extern "C" {
    #[link_name = "\u{1}_g_queue_remove"]
    pub fn g_queue_remove(queue: *mut GQueue, data: gconstpointer) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_queue_remove_all"]
    pub fn g_queue_remove_all(queue: *mut GQueue, data: gconstpointer) -> guint;
}
extern "C" {
    #[link_name = "\u{1}_g_queue_insert_before"]
    pub fn g_queue_insert_before(queue: *mut GQueue, sibling: *mut GList, data: gpointer);
}
extern "C" {
    #[link_name = "\u{1}_g_queue_insert_after"]
    pub fn g_queue_insert_after(queue: *mut GQueue, sibling: *mut GList, data: gpointer);
}
extern "C" {
    #[link_name = "\u{1}_g_queue_insert_sorted"]
    pub fn g_queue_insert_sorted(
        queue: *mut GQueue,
        data: gpointer,
        func: GCompareDataFunc,
        user_data: gpointer,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_queue_push_head_link"]
    pub fn g_queue_push_head_link(queue: *mut GQueue, link_: *mut GList);
}
extern "C" {
    #[link_name = "\u{1}_g_queue_push_tail_link"]
    pub fn g_queue_push_tail_link(queue: *mut GQueue, link_: *mut GList);
}
extern "C" {
    #[link_name = "\u{1}_g_queue_push_nth_link"]
    pub fn g_queue_push_nth_link(queue: *mut GQueue, n: gint, link_: *mut GList);
}
extern "C" {
    #[link_name = "\u{1}_g_queue_pop_head_link"]
    pub fn g_queue_pop_head_link(queue: *mut GQueue) -> *mut GList;
}
extern "C" {
    #[link_name = "\u{1}_g_queue_pop_tail_link"]
    pub fn g_queue_pop_tail_link(queue: *mut GQueue) -> *mut GList;
}
extern "C" {
    #[link_name = "\u{1}_g_queue_pop_nth_link"]
    pub fn g_queue_pop_nth_link(queue: *mut GQueue, n: guint) -> *mut GList;
}
extern "C" {
    #[link_name = "\u{1}_g_queue_peek_head_link"]
    pub fn g_queue_peek_head_link(queue: *mut GQueue) -> *mut GList;
}
extern "C" {
    #[link_name = "\u{1}_g_queue_peek_tail_link"]
    pub fn g_queue_peek_tail_link(queue: *mut GQueue) -> *mut GList;
}
extern "C" {
    #[link_name = "\u{1}_g_queue_peek_nth_link"]
    pub fn g_queue_peek_nth_link(queue: *mut GQueue, n: guint) -> *mut GList;
}
extern "C" {
    #[link_name = "\u{1}_g_queue_link_index"]
    pub fn g_queue_link_index(queue: *mut GQueue, link_: *mut GList) -> gint;
}
extern "C" {
    #[link_name = "\u{1}_g_queue_unlink"]
    pub fn g_queue_unlink(queue: *mut GQueue, link_: *mut GList);
}
extern "C" {
    #[link_name = "\u{1}_g_queue_delete_link"]
    pub fn g_queue_delete_link(queue: *mut GQueue, link_: *mut GList);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GRand {
    _unused: [u8; 0],
}
pub type GRand = _GRand;
extern "C" {
    #[link_name = "\u{1}_g_rand_new_with_seed"]
    pub fn g_rand_new_with_seed(seed: guint32) -> *mut GRand;
}
extern "C" {
    #[link_name = "\u{1}_g_rand_new_with_seed_array"]
    pub fn g_rand_new_with_seed_array(seed: *const guint32, seed_length: guint) -> *mut GRand;
}
extern "C" {
    #[link_name = "\u{1}_g_rand_new"]
    pub fn g_rand_new() -> *mut GRand;
}
extern "C" {
    #[link_name = "\u{1}_g_rand_free"]
    pub fn g_rand_free(rand_: *mut GRand);
}
extern "C" {
    #[link_name = "\u{1}_g_rand_copy"]
    pub fn g_rand_copy(rand_: *mut GRand) -> *mut GRand;
}
extern "C" {
    #[link_name = "\u{1}_g_rand_set_seed"]
    pub fn g_rand_set_seed(rand_: *mut GRand, seed: guint32);
}
extern "C" {
    #[link_name = "\u{1}_g_rand_set_seed_array"]
    pub fn g_rand_set_seed_array(rand_: *mut GRand, seed: *const guint32, seed_length: guint);
}
extern "C" {
    #[link_name = "\u{1}_g_rand_int"]
    pub fn g_rand_int(rand_: *mut GRand) -> guint32;
}
extern "C" {
    #[link_name = "\u{1}_g_rand_int_range"]
    pub fn g_rand_int_range(rand_: *mut GRand, begin: gint32, end: gint32) -> gint32;
}
extern "C" {
    #[link_name = "\u{1}_g_rand_double"]
    pub fn g_rand_double(rand_: *mut GRand) -> gdouble;
}
extern "C" {
    #[link_name = "\u{1}_g_rand_double_range"]
    pub fn g_rand_double_range(rand_: *mut GRand, begin: gdouble, end: gdouble) -> gdouble;
}
extern "C" {
    #[link_name = "\u{1}_g_random_set_seed"]
    pub fn g_random_set_seed(seed: guint32);
}
extern "C" {
    #[link_name = "\u{1}_g_random_int"]
    pub fn g_random_int() -> guint32;
}
extern "C" {
    #[link_name = "\u{1}_g_random_int_range"]
    pub fn g_random_int_range(begin: gint32, end: gint32) -> gint32;
}
extern "C" {
    #[link_name = "\u{1}_g_random_double"]
    pub fn g_random_double() -> gdouble;
}
extern "C" {
    #[link_name = "\u{1}_g_random_double_range"]
    pub fn g_random_double_range(begin: gdouble, end: gdouble) -> gdouble;
}
pub const GRegexError_G_REGEX_ERROR_COMPILE: GRegexError = 0;
pub const GRegexError_G_REGEX_ERROR_OPTIMIZE: GRegexError = 1;
pub const GRegexError_G_REGEX_ERROR_REPLACE: GRegexError = 2;
pub const GRegexError_G_REGEX_ERROR_MATCH: GRegexError = 3;
pub const GRegexError_G_REGEX_ERROR_INTERNAL: GRegexError = 4;
pub const GRegexError_G_REGEX_ERROR_STRAY_BACKSLASH: GRegexError = 101;
pub const GRegexError_G_REGEX_ERROR_MISSING_CONTROL_CHAR: GRegexError = 102;
pub const GRegexError_G_REGEX_ERROR_UNRECOGNIZED_ESCAPE: GRegexError = 103;
pub const GRegexError_G_REGEX_ERROR_QUANTIFIERS_OUT_OF_ORDER: GRegexError = 104;
pub const GRegexError_G_REGEX_ERROR_QUANTIFIER_TOO_BIG: GRegexError = 105;
pub const GRegexError_G_REGEX_ERROR_UNTERMINATED_CHARACTER_CLASS: GRegexError = 106;
pub const GRegexError_G_REGEX_ERROR_INVALID_ESCAPE_IN_CHARACTER_CLASS: GRegexError = 107;
pub const GRegexError_G_REGEX_ERROR_RANGE_OUT_OF_ORDER: GRegexError = 108;
pub const GRegexError_G_REGEX_ERROR_NOTHING_TO_REPEAT: GRegexError = 109;
pub const GRegexError_G_REGEX_ERROR_UNRECOGNIZED_CHARACTER: GRegexError = 112;
pub const GRegexError_G_REGEX_ERROR_POSIX_NAMED_CLASS_OUTSIDE_CLASS: GRegexError = 113;
pub const GRegexError_G_REGEX_ERROR_UNMATCHED_PARENTHESIS: GRegexError = 114;
pub const GRegexError_G_REGEX_ERROR_INEXISTENT_SUBPATTERN_REFERENCE: GRegexError = 115;
pub const GRegexError_G_REGEX_ERROR_UNTERMINATED_COMMENT: GRegexError = 118;
pub const GRegexError_G_REGEX_ERROR_EXPRESSION_TOO_LARGE: GRegexError = 120;
pub const GRegexError_G_REGEX_ERROR_MEMORY_ERROR: GRegexError = 121;
pub const GRegexError_G_REGEX_ERROR_VARIABLE_LENGTH_LOOKBEHIND: GRegexError = 125;
pub const GRegexError_G_REGEX_ERROR_MALFORMED_CONDITION: GRegexError = 126;
pub const GRegexError_G_REGEX_ERROR_TOO_MANY_CONDITIONAL_BRANCHES: GRegexError = 127;
pub const GRegexError_G_REGEX_ERROR_ASSERTION_EXPECTED: GRegexError = 128;
pub const GRegexError_G_REGEX_ERROR_UNKNOWN_POSIX_CLASS_NAME: GRegexError = 130;
pub const GRegexError_G_REGEX_ERROR_POSIX_COLLATING_ELEMENTS_NOT_SUPPORTED: GRegexError = 131;
pub const GRegexError_G_REGEX_ERROR_HEX_CODE_TOO_LARGE: GRegexError = 134;
pub const GRegexError_G_REGEX_ERROR_INVALID_CONDITION: GRegexError = 135;
pub const GRegexError_G_REGEX_ERROR_SINGLE_BYTE_MATCH_IN_LOOKBEHIND: GRegexError = 136;
pub const GRegexError_G_REGEX_ERROR_INFINITE_LOOP: GRegexError = 140;
pub const GRegexError_G_REGEX_ERROR_MISSING_SUBPATTERN_NAME_TERMINATOR: GRegexError = 142;
pub const GRegexError_G_REGEX_ERROR_DUPLICATE_SUBPATTERN_NAME: GRegexError = 143;
pub const GRegexError_G_REGEX_ERROR_MALFORMED_PROPERTY: GRegexError = 146;
pub const GRegexError_G_REGEX_ERROR_UNKNOWN_PROPERTY: GRegexError = 147;
pub const GRegexError_G_REGEX_ERROR_SUBPATTERN_NAME_TOO_LONG: GRegexError = 148;
pub const GRegexError_G_REGEX_ERROR_TOO_MANY_SUBPATTERNS: GRegexError = 149;
pub const GRegexError_G_REGEX_ERROR_INVALID_OCTAL_VALUE: GRegexError = 151;
pub const GRegexError_G_REGEX_ERROR_TOO_MANY_BRANCHES_IN_DEFINE: GRegexError = 154;
pub const GRegexError_G_REGEX_ERROR_DEFINE_REPETION: GRegexError = 155;
pub const GRegexError_G_REGEX_ERROR_INCONSISTENT_NEWLINE_OPTIONS: GRegexError = 156;
pub const GRegexError_G_REGEX_ERROR_MISSING_BACK_REFERENCE: GRegexError = 157;
pub const GRegexError_G_REGEX_ERROR_INVALID_RELATIVE_REFERENCE: GRegexError = 158;
pub const GRegexError_G_REGEX_ERROR_BACKTRACKING_CONTROL_VERB_ARGUMENT_FORBIDDEN: GRegexError = 159;
pub const GRegexError_G_REGEX_ERROR_UNKNOWN_BACKTRACKING_CONTROL_VERB: GRegexError = 160;
pub const GRegexError_G_REGEX_ERROR_NUMBER_TOO_BIG: GRegexError = 161;
pub const GRegexError_G_REGEX_ERROR_MISSING_SUBPATTERN_NAME: GRegexError = 162;
pub const GRegexError_G_REGEX_ERROR_MISSING_DIGIT: GRegexError = 163;
pub const GRegexError_G_REGEX_ERROR_INVALID_DATA_CHARACTER: GRegexError = 164;
pub const GRegexError_G_REGEX_ERROR_EXTRA_SUBPATTERN_NAME: GRegexError = 165;
pub const GRegexError_G_REGEX_ERROR_BACKTRACKING_CONTROL_VERB_ARGUMENT_REQUIRED: GRegexError = 166;
pub const GRegexError_G_REGEX_ERROR_INVALID_CONTROL_CHAR: GRegexError = 168;
pub const GRegexError_G_REGEX_ERROR_MISSING_NAME: GRegexError = 169;
pub const GRegexError_G_REGEX_ERROR_NOT_SUPPORTED_IN_CLASS: GRegexError = 171;
pub const GRegexError_G_REGEX_ERROR_TOO_MANY_FORWARD_REFERENCES: GRegexError = 172;
pub const GRegexError_G_REGEX_ERROR_NAME_TOO_LONG: GRegexError = 175;
pub const GRegexError_G_REGEX_ERROR_CHARACTER_VALUE_TOO_LARGE: GRegexError = 176;
/// GRegexError:
/// @G_REGEX_ERROR_COMPILE: Compilation of the regular expression failed.
/// @G_REGEX_ERROR_OPTIMIZE: Optimization of the regular expression failed.
/// @G_REGEX_ERROR_REPLACE: Replacement failed due to an ill-formed replacement
/// string.
/// @G_REGEX_ERROR_MATCH: The match process failed.
/// @G_REGEX_ERROR_INTERNAL: Internal error of the regular expression engine.
/// Since 2.16
/// @G_REGEX_ERROR_STRAY_BACKSLASH: "\\" at end of pattern. Since 2.16
/// @G_REGEX_ERROR_MISSING_CONTROL_CHAR: "\\c" at end of pattern. Since 2.16
/// @G_REGEX_ERROR_UNRECOGNIZED_ESCAPE: Unrecognized character follows "\\".
/// Since 2.16
/// @G_REGEX_ERROR_QUANTIFIERS_OUT_OF_ORDER: Numbers out of order in "{}"
/// quantifier. Since 2.16
/// @G_REGEX_ERROR_QUANTIFIER_TOO_BIG: Number too big in "{}" quantifier.
/// Since 2.16
/// @G_REGEX_ERROR_UNTERMINATED_CHARACTER_CLASS: Missing terminating "]" for
/// character class. Since 2.16
/// @G_REGEX_ERROR_INVALID_ESCAPE_IN_CHARACTER_CLASS: Invalid escape sequence
/// in character class. Since 2.16
/// @G_REGEX_ERROR_RANGE_OUT_OF_ORDER: Range out of order in character class.
/// Since 2.16
/// @G_REGEX_ERROR_NOTHING_TO_REPEAT: Nothing to repeat. Since 2.16
/// @G_REGEX_ERROR_UNRECOGNIZED_CHARACTER: Unrecognized character after "(?",
/// "(?<" or "(?P". Since 2.16
/// @G_REGEX_ERROR_POSIX_NAMED_CLASS_OUTSIDE_CLASS: POSIX named classes are
/// supported only within a class. Since 2.16
/// @G_REGEX_ERROR_UNMATCHED_PARENTHESIS: Missing terminating ")" or ")"
/// without opening "(". Since 2.16
/// @G_REGEX_ERROR_INEXISTENT_SUBPATTERN_REFERENCE: Reference to non-existent
/// subpattern. Since 2.16
/// @G_REGEX_ERROR_UNTERMINATED_COMMENT: Missing terminating ")" after comment.
/// Since 2.16
/// @G_REGEX_ERROR_EXPRESSION_TOO_LARGE: Regular expression too large.
/// Since 2.16
/// @G_REGEX_ERROR_MEMORY_ERROR: Failed to get memory. Since 2.16
/// @G_REGEX_ERROR_VARIABLE_LENGTH_LOOKBEHIND: Lookbehind assertion is not
/// fixed length. Since 2.16
/// @G_REGEX_ERROR_MALFORMED_CONDITION: Malformed number or name after "(?(".
/// Since 2.16
/// @G_REGEX_ERROR_TOO_MANY_CONDITIONAL_BRANCHES: Conditional group contains
/// more than two branches. Since 2.16
/// @G_REGEX_ERROR_ASSERTION_EXPECTED: Assertion expected after "(?(".
/// Since 2.16
/// @G_REGEX_ERROR_UNKNOWN_POSIX_CLASS_NAME: Unknown POSIX class name.
/// Since 2.16
/// @G_REGEX_ERROR_POSIX_COLLATING_ELEMENTS_NOT_SUPPORTED: POSIX collating
/// elements are not supported. Since 2.16
/// @G_REGEX_ERROR_HEX_CODE_TOO_LARGE: Character value in "\\x{...}" sequence
/// is too large. Since 2.16
/// @G_REGEX_ERROR_INVALID_CONDITION: Invalid condition "(?(0)". Since 2.16
/// @G_REGEX_ERROR_SINGLE_BYTE_MATCH_IN_LOOKBEHIND: \\C not allowed in
/// lookbehind assertion. Since 2.16
/// @G_REGEX_ERROR_INFINITE_LOOP: Recursive call could loop indefinitely.
/// Since 2.16
/// @G_REGEX_ERROR_MISSING_SUBPATTERN_NAME_TERMINATOR: Missing terminator
/// in subpattern name. Since 2.16
/// @G_REGEX_ERROR_DUPLICATE_SUBPATTERN_NAME: Two named subpatterns have
/// the same name. Since 2.16
/// @G_REGEX_ERROR_MALFORMED_PROPERTY: Malformed "\\P" or "\\p" sequence.
/// Since 2.16
/// @G_REGEX_ERROR_UNKNOWN_PROPERTY: Unknown property name after "\\P" or
/// "\\p". Since 2.16
/// @G_REGEX_ERROR_SUBPATTERN_NAME_TOO_LONG: Subpattern name is too long
/// (maximum 32 characters). Since 2.16
/// @G_REGEX_ERROR_TOO_MANY_SUBPATTERNS: Too many named subpatterns (maximum
/// 10,000). Since 2.16
/// @G_REGEX_ERROR_INVALID_OCTAL_VALUE: Octal value is greater than "\\377".
/// Since 2.16
/// @G_REGEX_ERROR_TOO_MANY_BRANCHES_IN_DEFINE: "DEFINE" group contains more
/// than one branch. Since 2.16
/// @G_REGEX_ERROR_DEFINE_REPETION: Repeating a "DEFINE" group is not allowed.
/// This error is never raised. Since: 2.16 Deprecated: 2.34
/// @G_REGEX_ERROR_INCONSISTENT_NEWLINE_OPTIONS: Inconsistent newline options.
/// Since 2.16
/// @G_REGEX_ERROR_MISSING_BACK_REFERENCE: "\\g" is not followed by a braced,
/// angle-bracketed, or quoted name or number, or by a plain number. Since: 2.16
/// @G_REGEX_ERROR_INVALID_RELATIVE_REFERENCE: relative reference must not be zero. Since: 2.34
/// @G_REGEX_ERROR_BACKTRACKING_CONTROL_VERB_ARGUMENT_FORBIDDEN: the backtracing
/// control verb used does not allow an argument. Since: 2.34
/// @G_REGEX_ERROR_UNKNOWN_BACKTRACKING_CONTROL_VERB: unknown backtracing
/// control verb. Since: 2.34
/// @G_REGEX_ERROR_NUMBER_TOO_BIG: number is too big in escape sequence. Since: 2.34
/// @G_REGEX_ERROR_MISSING_SUBPATTERN_NAME: Missing subpattern name. Since: 2.34
/// @G_REGEX_ERROR_MISSING_DIGIT: Missing digit. Since 2.34
/// @G_REGEX_ERROR_INVALID_DATA_CHARACTER: In JavaScript compatibility mode,
/// "[" is an invalid data character. Since: 2.34
/// @G_REGEX_ERROR_EXTRA_SUBPATTERN_NAME: different names for subpatterns of the
/// same number are not allowed. Since: 2.34
/// @G_REGEX_ERROR_BACKTRACKING_CONTROL_VERB_ARGUMENT_REQUIRED: the backtracing control
/// verb requires an argument. Since: 2.34
/// @G_REGEX_ERROR_INVALID_CONTROL_CHAR: "\\c" must be followed by an ASCII
/// character. Since: 2.34
/// @G_REGEX_ERROR_MISSING_NAME: "\\k" is not followed by a braced, angle-bracketed, or
/// quoted name. Since: 2.34
/// @G_REGEX_ERROR_NOT_SUPPORTED_IN_CLASS: "\\N" is not supported in a class. Since: 2.34
/// @G_REGEX_ERROR_TOO_MANY_FORWARD_REFERENCES: too many forward references. Since: 2.34
/// @G_REGEX_ERROR_NAME_TOO_LONG: the name is too long in "(*MARK)", "(*PRUNE)",
/// "(*SKIP)", or "(*THEN)". Since: 2.34
/// @G_REGEX_ERROR_CHARACTER_VALUE_TOO_LARGE: the character value in the \\u sequence is
/// too large. Since: 2.34
///
/// Error codes returned by regular expressions functions.
///
/// Since: 2.14
pub type GRegexError = u32;
extern "C" {
    #[link_name = "\u{1}_g_regex_error_quark"]
    pub fn g_regex_error_quark() -> GQuark;
}
pub const GRegexCompileFlags_G_REGEX_CASELESS: GRegexCompileFlags = 1;
pub const GRegexCompileFlags_G_REGEX_MULTILINE: GRegexCompileFlags = 2;
pub const GRegexCompileFlags_G_REGEX_DOTALL: GRegexCompileFlags = 4;
pub const GRegexCompileFlags_G_REGEX_EXTENDED: GRegexCompileFlags = 8;
pub const GRegexCompileFlags_G_REGEX_ANCHORED: GRegexCompileFlags = 16;
pub const GRegexCompileFlags_G_REGEX_DOLLAR_ENDONLY: GRegexCompileFlags = 32;
pub const GRegexCompileFlags_G_REGEX_UNGREEDY: GRegexCompileFlags = 512;
pub const GRegexCompileFlags_G_REGEX_RAW: GRegexCompileFlags = 2048;
pub const GRegexCompileFlags_G_REGEX_NO_AUTO_CAPTURE: GRegexCompileFlags = 4096;
pub const GRegexCompileFlags_G_REGEX_OPTIMIZE: GRegexCompileFlags = 8192;
pub const GRegexCompileFlags_G_REGEX_FIRSTLINE: GRegexCompileFlags = 262144;
pub const GRegexCompileFlags_G_REGEX_DUPNAMES: GRegexCompileFlags = 524288;
pub const GRegexCompileFlags_G_REGEX_NEWLINE_CR: GRegexCompileFlags = 1048576;
pub const GRegexCompileFlags_G_REGEX_NEWLINE_LF: GRegexCompileFlags = 2097152;
pub const GRegexCompileFlags_G_REGEX_NEWLINE_CRLF: GRegexCompileFlags = 3145728;
pub const GRegexCompileFlags_G_REGEX_NEWLINE_ANYCRLF: GRegexCompileFlags = 5242880;
pub const GRegexCompileFlags_G_REGEX_BSR_ANYCRLF: GRegexCompileFlags = 8388608;
pub const GRegexCompileFlags_G_REGEX_JAVASCRIPT_COMPAT: GRegexCompileFlags = 33554432;
/// GRegexCompileFlags:
/// @G_REGEX_CASELESS: Letters in the pattern match both upper- and
/// lowercase letters. This option can be changed within a pattern
/// by a "(?i)" option setting.
/// @G_REGEX_MULTILINE: By default, GRegex treats the strings as consisting
/// of a single line of characters (even if it actually contains
/// newlines). The "start of line" metacharacter ("^") matches only
/// at the start of the string, while the "end of line" metacharacter
/// ("$") matches only at the end of the string, or before a terminating
/// newline (unless #G_REGEX_DOLLAR_ENDONLY is set). When
/// #G_REGEX_MULTILINE is set, the "start of line" and "end of line"
/// constructs match immediately following or immediately before any
/// newline in the string, respectively, as well as at the very start
/// and end. This can be changed within a pattern by a "(?m)" option
/// setting.
/// @G_REGEX_DOTALL: A dot metacharater (".") in the pattern matches all
/// characters, including newlines. Without it, newlines are excluded.
/// This option can be changed within a pattern by a ("?s") option setting.
/// @G_REGEX_EXTENDED: Whitespace data characters in the pattern are
/// totally ignored except when escaped or inside a character class.
/// Whitespace does not include the VT character (code 11). In addition,
/// characters between an unescaped "#" outside a character class and
/// the next newline character, inclusive, are also ignored. This can
/// be changed within a pattern by a "(?x)" option setting.
/// @G_REGEX_ANCHORED: The pattern is forced to be "anchored", that is,
/// it is constrained to match only at the first matching point in the
/// string that is being searched. This effect can also be achieved by
/// appropriate constructs in the pattern itself such as the "^"
/// metacharater.
/// @G_REGEX_DOLLAR_ENDONLY: A dollar metacharacter ("$") in the pattern
/// matches only at the end of the string. Without this option, a
/// dollar also matches immediately before the final character if
/// it is a newline (but not before any other newlines). This option
/// is ignored if #G_REGEX_MULTILINE is set.
/// @G_REGEX_UNGREEDY: Inverts the "greediness" of the quantifiers so that
/// they are not greedy by default, but become greedy if followed by "?".
/// It can also be set by a "(?U)" option setting within the pattern.
/// @G_REGEX_RAW: Usually strings must be valid UTF-8 strings, using this
/// flag they are considered as a raw sequence of bytes.
/// @G_REGEX_NO_AUTO_CAPTURE: Disables the use of numbered capturing
/// parentheses in the pattern. Any opening parenthesis that is not
/// followed by "?" behaves as if it were followed by "?:" but named
/// parentheses can still be used for capturing (and they acquire numbers
/// in the usual way).
/// @G_REGEX_OPTIMIZE: Optimize the regular expression. If the pattern will
/// be used many times, then it may be worth the effort to optimize it
/// to improve the speed of matches.
/// @G_REGEX_FIRSTLINE: Limits an unanchored pattern to match before (or at) the
/// first newline. Since: 2.34
/// @G_REGEX_DUPNAMES: Names used to identify capturing subpatterns need not
/// be unique. This can be helpful for certain types of pattern when it
/// is known that only one instance of the named subpattern can ever be
/// matched.
/// @G_REGEX_NEWLINE_CR: Usually any newline character or character sequence is
/// recognized. If this option is set, the only recognized newline character
/// is '\r'.
/// @G_REGEX_NEWLINE_LF: Usually any newline character or character sequence is
/// recognized. If this option is set, the only recognized newline character
/// is '\n'.
/// @G_REGEX_NEWLINE_CRLF: Usually any newline character or character sequence is
/// recognized. If this option is set, the only recognized newline character
/// sequence is '\r\n'.
/// @G_REGEX_NEWLINE_ANYCRLF: Usually any newline character or character sequence
/// is recognized. If this option is set, the only recognized newline character
/// sequences are '\r', '\n', and '\r\n'. Since: 2.34
/// @G_REGEX_BSR_ANYCRLF: Usually any newline character or character sequence
/// is recognised. If this option is set, then "\R" only recognizes the newline
/// characters '\r', '\n' and '\r\n'. Since: 2.34
/// @G_REGEX_JAVASCRIPT_COMPAT: Changes behaviour so that it is compatible with
/// JavaScript rather than PCRE. Since: 2.34
///
/// Flags specifying compile-time options.
///
/// Since: 2.14
pub type GRegexCompileFlags = u32;
pub const GRegexMatchFlags_G_REGEX_MATCH_ANCHORED: GRegexMatchFlags = 16;
pub const GRegexMatchFlags_G_REGEX_MATCH_NOTBOL: GRegexMatchFlags = 128;
pub const GRegexMatchFlags_G_REGEX_MATCH_NOTEOL: GRegexMatchFlags = 256;
pub const GRegexMatchFlags_G_REGEX_MATCH_NOTEMPTY: GRegexMatchFlags = 1024;
pub const GRegexMatchFlags_G_REGEX_MATCH_PARTIAL: GRegexMatchFlags = 32768;
pub const GRegexMatchFlags_G_REGEX_MATCH_NEWLINE_CR: GRegexMatchFlags = 1048576;
pub const GRegexMatchFlags_G_REGEX_MATCH_NEWLINE_LF: GRegexMatchFlags = 2097152;
pub const GRegexMatchFlags_G_REGEX_MATCH_NEWLINE_CRLF: GRegexMatchFlags = 3145728;
pub const GRegexMatchFlags_G_REGEX_MATCH_NEWLINE_ANY: GRegexMatchFlags = 4194304;
pub const GRegexMatchFlags_G_REGEX_MATCH_NEWLINE_ANYCRLF: GRegexMatchFlags = 5242880;
pub const GRegexMatchFlags_G_REGEX_MATCH_BSR_ANYCRLF: GRegexMatchFlags = 8388608;
pub const GRegexMatchFlags_G_REGEX_MATCH_BSR_ANY: GRegexMatchFlags = 16777216;
pub const GRegexMatchFlags_G_REGEX_MATCH_PARTIAL_SOFT: GRegexMatchFlags = 32768;
pub const GRegexMatchFlags_G_REGEX_MATCH_PARTIAL_HARD: GRegexMatchFlags = 134217728;
pub const GRegexMatchFlags_G_REGEX_MATCH_NOTEMPTY_ATSTART: GRegexMatchFlags = 268435456;
/// GRegexMatchFlags:
/// @G_REGEX_MATCH_ANCHORED: The pattern is forced to be "anchored", that is,
/// it is constrained to match only at the first matching point in the
/// string that is being searched. This effect can also be achieved by
/// appropriate constructs in the pattern itself such as the "^"
/// metacharater.
/// @G_REGEX_MATCH_NOTBOL: Specifies that first character of the string is
/// not the beginning of a line, so the circumflex metacharacter should
/// not match before it. Setting this without #G_REGEX_MULTILINE (at
/// compile time) causes circumflex never to match. This option affects
/// only the behaviour of the circumflex metacharacter, it does not
/// affect "\A".
/// @G_REGEX_MATCH_NOTEOL: Specifies that the end of the subject string is
/// not the end of a line, so the dollar metacharacter should not match
/// it nor (except in multiline mode) a newline immediately before it.
/// Setting this without #G_REGEX_MULTILINE (at compile time) causes
/// dollar never to match. This option affects only the behaviour of
/// the dollar metacharacter, it does not affect "\Z" or "\z".
/// @G_REGEX_MATCH_NOTEMPTY: An empty string is not considered to be a valid
/// match if this option is set. If there are alternatives in the pattern,
/// they are tried. If all the alternatives match the empty string, the
/// entire match fails. For example, if the pattern "a?b?" is applied to
/// a string not beginning with "a" or "b", it matches the empty string
/// at the start of the string. With this flag set, this match is not
/// valid, so GRegex searches further into the string for occurrences
/// of "a" or "b".
/// @G_REGEX_MATCH_PARTIAL: Turns on the partial matching feature, for more
/// documentation on partial matching see g_match_info_is_partial_match().
/// @G_REGEX_MATCH_NEWLINE_CR: Overrides the newline definition set when
/// creating a new #GRegex, setting the '\r' character as line terminator.
/// @G_REGEX_MATCH_NEWLINE_LF: Overrides the newline definition set when
/// creating a new #GRegex, setting the '\n' character as line terminator.
/// @G_REGEX_MATCH_NEWLINE_CRLF: Overrides the newline definition set when
/// creating a new #GRegex, setting the '\r\n' characters sequence as line terminator.
/// @G_REGEX_MATCH_NEWLINE_ANY: Overrides the newline definition set when
/// creating a new #GRegex, any Unicode newline sequence
/// is recognised as a newline. These are '\r', '\n' and '\rn', and the
/// single characters U+000B LINE TABULATION, U+000C FORM FEED (FF),
/// U+0085 NEXT LINE (NEL), U+2028 LINE SEPARATOR and
/// U+2029 PARAGRAPH SEPARATOR.
/// @G_REGEX_MATCH_NEWLINE_ANYCRLF: Overrides the newline definition set when
/// creating a new #GRegex; any '\r', '\n', or '\r\n' character sequence
/// is recognized as a newline. Since: 2.34
/// @G_REGEX_MATCH_BSR_ANYCRLF: Overrides the newline definition for "\R" set when
/// creating a new #GRegex; only '\r', '\n', or '\r\n' character sequences
/// are recognized as a newline by "\R". Since: 2.34
/// @G_REGEX_MATCH_BSR_ANY: Overrides the newline definition for "\R" set when
/// creating a new #GRegex; any Unicode newline character or character sequence
/// are recognized as a newline by "\R". These are '\r', '\n' and '\rn', and the
/// single characters U+000B LINE TABULATION, U+000C FORM FEED (FF),
/// U+0085 NEXT LINE (NEL), U+2028 LINE SEPARATOR and
/// U+2029 PARAGRAPH SEPARATOR. Since: 2.34
/// @G_REGEX_MATCH_PARTIAL_SOFT: An alias for #G_REGEX_MATCH_PARTIAL. Since: 2.34
/// @G_REGEX_MATCH_PARTIAL_HARD: Turns on the partial matching feature. In contrast to
/// to #G_REGEX_MATCH_PARTIAL_SOFT, this stops matching as soon as a partial match
/// is found, without continuing to search for a possible complete match. See
/// g_match_info_is_partial_match() for more information. Since: 2.34
/// @G_REGEX_MATCH_NOTEMPTY_ATSTART: Like #G_REGEX_MATCH_NOTEMPTY, but only applied to
/// the start of the matched string. For anchored
/// patterns this can only happen for pattern containing "\K". Since: 2.34
///
/// Flags specifying match-time options.
///
/// Since: 2.14
pub type GRegexMatchFlags = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GRegex {
    _unused: [u8; 0],
}
/// GRegex:
///
/// A GRegex is the "compiled" form of a regular expression pattern.
/// This structure is opaque and its fields cannot be accessed directly.
///
/// Since: 2.14
pub type GRegex = _GRegex;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GMatchInfo {
    _unused: [u8; 0],
}
/// GMatchInfo:
///
/// A GMatchInfo is an opaque struct used to return information about
/// matches.
pub type GMatchInfo = _GMatchInfo;
/// GRegexEvalCallback:
/// @match_info: the #GMatchInfo generated by the match.
/// Use g_match_info_get_regex() and g_match_info_get_string() if you
/// need the #GRegex or the matched string.
/// @result: a #GString containing the new string
/// @user_data: user data passed to g_regex_replace_eval()
///
/// Specifies the type of the function passed to g_regex_replace_eval().
/// It is called for each occurrence of the pattern in the string passed
/// to g_regex_replace_eval(), and it should append the replacement to
/// @result.
///
/// Returns: %FALSE to continue the replacement process, %TRUE to stop it
///
/// Since: 2.14
pub type GRegexEvalCallback = ::std::option::Option<
    unsafe extern "C" fn(match_info: *const GMatchInfo, result: *mut GString, user_data: gpointer)
        -> gboolean,
>;
extern "C" {
    #[link_name = "\u{1}_g_regex_new"]
    pub fn g_regex_new(
        pattern: *const gchar,
        compile_options: GRegexCompileFlags,
        match_options: GRegexMatchFlags,
        error: *mut *mut GError,
    ) -> *mut GRegex;
}
extern "C" {
    #[link_name = "\u{1}_g_regex_ref"]
    pub fn g_regex_ref(regex: *mut GRegex) -> *mut GRegex;
}
extern "C" {
    #[link_name = "\u{1}_g_regex_unref"]
    pub fn g_regex_unref(regex: *mut GRegex);
}
extern "C" {
    #[link_name = "\u{1}_g_regex_get_pattern"]
    pub fn g_regex_get_pattern(regex: *const GRegex) -> *const gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_regex_get_max_backref"]
    pub fn g_regex_get_max_backref(regex: *const GRegex) -> gint;
}
extern "C" {
    #[link_name = "\u{1}_g_regex_get_capture_count"]
    pub fn g_regex_get_capture_count(regex: *const GRegex) -> gint;
}
extern "C" {
    #[link_name = "\u{1}_g_regex_get_has_cr_or_lf"]
    pub fn g_regex_get_has_cr_or_lf(regex: *const GRegex) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_regex_get_max_lookbehind"]
    pub fn g_regex_get_max_lookbehind(regex: *const GRegex) -> gint;
}
extern "C" {
    #[link_name = "\u{1}_g_regex_get_string_number"]
    pub fn g_regex_get_string_number(regex: *const GRegex, name: *const gchar) -> gint;
}
extern "C" {
    #[link_name = "\u{1}_g_regex_escape_string"]
    pub fn g_regex_escape_string(string: *const gchar, length: gint) -> *mut gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_regex_escape_nul"]
    pub fn g_regex_escape_nul(string: *const gchar, length: gint) -> *mut gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_regex_get_compile_flags"]
    pub fn g_regex_get_compile_flags(regex: *const GRegex) -> GRegexCompileFlags;
}
extern "C" {
    #[link_name = "\u{1}_g_regex_get_match_flags"]
    pub fn g_regex_get_match_flags(regex: *const GRegex) -> GRegexMatchFlags;
}
extern "C" {
    #[link_name = "\u{1}_g_regex_match_simple"]
    pub fn g_regex_match_simple(
        pattern: *const gchar,
        string: *const gchar,
        compile_options: GRegexCompileFlags,
        match_options: GRegexMatchFlags,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_regex_match"]
    pub fn g_regex_match(
        regex: *const GRegex,
        string: *const gchar,
        match_options: GRegexMatchFlags,
        match_info: *mut *mut GMatchInfo,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_regex_match_full"]
    pub fn g_regex_match_full(
        regex: *const GRegex,
        string: *const gchar,
        string_len: gssize,
        start_position: gint,
        match_options: GRegexMatchFlags,
        match_info: *mut *mut GMatchInfo,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_regex_match_all"]
    pub fn g_regex_match_all(
        regex: *const GRegex,
        string: *const gchar,
        match_options: GRegexMatchFlags,
        match_info: *mut *mut GMatchInfo,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_regex_match_all_full"]
    pub fn g_regex_match_all_full(
        regex: *const GRegex,
        string: *const gchar,
        string_len: gssize,
        start_position: gint,
        match_options: GRegexMatchFlags,
        match_info: *mut *mut GMatchInfo,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_regex_split_simple"]
    pub fn g_regex_split_simple(
        pattern: *const gchar,
        string: *const gchar,
        compile_options: GRegexCompileFlags,
        match_options: GRegexMatchFlags,
    ) -> *mut *mut gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_regex_split"]
    pub fn g_regex_split(
        regex: *const GRegex,
        string: *const gchar,
        match_options: GRegexMatchFlags,
    ) -> *mut *mut gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_regex_split_full"]
    pub fn g_regex_split_full(
        regex: *const GRegex,
        string: *const gchar,
        string_len: gssize,
        start_position: gint,
        match_options: GRegexMatchFlags,
        max_tokens: gint,
        error: *mut *mut GError,
    ) -> *mut *mut gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_regex_replace"]
    pub fn g_regex_replace(
        regex: *const GRegex,
        string: *const gchar,
        string_len: gssize,
        start_position: gint,
        replacement: *const gchar,
        match_options: GRegexMatchFlags,
        error: *mut *mut GError,
    ) -> *mut gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_regex_replace_literal"]
    pub fn g_regex_replace_literal(
        regex: *const GRegex,
        string: *const gchar,
        string_len: gssize,
        start_position: gint,
        replacement: *const gchar,
        match_options: GRegexMatchFlags,
        error: *mut *mut GError,
    ) -> *mut gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_regex_replace_eval"]
    pub fn g_regex_replace_eval(
        regex: *const GRegex,
        string: *const gchar,
        string_len: gssize,
        start_position: gint,
        match_options: GRegexMatchFlags,
        eval: GRegexEvalCallback,
        user_data: gpointer,
        error: *mut *mut GError,
    ) -> *mut gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_regex_check_replacement"]
    pub fn g_regex_check_replacement(
        replacement: *const gchar,
        has_references: *mut gboolean,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_match_info_get_regex"]
    pub fn g_match_info_get_regex(match_info: *const GMatchInfo) -> *mut GRegex;
}
extern "C" {
    #[link_name = "\u{1}_g_match_info_get_string"]
    pub fn g_match_info_get_string(match_info: *const GMatchInfo) -> *const gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_match_info_ref"]
    pub fn g_match_info_ref(match_info: *mut GMatchInfo) -> *mut GMatchInfo;
}
extern "C" {
    #[link_name = "\u{1}_g_match_info_unref"]
    pub fn g_match_info_unref(match_info: *mut GMatchInfo);
}
extern "C" {
    #[link_name = "\u{1}_g_match_info_free"]
    pub fn g_match_info_free(match_info: *mut GMatchInfo);
}
extern "C" {
    #[link_name = "\u{1}_g_match_info_next"]
    pub fn g_match_info_next(match_info: *mut GMatchInfo, error: *mut *mut GError) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_match_info_matches"]
    pub fn g_match_info_matches(match_info: *const GMatchInfo) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_match_info_get_match_count"]
    pub fn g_match_info_get_match_count(match_info: *const GMatchInfo) -> gint;
}
extern "C" {
    #[link_name = "\u{1}_g_match_info_is_partial_match"]
    pub fn g_match_info_is_partial_match(match_info: *const GMatchInfo) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_match_info_expand_references"]
    pub fn g_match_info_expand_references(
        match_info: *const GMatchInfo,
        string_to_expand: *const gchar,
        error: *mut *mut GError,
    ) -> *mut gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_match_info_fetch"]
    pub fn g_match_info_fetch(match_info: *const GMatchInfo, match_num: gint) -> *mut gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_match_info_fetch_pos"]
    pub fn g_match_info_fetch_pos(
        match_info: *const GMatchInfo,
        match_num: gint,
        start_pos: *mut gint,
        end_pos: *mut gint,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_match_info_fetch_named"]
    pub fn g_match_info_fetch_named(
        match_info: *const GMatchInfo,
        name: *const gchar,
    ) -> *mut gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_match_info_fetch_named_pos"]
    pub fn g_match_info_fetch_named_pos(
        match_info: *const GMatchInfo,
        name: *const gchar,
        start_pos: *mut gint,
        end_pos: *mut gint,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_match_info_fetch_all"]
    pub fn g_match_info_fetch_all(match_info: *const GMatchInfo) -> *mut *mut gchar;
}
pub type GScanner = _GScanner;
pub type GScannerConfig = _GScannerConfig;
pub type GTokenValue = _GTokenValue;
pub type GScannerMsgFunc = ::std::option::Option<
    unsafe extern "C" fn(scanner: *mut GScanner, message: *mut gchar, error: gboolean),
>;
pub const GErrorType_G_ERR_UNKNOWN: GErrorType = 0;
pub const GErrorType_G_ERR_UNEXP_EOF: GErrorType = 1;
pub const GErrorType_G_ERR_UNEXP_EOF_IN_STRING: GErrorType = 2;
pub const GErrorType_G_ERR_UNEXP_EOF_IN_COMMENT: GErrorType = 3;
pub const GErrorType_G_ERR_NON_DIGIT_IN_CONST: GErrorType = 4;
pub const GErrorType_G_ERR_DIGIT_RADIX: GErrorType = 5;
pub const GErrorType_G_ERR_FLOAT_RADIX: GErrorType = 6;
pub const GErrorType_G_ERR_FLOAT_MALFORMED: GErrorType = 7;
pub type GErrorType = u32;
pub const GTokenType_G_TOKEN_EOF: GTokenType = 0;
pub const GTokenType_G_TOKEN_LEFT_PAREN: GTokenType = 40;
pub const GTokenType_G_TOKEN_RIGHT_PAREN: GTokenType = 41;
pub const GTokenType_G_TOKEN_LEFT_CURLY: GTokenType = 123;
pub const GTokenType_G_TOKEN_RIGHT_CURLY: GTokenType = 125;
pub const GTokenType_G_TOKEN_LEFT_BRACE: GTokenType = 91;
pub const GTokenType_G_TOKEN_RIGHT_BRACE: GTokenType = 93;
pub const GTokenType_G_TOKEN_EQUAL_SIGN: GTokenType = 61;
pub const GTokenType_G_TOKEN_COMMA: GTokenType = 44;
pub const GTokenType_G_TOKEN_NONE: GTokenType = 256;
pub const GTokenType_G_TOKEN_ERROR: GTokenType = 257;
pub const GTokenType_G_TOKEN_CHAR: GTokenType = 258;
pub const GTokenType_G_TOKEN_BINARY: GTokenType = 259;
pub const GTokenType_G_TOKEN_OCTAL: GTokenType = 260;
pub const GTokenType_G_TOKEN_INT: GTokenType = 261;
pub const GTokenType_G_TOKEN_HEX: GTokenType = 262;
pub const GTokenType_G_TOKEN_FLOAT: GTokenType = 263;
pub const GTokenType_G_TOKEN_STRING: GTokenType = 264;
pub const GTokenType_G_TOKEN_SYMBOL: GTokenType = 265;
pub const GTokenType_G_TOKEN_IDENTIFIER: GTokenType = 266;
pub const GTokenType_G_TOKEN_IDENTIFIER_NULL: GTokenType = 267;
pub const GTokenType_G_TOKEN_COMMENT_SINGLE: GTokenType = 268;
pub const GTokenType_G_TOKEN_COMMENT_MULTI: GTokenType = 269;
pub const GTokenType_G_TOKEN_LAST: GTokenType = 270;
pub type GTokenType = u32;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _GTokenValue {
    pub v_symbol: gpointer,
    pub v_identifier: *mut gchar,
    pub v_binary: gulong,
    pub v_octal: gulong,
    pub v_int: gulong,
    pub v_int64: guint64,
    pub v_float: gdouble,
    pub v_hex: gulong,
    pub v_string: *mut gchar,
    pub v_comment: *mut gchar,
    pub v_char: guchar,
    pub v_error: guint,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout__GTokenValue() {
    assert_eq!(
        ::std::mem::size_of::<_GTokenValue>(),
        8usize,
        concat!("Size of: ", stringify!(_GTokenValue))
    );
    assert_eq!(
        ::std::mem::align_of::<_GTokenValue>(),
        8usize,
        concat!("Alignment of ", stringify!(_GTokenValue))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GTokenValue>())).v_symbol as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTokenValue),
            "::",
            stringify!(v_symbol)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GTokenValue>())).v_identifier as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTokenValue),
            "::",
            stringify!(v_identifier)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GTokenValue>())).v_binary as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTokenValue),
            "::",
            stringify!(v_binary)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GTokenValue>())).v_octal as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTokenValue),
            "::",
            stringify!(v_octal)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GTokenValue>())).v_int as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTokenValue),
            "::",
            stringify!(v_int)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GTokenValue>())).v_int64 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTokenValue),
            "::",
            stringify!(v_int64)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GTokenValue>())).v_float as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTokenValue),
            "::",
            stringify!(v_float)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GTokenValue>())).v_hex as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTokenValue),
            "::",
            stringify!(v_hex)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GTokenValue>())).v_string as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTokenValue),
            "::",
            stringify!(v_string)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GTokenValue>())).v_comment as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTokenValue),
            "::",
            stringify!(v_comment)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GTokenValue>())).v_char as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTokenValue),
            "::",
            stringify!(v_char)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GTokenValue>())).v_error as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTokenValue),
            "::",
            stringify!(v_error)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GScannerConfig {
    pub cset_skip_characters: *mut gchar,
    pub cset_identifier_first: *mut gchar,
    pub cset_identifier_nth: *mut gchar,
    pub cpair_comment_single: *mut gchar,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 3usize], u8>,
    pub padding_dummy: guint,
}
#[test]
fn bindgen_test_layout__GScannerConfig() {
    assert_eq!(
        ::std::mem::size_of::<_GScannerConfig>(),
        40usize,
        concat!("Size of: ", stringify!(_GScannerConfig))
    );
    assert_eq!(
        ::std::mem::align_of::<_GScannerConfig>(),
        8usize,
        concat!("Alignment of ", stringify!(_GScannerConfig))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GScannerConfig>())).cset_skip_characters as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GScannerConfig),
            "::",
            stringify!(cset_skip_characters)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GScannerConfig>())).cset_identifier_first as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GScannerConfig),
            "::",
            stringify!(cset_identifier_first)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GScannerConfig>())).cset_identifier_nth as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GScannerConfig),
            "::",
            stringify!(cset_identifier_nth)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GScannerConfig>())).cpair_comment_single as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GScannerConfig),
            "::",
            stringify!(cpair_comment_single)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GScannerConfig>())).padding_dummy as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(_GScannerConfig),
            "::",
            stringify!(padding_dummy)
        )
    );
}
impl _GScannerConfig {
    #[inline]
    pub fn case_sensitive(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_case_sensitive(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn skip_comment_multi(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_skip_comment_multi(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn skip_comment_single(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_skip_comment_single(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn scan_comment_multi(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_scan_comment_multi(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn scan_identifier(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_scan_identifier(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn scan_identifier_1char(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_scan_identifier_1char(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn scan_identifier_NULL(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_scan_identifier_NULL(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn scan_symbols(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_scan_symbols(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn scan_binary(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_scan_binary(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn scan_octal(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_scan_octal(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn scan_float(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_scan_float(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn scan_hex(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_scan_hex(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn scan_hex_dollar(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_scan_hex_dollar(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn scan_string_sq(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_scan_string_sq(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn scan_string_dq(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_scan_string_dq(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn numbers_2_int(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_numbers_2_int(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn int_2_float(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_int_2_float(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn identifier_2_string(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_identifier_2_string(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn char_2_token(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_char_2_token(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn symbol_2_token(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(19usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_symbol_2_token(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(19usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn scope_0_fallback(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(20usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_scope_0_fallback(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(20usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn store_int64(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(21usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_store_int64(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(21usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        case_sensitive: guint,
        skip_comment_multi: guint,
        skip_comment_single: guint,
        scan_comment_multi: guint,
        scan_identifier: guint,
        scan_identifier_1char: guint,
        scan_identifier_NULL: guint,
        scan_symbols: guint,
        scan_binary: guint,
        scan_octal: guint,
        scan_float: guint,
        scan_hex: guint,
        scan_hex_dollar: guint,
        scan_string_sq: guint,
        scan_string_dq: guint,
        numbers_2_int: guint,
        int_2_float: guint,
        identifier_2_string: guint,
        char_2_token: guint,
        symbol_2_token: guint,
        scope_0_fallback: guint,
        store_int64: guint,
    ) -> __BindgenBitfieldUnit<[u8; 3usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 3usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let case_sensitive: u32 = unsafe { ::std::mem::transmute(case_sensitive) };
            case_sensitive as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let skip_comment_multi: u32 = unsafe { ::std::mem::transmute(skip_comment_multi) };
            skip_comment_multi as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let skip_comment_single: u32 = unsafe { ::std::mem::transmute(skip_comment_single) };
            skip_comment_single as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let scan_comment_multi: u32 = unsafe { ::std::mem::transmute(scan_comment_multi) };
            scan_comment_multi as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let scan_identifier: u32 = unsafe { ::std::mem::transmute(scan_identifier) };
            scan_identifier as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let scan_identifier_1char: u32 =
                unsafe { ::std::mem::transmute(scan_identifier_1char) };
            scan_identifier_1char as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let scan_identifier_NULL: u32 = unsafe { ::std::mem::transmute(scan_identifier_NULL) };
            scan_identifier_NULL as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let scan_symbols: u32 = unsafe { ::std::mem::transmute(scan_symbols) };
            scan_symbols as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let scan_binary: u32 = unsafe { ::std::mem::transmute(scan_binary) };
            scan_binary as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let scan_octal: u32 = unsafe { ::std::mem::transmute(scan_octal) };
            scan_octal as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let scan_float: u32 = unsafe { ::std::mem::transmute(scan_float) };
            scan_float as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let scan_hex: u32 = unsafe { ::std::mem::transmute(scan_hex) };
            scan_hex as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let scan_hex_dollar: u32 = unsafe { ::std::mem::transmute(scan_hex_dollar) };
            scan_hex_dollar as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let scan_string_sq: u32 = unsafe { ::std::mem::transmute(scan_string_sq) };
            scan_string_sq as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let scan_string_dq: u32 = unsafe { ::std::mem::transmute(scan_string_dq) };
            scan_string_dq as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let numbers_2_int: u32 = unsafe { ::std::mem::transmute(numbers_2_int) };
            numbers_2_int as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let int_2_float: u32 = unsafe { ::std::mem::transmute(int_2_float) };
            int_2_float as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let identifier_2_string: u32 = unsafe { ::std::mem::transmute(identifier_2_string) };
            identifier_2_string as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let char_2_token: u32 = unsafe { ::std::mem::transmute(char_2_token) };
            char_2_token as u64
        });
        __bindgen_bitfield_unit.set(19usize, 1u8, {
            let symbol_2_token: u32 = unsafe { ::std::mem::transmute(symbol_2_token) };
            symbol_2_token as u64
        });
        __bindgen_bitfield_unit.set(20usize, 1u8, {
            let scope_0_fallback: u32 = unsafe { ::std::mem::transmute(scope_0_fallback) };
            scope_0_fallback as u64
        });
        __bindgen_bitfield_unit.set(21usize, 1u8, {
            let store_int64: u32 = unsafe { ::std::mem::transmute(store_int64) };
            store_int64 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _GScanner {
    pub user_data: gpointer,
    pub max_parse_errors: guint,
    pub parse_errors: guint,
    pub input_name: *const gchar,
    pub qdata: *mut GData,
    pub config: *mut GScannerConfig,
    pub token: GTokenType,
    pub value: GTokenValue,
    pub line: guint,
    pub position: guint,
    pub next_token: GTokenType,
    pub next_value: GTokenValue,
    pub next_line: guint,
    pub next_position: guint,
    pub symbol_table: *mut GHashTable,
    pub input_fd: gint,
    pub text: *const gchar,
    pub text_end: *const gchar,
    pub buffer: *mut gchar,
    pub scope_id: guint,
    pub msg_handler: GScannerMsgFunc,
}
#[test]
fn bindgen_test_layout__GScanner() {
    assert_eq!(
        ::std::mem::size_of::<_GScanner>(),
        144usize,
        concat!("Size of: ", stringify!(_GScanner))
    );
    assert_eq!(
        ::std::mem::align_of::<_GScanner>(),
        8usize,
        concat!("Alignment of ", stringify!(_GScanner))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GScanner>())).user_data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GScanner),
            "::",
            stringify!(user_data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GScanner>())).max_parse_errors as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GScanner),
            "::",
            stringify!(max_parse_errors)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GScanner>())).parse_errors as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_GScanner),
            "::",
            stringify!(parse_errors)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GScanner>())).input_name as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GScanner),
            "::",
            stringify!(input_name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GScanner>())).qdata as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GScanner),
            "::",
            stringify!(qdata)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GScanner>())).config as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_GScanner),
            "::",
            stringify!(config)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GScanner>())).token as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_GScanner),
            "::",
            stringify!(token)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GScanner>())).value as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_GScanner),
            "::",
            stringify!(value)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GScanner>())).line as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_GScanner),
            "::",
            stringify!(line)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GScanner>())).position as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(_GScanner),
            "::",
            stringify!(position)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GScanner>())).next_token as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_GScanner),
            "::",
            stringify!(next_token)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GScanner>())).next_value as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_GScanner),
            "::",
            stringify!(next_value)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GScanner>())).next_line as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_GScanner),
            "::",
            stringify!(next_line)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GScanner>())).next_position as *const _ as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(_GScanner),
            "::",
            stringify!(next_position)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GScanner>())).symbol_table as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_GScanner),
            "::",
            stringify!(symbol_table)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GScanner>())).input_fd as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_GScanner),
            "::",
            stringify!(input_fd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GScanner>())).text as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_GScanner),
            "::",
            stringify!(text)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GScanner>())).text_end as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(_GScanner),
            "::",
            stringify!(text_end)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GScanner>())).buffer as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(_GScanner),
            "::",
            stringify!(buffer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GScanner>())).scope_id as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(_GScanner),
            "::",
            stringify!(scope_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GScanner>())).msg_handler as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_GScanner),
            "::",
            stringify!(msg_handler)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_g_scanner_new"]
    pub fn g_scanner_new(config_templ: *const GScannerConfig) -> *mut GScanner;
}
extern "C" {
    #[link_name = "\u{1}_g_scanner_destroy"]
    pub fn g_scanner_destroy(scanner: *mut GScanner);
}
extern "C" {
    #[link_name = "\u{1}_g_scanner_input_file"]
    pub fn g_scanner_input_file(scanner: *mut GScanner, input_fd: gint);
}
extern "C" {
    #[link_name = "\u{1}_g_scanner_sync_file_offset"]
    pub fn g_scanner_sync_file_offset(scanner: *mut GScanner);
}
extern "C" {
    #[link_name = "\u{1}_g_scanner_input_text"]
    pub fn g_scanner_input_text(scanner: *mut GScanner, text: *const gchar, text_len: guint);
}
extern "C" {
    #[link_name = "\u{1}_g_scanner_get_next_token"]
    pub fn g_scanner_get_next_token(scanner: *mut GScanner) -> GTokenType;
}
extern "C" {
    #[link_name = "\u{1}_g_scanner_peek_next_token"]
    pub fn g_scanner_peek_next_token(scanner: *mut GScanner) -> GTokenType;
}
extern "C" {
    #[link_name = "\u{1}_g_scanner_cur_token"]
    pub fn g_scanner_cur_token(scanner: *mut GScanner) -> GTokenType;
}
extern "C" {
    #[link_name = "\u{1}_g_scanner_cur_value"]
    pub fn g_scanner_cur_value(scanner: *mut GScanner) -> GTokenValue;
}
extern "C" {
    #[link_name = "\u{1}_g_scanner_cur_line"]
    pub fn g_scanner_cur_line(scanner: *mut GScanner) -> guint;
}
extern "C" {
    #[link_name = "\u{1}_g_scanner_cur_position"]
    pub fn g_scanner_cur_position(scanner: *mut GScanner) -> guint;
}
extern "C" {
    #[link_name = "\u{1}_g_scanner_eof"]
    pub fn g_scanner_eof(scanner: *mut GScanner) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_scanner_set_scope"]
    pub fn g_scanner_set_scope(scanner: *mut GScanner, scope_id: guint) -> guint;
}
extern "C" {
    #[link_name = "\u{1}_g_scanner_scope_add_symbol"]
    pub fn g_scanner_scope_add_symbol(
        scanner: *mut GScanner,
        scope_id: guint,
        symbol: *const gchar,
        value: gpointer,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_scanner_scope_remove_symbol"]
    pub fn g_scanner_scope_remove_symbol(
        scanner: *mut GScanner,
        scope_id: guint,
        symbol: *const gchar,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_scanner_scope_lookup_symbol"]
    pub fn g_scanner_scope_lookup_symbol(
        scanner: *mut GScanner,
        scope_id: guint,
        symbol: *const gchar,
    ) -> gpointer;
}
extern "C" {
    #[link_name = "\u{1}_g_scanner_scope_foreach_symbol"]
    pub fn g_scanner_scope_foreach_symbol(
        scanner: *mut GScanner,
        scope_id: guint,
        func: GHFunc,
        user_data: gpointer,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_scanner_lookup_symbol"]
    pub fn g_scanner_lookup_symbol(scanner: *mut GScanner, symbol: *const gchar) -> gpointer;
}
extern "C" {
    #[link_name = "\u{1}_g_scanner_unexp_token"]
    pub fn g_scanner_unexp_token(
        scanner: *mut GScanner,
        expected_token: GTokenType,
        identifier_spec: *const gchar,
        symbol_spec: *const gchar,
        symbol_name: *const gchar,
        message: *const gchar,
        is_error: gint,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_scanner_error"]
    pub fn g_scanner_error(scanner: *mut GScanner, format: *const gchar, ...);
}
extern "C" {
    #[link_name = "\u{1}_g_scanner_warn"]
    pub fn g_scanner_warn(scanner: *mut GScanner, format: *const gchar, ...);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GSequence {
    _unused: [u8; 0],
}
pub type GSequence = _GSequence;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GSequenceNode {
    _unused: [u8; 0],
}
pub type GSequenceIter = _GSequenceNode;
pub type GSequenceIterCompareFunc = ::std::option::Option<
    unsafe extern "C" fn(a: *mut GSequenceIter, b: *mut GSequenceIter, data: gpointer) -> gint,
>;
extern "C" {
    #[link_name = "\u{1}_g_sequence_new"]
    pub fn g_sequence_new(data_destroy: GDestroyNotify) -> *mut GSequence;
}
extern "C" {
    #[link_name = "\u{1}_g_sequence_free"]
    pub fn g_sequence_free(seq: *mut GSequence);
}
extern "C" {
    #[link_name = "\u{1}_g_sequence_get_length"]
    pub fn g_sequence_get_length(seq: *mut GSequence) -> gint;
}
extern "C" {
    #[link_name = "\u{1}_g_sequence_foreach"]
    pub fn g_sequence_foreach(seq: *mut GSequence, func: GFunc, user_data: gpointer);
}
extern "C" {
    #[link_name = "\u{1}_g_sequence_foreach_range"]
    pub fn g_sequence_foreach_range(
        begin: *mut GSequenceIter,
        end: *mut GSequenceIter,
        func: GFunc,
        user_data: gpointer,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_sequence_sort"]
    pub fn g_sequence_sort(seq: *mut GSequence, cmp_func: GCompareDataFunc, cmp_data: gpointer);
}
extern "C" {
    #[link_name = "\u{1}_g_sequence_sort_iter"]
    pub fn g_sequence_sort_iter(
        seq: *mut GSequence,
        cmp_func: GSequenceIterCompareFunc,
        cmp_data: gpointer,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_sequence_is_empty"]
    pub fn g_sequence_is_empty(seq: *mut GSequence) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_sequence_get_begin_iter"]
    pub fn g_sequence_get_begin_iter(seq: *mut GSequence) -> *mut GSequenceIter;
}
extern "C" {
    #[link_name = "\u{1}_g_sequence_get_end_iter"]
    pub fn g_sequence_get_end_iter(seq: *mut GSequence) -> *mut GSequenceIter;
}
extern "C" {
    #[link_name = "\u{1}_g_sequence_get_iter_at_pos"]
    pub fn g_sequence_get_iter_at_pos(seq: *mut GSequence, pos: gint) -> *mut GSequenceIter;
}
extern "C" {
    #[link_name = "\u{1}_g_sequence_append"]
    pub fn g_sequence_append(seq: *mut GSequence, data: gpointer) -> *mut GSequenceIter;
}
extern "C" {
    #[link_name = "\u{1}_g_sequence_prepend"]
    pub fn g_sequence_prepend(seq: *mut GSequence, data: gpointer) -> *mut GSequenceIter;
}
extern "C" {
    #[link_name = "\u{1}_g_sequence_insert_before"]
    pub fn g_sequence_insert_before(iter: *mut GSequenceIter, data: gpointer)
        -> *mut GSequenceIter;
}
extern "C" {
    #[link_name = "\u{1}_g_sequence_move"]
    pub fn g_sequence_move(src: *mut GSequenceIter, dest: *mut GSequenceIter);
}
extern "C" {
    #[link_name = "\u{1}_g_sequence_swap"]
    pub fn g_sequence_swap(a: *mut GSequenceIter, b: *mut GSequenceIter);
}
extern "C" {
    #[link_name = "\u{1}_g_sequence_insert_sorted"]
    pub fn g_sequence_insert_sorted(
        seq: *mut GSequence,
        data: gpointer,
        cmp_func: GCompareDataFunc,
        cmp_data: gpointer,
    ) -> *mut GSequenceIter;
}
extern "C" {
    #[link_name = "\u{1}_g_sequence_insert_sorted_iter"]
    pub fn g_sequence_insert_sorted_iter(
        seq: *mut GSequence,
        data: gpointer,
        iter_cmp: GSequenceIterCompareFunc,
        cmp_data: gpointer,
    ) -> *mut GSequenceIter;
}
extern "C" {
    #[link_name = "\u{1}_g_sequence_sort_changed"]
    pub fn g_sequence_sort_changed(
        iter: *mut GSequenceIter,
        cmp_func: GCompareDataFunc,
        cmp_data: gpointer,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_sequence_sort_changed_iter"]
    pub fn g_sequence_sort_changed_iter(
        iter: *mut GSequenceIter,
        iter_cmp: GSequenceIterCompareFunc,
        cmp_data: gpointer,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_sequence_remove"]
    pub fn g_sequence_remove(iter: *mut GSequenceIter);
}
extern "C" {
    #[link_name = "\u{1}_g_sequence_remove_range"]
    pub fn g_sequence_remove_range(begin: *mut GSequenceIter, end: *mut GSequenceIter);
}
extern "C" {
    #[link_name = "\u{1}_g_sequence_move_range"]
    pub fn g_sequence_move_range(
        dest: *mut GSequenceIter,
        begin: *mut GSequenceIter,
        end: *mut GSequenceIter,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_sequence_search"]
    pub fn g_sequence_search(
        seq: *mut GSequence,
        data: gpointer,
        cmp_func: GCompareDataFunc,
        cmp_data: gpointer,
    ) -> *mut GSequenceIter;
}
extern "C" {
    #[link_name = "\u{1}_g_sequence_search_iter"]
    pub fn g_sequence_search_iter(
        seq: *mut GSequence,
        data: gpointer,
        iter_cmp: GSequenceIterCompareFunc,
        cmp_data: gpointer,
    ) -> *mut GSequenceIter;
}
extern "C" {
    #[link_name = "\u{1}_g_sequence_lookup"]
    pub fn g_sequence_lookup(
        seq: *mut GSequence,
        data: gpointer,
        cmp_func: GCompareDataFunc,
        cmp_data: gpointer,
    ) -> *mut GSequenceIter;
}
extern "C" {
    #[link_name = "\u{1}_g_sequence_lookup_iter"]
    pub fn g_sequence_lookup_iter(
        seq: *mut GSequence,
        data: gpointer,
        iter_cmp: GSequenceIterCompareFunc,
        cmp_data: gpointer,
    ) -> *mut GSequenceIter;
}
extern "C" {
    #[link_name = "\u{1}_g_sequence_get"]
    pub fn g_sequence_get(iter: *mut GSequenceIter) -> gpointer;
}
extern "C" {
    #[link_name = "\u{1}_g_sequence_set"]
    pub fn g_sequence_set(iter: *mut GSequenceIter, data: gpointer);
}
extern "C" {
    #[link_name = "\u{1}_g_sequence_iter_is_begin"]
    pub fn g_sequence_iter_is_begin(iter: *mut GSequenceIter) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_sequence_iter_is_end"]
    pub fn g_sequence_iter_is_end(iter: *mut GSequenceIter) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_sequence_iter_next"]
    pub fn g_sequence_iter_next(iter: *mut GSequenceIter) -> *mut GSequenceIter;
}
extern "C" {
    #[link_name = "\u{1}_g_sequence_iter_prev"]
    pub fn g_sequence_iter_prev(iter: *mut GSequenceIter) -> *mut GSequenceIter;
}
extern "C" {
    #[link_name = "\u{1}_g_sequence_iter_get_position"]
    pub fn g_sequence_iter_get_position(iter: *mut GSequenceIter) -> gint;
}
extern "C" {
    #[link_name = "\u{1}_g_sequence_iter_move"]
    pub fn g_sequence_iter_move(iter: *mut GSequenceIter, delta: gint) -> *mut GSequenceIter;
}
extern "C" {
    #[link_name = "\u{1}_g_sequence_iter_get_sequence"]
    pub fn g_sequence_iter_get_sequence(iter: *mut GSequenceIter) -> *mut GSequence;
}
extern "C" {
    #[link_name = "\u{1}_g_sequence_iter_compare"]
    pub fn g_sequence_iter_compare(a: *mut GSequenceIter, b: *mut GSequenceIter) -> gint;
}
extern "C" {
    #[link_name = "\u{1}_g_sequence_range_get_midpoint"]
    pub fn g_sequence_range_get_midpoint(
        begin: *mut GSequenceIter,
        end: *mut GSequenceIter,
    ) -> *mut GSequenceIter;
}
pub const GShellError_G_SHELL_ERROR_BAD_QUOTING: GShellError = 0;
pub const GShellError_G_SHELL_ERROR_EMPTY_STRING: GShellError = 1;
pub const GShellError_G_SHELL_ERROR_FAILED: GShellError = 2;
pub type GShellError = u32;
extern "C" {
    #[link_name = "\u{1}_g_shell_error_quark"]
    pub fn g_shell_error_quark() -> GQuark;
}
extern "C" {
    #[link_name = "\u{1}_g_shell_quote"]
    pub fn g_shell_quote(unquoted_string: *const gchar) -> *mut gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_shell_unquote"]
    pub fn g_shell_unquote(quoted_string: *const gchar, error: *mut *mut GError) -> *mut gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_shell_parse_argv"]
    pub fn g_shell_parse_argv(
        command_line: *const gchar,
        argcp: *mut gint,
        argvp: *mut *mut *mut gchar,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_slice_alloc"]
    pub fn g_slice_alloc(block_size: gsize) -> gpointer;
}
extern "C" {
    #[link_name = "\u{1}_g_slice_alloc0"]
    pub fn g_slice_alloc0(block_size: gsize) -> gpointer;
}
extern "C" {
    #[link_name = "\u{1}_g_slice_copy"]
    pub fn g_slice_copy(block_size: gsize, mem_block: gconstpointer) -> gpointer;
}
extern "C" {
    #[link_name = "\u{1}_g_slice_free1"]
    pub fn g_slice_free1(block_size: gsize, mem_block: gpointer);
}
extern "C" {
    #[link_name = "\u{1}_g_slice_free_chain_with_offset"]
    pub fn g_slice_free_chain_with_offset(
        block_size: gsize,
        mem_chain: gpointer,
        next_offset: gsize,
    );
}
pub const GSliceConfig_G_SLICE_CONFIG_ALWAYS_MALLOC: GSliceConfig = 1;
pub const GSliceConfig_G_SLICE_CONFIG_BYPASS_MAGAZINES: GSliceConfig = 2;
pub const GSliceConfig_G_SLICE_CONFIG_WORKING_SET_MSECS: GSliceConfig = 3;
pub const GSliceConfig_G_SLICE_CONFIG_COLOR_INCREMENT: GSliceConfig = 4;
pub const GSliceConfig_G_SLICE_CONFIG_CHUNK_SIZES: GSliceConfig = 5;
pub const GSliceConfig_G_SLICE_CONFIG_CONTENTION_COUNTER: GSliceConfig = 6;
pub type GSliceConfig = u32;
extern "C" {
    #[link_name = "\u{1}_g_slice_set_config"]
    pub fn g_slice_set_config(ckey: GSliceConfig, value: gint64);
}
extern "C" {
    #[link_name = "\u{1}_g_slice_get_config"]
    pub fn g_slice_get_config(ckey: GSliceConfig) -> gint64;
}
extern "C" {
    #[link_name = "\u{1}_g_slice_get_config_state"]
    pub fn g_slice_get_config_state(
        ckey: GSliceConfig,
        address: gint64,
        n_values: *mut guint,
    ) -> *mut gint64;
}
pub const GSpawnError_G_SPAWN_ERROR_FORK: GSpawnError = 0;
pub const GSpawnError_G_SPAWN_ERROR_READ: GSpawnError = 1;
pub const GSpawnError_G_SPAWN_ERROR_CHDIR: GSpawnError = 2;
pub const GSpawnError_G_SPAWN_ERROR_ACCES: GSpawnError = 3;
pub const GSpawnError_G_SPAWN_ERROR_PERM: GSpawnError = 4;
pub const GSpawnError_G_SPAWN_ERROR_TOO_BIG: GSpawnError = 5;
pub const GSpawnError_G_SPAWN_ERROR_2BIG: GSpawnError = 5;
pub const GSpawnError_G_SPAWN_ERROR_NOEXEC: GSpawnError = 6;
pub const GSpawnError_G_SPAWN_ERROR_NAMETOOLONG: GSpawnError = 7;
pub const GSpawnError_G_SPAWN_ERROR_NOENT: GSpawnError = 8;
pub const GSpawnError_G_SPAWN_ERROR_NOMEM: GSpawnError = 9;
pub const GSpawnError_G_SPAWN_ERROR_NOTDIR: GSpawnError = 10;
pub const GSpawnError_G_SPAWN_ERROR_LOOP: GSpawnError = 11;
pub const GSpawnError_G_SPAWN_ERROR_TXTBUSY: GSpawnError = 12;
pub const GSpawnError_G_SPAWN_ERROR_IO: GSpawnError = 13;
pub const GSpawnError_G_SPAWN_ERROR_NFILE: GSpawnError = 14;
pub const GSpawnError_G_SPAWN_ERROR_MFILE: GSpawnError = 15;
pub const GSpawnError_G_SPAWN_ERROR_INVAL: GSpawnError = 16;
pub const GSpawnError_G_SPAWN_ERROR_ISDIR: GSpawnError = 17;
pub const GSpawnError_G_SPAWN_ERROR_LIBBAD: GSpawnError = 18;
pub const GSpawnError_G_SPAWN_ERROR_FAILED: GSpawnError = 19;
/// GSpawnError:
/// @G_SPAWN_ERROR_FORK: Fork failed due to lack of memory.
/// @G_SPAWN_ERROR_READ: Read or select on pipes failed.
/// @G_SPAWN_ERROR_CHDIR: Changing to working directory failed.
/// @G_SPAWN_ERROR_ACCES: execv() returned `EACCES`
/// @G_SPAWN_ERROR_PERM: execv() returned `EPERM`
/// @G_SPAWN_ERROR_TOO_BIG: execv() returned `E2BIG`
/// @G_SPAWN_ERROR_2BIG: deprecated alias for %G_SPAWN_ERROR_TOO_BIG
/// @G_SPAWN_ERROR_NOEXEC: execv() returned `ENOEXEC`
/// @G_SPAWN_ERROR_NAMETOOLONG: execv() returned `ENAMETOOLONG`
/// @G_SPAWN_ERROR_NOENT: execv() returned `ENOENT`
/// @G_SPAWN_ERROR_NOMEM: execv() returned `ENOMEM`
/// @G_SPAWN_ERROR_NOTDIR: execv() returned `ENOTDIR`
/// @G_SPAWN_ERROR_LOOP: execv() returned `ELOOP`
/// @G_SPAWN_ERROR_TXTBUSY: execv() returned `ETXTBUSY`
/// @G_SPAWN_ERROR_IO: execv() returned `EIO`
/// @G_SPAWN_ERROR_NFILE: execv() returned `ENFILE`
/// @G_SPAWN_ERROR_MFILE: execv() returned `EMFILE`
/// @G_SPAWN_ERROR_INVAL: execv() returned `EINVAL`
/// @G_SPAWN_ERROR_ISDIR: execv() returned `EISDIR`
/// @G_SPAWN_ERROR_LIBBAD: execv() returned `ELIBBAD`
/// @G_SPAWN_ERROR_FAILED: Some other fatal failure,
/// `error->message` should explain.
///
/// Error codes returned by spawning processes.
pub type GSpawnError = u32;
/// GSpawnChildSetupFunc:
/// @user_data: user data to pass to the function.
///
/// Specifies the type of the setup function passed to g_spawn_async(),
/// g_spawn_sync() and g_spawn_async_with_pipes(), which can, in very
/// limited ways, be used to affect the child's execution.
///
/// On POSIX platforms, the function is called in the child after GLib
/// has performed all the setup it plans to perform, but before calling
/// exec(). Actions taken in this function will only affect the child,
/// not the parent.
///
/// On Windows, the function is called in the parent. Its usefulness on
/// Windows is thus questionable. In many cases executing the child setup
/// function in the parent can have ill effects, and you should be very
/// careful when porting software to Windows that uses child setup
/// functions.
///
/// However, even on POSIX, you are extremely limited in what you can
/// safely do from a #GSpawnChildSetupFunc, because any mutexes that were
/// held by other threads in the parent process at the time of the fork()
/// will still be locked in the child process, and they will never be
/// unlocked (since the threads that held them don't exist in the child).
/// POSIX allows only async-signal-safe functions (see signal(7)) to be
/// called in the child between fork() and exec(), which drastically limits
/// the usefulness of child setup functions.
///
/// In particular, it is not safe to call any function which may
/// call malloc(), which includes POSIX functions such as setenv().
/// If you need to set up the child environment differently from
/// the parent, you should use g_get_environ(), g_environ_setenv(),
/// and g_environ_unsetenv(), and then pass the complete environment
/// list to the `g_spawn...` function.
pub type GSpawnChildSetupFunc = ::std::option::Option<unsafe extern "C" fn(user_data: gpointer)>;
pub const GSpawnFlags_G_SPAWN_DEFAULT: GSpawnFlags = 0;
pub const GSpawnFlags_G_SPAWN_LEAVE_DESCRIPTORS_OPEN: GSpawnFlags = 1;
pub const GSpawnFlags_G_SPAWN_DO_NOT_REAP_CHILD: GSpawnFlags = 2;
pub const GSpawnFlags_G_SPAWN_SEARCH_PATH: GSpawnFlags = 4;
pub const GSpawnFlags_G_SPAWN_STDOUT_TO_DEV_NULL: GSpawnFlags = 8;
pub const GSpawnFlags_G_SPAWN_STDERR_TO_DEV_NULL: GSpawnFlags = 16;
pub const GSpawnFlags_G_SPAWN_CHILD_INHERITS_STDIN: GSpawnFlags = 32;
pub const GSpawnFlags_G_SPAWN_FILE_AND_ARGV_ZERO: GSpawnFlags = 64;
pub const GSpawnFlags_G_SPAWN_SEARCH_PATH_FROM_ENVP: GSpawnFlags = 128;
pub const GSpawnFlags_G_SPAWN_CLOEXEC_PIPES: GSpawnFlags = 256;
/// GSpawnFlags:
/// @G_SPAWN_DEFAULT: no flags, default behaviour
/// @G_SPAWN_LEAVE_DESCRIPTORS_OPEN: the parent's open file descriptors will
/// be inherited by the child; otherwise all descriptors except stdin,
/// stdout and stderr will be closed before calling exec() in the child.
/// @G_SPAWN_DO_NOT_REAP_CHILD: the child will not be automatically reaped;
/// you must use g_child_watch_add() yourself (or call waitpid() or handle
/// `SIGCHLD` yourself), or the child will become a zombie.
/// @G_SPAWN_SEARCH_PATH: `argv[0]` need not be an absolute path, it will be
/// looked for in the user's `PATH`.
/// @G_SPAWN_STDOUT_TO_DEV_NULL: the child's standard output will be discarded,
/// instead of going to the same location as the parent's standard output.
/// @G_SPAWN_STDERR_TO_DEV_NULL: the child's standard error will be discarded.
/// @G_SPAWN_CHILD_INHERITS_STDIN: the child will inherit the parent's standard
/// input (by default, the child's standard input is attached to `/dev/null`).
/// @G_SPAWN_FILE_AND_ARGV_ZERO: the first element of `argv` is the file to
/// execute, while the remaining elements are the actual argument vector
/// to pass to the file. Normally g_spawn_async_with_pipes() uses `argv[0]`
/// as the file to execute, and passes all of `argv` to the child.
/// @G_SPAWN_SEARCH_PATH_FROM_ENVP: if `argv[0]` is not an abolute path,
/// it will be looked for in the `PATH` from the passed child environment.
/// Since: 2.34
/// @G_SPAWN_CLOEXEC_PIPES: create all pipes with the `O_CLOEXEC` flag set.
/// Since: 2.40
///
/// Flags passed to g_spawn_sync(), g_spawn_async() and g_spawn_async_with_pipes().
pub type GSpawnFlags = u32;
extern "C" {
    #[link_name = "\u{1}_g_spawn_error_quark"]
    pub fn g_spawn_error_quark() -> GQuark;
}
extern "C" {
    #[link_name = "\u{1}_g_spawn_exit_error_quark"]
    pub fn g_spawn_exit_error_quark() -> GQuark;
}
extern "C" {
    #[link_name = "\u{1}_g_spawn_async"]
    pub fn g_spawn_async(
        working_directory: *const gchar,
        argv: *mut *mut gchar,
        envp: *mut *mut gchar,
        flags: GSpawnFlags,
        child_setup: GSpawnChildSetupFunc,
        user_data: gpointer,
        child_pid: *mut GPid,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_spawn_async_with_pipes"]
    pub fn g_spawn_async_with_pipes(
        working_directory: *const gchar,
        argv: *mut *mut gchar,
        envp: *mut *mut gchar,
        flags: GSpawnFlags,
        child_setup: GSpawnChildSetupFunc,
        user_data: gpointer,
        child_pid: *mut GPid,
        standard_input: *mut gint,
        standard_output: *mut gint,
        standard_error: *mut gint,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_spawn_sync"]
    pub fn g_spawn_sync(
        working_directory: *const gchar,
        argv: *mut *mut gchar,
        envp: *mut *mut gchar,
        flags: GSpawnFlags,
        child_setup: GSpawnChildSetupFunc,
        user_data: gpointer,
        standard_output: *mut *mut gchar,
        standard_error: *mut *mut gchar,
        exit_status: *mut gint,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_spawn_command_line_sync"]
    pub fn g_spawn_command_line_sync(
        command_line: *const gchar,
        standard_output: *mut *mut gchar,
        standard_error: *mut *mut gchar,
        exit_status: *mut gint,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_spawn_command_line_async"]
    pub fn g_spawn_command_line_async(
        command_line: *const gchar,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_spawn_check_exit_status"]
    pub fn g_spawn_check_exit_status(exit_status: gint, error: *mut *mut GError) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_spawn_close_pid"]
    pub fn g_spawn_close_pid(pid: GPid);
}
pub const GAsciiType_G_ASCII_ALNUM: GAsciiType = 1;
pub const GAsciiType_G_ASCII_ALPHA: GAsciiType = 2;
pub const GAsciiType_G_ASCII_CNTRL: GAsciiType = 4;
pub const GAsciiType_G_ASCII_DIGIT: GAsciiType = 8;
pub const GAsciiType_G_ASCII_GRAPH: GAsciiType = 16;
pub const GAsciiType_G_ASCII_LOWER: GAsciiType = 32;
pub const GAsciiType_G_ASCII_PRINT: GAsciiType = 64;
pub const GAsciiType_G_ASCII_PUNCT: GAsciiType = 128;
pub const GAsciiType_G_ASCII_SPACE: GAsciiType = 256;
pub const GAsciiType_G_ASCII_UPPER: GAsciiType = 512;
pub const GAsciiType_G_ASCII_XDIGIT: GAsciiType = 1024;
pub type GAsciiType = u32;
extern "C" {
    #[link_name = "\u{1}_g_ascii_table"]
    pub static mut g_ascii_table: *const guint16;
}
extern "C" {
    #[link_name = "\u{1}_g_ascii_tolower"]
    pub fn g_ascii_tolower(c: gchar) -> gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_ascii_toupper"]
    pub fn g_ascii_toupper(c: gchar) -> gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_ascii_digit_value"]
    pub fn g_ascii_digit_value(c: gchar) -> gint;
}
extern "C" {
    #[link_name = "\u{1}_g_ascii_xdigit_value"]
    pub fn g_ascii_xdigit_value(c: gchar) -> gint;
}
extern "C" {
    #[link_name = "\u{1}_g_strdelimit"]
    pub fn g_strdelimit(
        string: *mut gchar,
        delimiters: *const gchar,
        new_delimiter: gchar,
    ) -> *mut gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_strcanon"]
    pub fn g_strcanon(
        string: *mut gchar,
        valid_chars: *const gchar,
        substitutor: gchar,
    ) -> *mut gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_strerror"]
    pub fn g_strerror(errnum: gint) -> *const gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_strsignal"]
    pub fn g_strsignal(signum: gint) -> *const gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_strreverse"]
    pub fn g_strreverse(string: *mut gchar) -> *mut gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_strlcpy"]
    pub fn g_strlcpy(dest: *mut gchar, src: *const gchar, dest_size: gsize) -> gsize;
}
extern "C" {
    #[link_name = "\u{1}_g_strlcat"]
    pub fn g_strlcat(dest: *mut gchar, src: *const gchar, dest_size: gsize) -> gsize;
}
extern "C" {
    #[link_name = "\u{1}_g_strstr_len"]
    pub fn g_strstr_len(
        haystack: *const gchar,
        haystack_len: gssize,
        needle: *const gchar,
    ) -> *mut gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_strrstr"]
    pub fn g_strrstr(haystack: *const gchar, needle: *const gchar) -> *mut gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_strrstr_len"]
    pub fn g_strrstr_len(
        haystack: *const gchar,
        haystack_len: gssize,
        needle: *const gchar,
    ) -> *mut gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_str_has_suffix"]
    pub fn g_str_has_suffix(str: *const gchar, suffix: *const gchar) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_str_has_prefix"]
    pub fn g_str_has_prefix(str: *const gchar, prefix: *const gchar) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_strtod"]
    pub fn g_strtod(nptr: *const gchar, endptr: *mut *mut gchar) -> gdouble;
}
extern "C" {
    #[link_name = "\u{1}_g_ascii_strtod"]
    pub fn g_ascii_strtod(nptr: *const gchar, endptr: *mut *mut gchar) -> gdouble;
}
extern "C" {
    #[link_name = "\u{1}_g_ascii_strtoull"]
    pub fn g_ascii_strtoull(nptr: *const gchar, endptr: *mut *mut gchar, base: guint) -> guint64;
}
extern "C" {
    #[link_name = "\u{1}_g_ascii_strtoll"]
    pub fn g_ascii_strtoll(nptr: *const gchar, endptr: *mut *mut gchar, base: guint) -> gint64;
}
extern "C" {
    #[link_name = "\u{1}_g_ascii_dtostr"]
    pub fn g_ascii_dtostr(buffer: *mut gchar, buf_len: gint, d: gdouble) -> *mut gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_ascii_formatd"]
    pub fn g_ascii_formatd(
        buffer: *mut gchar,
        buf_len: gint,
        format: *const gchar,
        d: gdouble,
    ) -> *mut gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_strchug"]
    pub fn g_strchug(string: *mut gchar) -> *mut gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_strchomp"]
    pub fn g_strchomp(string: *mut gchar) -> *mut gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_ascii_strcasecmp"]
    pub fn g_ascii_strcasecmp(s1: *const gchar, s2: *const gchar) -> gint;
}
extern "C" {
    #[link_name = "\u{1}_g_ascii_strncasecmp"]
    pub fn g_ascii_strncasecmp(s1: *const gchar, s2: *const gchar, n: gsize) -> gint;
}
extern "C" {
    #[link_name = "\u{1}_g_ascii_strdown"]
    pub fn g_ascii_strdown(str: *const gchar, len: gssize) -> *mut gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_ascii_strup"]
    pub fn g_ascii_strup(str: *const gchar, len: gssize) -> *mut gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_str_is_ascii"]
    pub fn g_str_is_ascii(str: *const gchar) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_strcasecmp"]
    pub fn g_strcasecmp(s1: *const gchar, s2: *const gchar) -> gint;
}
extern "C" {
    #[link_name = "\u{1}_g_strncasecmp"]
    pub fn g_strncasecmp(s1: *const gchar, s2: *const gchar, n: guint) -> gint;
}
extern "C" {
    #[link_name = "\u{1}_g_strdown"]
    pub fn g_strdown(string: *mut gchar) -> *mut gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_strup"]
    pub fn g_strup(string: *mut gchar) -> *mut gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_strdup"]
    pub fn g_strdup(str: *const gchar) -> *mut gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_strdup_printf"]
    pub fn g_strdup_printf(format: *const gchar, ...) -> *mut gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_strdup_vprintf"]
    pub fn g_strdup_vprintf(format: *const gchar, args: *mut __va_list_tag) -> *mut gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_strndup"]
    pub fn g_strndup(str: *const gchar, n: gsize) -> *mut gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_strnfill"]
    pub fn g_strnfill(length: gsize, fill_char: gchar) -> *mut gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_strconcat"]
    pub fn g_strconcat(string1: *const gchar, ...) -> *mut gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_strjoin"]
    pub fn g_strjoin(separator: *const gchar, ...) -> *mut gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_strcompress"]
    pub fn g_strcompress(source: *const gchar) -> *mut gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_strescape"]
    pub fn g_strescape(source: *const gchar, exceptions: *const gchar) -> *mut gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_memdup"]
    pub fn g_memdup(mem: gconstpointer, byte_size: guint) -> gpointer;
}
pub type GStrv = *mut *mut gchar;
extern "C" {
    #[link_name = "\u{1}_g_strsplit"]
    pub fn g_strsplit(
        string: *const gchar,
        delimiter: *const gchar,
        max_tokens: gint,
    ) -> *mut *mut gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_strsplit_set"]
    pub fn g_strsplit_set(
        string: *const gchar,
        delimiters: *const gchar,
        max_tokens: gint,
    ) -> *mut *mut gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_strjoinv"]
    pub fn g_strjoinv(separator: *const gchar, str_array: *mut *mut gchar) -> *mut gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_strfreev"]
    pub fn g_strfreev(str_array: *mut *mut gchar);
}
extern "C" {
    #[link_name = "\u{1}_g_strdupv"]
    pub fn g_strdupv(str_array: *mut *mut gchar) -> *mut *mut gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_strv_length"]
    pub fn g_strv_length(str_array: *mut *mut gchar) -> guint;
}
extern "C" {
    #[link_name = "\u{1}_g_stpcpy"]
    pub fn g_stpcpy(dest: *mut gchar, src: *const ::std::os::raw::c_char) -> *mut gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_str_to_ascii"]
    pub fn g_str_to_ascii(str: *const gchar, from_locale: *const gchar) -> *mut gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_str_tokenize_and_fold"]
    pub fn g_str_tokenize_and_fold(
        string: *const gchar,
        translit_locale: *const gchar,
        ascii_alternates: *mut *mut *mut gchar,
    ) -> *mut *mut gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_str_match_string"]
    pub fn g_str_match_string(
        search_term: *const gchar,
        potential_hit: *const gchar,
        accept_alternates: gboolean,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_strv_contains"]
    pub fn g_strv_contains(strv: *const *const gchar, str: *const gchar) -> gboolean;
}
pub const GNumberParserError_G_NUMBER_PARSER_ERROR_INVALID: GNumberParserError = 0;
pub const GNumberParserError_G_NUMBER_PARSER_ERROR_OUT_OF_BOUNDS: GNumberParserError = 1;
/// GNumberParserError:
/// @G_NUMBER_PARSER_ERROR_INVALID: String was not a valid number.
/// @G_NUMBER_PARSER_ERROR_OUT_OF_BOUNDS: String was a number, but out of bounds.
///
/// Error codes returned by functions converting a string to a number.
///
/// Since: 2.54
pub type GNumberParserError = u32;
extern "C" {
    #[link_name = "\u{1}_g_number_parser_error_quark"]
    pub fn g_number_parser_error_quark() -> GQuark;
}
extern "C" {
    #[link_name = "\u{1}_g_ascii_string_to_signed"]
    pub fn g_ascii_string_to_signed(
        str: *const gchar,
        base: guint,
        min: gint64,
        max: gint64,
        out_num: *mut gint64,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_ascii_string_to_unsigned"]
    pub fn g_ascii_string_to_unsigned(
        str: *const gchar,
        base: guint,
        min: guint64,
        max: guint64,
        out_num: *mut guint64,
        error: *mut *mut GError,
    ) -> gboolean;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GStringChunk {
    _unused: [u8; 0],
}
pub type GStringChunk = _GStringChunk;
extern "C" {
    #[link_name = "\u{1}_g_string_chunk_new"]
    pub fn g_string_chunk_new(size: gsize) -> *mut GStringChunk;
}
extern "C" {
    #[link_name = "\u{1}_g_string_chunk_free"]
    pub fn g_string_chunk_free(chunk: *mut GStringChunk);
}
extern "C" {
    #[link_name = "\u{1}_g_string_chunk_clear"]
    pub fn g_string_chunk_clear(chunk: *mut GStringChunk);
}
extern "C" {
    #[link_name = "\u{1}_g_string_chunk_insert"]
    pub fn g_string_chunk_insert(chunk: *mut GStringChunk, string: *const gchar) -> *mut gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_string_chunk_insert_len"]
    pub fn g_string_chunk_insert_len(
        chunk: *mut GStringChunk,
        string: *const gchar,
        len: gssize,
    ) -> *mut gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_string_chunk_insert_const"]
    pub fn g_string_chunk_insert_const(
        chunk: *mut GStringChunk,
        string: *const gchar,
    ) -> *mut gchar;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GTestCase {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GTestSuite {
    _unused: [u8; 0],
}
pub type GTestFunc = ::std::option::Option<unsafe extern "C" fn()>;
pub type GTestDataFunc = ::std::option::Option<unsafe extern "C" fn(user_data: gconstpointer)>;
pub type GTestFixtureFunc =
    ::std::option::Option<unsafe extern "C" fn(fixture: gpointer, user_data: gconstpointer)>;
extern "C" {
    #[link_name = "\u{1}_g_strcmp0"]
    pub fn g_strcmp0(
        str1: *const ::std::os::raw::c_char,
        str2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_g_test_minimized_result"]
    pub fn g_test_minimized_result(
        minimized_quantity: f64,
        format: *const ::std::os::raw::c_char,
        ...
    );
}
extern "C" {
    #[link_name = "\u{1}_g_test_maximized_result"]
    pub fn g_test_maximized_result(
        maximized_quantity: f64,
        format: *const ::std::os::raw::c_char,
        ...
    );
}
extern "C" {
    #[link_name = "\u{1}_g_test_init"]
    pub fn g_test_init(
        argc: *mut ::std::os::raw::c_int,
        argv: *mut *mut *mut ::std::os::raw::c_char,
        ...
    );
}
extern "C" {
    #[link_name = "\u{1}_g_test_subprocess"]
    pub fn g_test_subprocess() -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_test_run"]
    pub fn g_test_run() -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_g_test_add_func"]
    pub fn g_test_add_func(testpath: *const ::std::os::raw::c_char, test_func: GTestFunc);
}
extern "C" {
    #[link_name = "\u{1}_g_test_add_data_func"]
    pub fn g_test_add_data_func(
        testpath: *const ::std::os::raw::c_char,
        test_data: gconstpointer,
        test_func: GTestDataFunc,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_test_add_data_func_full"]
    pub fn g_test_add_data_func_full(
        testpath: *const ::std::os::raw::c_char,
        test_data: gpointer,
        test_func: GTestDataFunc,
        data_free_func: GDestroyNotify,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_test_fail"]
    pub fn g_test_fail();
}
extern "C" {
    #[link_name = "\u{1}_g_test_incomplete"]
    pub fn g_test_incomplete(msg: *const gchar);
}
extern "C" {
    #[link_name = "\u{1}_g_test_skip"]
    pub fn g_test_skip(msg: *const gchar);
}
extern "C" {
    #[link_name = "\u{1}_g_test_failed"]
    pub fn g_test_failed() -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_test_set_nonfatal_assertions"]
    pub fn g_test_set_nonfatal_assertions();
}
extern "C" {
    #[link_name = "\u{1}_g_test_message"]
    pub fn g_test_message(format: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    #[link_name = "\u{1}_g_test_bug_base"]
    pub fn g_test_bug_base(uri_pattern: *const ::std::os::raw::c_char);
}
extern "C" {
    #[link_name = "\u{1}_g_test_bug"]
    pub fn g_test_bug(bug_uri_snippet: *const ::std::os::raw::c_char);
}
extern "C" {
    #[link_name = "\u{1}_g_test_timer_start"]
    pub fn g_test_timer_start();
}
extern "C" {
    #[link_name = "\u{1}_g_test_timer_elapsed"]
    pub fn g_test_timer_elapsed() -> f64;
}
extern "C" {
    #[link_name = "\u{1}_g_test_timer_last"]
    pub fn g_test_timer_last() -> f64;
}
extern "C" {
    #[link_name = "\u{1}_g_test_queue_free"]
    pub fn g_test_queue_free(gfree_pointer: gpointer);
}
extern "C" {
    #[link_name = "\u{1}_g_test_queue_destroy"]
    pub fn g_test_queue_destroy(destroy_func: GDestroyNotify, destroy_data: gpointer);
}
pub const GTestTrapFlags_G_TEST_TRAP_SILENCE_STDOUT: GTestTrapFlags = 128;
pub const GTestTrapFlags_G_TEST_TRAP_SILENCE_STDERR: GTestTrapFlags = 256;
pub const GTestTrapFlags_G_TEST_TRAP_INHERIT_STDIN: GTestTrapFlags = 512;
pub type GTestTrapFlags = u32;
extern "C" {
    #[link_name = "\u{1}_g_test_trap_fork"]
    pub fn g_test_trap_fork(usec_timeout: guint64, test_trap_flags: GTestTrapFlags) -> gboolean;
}
pub const GTestSubprocessFlags_G_TEST_SUBPROCESS_INHERIT_STDIN: GTestSubprocessFlags = 1;
pub const GTestSubprocessFlags_G_TEST_SUBPROCESS_INHERIT_STDOUT: GTestSubprocessFlags = 2;
pub const GTestSubprocessFlags_G_TEST_SUBPROCESS_INHERIT_STDERR: GTestSubprocessFlags = 4;
pub type GTestSubprocessFlags = u32;
extern "C" {
    #[link_name = "\u{1}_g_test_trap_subprocess"]
    pub fn g_test_trap_subprocess(
        test_path: *const ::std::os::raw::c_char,
        usec_timeout: guint64,
        test_flags: GTestSubprocessFlags,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_test_trap_has_passed"]
    pub fn g_test_trap_has_passed() -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_test_trap_reached_timeout"]
    pub fn g_test_trap_reached_timeout() -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_test_rand_int"]
    pub fn g_test_rand_int() -> gint32;
}
extern "C" {
    #[link_name = "\u{1}_g_test_rand_int_range"]
    pub fn g_test_rand_int_range(begin: gint32, end: gint32) -> gint32;
}
extern "C" {
    #[link_name = "\u{1}_g_test_rand_double"]
    pub fn g_test_rand_double() -> f64;
}
extern "C" {
    #[link_name = "\u{1}_g_test_rand_double_range"]
    pub fn g_test_rand_double_range(range_start: f64, range_end: f64) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_g_test_create_case"]
    pub fn g_test_create_case(
        test_name: *const ::std::os::raw::c_char,
        data_size: gsize,
        test_data: gconstpointer,
        data_setup: GTestFixtureFunc,
        data_test: GTestFixtureFunc,
        data_teardown: GTestFixtureFunc,
    ) -> *mut GTestCase;
}
extern "C" {
    #[link_name = "\u{1}_g_test_create_suite"]
    pub fn g_test_create_suite(suite_name: *const ::std::os::raw::c_char) -> *mut GTestSuite;
}
extern "C" {
    #[link_name = "\u{1}_g_test_get_root"]
    pub fn g_test_get_root() -> *mut GTestSuite;
}
extern "C" {
    #[link_name = "\u{1}_g_test_suite_add"]
    pub fn g_test_suite_add(suite: *mut GTestSuite, test_case: *mut GTestCase);
}
extern "C" {
    #[link_name = "\u{1}_g_test_suite_add_suite"]
    pub fn g_test_suite_add_suite(suite: *mut GTestSuite, nestedsuite: *mut GTestSuite);
}
extern "C" {
    #[link_name = "\u{1}_g_test_run_suite"]
    pub fn g_test_run_suite(suite: *mut GTestSuite) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_g_test_trap_assertions"]
    pub fn g_test_trap_assertions(
        domain: *const ::std::os::raw::c_char,
        file: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
        func: *const ::std::os::raw::c_char,
        assertion_flags: guint64,
        pattern: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_assertion_message"]
    pub fn g_assertion_message(
        domain: *const ::std::os::raw::c_char,
        file: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
        func: *const ::std::os::raw::c_char,
        message: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_assertion_message_expr"]
    pub fn g_assertion_message_expr(
        domain: *const ::std::os::raw::c_char,
        file: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
        func: *const ::std::os::raw::c_char,
        expr: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_assertion_message_cmpstr"]
    pub fn g_assertion_message_cmpstr(
        domain: *const ::std::os::raw::c_char,
        file: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
        func: *const ::std::os::raw::c_char,
        expr: *const ::std::os::raw::c_char,
        arg1: *const ::std::os::raw::c_char,
        cmp: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_assertion_message_cmpnum"]
    pub fn g_assertion_message_cmpnum(
        domain: *const ::std::os::raw::c_char,
        file: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
        func: *const ::std::os::raw::c_char,
        expr: *const ::std::os::raw::c_char,
        arg1: f64,
        cmp: *const ::std::os::raw::c_char,
        arg2: f64,
        numtype: ::std::os::raw::c_char,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_assertion_message_error"]
    pub fn g_assertion_message_error(
        domain: *const ::std::os::raw::c_char,
        file: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
        func: *const ::std::os::raw::c_char,
        expr: *const ::std::os::raw::c_char,
        error: *const GError,
        error_domain: GQuark,
        error_code: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_test_add_vtable"]
    pub fn g_test_add_vtable(
        testpath: *const ::std::os::raw::c_char,
        data_size: gsize,
        test_data: gconstpointer,
        data_setup: GTestFixtureFunc,
        data_test: GTestFixtureFunc,
        data_teardown: GTestFixtureFunc,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GTestConfig {
    pub test_initialized: gboolean,
    pub test_quick: gboolean,
    pub test_perf: gboolean,
    pub test_verbose: gboolean,
    pub test_quiet: gboolean,
    pub test_undefined: gboolean,
}
#[test]
fn bindgen_test_layout_GTestConfig() {
    assert_eq!(
        ::std::mem::size_of::<GTestConfig>(),
        24usize,
        concat!("Size of: ", stringify!(GTestConfig))
    );
    assert_eq!(
        ::std::mem::align_of::<GTestConfig>(),
        4usize,
        concat!("Alignment of ", stringify!(GTestConfig))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GTestConfig>())).test_initialized as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GTestConfig),
            "::",
            stringify!(test_initialized)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GTestConfig>())).test_quick as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(GTestConfig),
            "::",
            stringify!(test_quick)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GTestConfig>())).test_perf as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(GTestConfig),
            "::",
            stringify!(test_perf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GTestConfig>())).test_verbose as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(GTestConfig),
            "::",
            stringify!(test_verbose)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GTestConfig>())).test_quiet as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(GTestConfig),
            "::",
            stringify!(test_quiet)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GTestConfig>())).test_undefined as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(GTestConfig),
            "::",
            stringify!(test_undefined)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_g_test_config_vars"]
    pub static mut g_test_config_vars: *const GTestConfig;
}
pub const GTestResult_G_TEST_RUN_SUCCESS: GTestResult = 0;
pub const GTestResult_G_TEST_RUN_SKIPPED: GTestResult = 1;
pub const GTestResult_G_TEST_RUN_FAILURE: GTestResult = 2;
pub const GTestResult_G_TEST_RUN_INCOMPLETE: GTestResult = 3;
pub type GTestResult = u32;
pub const GTestLogType_G_TEST_LOG_NONE: GTestLogType = 0;
pub const GTestLogType_G_TEST_LOG_ERROR: GTestLogType = 1;
pub const GTestLogType_G_TEST_LOG_START_BINARY: GTestLogType = 2;
pub const GTestLogType_G_TEST_LOG_LIST_CASE: GTestLogType = 3;
pub const GTestLogType_G_TEST_LOG_SKIP_CASE: GTestLogType = 4;
pub const GTestLogType_G_TEST_LOG_START_CASE: GTestLogType = 5;
pub const GTestLogType_G_TEST_LOG_STOP_CASE: GTestLogType = 6;
pub const GTestLogType_G_TEST_LOG_MIN_RESULT: GTestLogType = 7;
pub const GTestLogType_G_TEST_LOG_MAX_RESULT: GTestLogType = 8;
pub const GTestLogType_G_TEST_LOG_MESSAGE: GTestLogType = 9;
pub const GTestLogType_G_TEST_LOG_START_SUITE: GTestLogType = 10;
pub const GTestLogType_G_TEST_LOG_STOP_SUITE: GTestLogType = 11;
pub type GTestLogType = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GTestLogMsg {
    pub log_type: GTestLogType,
    pub n_strings: guint,
    pub strings: *mut *mut gchar,
    pub n_nums: guint,
    pub nums: *mut f64,
}
#[test]
fn bindgen_test_layout_GTestLogMsg() {
    assert_eq!(
        ::std::mem::size_of::<GTestLogMsg>(),
        32usize,
        concat!("Size of: ", stringify!(GTestLogMsg))
    );
    assert_eq!(
        ::std::mem::align_of::<GTestLogMsg>(),
        8usize,
        concat!("Alignment of ", stringify!(GTestLogMsg))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GTestLogMsg>())).log_type as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GTestLogMsg),
            "::",
            stringify!(log_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GTestLogMsg>())).n_strings as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(GTestLogMsg),
            "::",
            stringify!(n_strings)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GTestLogMsg>())).strings as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(GTestLogMsg),
            "::",
            stringify!(strings)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GTestLogMsg>())).n_nums as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(GTestLogMsg),
            "::",
            stringify!(n_nums)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GTestLogMsg>())).nums as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(GTestLogMsg),
            "::",
            stringify!(nums)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GTestLogBuffer {
    pub data: *mut GString,
    pub msgs: *mut GSList,
}
#[test]
fn bindgen_test_layout_GTestLogBuffer() {
    assert_eq!(
        ::std::mem::size_of::<GTestLogBuffer>(),
        16usize,
        concat!("Size of: ", stringify!(GTestLogBuffer))
    );
    assert_eq!(
        ::std::mem::align_of::<GTestLogBuffer>(),
        8usize,
        concat!("Alignment of ", stringify!(GTestLogBuffer))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GTestLogBuffer>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GTestLogBuffer),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GTestLogBuffer>())).msgs as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(GTestLogBuffer),
            "::",
            stringify!(msgs)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_g_test_log_type_name"]
    pub fn g_test_log_type_name(log_type: GTestLogType) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_g_test_log_buffer_new"]
    pub fn g_test_log_buffer_new() -> *mut GTestLogBuffer;
}
extern "C" {
    #[link_name = "\u{1}_g_test_log_buffer_free"]
    pub fn g_test_log_buffer_free(tbuffer: *mut GTestLogBuffer);
}
extern "C" {
    #[link_name = "\u{1}_g_test_log_buffer_push"]
    pub fn g_test_log_buffer_push(
        tbuffer: *mut GTestLogBuffer,
        n_bytes: guint,
        bytes: *const guint8,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_test_log_buffer_pop"]
    pub fn g_test_log_buffer_pop(tbuffer: *mut GTestLogBuffer) -> *mut GTestLogMsg;
}
extern "C" {
    #[link_name = "\u{1}_g_test_log_msg_free"]
    pub fn g_test_log_msg_free(tmsg: *mut GTestLogMsg);
}
/// GTestLogFatalFunc:
/// @log_domain: the log domain of the message
/// @log_level: the log level of the message (including the fatal and recursion flags)
/// @message: the message to process
/// @user_data: user data, set in g_test_log_set_fatal_handler()
///
/// Specifies the prototype of fatal log handler functions.
///
/// Returns: %TRUE if the program should abort, %FALSE otherwise
///
/// Since: 2.22
pub type GTestLogFatalFunc = ::std::option::Option<
    unsafe extern "C" fn(
        log_domain: *const gchar,
        log_level: GLogLevelFlags,
        message: *const gchar,
        user_data: gpointer,
    ) -> gboolean,
>;
extern "C" {
    #[link_name = "\u{1}_g_test_log_set_fatal_handler"]
    pub fn g_test_log_set_fatal_handler(log_func: GTestLogFatalFunc, user_data: gpointer);
}
extern "C" {
    #[link_name = "\u{1}_g_test_expect_message"]
    pub fn g_test_expect_message(
        log_domain: *const gchar,
        log_level: GLogLevelFlags,
        pattern: *const gchar,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_test_assert_expected_messages_internal"]
    pub fn g_test_assert_expected_messages_internal(
        domain: *const ::std::os::raw::c_char,
        file: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
        func: *const ::std::os::raw::c_char,
    );
}
pub const GTestFileType_G_TEST_DIST: GTestFileType = 0;
pub const GTestFileType_G_TEST_BUILT: GTestFileType = 1;
pub type GTestFileType = u32;
extern "C" {
    #[link_name = "\u{1}_g_test_build_filename"]
    pub fn g_test_build_filename(
        file_type: GTestFileType,
        first_path: *const gchar,
        ...
    ) -> *mut gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_test_get_dir"]
    pub fn g_test_get_dir(file_type: GTestFileType) -> *const gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_test_get_filename"]
    pub fn g_test_get_filename(
        file_type: GTestFileType,
        first_path: *const gchar,
        ...
    ) -> *const gchar;
}
pub type GThreadPool = _GThreadPool;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GThreadPool {
    pub func: GFunc,
    pub user_data: gpointer,
    pub exclusive: gboolean,
}
#[test]
fn bindgen_test_layout__GThreadPool() {
    assert_eq!(
        ::std::mem::size_of::<_GThreadPool>(),
        24usize,
        concat!("Size of: ", stringify!(_GThreadPool))
    );
    assert_eq!(
        ::std::mem::align_of::<_GThreadPool>(),
        8usize,
        concat!("Alignment of ", stringify!(_GThreadPool))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GThreadPool>())).func as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GThreadPool),
            "::",
            stringify!(func)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GThreadPool>())).user_data as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GThreadPool),
            "::",
            stringify!(user_data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GThreadPool>())).exclusive as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GThreadPool),
            "::",
            stringify!(exclusive)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_g_thread_pool_new"]
    pub fn g_thread_pool_new(
        func: GFunc,
        user_data: gpointer,
        max_threads: gint,
        exclusive: gboolean,
        error: *mut *mut GError,
    ) -> *mut GThreadPool;
}
extern "C" {
    #[link_name = "\u{1}_g_thread_pool_free"]
    pub fn g_thread_pool_free(pool: *mut GThreadPool, immediate: gboolean, wait_: gboolean);
}
extern "C" {
    #[link_name = "\u{1}_g_thread_pool_push"]
    pub fn g_thread_pool_push(
        pool: *mut GThreadPool,
        data: gpointer,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_thread_pool_unprocessed"]
    pub fn g_thread_pool_unprocessed(pool: *mut GThreadPool) -> guint;
}
extern "C" {
    #[link_name = "\u{1}_g_thread_pool_set_sort_function"]
    pub fn g_thread_pool_set_sort_function(
        pool: *mut GThreadPool,
        func: GCompareDataFunc,
        user_data: gpointer,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_thread_pool_move_to_front"]
    pub fn g_thread_pool_move_to_front(pool: *mut GThreadPool, data: gpointer) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_thread_pool_set_max_threads"]
    pub fn g_thread_pool_set_max_threads(
        pool: *mut GThreadPool,
        max_threads: gint,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_thread_pool_get_max_threads"]
    pub fn g_thread_pool_get_max_threads(pool: *mut GThreadPool) -> gint;
}
extern "C" {
    #[link_name = "\u{1}_g_thread_pool_get_num_threads"]
    pub fn g_thread_pool_get_num_threads(pool: *mut GThreadPool) -> guint;
}
extern "C" {
    #[link_name = "\u{1}_g_thread_pool_set_max_unused_threads"]
    pub fn g_thread_pool_set_max_unused_threads(max_threads: gint);
}
extern "C" {
    #[link_name = "\u{1}_g_thread_pool_get_max_unused_threads"]
    pub fn g_thread_pool_get_max_unused_threads() -> gint;
}
extern "C" {
    #[link_name = "\u{1}_g_thread_pool_get_num_unused_threads"]
    pub fn g_thread_pool_get_num_unused_threads() -> guint;
}
extern "C" {
    #[link_name = "\u{1}_g_thread_pool_stop_unused_threads"]
    pub fn g_thread_pool_stop_unused_threads();
}
extern "C" {
    #[link_name = "\u{1}_g_thread_pool_set_max_idle_time"]
    pub fn g_thread_pool_set_max_idle_time(interval: guint);
}
extern "C" {
    #[link_name = "\u{1}_g_thread_pool_get_max_idle_time"]
    pub fn g_thread_pool_get_max_idle_time() -> guint;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GTimer {
    _unused: [u8; 0],
}
pub type GTimer = _GTimer;
extern "C" {
    #[link_name = "\u{1}_g_timer_new"]
    pub fn g_timer_new() -> *mut GTimer;
}
extern "C" {
    #[link_name = "\u{1}_g_timer_destroy"]
    pub fn g_timer_destroy(timer: *mut GTimer);
}
extern "C" {
    #[link_name = "\u{1}_g_timer_start"]
    pub fn g_timer_start(timer: *mut GTimer);
}
extern "C" {
    #[link_name = "\u{1}_g_timer_stop"]
    pub fn g_timer_stop(timer: *mut GTimer);
}
extern "C" {
    #[link_name = "\u{1}_g_timer_reset"]
    pub fn g_timer_reset(timer: *mut GTimer);
}
extern "C" {
    #[link_name = "\u{1}_g_timer_continue"]
    pub fn g_timer_continue(timer: *mut GTimer);
}
extern "C" {
    #[link_name = "\u{1}_g_timer_elapsed"]
    pub fn g_timer_elapsed(timer: *mut GTimer, microseconds: *mut gulong) -> gdouble;
}
extern "C" {
    #[link_name = "\u{1}_g_usleep"]
    pub fn g_usleep(microseconds: gulong);
}
extern "C" {
    #[link_name = "\u{1}_g_time_val_add"]
    pub fn g_time_val_add(time_: *mut GTimeVal, microseconds: glong);
}
extern "C" {
    #[link_name = "\u{1}_g_time_val_from_iso8601"]
    pub fn g_time_val_from_iso8601(iso_date: *const gchar, time_: *mut GTimeVal) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_time_val_to_iso8601"]
    pub fn g_time_val_to_iso8601(time_: *mut GTimeVal) -> *mut gchar;
}
pub type GTrashStack = _GTrashStack;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GTrashStack {
    pub next: *mut GTrashStack,
}
#[test]
fn bindgen_test_layout__GTrashStack() {
    assert_eq!(
        ::std::mem::size_of::<_GTrashStack>(),
        8usize,
        concat!("Size of: ", stringify!(_GTrashStack))
    );
    assert_eq!(
        ::std::mem::align_of::<_GTrashStack>(),
        8usize,
        concat!("Alignment of ", stringify!(_GTrashStack))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GTrashStack>())).next as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTrashStack),
            "::",
            stringify!(next)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_g_trash_stack_push"]
    pub fn g_trash_stack_push(stack_p: *mut *mut GTrashStack, data_p: gpointer);
}
extern "C" {
    #[link_name = "\u{1}_g_trash_stack_pop"]
    pub fn g_trash_stack_pop(stack_p: *mut *mut GTrashStack) -> gpointer;
}
extern "C" {
    #[link_name = "\u{1}_g_trash_stack_peek"]
    pub fn g_trash_stack_peek(stack_p: *mut *mut GTrashStack) -> gpointer;
}
extern "C" {
    #[link_name = "\u{1}_g_trash_stack_height"]
    pub fn g_trash_stack_height(stack_p: *mut *mut GTrashStack) -> guint;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GTree {
    _unused: [u8; 0],
}
pub type GTree = _GTree;
pub type GTraverseFunc = ::std::option::Option<
    unsafe extern "C" fn(key: gpointer, value: gpointer, data: gpointer) -> gboolean,
>;
extern "C" {
    #[link_name = "\u{1}_g_tree_new"]
    pub fn g_tree_new(key_compare_func: GCompareFunc) -> *mut GTree;
}
extern "C" {
    #[link_name = "\u{1}_g_tree_new_with_data"]
    pub fn g_tree_new_with_data(
        key_compare_func: GCompareDataFunc,
        key_compare_data: gpointer,
    ) -> *mut GTree;
}
extern "C" {
    #[link_name = "\u{1}_g_tree_new_full"]
    pub fn g_tree_new_full(
        key_compare_func: GCompareDataFunc,
        key_compare_data: gpointer,
        key_destroy_func: GDestroyNotify,
        value_destroy_func: GDestroyNotify,
    ) -> *mut GTree;
}
extern "C" {
    #[link_name = "\u{1}_g_tree_ref"]
    pub fn g_tree_ref(tree: *mut GTree) -> *mut GTree;
}
extern "C" {
    #[link_name = "\u{1}_g_tree_unref"]
    pub fn g_tree_unref(tree: *mut GTree);
}
extern "C" {
    #[link_name = "\u{1}_g_tree_destroy"]
    pub fn g_tree_destroy(tree: *mut GTree);
}
extern "C" {
    #[link_name = "\u{1}_g_tree_insert"]
    pub fn g_tree_insert(tree: *mut GTree, key: gpointer, value: gpointer);
}
extern "C" {
    #[link_name = "\u{1}_g_tree_replace"]
    pub fn g_tree_replace(tree: *mut GTree, key: gpointer, value: gpointer);
}
extern "C" {
    #[link_name = "\u{1}_g_tree_remove"]
    pub fn g_tree_remove(tree: *mut GTree, key: gconstpointer) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_tree_steal"]
    pub fn g_tree_steal(tree: *mut GTree, key: gconstpointer) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_tree_lookup"]
    pub fn g_tree_lookup(tree: *mut GTree, key: gconstpointer) -> gpointer;
}
extern "C" {
    #[link_name = "\u{1}_g_tree_lookup_extended"]
    pub fn g_tree_lookup_extended(
        tree: *mut GTree,
        lookup_key: gconstpointer,
        orig_key: *mut gpointer,
        value: *mut gpointer,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_tree_foreach"]
    pub fn g_tree_foreach(tree: *mut GTree, func: GTraverseFunc, user_data: gpointer);
}
extern "C" {
    #[link_name = "\u{1}_g_tree_traverse"]
    pub fn g_tree_traverse(
        tree: *mut GTree,
        traverse_func: GTraverseFunc,
        traverse_type: GTraverseType,
        user_data: gpointer,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_tree_search"]
    pub fn g_tree_search(
        tree: *mut GTree,
        search_func: GCompareFunc,
        user_data: gconstpointer,
    ) -> gpointer;
}
extern "C" {
    #[link_name = "\u{1}_g_tree_height"]
    pub fn g_tree_height(tree: *mut GTree) -> gint;
}
extern "C" {
    #[link_name = "\u{1}_g_tree_nnodes"]
    pub fn g_tree_nnodes(tree: *mut GTree) -> gint;
}
extern "C" {
    #[link_name = "\u{1}_g_uri_unescape_string"]
    pub fn g_uri_unescape_string(
        escaped_string: *const ::std::os::raw::c_char,
        illegal_characters: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_g_uri_unescape_segment"]
    pub fn g_uri_unescape_segment(
        escaped_string: *const ::std::os::raw::c_char,
        escaped_string_end: *const ::std::os::raw::c_char,
        illegal_characters: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_g_uri_parse_scheme"]
    pub fn g_uri_parse_scheme(uri: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_g_uri_escape_string"]
    pub fn g_uri_escape_string(
        unescaped: *const ::std::os::raw::c_char,
        reserved_chars_allowed: *const ::std::os::raw::c_char,
        allow_utf8: gboolean,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_g_uuid_string_is_valid"]
    pub fn g_uuid_string_is_valid(str: *const gchar) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_uuid_string_random"]
    pub fn g_uuid_string_random() -> *mut gchar;
}
extern "C" {
    #[link_name = "\u{1}_glib_major_version"]
    pub static mut glib_major_version: guint;
}
extern "C" {
    #[link_name = "\u{1}_glib_minor_version"]
    pub static mut glib_minor_version: guint;
}
extern "C" {
    #[link_name = "\u{1}_glib_micro_version"]
    pub static mut glib_micro_version: guint;
}
extern "C" {
    #[link_name = "\u{1}_glib_interface_age"]
    pub static mut glib_interface_age: guint;
}
extern "C" {
    #[link_name = "\u{1}_glib_binary_age"]
    pub static mut glib_binary_age: guint;
}
extern "C" {
    #[link_name = "\u{1}_glib_check_version"]
    pub fn glib_check_version(
        required_major: guint,
        required_minor: guint,
        required_micro: guint,
    ) -> *const gchar;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GAllocator {
    _unused: [u8; 0],
}
pub type GAllocator = _GAllocator;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GMemChunk {
    _unused: [u8; 0],
}
pub type GMemChunk = _GMemChunk;
extern "C" {
    #[link_name = "\u{1}_g_mem_chunk_new"]
    pub fn g_mem_chunk_new(
        name: *const gchar,
        atom_size: gint,
        area_size: gsize,
        type_: gint,
    ) -> *mut GMemChunk;
}
extern "C" {
    #[link_name = "\u{1}_g_mem_chunk_destroy"]
    pub fn g_mem_chunk_destroy(mem_chunk: *mut GMemChunk);
}
extern "C" {
    #[link_name = "\u{1}_g_mem_chunk_alloc"]
    pub fn g_mem_chunk_alloc(mem_chunk: *mut GMemChunk) -> gpointer;
}
extern "C" {
    #[link_name = "\u{1}_g_mem_chunk_alloc0"]
    pub fn g_mem_chunk_alloc0(mem_chunk: *mut GMemChunk) -> gpointer;
}
extern "C" {
    #[link_name = "\u{1}_g_mem_chunk_free"]
    pub fn g_mem_chunk_free(mem_chunk: *mut GMemChunk, mem: gpointer);
}
extern "C" {
    #[link_name = "\u{1}_g_mem_chunk_clean"]
    pub fn g_mem_chunk_clean(mem_chunk: *mut GMemChunk);
}
extern "C" {
    #[link_name = "\u{1}_g_mem_chunk_reset"]
    pub fn g_mem_chunk_reset(mem_chunk: *mut GMemChunk);
}
extern "C" {
    #[link_name = "\u{1}_g_mem_chunk_print"]
    pub fn g_mem_chunk_print(mem_chunk: *mut GMemChunk);
}
extern "C" {
    #[link_name = "\u{1}_g_mem_chunk_info"]
    pub fn g_mem_chunk_info();
}
extern "C" {
    #[link_name = "\u{1}_g_blow_chunks"]
    pub fn g_blow_chunks();
}
extern "C" {
    #[link_name = "\u{1}_g_allocator_new"]
    pub fn g_allocator_new(name: *const gchar, n_preallocs: guint) -> *mut GAllocator;
}
extern "C" {
    #[link_name = "\u{1}_g_allocator_free"]
    pub fn g_allocator_free(allocator: *mut GAllocator);
}
extern "C" {
    #[link_name = "\u{1}_g_list_push_allocator"]
    pub fn g_list_push_allocator(allocator: *mut GAllocator);
}
extern "C" {
    #[link_name = "\u{1}_g_list_pop_allocator"]
    pub fn g_list_pop_allocator();
}
extern "C" {
    #[link_name = "\u{1}_g_slist_push_allocator"]
    pub fn g_slist_push_allocator(allocator: *mut GAllocator);
}
extern "C" {
    #[link_name = "\u{1}_g_slist_pop_allocator"]
    pub fn g_slist_pop_allocator();
}
extern "C" {
    #[link_name = "\u{1}_g_node_push_allocator"]
    pub fn g_node_push_allocator(allocator: *mut GAllocator);
}
extern "C" {
    #[link_name = "\u{1}_g_node_pop_allocator"]
    pub fn g_node_pop_allocator();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GCache {
    _unused: [u8; 0],
}
pub type GCache = _GCache;
pub type GCacheNewFunc = ::std::option::Option<unsafe extern "C" fn(key: gpointer) -> gpointer>;
pub type GCacheDupFunc = ::std::option::Option<unsafe extern "C" fn(value: gpointer) -> gpointer>;
pub type GCacheDestroyFunc = ::std::option::Option<unsafe extern "C" fn(value: gpointer)>;
extern "C" {
    #[link_name = "\u{1}_g_cache_new"]
    pub fn g_cache_new(
        value_new_func: GCacheNewFunc,
        value_destroy_func: GCacheDestroyFunc,
        key_dup_func: GCacheDupFunc,
        key_destroy_func: GCacheDestroyFunc,
        hash_key_func: GHashFunc,
        hash_value_func: GHashFunc,
        key_equal_func: GEqualFunc,
    ) -> *mut GCache;
}
extern "C" {
    #[link_name = "\u{1}_g_cache_destroy"]
    pub fn g_cache_destroy(cache: *mut GCache);
}
extern "C" {
    #[link_name = "\u{1}_g_cache_insert"]
    pub fn g_cache_insert(cache: *mut GCache, key: gpointer) -> gpointer;
}
extern "C" {
    #[link_name = "\u{1}_g_cache_remove"]
    pub fn g_cache_remove(cache: *mut GCache, value: gconstpointer);
}
extern "C" {
    #[link_name = "\u{1}_g_cache_key_foreach"]
    pub fn g_cache_key_foreach(cache: *mut GCache, func: GHFunc, user_data: gpointer);
}
extern "C" {
    #[link_name = "\u{1}_g_cache_value_foreach"]
    pub fn g_cache_value_foreach(cache: *mut GCache, func: GHFunc, user_data: gpointer);
}
pub type GCompletion = _GCompletion;
pub type GCompletionFunc =
    ::std::option::Option<unsafe extern "C" fn(arg1: gpointer) -> *mut gchar>;
pub type GCompletionStrncmpFunc = ::std::option::Option<
    unsafe extern "C" fn(s1: *const gchar, s2: *const gchar, n: gsize) -> gint,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GCompletion {
    pub items: *mut GList,
    pub func: GCompletionFunc,
    pub prefix: *mut gchar,
    pub cache: *mut GList,
    pub strncmp_func: GCompletionStrncmpFunc,
}
#[test]
fn bindgen_test_layout__GCompletion() {
    assert_eq!(
        ::std::mem::size_of::<_GCompletion>(),
        40usize,
        concat!("Size of: ", stringify!(_GCompletion))
    );
    assert_eq!(
        ::std::mem::align_of::<_GCompletion>(),
        8usize,
        concat!("Alignment of ", stringify!(_GCompletion))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GCompletion>())).items as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GCompletion),
            "::",
            stringify!(items)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GCompletion>())).func as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GCompletion),
            "::",
            stringify!(func)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GCompletion>())).prefix as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GCompletion),
            "::",
            stringify!(prefix)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GCompletion>())).cache as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GCompletion),
            "::",
            stringify!(cache)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GCompletion>())).strncmp_func as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_GCompletion),
            "::",
            stringify!(strncmp_func)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_g_completion_new"]
    pub fn g_completion_new(func: GCompletionFunc) -> *mut GCompletion;
}
extern "C" {
    #[link_name = "\u{1}_g_completion_add_items"]
    pub fn g_completion_add_items(cmp: *mut GCompletion, items: *mut GList);
}
extern "C" {
    #[link_name = "\u{1}_g_completion_remove_items"]
    pub fn g_completion_remove_items(cmp: *mut GCompletion, items: *mut GList);
}
extern "C" {
    #[link_name = "\u{1}_g_completion_clear_items"]
    pub fn g_completion_clear_items(cmp: *mut GCompletion);
}
extern "C" {
    #[link_name = "\u{1}_g_completion_complete"]
    pub fn g_completion_complete(
        cmp: *mut GCompletion,
        prefix: *const gchar,
        new_prefix: *mut *mut gchar,
    ) -> *mut GList;
}
extern "C" {
    #[link_name = "\u{1}_g_completion_complete_utf8"]
    pub fn g_completion_complete_utf8(
        cmp: *mut GCompletion,
        prefix: *const gchar,
        new_prefix: *mut *mut gchar,
    ) -> *mut GList;
}
extern "C" {
    #[link_name = "\u{1}_g_completion_set_compare"]
    pub fn g_completion_set_compare(cmp: *mut GCompletion, strncmp_func: GCompletionStrncmpFunc);
}
extern "C" {
    #[link_name = "\u{1}_g_completion_free"]
    pub fn g_completion_free(cmp: *mut GCompletion);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GRelation {
    _unused: [u8; 0],
}
pub type GRelation = _GRelation;
pub type GTuples = _GTuples;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GTuples {
    pub len: guint,
}
#[test]
fn bindgen_test_layout__GTuples() {
    assert_eq!(
        ::std::mem::size_of::<_GTuples>(),
        4usize,
        concat!("Size of: ", stringify!(_GTuples))
    );
    assert_eq!(
        ::std::mem::align_of::<_GTuples>(),
        4usize,
        concat!("Alignment of ", stringify!(_GTuples))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GTuples>())).len as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTuples),
            "::",
            stringify!(len)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_g_relation_new"]
    pub fn g_relation_new(fields: gint) -> *mut GRelation;
}
extern "C" {
    #[link_name = "\u{1}_g_relation_destroy"]
    pub fn g_relation_destroy(relation: *mut GRelation);
}
extern "C" {
    #[link_name = "\u{1}_g_relation_index"]
    pub fn g_relation_index(
        relation: *mut GRelation,
        field: gint,
        hash_func: GHashFunc,
        key_equal_func: GEqualFunc,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_relation_insert"]
    pub fn g_relation_insert(relation: *mut GRelation, ...);
}
extern "C" {
    #[link_name = "\u{1}_g_relation_delete"]
    pub fn g_relation_delete(relation: *mut GRelation, key: gconstpointer, field: gint) -> gint;
}
extern "C" {
    #[link_name = "\u{1}_g_relation_select"]
    pub fn g_relation_select(
        relation: *mut GRelation,
        key: gconstpointer,
        field: gint,
    ) -> *mut GTuples;
}
extern "C" {
    #[link_name = "\u{1}_g_relation_count"]
    pub fn g_relation_count(relation: *mut GRelation, key: gconstpointer, field: gint) -> gint;
}
extern "C" {
    #[link_name = "\u{1}_g_relation_exists"]
    pub fn g_relation_exists(relation: *mut GRelation, ...) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_relation_print"]
    pub fn g_relation_print(relation: *mut GRelation);
}
extern "C" {
    #[link_name = "\u{1}_g_tuples_destroy"]
    pub fn g_tuples_destroy(tuples: *mut GTuples);
}
extern "C" {
    #[link_name = "\u{1}_g_tuples_index"]
    pub fn g_tuples_index(tuples: *mut GTuples, index_: gint, field: gint) -> gpointer;
}
pub const GThreadPriority_G_THREAD_PRIORITY_LOW: GThreadPriority = 0;
pub const GThreadPriority_G_THREAD_PRIORITY_NORMAL: GThreadPriority = 1;
pub const GThreadPriority_G_THREAD_PRIORITY_HIGH: GThreadPriority = 2;
pub const GThreadPriority_G_THREAD_PRIORITY_URGENT: GThreadPriority = 3;
pub type GThreadPriority = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GThread {
    pub func: GThreadFunc,
    pub data: gpointer,
    pub joinable: gboolean,
    pub priority: GThreadPriority,
}
#[test]
fn bindgen_test_layout__GThread() {
    assert_eq!(
        ::std::mem::size_of::<_GThread>(),
        24usize,
        concat!("Size of: ", stringify!(_GThread))
    );
    assert_eq!(
        ::std::mem::align_of::<_GThread>(),
        8usize,
        concat!("Alignment of ", stringify!(_GThread))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GThread>())).func as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GThread),
            "::",
            stringify!(func)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GThread>())).data as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GThread),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GThread>())).joinable as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GThread),
            "::",
            stringify!(joinable)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GThread>())).priority as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_GThread),
            "::",
            stringify!(priority)
        )
    );
}
pub type GThreadFunctions = _GThreadFunctions;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GThreadFunctions {
    pub mutex_new: ::std::option::Option<unsafe extern "C" fn() -> *mut GMutex>,
    pub mutex_lock: ::std::option::Option<unsafe extern "C" fn(mutex: *mut GMutex)>,
    pub mutex_trylock: ::std::option::Option<unsafe extern "C" fn(mutex: *mut GMutex) -> gboolean>,
    pub mutex_unlock: ::std::option::Option<unsafe extern "C" fn(mutex: *mut GMutex)>,
    pub mutex_free: ::std::option::Option<unsafe extern "C" fn(mutex: *mut GMutex)>,
    pub cond_new: ::std::option::Option<unsafe extern "C" fn() -> *mut GCond>,
    pub cond_signal: ::std::option::Option<unsafe extern "C" fn(cond: *mut GCond)>,
    pub cond_broadcast: ::std::option::Option<unsafe extern "C" fn(cond: *mut GCond)>,
    pub cond_wait:
        ::std::option::Option<unsafe extern "C" fn(cond: *mut GCond, mutex: *mut GMutex)>,
    pub cond_timed_wait: ::std::option::Option<
        unsafe extern "C" fn(cond: *mut GCond, mutex: *mut GMutex, end_time: *mut GTimeVal)
            -> gboolean,
    >,
    pub cond_free: ::std::option::Option<unsafe extern "C" fn(cond: *mut GCond)>,
    pub private_new:
        ::std::option::Option<unsafe extern "C" fn(destructor: GDestroyNotify) -> *mut GPrivate>,
    pub private_get:
        ::std::option::Option<unsafe extern "C" fn(private_key: *mut GPrivate) -> gpointer>,
    pub private_set:
        ::std::option::Option<unsafe extern "C" fn(private_key: *mut GPrivate, data: gpointer)>,
    pub thread_create: ::std::option::Option<
        unsafe extern "C" fn(
            func: GThreadFunc,
            data: gpointer,
            stack_size: gulong,
            joinable: gboolean,
            bound: gboolean,
            priority: GThreadPriority,
            thread: gpointer,
            error: *mut *mut GError,
        ),
    >,
    pub thread_yield: ::std::option::Option<unsafe extern "C" fn()>,
    pub thread_join: ::std::option::Option<unsafe extern "C" fn(thread: gpointer)>,
    pub thread_exit: ::std::option::Option<unsafe extern "C" fn()>,
    pub thread_set_priority:
        ::std::option::Option<unsafe extern "C" fn(thread: gpointer, priority: GThreadPriority)>,
    pub thread_self: ::std::option::Option<unsafe extern "C" fn(thread: gpointer)>,
    pub thread_equal: ::std::option::Option<
        unsafe extern "C" fn(thread1: gpointer, thread2: gpointer) -> gboolean,
    >,
}
#[test]
fn bindgen_test_layout__GThreadFunctions() {
    assert_eq!(
        ::std::mem::size_of::<_GThreadFunctions>(),
        168usize,
        concat!("Size of: ", stringify!(_GThreadFunctions))
    );
    assert_eq!(
        ::std::mem::align_of::<_GThreadFunctions>(),
        8usize,
        concat!("Alignment of ", stringify!(_GThreadFunctions))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GThreadFunctions>())).mutex_new as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GThreadFunctions),
            "::",
            stringify!(mutex_new)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GThreadFunctions>())).mutex_lock as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GThreadFunctions),
            "::",
            stringify!(mutex_lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GThreadFunctions>())).mutex_trylock as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GThreadFunctions),
            "::",
            stringify!(mutex_trylock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GThreadFunctions>())).mutex_unlock as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GThreadFunctions),
            "::",
            stringify!(mutex_unlock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GThreadFunctions>())).mutex_free as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_GThreadFunctions),
            "::",
            stringify!(mutex_free)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GThreadFunctions>())).cond_new as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_GThreadFunctions),
            "::",
            stringify!(cond_new)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GThreadFunctions>())).cond_signal as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_GThreadFunctions),
            "::",
            stringify!(cond_signal)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GThreadFunctions>())).cond_broadcast as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_GThreadFunctions),
            "::",
            stringify!(cond_broadcast)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GThreadFunctions>())).cond_wait as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_GThreadFunctions),
            "::",
            stringify!(cond_wait)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GThreadFunctions>())).cond_timed_wait as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_GThreadFunctions),
            "::",
            stringify!(cond_timed_wait)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GThreadFunctions>())).cond_free as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_GThreadFunctions),
            "::",
            stringify!(cond_free)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GThreadFunctions>())).private_new as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_GThreadFunctions),
            "::",
            stringify!(private_new)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GThreadFunctions>())).private_get as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_GThreadFunctions),
            "::",
            stringify!(private_get)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GThreadFunctions>())).private_set as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_GThreadFunctions),
            "::",
            stringify!(private_set)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GThreadFunctions>())).thread_create as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(_GThreadFunctions),
            "::",
            stringify!(thread_create)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GThreadFunctions>())).thread_yield as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(_GThreadFunctions),
            "::",
            stringify!(thread_yield)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GThreadFunctions>())).thread_join as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(_GThreadFunctions),
            "::",
            stringify!(thread_join)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GThreadFunctions>())).thread_exit as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_GThreadFunctions),
            "::",
            stringify!(thread_exit)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GThreadFunctions>())).thread_set_priority as *const _ as usize
        },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_GThreadFunctions),
            "::",
            stringify!(thread_set_priority)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GThreadFunctions>())).thread_self as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(_GThreadFunctions),
            "::",
            stringify!(thread_self)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GThreadFunctions>())).thread_equal as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_GThreadFunctions),
            "::",
            stringify!(thread_equal)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_g_thread_functions_for_glib_use"]
    pub static mut g_thread_functions_for_glib_use: GThreadFunctions;
}
extern "C" {
    #[link_name = "\u{1}_g_thread_use_default_impl"]
    pub static mut g_thread_use_default_impl: gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_thread_gettime"]
    pub static mut g_thread_gettime: ::std::option::Option<unsafe extern "C" fn() -> guint64>;
}
extern "C" {
    #[link_name = "\u{1}_g_thread_create"]
    pub fn g_thread_create(
        func: GThreadFunc,
        data: gpointer,
        joinable: gboolean,
        error: *mut *mut GError,
    ) -> *mut GThread;
}
extern "C" {
    #[link_name = "\u{1}_g_thread_create_full"]
    pub fn g_thread_create_full(
        func: GThreadFunc,
        data: gpointer,
        stack_size: gulong,
        joinable: gboolean,
        bound: gboolean,
        priority: GThreadPriority,
        error: *mut *mut GError,
    ) -> *mut GThread;
}
extern "C" {
    #[link_name = "\u{1}_g_thread_set_priority"]
    pub fn g_thread_set_priority(thread: *mut GThread, priority: GThreadPriority);
}
extern "C" {
    #[link_name = "\u{1}_g_thread_foreach"]
    pub fn g_thread_foreach(thread_func: GFunc, user_data: gpointer);
}
pub type u_char = ::std::os::raw::c_uchar;
pub type u_short = ::std::os::raw::c_ushort;
pub type u_int = ::std::os::raw::c_uint;
pub type u_long = ::std::os::raw::c_ulong;
pub type ushort = ::std::os::raw::c_ushort;
pub type uint = ::std::os::raw::c_uint;
pub type u_quad_t = u_int64_t;
pub type quad_t = i64;
pub type qaddr_t = *mut quad_t;
pub type caddr_t = *mut ::std::os::raw::c_char;
pub type daddr_t = i32;
pub type fixpt_t = u_int32_t;
pub type blkcnt_t = __darwin_blkcnt_t;
pub type blksize_t = __darwin_blksize_t;
pub type gid_t = __darwin_gid_t;
pub type in_addr_t = __uint32_t;
pub type in_port_t = __uint16_t;
pub type ino64_t = __darwin_ino64_t;
pub type key_t = __int32_t;
pub type nlink_t = __uint16_t;
pub type off_t = __darwin_off_t;
pub type segsz_t = i32;
pub type swblk_t = i32;
pub type useconds_t = __darwin_useconds_t;
pub type suseconds_t = __darwin_suseconds_t;
pub type rsize_t = __darwin_size_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fd_set {
    pub fds_bits: [__int32_t; 32usize],
}
#[test]
fn bindgen_test_layout_fd_set() {
    assert_eq!(
        ::std::mem::size_of::<fd_set>(),
        128usize,
        concat!("Size of: ", stringify!(fd_set))
    );
    assert_eq!(
        ::std::mem::align_of::<fd_set>(),
        4usize,
        concat!("Alignment of ", stringify!(fd_set))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fd_set>())).fds_bits as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fd_set),
            "::",
            stringify!(fds_bits)
        )
    );
}
pub type fd_mask = __int32_t;
pub type pthread_cond_t = __darwin_pthread_cond_t;
pub type pthread_condattr_t = __darwin_pthread_condattr_t;
pub type pthread_mutex_t = __darwin_pthread_mutex_t;
pub type pthread_mutexattr_t = __darwin_pthread_mutexattr_t;
pub type pthread_once_t = __darwin_pthread_once_t;
pub type pthread_rwlock_t = __darwin_pthread_rwlock_t;
pub type pthread_rwlockattr_t = __darwin_pthread_rwlockattr_t;
pub type pthread_key_t = __darwin_pthread_key_t;
pub type fsblkcnt_t = __darwin_fsblkcnt_t;
pub type fsfilcnt_t = __darwin_fsfilcnt_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sched_param {
    pub sched_priority: ::std::os::raw::c_int,
    pub __opaque: [::std::os::raw::c_char; 4usize],
}
#[test]
fn bindgen_test_layout_sched_param() {
    assert_eq!(
        ::std::mem::size_of::<sched_param>(),
        8usize,
        concat!("Size of: ", stringify!(sched_param))
    );
    assert_eq!(
        ::std::mem::align_of::<sched_param>(),
        4usize,
        concat!("Alignment of ", stringify!(sched_param))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sched_param>())).sched_priority as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_param),
            "::",
            stringify!(sched_priority)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sched_param>())).__opaque as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_param),
            "::",
            stringify!(__opaque)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_sched_yield"]
    pub fn sched_yield() -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_sched_get_priority_min"]
    pub fn sched_get_priority_min(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_sched_get_priority_max"]
    pub fn sched_get_priority_max(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
pub const QOS_CLASS_USER_INTERACTIVE: _bindgen_ty_1 = 33;
pub const QOS_CLASS_USER_INITIATED: _bindgen_ty_1 = 25;
pub const QOS_CLASS_DEFAULT: _bindgen_ty_1 = 21;
pub const QOS_CLASS_UTILITY: _bindgen_ty_1 = 17;
pub const QOS_CLASS_BACKGROUND: _bindgen_ty_1 = 9;
pub const QOS_CLASS_UNSPECIFIED: _bindgen_ty_1 = 0;
pub type _bindgen_ty_1 = u32;
pub type qos_class_t = ::std::os::raw::c_uint;
extern "C" {
    #[link_name = "\u{1}_qos_class_self"]
    pub fn qos_class_self() -> qos_class_t;
}
extern "C" {
    #[link_name = "\u{1}_qos_class_main"]
    pub fn qos_class_main() -> qos_class_t;
}
extern "C" {
    #[link_name = "\u{1}_pthread_attr_set_qos_class_np"]
    pub fn pthread_attr_set_qos_class_np(
        __attr: *mut pthread_attr_t,
        __qos_class: qos_class_t,
        __relative_priority: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_pthread_attr_get_qos_class_np"]
    pub fn pthread_attr_get_qos_class_np(
        __attr: *mut pthread_attr_t,
        __qos_class: *mut qos_class_t,
        __relative_priority: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_pthread_set_qos_class_self_np"]
    pub fn pthread_set_qos_class_self_np(
        __qos_class: qos_class_t,
        __relative_priority: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_pthread_get_qos_class_np"]
    pub fn pthread_get_qos_class_np(
        __pthread: pthread_t,
        __qos_class: *mut qos_class_t,
        __relative_priority: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_override_s {
    _unused: [u8; 0],
}
pub type pthread_override_t = *mut pthread_override_s;
extern "C" {
    #[link_name = "\u{1}_pthread_override_qos_class_start_np"]
    pub fn pthread_override_qos_class_start_np(
        __pthread: pthread_t,
        __qos_class: qos_class_t,
        __relative_priority: ::std::os::raw::c_int,
    ) -> pthread_override_t;
}
extern "C" {
    #[link_name = "\u{1}_pthread_override_qos_class_end_np"]
    pub fn pthread_override_qos_class_end_np(
        __override: pthread_override_t,
    ) -> ::std::os::raw::c_int;
}
pub type mach_port_t = __darwin_mach_port_t;
extern "C" {
    #[link_name = "\u{1}_pthread_atfork"]
    pub fn pthread_atfork(
        arg1: ::std::option::Option<unsafe extern "C" fn()>,
        arg2: ::std::option::Option<unsafe extern "C" fn()>,
        arg3: ::std::option::Option<unsafe extern "C" fn()>,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_pthread_attr_destroy"]
    pub fn pthread_attr_destroy(arg1: *mut pthread_attr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_pthread_attr_getdetachstate"]
    pub fn pthread_attr_getdetachstate(
        arg1: *const pthread_attr_t,
        arg2: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_pthread_attr_getguardsize"]
    pub fn pthread_attr_getguardsize(
        arg1: *const pthread_attr_t,
        arg2: *mut usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_pthread_attr_getinheritsched"]
    pub fn pthread_attr_getinheritsched(
        arg1: *const pthread_attr_t,
        arg2: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_pthread_attr_getschedparam"]
    pub fn pthread_attr_getschedparam(
        arg1: *const pthread_attr_t,
        arg2: *mut sched_param,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_pthread_attr_getschedpolicy"]
    pub fn pthread_attr_getschedpolicy(
        arg1: *const pthread_attr_t,
        arg2: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_pthread_attr_getscope"]
    pub fn pthread_attr_getscope(
        arg1: *const pthread_attr_t,
        arg2: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_pthread_attr_getstack"]
    pub fn pthread_attr_getstack(
        arg1: *const pthread_attr_t,
        arg2: *mut *mut ::std::os::raw::c_void,
        arg3: *mut usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_pthread_attr_getstackaddr"]
    pub fn pthread_attr_getstackaddr(
        arg1: *const pthread_attr_t,
        arg2: *mut *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_pthread_attr_getstacksize"]
    pub fn pthread_attr_getstacksize(
        arg1: *const pthread_attr_t,
        arg2: *mut usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_pthread_attr_init"]
    pub fn pthread_attr_init(arg1: *mut pthread_attr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_pthread_attr_setdetachstate"]
    pub fn pthread_attr_setdetachstate(
        arg1: *mut pthread_attr_t,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_pthread_attr_setguardsize"]
    pub fn pthread_attr_setguardsize(
        arg1: *mut pthread_attr_t,
        arg2: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_pthread_attr_setinheritsched"]
    pub fn pthread_attr_setinheritsched(
        arg1: *mut pthread_attr_t,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_pthread_attr_setschedparam"]
    pub fn pthread_attr_setschedparam(
        arg1: *mut pthread_attr_t,
        arg2: *const sched_param,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_pthread_attr_setschedpolicy"]
    pub fn pthread_attr_setschedpolicy(
        arg1: *mut pthread_attr_t,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_pthread_attr_setscope"]
    pub fn pthread_attr_setscope(
        arg1: *mut pthread_attr_t,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_pthread_attr_setstack"]
    pub fn pthread_attr_setstack(
        arg1: *mut pthread_attr_t,
        arg2: *mut ::std::os::raw::c_void,
        arg3: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_pthread_attr_setstackaddr"]
    pub fn pthread_attr_setstackaddr(
        arg1: *mut pthread_attr_t,
        arg2: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_pthread_attr_setstacksize"]
    pub fn pthread_attr_setstacksize(
        arg1: *mut pthread_attr_t,
        arg2: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_pthread_cancel"]
    pub fn pthread_cancel(arg1: pthread_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_pthread_cond_broadcast"]
    pub fn pthread_cond_broadcast(arg1: *mut pthread_cond_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_pthread_cond_destroy"]
    pub fn pthread_cond_destroy(arg1: *mut pthread_cond_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_pthread_cond_init"]
    pub fn pthread_cond_init(
        arg1: *mut pthread_cond_t,
        arg2: *const pthread_condattr_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_pthread_cond_signal"]
    pub fn pthread_cond_signal(arg1: *mut pthread_cond_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_pthread_cond_timedwait"]
    pub fn pthread_cond_timedwait(
        arg1: *mut pthread_cond_t,
        arg2: *mut pthread_mutex_t,
        arg3: *const timespec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_pthread_cond_wait"]
    pub fn pthread_cond_wait(
        arg1: *mut pthread_cond_t,
        arg2: *mut pthread_mutex_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_pthread_condattr_destroy"]
    pub fn pthread_condattr_destroy(arg1: *mut pthread_condattr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_pthread_condattr_init"]
    pub fn pthread_condattr_init(arg1: *mut pthread_condattr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_pthread_condattr_getpshared"]
    pub fn pthread_condattr_getpshared(
        arg1: *const pthread_condattr_t,
        arg2: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_pthread_condattr_setpshared"]
    pub fn pthread_condattr_setpshared(
        arg1: *mut pthread_condattr_t,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_pthread_create"]
    pub fn pthread_create(
        arg1: *mut pthread_t,
        arg2: *const pthread_attr_t,
        arg3: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void) -> *mut ::std::os::raw::c_void,
        >,
        arg4: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_pthread_detach"]
    pub fn pthread_detach(arg1: pthread_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_pthread_equal"]
    pub fn pthread_equal(arg1: pthread_t, arg2: pthread_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_pthread_exit"]
    pub fn pthread_exit(arg1: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[link_name = "\u{1}_pthread_getconcurrency"]
    pub fn pthread_getconcurrency() -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_pthread_getschedparam"]
    pub fn pthread_getschedparam(
        arg1: pthread_t,
        arg2: *mut ::std::os::raw::c_int,
        arg3: *mut sched_param,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_pthread_getspecific"]
    pub fn pthread_getspecific(arg1: pthread_key_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[link_name = "\u{1}_pthread_join"]
    pub fn pthread_join(
        arg1: pthread_t,
        arg2: *mut *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_pthread_key_create"]
    pub fn pthread_key_create(
        arg1: *mut pthread_key_t,
        arg2: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_pthread_key_delete"]
    pub fn pthread_key_delete(arg1: pthread_key_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_pthread_mutex_destroy"]
    pub fn pthread_mutex_destroy(arg1: *mut pthread_mutex_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_pthread_mutex_getprioceiling"]
    pub fn pthread_mutex_getprioceiling(
        arg1: *const pthread_mutex_t,
        arg2: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_pthread_mutex_init"]
    pub fn pthread_mutex_init(
        arg1: *mut pthread_mutex_t,
        arg2: *const pthread_mutexattr_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_pthread_mutex_lock"]
    pub fn pthread_mutex_lock(arg1: *mut pthread_mutex_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_pthread_mutex_setprioceiling"]
    pub fn pthread_mutex_setprioceiling(
        arg1: *mut pthread_mutex_t,
        arg2: ::std::os::raw::c_int,
        arg3: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_pthread_mutex_trylock"]
    pub fn pthread_mutex_trylock(arg1: *mut pthread_mutex_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_pthread_mutex_unlock"]
    pub fn pthread_mutex_unlock(arg1: *mut pthread_mutex_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_pthread_mutexattr_destroy"]
    pub fn pthread_mutexattr_destroy(arg1: *mut pthread_mutexattr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_pthread_mutexattr_getprioceiling"]
    pub fn pthread_mutexattr_getprioceiling(
        arg1: *const pthread_mutexattr_t,
        arg2: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_pthread_mutexattr_getprotocol"]
    pub fn pthread_mutexattr_getprotocol(
        arg1: *const pthread_mutexattr_t,
        arg2: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_pthread_mutexattr_getpshared"]
    pub fn pthread_mutexattr_getpshared(
        arg1: *const pthread_mutexattr_t,
        arg2: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_pthread_mutexattr_gettype"]
    pub fn pthread_mutexattr_gettype(
        arg1: *const pthread_mutexattr_t,
        arg2: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_pthread_mutexattr_init"]
    pub fn pthread_mutexattr_init(arg1: *mut pthread_mutexattr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_pthread_mutexattr_setprioceiling"]
    pub fn pthread_mutexattr_setprioceiling(
        arg1: *mut pthread_mutexattr_t,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_pthread_mutexattr_setprotocol"]
    pub fn pthread_mutexattr_setprotocol(
        arg1: *mut pthread_mutexattr_t,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_pthread_mutexattr_setpshared"]
    pub fn pthread_mutexattr_setpshared(
        arg1: *mut pthread_mutexattr_t,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_pthread_mutexattr_settype"]
    pub fn pthread_mutexattr_settype(
        arg1: *mut pthread_mutexattr_t,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_pthread_once"]
    pub fn pthread_once(
        arg1: *mut pthread_once_t,
        arg2: ::std::option::Option<unsafe extern "C" fn()>,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_pthread_rwlock_destroy"]
    pub fn pthread_rwlock_destroy(arg1: *mut pthread_rwlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_pthread_rwlock_init"]
    pub fn pthread_rwlock_init(
        arg1: *mut pthread_rwlock_t,
        arg2: *const pthread_rwlockattr_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_pthread_rwlock_rdlock"]
    pub fn pthread_rwlock_rdlock(arg1: *mut pthread_rwlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_pthread_rwlock_tryrdlock"]
    pub fn pthread_rwlock_tryrdlock(arg1: *mut pthread_rwlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_pthread_rwlock_trywrlock"]
    pub fn pthread_rwlock_trywrlock(arg1: *mut pthread_rwlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_pthread_rwlock_wrlock"]
    pub fn pthread_rwlock_wrlock(arg1: *mut pthread_rwlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_pthread_rwlock_unlock"]
    pub fn pthread_rwlock_unlock(arg1: *mut pthread_rwlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_pthread_rwlockattr_destroy"]
    pub fn pthread_rwlockattr_destroy(arg1: *mut pthread_rwlockattr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_pthread_rwlockattr_getpshared"]
    pub fn pthread_rwlockattr_getpshared(
        arg1: *const pthread_rwlockattr_t,
        arg2: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_pthread_rwlockattr_init"]
    pub fn pthread_rwlockattr_init(arg1: *mut pthread_rwlockattr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_pthread_rwlockattr_setpshared"]
    pub fn pthread_rwlockattr_setpshared(
        arg1: *mut pthread_rwlockattr_t,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_pthread_self"]
    pub fn pthread_self() -> pthread_t;
}
extern "C" {
    #[link_name = "\u{1}_pthread_setcancelstate"]
    pub fn pthread_setcancelstate(
        arg1: ::std::os::raw::c_int,
        arg2: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_pthread_setcanceltype"]
    pub fn pthread_setcanceltype(
        arg1: ::std::os::raw::c_int,
        arg2: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_pthread_setconcurrency"]
    pub fn pthread_setconcurrency(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_pthread_setschedparam"]
    pub fn pthread_setschedparam(
        arg1: pthread_t,
        arg2: ::std::os::raw::c_int,
        arg3: *const sched_param,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_pthread_setspecific"]
    pub fn pthread_setspecific(
        arg1: pthread_key_t,
        arg2: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_pthread_testcancel"]
    pub fn pthread_testcancel();
}
extern "C" {
    #[link_name = "\u{1}_pthread_is_threaded_np"]
    pub fn pthread_is_threaded_np() -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_pthread_threadid_np"]
    pub fn pthread_threadid_np(arg1: pthread_t, arg2: *mut __uint64_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_pthread_getname_np"]
    pub fn pthread_getname_np(
        arg1: pthread_t,
        arg2: *mut ::std::os::raw::c_char,
        arg3: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_pthread_setname_np"]
    pub fn pthread_setname_np(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_pthread_main_np"]
    pub fn pthread_main_np() -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_pthread_mach_thread_np"]
    pub fn pthread_mach_thread_np(arg1: pthread_t) -> mach_port_t;
}
extern "C" {
    #[link_name = "\u{1}_pthread_get_stacksize_np"]
    pub fn pthread_get_stacksize_np(arg1: pthread_t) -> usize;
}
extern "C" {
    #[link_name = "\u{1}_pthread_get_stackaddr_np"]
    pub fn pthread_get_stackaddr_np(arg1: pthread_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[link_name = "\u{1}_pthread_cond_signal_thread_np"]
    pub fn pthread_cond_signal_thread_np(
        arg1: *mut pthread_cond_t,
        arg2: pthread_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_pthread_cond_timedwait_relative_np"]
    pub fn pthread_cond_timedwait_relative_np(
        arg1: *mut pthread_cond_t,
        arg2: *mut pthread_mutex_t,
        arg3: *const timespec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_pthread_create_suspended_np"]
    pub fn pthread_create_suspended_np(
        arg1: *mut pthread_t,
        arg2: *const pthread_attr_t,
        arg3: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void) -> *mut ::std::os::raw::c_void,
        >,
        arg4: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_pthread_from_mach_thread_np"]
    pub fn pthread_from_mach_thread_np(arg1: mach_port_t) -> pthread_t;
}
extern "C" {
    #[link_name = "\u{1}_pthread_yield_np"]
    pub fn pthread_yield_np();
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct GStaticMutex {
    pub mutex: *mut GMutex,
    pub unused: pthread_mutex_t,
}
#[test]
fn bindgen_test_layout_GStaticMutex() {
    assert_eq!(
        ::std::mem::size_of::<GStaticMutex>(),
        72usize,
        concat!("Size of: ", stringify!(GStaticMutex))
    );
    assert_eq!(
        ::std::mem::align_of::<GStaticMutex>(),
        8usize,
        concat!("Alignment of ", stringify!(GStaticMutex))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GStaticMutex>())).mutex as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GStaticMutex),
            "::",
            stringify!(mutex)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GStaticMutex>())).unused as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(GStaticMutex),
            "::",
            stringify!(unused)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_g_static_mutex_init"]
    pub fn g_static_mutex_init(mutex: *mut GStaticMutex);
}
extern "C" {
    #[link_name = "\u{1}_g_static_mutex_free"]
    pub fn g_static_mutex_free(mutex: *mut GStaticMutex);
}
extern "C" {
    #[link_name = "\u{1}_g_static_mutex_get_mutex_impl"]
    pub fn g_static_mutex_get_mutex_impl(mutex: *mut GStaticMutex) -> *mut GMutex;
}
pub type GStaticRecMutex = _GStaticRecMutex;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _GStaticRecMutex {
    pub mutex: GStaticMutex,
    pub depth: guint,
    pub unused: _GStaticRecMutex__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _GStaticRecMutex__bindgen_ty_1 {
    pub owner: pthread_t,
    pub dummy: gdouble,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout__GStaticRecMutex__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<_GStaticRecMutex__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(_GStaticRecMutex__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<_GStaticRecMutex__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(_GStaticRecMutex__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GStaticRecMutex__bindgen_ty_1>())).owner as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GStaticRecMutex__bindgen_ty_1),
            "::",
            stringify!(owner)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GStaticRecMutex__bindgen_ty_1>())).dummy as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GStaticRecMutex__bindgen_ty_1),
            "::",
            stringify!(dummy)
        )
    );
}
#[test]
fn bindgen_test_layout__GStaticRecMutex() {
    assert_eq!(
        ::std::mem::size_of::<_GStaticRecMutex>(),
        88usize,
        concat!("Size of: ", stringify!(_GStaticRecMutex))
    );
    assert_eq!(
        ::std::mem::align_of::<_GStaticRecMutex>(),
        8usize,
        concat!("Alignment of ", stringify!(_GStaticRecMutex))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GStaticRecMutex>())).mutex as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GStaticRecMutex),
            "::",
            stringify!(mutex)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GStaticRecMutex>())).depth as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_GStaticRecMutex),
            "::",
            stringify!(depth)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GStaticRecMutex>())).unused as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_GStaticRecMutex),
            "::",
            stringify!(unused)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_g_static_rec_mutex_init"]
    pub fn g_static_rec_mutex_init(mutex: *mut GStaticRecMutex);
}
extern "C" {
    #[link_name = "\u{1}_g_static_rec_mutex_lock"]
    pub fn g_static_rec_mutex_lock(mutex: *mut GStaticRecMutex);
}
extern "C" {
    #[link_name = "\u{1}_g_static_rec_mutex_trylock"]
    pub fn g_static_rec_mutex_trylock(mutex: *mut GStaticRecMutex) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_static_rec_mutex_unlock"]
    pub fn g_static_rec_mutex_unlock(mutex: *mut GStaticRecMutex);
}
extern "C" {
    #[link_name = "\u{1}_g_static_rec_mutex_lock_full"]
    pub fn g_static_rec_mutex_lock_full(mutex: *mut GStaticRecMutex, depth: guint);
}
extern "C" {
    #[link_name = "\u{1}_g_static_rec_mutex_unlock_full"]
    pub fn g_static_rec_mutex_unlock_full(mutex: *mut GStaticRecMutex) -> guint;
}
extern "C" {
    #[link_name = "\u{1}_g_static_rec_mutex_free"]
    pub fn g_static_rec_mutex_free(mutex: *mut GStaticRecMutex);
}
pub type GStaticRWLock = _GStaticRWLock;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _GStaticRWLock {
    pub mutex: GStaticMutex,
    pub read_cond: *mut GCond,
    pub write_cond: *mut GCond,
    pub read_counter: guint,
    pub have_writer: gboolean,
    pub want_to_read: guint,
    pub want_to_write: guint,
}
#[test]
fn bindgen_test_layout__GStaticRWLock() {
    assert_eq!(
        ::std::mem::size_of::<_GStaticRWLock>(),
        104usize,
        concat!("Size of: ", stringify!(_GStaticRWLock))
    );
    assert_eq!(
        ::std::mem::align_of::<_GStaticRWLock>(),
        8usize,
        concat!("Alignment of ", stringify!(_GStaticRWLock))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GStaticRWLock>())).mutex as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GStaticRWLock),
            "::",
            stringify!(mutex)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GStaticRWLock>())).read_cond as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_GStaticRWLock),
            "::",
            stringify!(read_cond)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GStaticRWLock>())).write_cond as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_GStaticRWLock),
            "::",
            stringify!(write_cond)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GStaticRWLock>())).read_counter as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_GStaticRWLock),
            "::",
            stringify!(read_counter)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GStaticRWLock>())).have_writer as *const _ as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(_GStaticRWLock),
            "::",
            stringify!(have_writer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GStaticRWLock>())).want_to_read as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_GStaticRWLock),
            "::",
            stringify!(want_to_read)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GStaticRWLock>())).want_to_write as *const _ as usize },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(_GStaticRWLock),
            "::",
            stringify!(want_to_write)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_g_static_rw_lock_init"]
    pub fn g_static_rw_lock_init(lock: *mut GStaticRWLock);
}
extern "C" {
    #[link_name = "\u{1}_g_static_rw_lock_reader_lock"]
    pub fn g_static_rw_lock_reader_lock(lock: *mut GStaticRWLock);
}
extern "C" {
    #[link_name = "\u{1}_g_static_rw_lock_reader_trylock"]
    pub fn g_static_rw_lock_reader_trylock(lock: *mut GStaticRWLock) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_static_rw_lock_reader_unlock"]
    pub fn g_static_rw_lock_reader_unlock(lock: *mut GStaticRWLock);
}
extern "C" {
    #[link_name = "\u{1}_g_static_rw_lock_writer_lock"]
    pub fn g_static_rw_lock_writer_lock(lock: *mut GStaticRWLock);
}
extern "C" {
    #[link_name = "\u{1}_g_static_rw_lock_writer_trylock"]
    pub fn g_static_rw_lock_writer_trylock(lock: *mut GStaticRWLock) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_static_rw_lock_writer_unlock"]
    pub fn g_static_rw_lock_writer_unlock(lock: *mut GStaticRWLock);
}
extern "C" {
    #[link_name = "\u{1}_g_static_rw_lock_free"]
    pub fn g_static_rw_lock_free(lock: *mut GStaticRWLock);
}
extern "C" {
    #[link_name = "\u{1}_g_private_new"]
    pub fn g_private_new(notify: GDestroyNotify) -> *mut GPrivate;
}
pub type GStaticPrivate = _GStaticPrivate;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GStaticPrivate {
    pub index: guint,
}
#[test]
fn bindgen_test_layout__GStaticPrivate() {
    assert_eq!(
        ::std::mem::size_of::<_GStaticPrivate>(),
        4usize,
        concat!("Size of: ", stringify!(_GStaticPrivate))
    );
    assert_eq!(
        ::std::mem::align_of::<_GStaticPrivate>(),
        4usize,
        concat!("Alignment of ", stringify!(_GStaticPrivate))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GStaticPrivate>())).index as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GStaticPrivate),
            "::",
            stringify!(index)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_g_static_private_init"]
    pub fn g_static_private_init(private_key: *mut GStaticPrivate);
}
extern "C" {
    #[link_name = "\u{1}_g_static_private_get"]
    pub fn g_static_private_get(private_key: *mut GStaticPrivate) -> gpointer;
}
extern "C" {
    #[link_name = "\u{1}_g_static_private_set"]
    pub fn g_static_private_set(
        private_key: *mut GStaticPrivate,
        data: gpointer,
        notify: GDestroyNotify,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_static_private_free"]
    pub fn g_static_private_free(private_key: *mut GStaticPrivate);
}
extern "C" {
    #[link_name = "\u{1}_g_once_init_enter_impl"]
    pub fn g_once_init_enter_impl(location: *mut gsize) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_thread_init"]
    pub fn g_thread_init(vtable: gpointer);
}
extern "C" {
    #[link_name = "\u{1}_g_thread_init_with_errorcheck_mutexes"]
    pub fn g_thread_init_with_errorcheck_mutexes(vtable: gpointer);
}
extern "C" {
    #[link_name = "\u{1}_g_thread_get_initialized"]
    pub fn g_thread_get_initialized() -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_threads_got_initialized"]
    pub static mut g_threads_got_initialized: gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_mutex_new"]
    pub fn g_mutex_new() -> *mut GMutex;
}
extern "C" {
    #[link_name = "\u{1}_g_mutex_free"]
    pub fn g_mutex_free(mutex: *mut GMutex);
}
extern "C" {
    #[link_name = "\u{1}_g_cond_new"]
    pub fn g_cond_new() -> *mut GCond;
}
extern "C" {
    #[link_name = "\u{1}_g_cond_free"]
    pub fn g_cond_free(cond: *mut GCond);
}
extern "C" {
    #[link_name = "\u{1}_g_cond_timed_wait"]
    pub fn g_cond_timed_wait(
        cond: *mut GCond,
        mutex: *mut GMutex,
        timeval: *mut GTimeVal,
    ) -> gboolean;
}
pub type GAsyncQueue_autoptr = *mut GAsyncQueue;
pub type GBookmarkFile_autoptr = *mut GBookmarkFile;
pub type GBytes_autoptr = *mut GBytes;
pub type GChecksum_autoptr = *mut GChecksum;
pub type GDateTime_autoptr = *mut GDateTime;
pub type GDir_autoptr = *mut GDir;
pub type GError_autoptr = *mut GError;
pub type GHashTable_autoptr = *mut GHashTable;
pub type GHmac_autoptr = *mut GHmac;
pub type GIOChannel_autoptr = *mut GIOChannel;
pub type GKeyFile_autoptr = *mut GKeyFile;
pub type GList_autoptr = *mut GList;
pub type GArray_autoptr = *mut GArray;
pub type GPtrArray_autoptr = *mut GPtrArray;
pub type GByteArray_autoptr = *mut GByteArray;
pub type GMainContext_autoptr = *mut GMainContext;
pub type GMainLoop_autoptr = *mut GMainLoop;
pub type GSource_autoptr = *mut GSource;
pub type GMappedFile_autoptr = *mut GMappedFile;
pub type GMarkupParseContext_autoptr = *mut GMarkupParseContext;
pub type GNode_autoptr = *mut GNode;
pub type GOptionContext_autoptr = *mut GOptionContext;
pub type GOptionGroup_autoptr = *mut GOptionGroup;
pub type GPatternSpec_autoptr = *mut GPatternSpec;
pub type GQueue_autoptr = *mut GQueue;
pub type GRand_autoptr = *mut GRand;
pub type GRegex_autoptr = *mut GRegex;
pub type GMatchInfo_autoptr = *mut GMatchInfo;
pub type GScanner_autoptr = *mut GScanner;
pub type GSequence_autoptr = *mut GSequence;
pub type GSList_autoptr = *mut GSList;
pub type GString_autoptr = *mut GString;
pub type GStringChunk_autoptr = *mut GStringChunk;
pub type GThread_autoptr = *mut GThread;
pub type GMutexLocker_autoptr = *mut GMutexLocker;
pub type GTimer_autoptr = *mut GTimer;
pub type GTimeZone_autoptr = *mut GTimeZone;
pub type GTree_autoptr = *mut GTree;
pub type GVariant_autoptr = *mut GVariant;
pub type GVariantBuilder_autoptr = *mut GVariantBuilder;
pub type GVariantIter_autoptr = *mut GVariantIter;
pub type GVariantDict_autoptr = *mut GVariantDict;
pub type GVariantType_autoptr = *mut GVariantType;
pub type GType = gsize;
pub type GValue = _GValue;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _GTypeCValue {
    _unused: [u8; 0],
}
pub type GTypeCValue = _GTypeCValue;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GTypePlugin {
    _unused: [u8; 0],
}
pub type GTypePlugin = _GTypePlugin;
pub type GTypeClass = _GTypeClass;
pub type GTypeInterface = _GTypeInterface;
pub type GTypeInstance = _GTypeInstance;
pub type GTypeInfo = _GTypeInfo;
pub type GTypeFundamentalInfo = _GTypeFundamentalInfo;
pub type GInterfaceInfo = _GInterfaceInfo;
pub type GTypeValueTable = _GTypeValueTable;
pub type GTypeQuery = _GTypeQuery;
/// GTypeClass:
///
/// An opaque structure used as the base of all classes.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GTypeClass {
    pub g_type: GType,
}
#[test]
fn bindgen_test_layout__GTypeClass() {
    assert_eq!(
        ::std::mem::size_of::<_GTypeClass>(),
        8usize,
        concat!("Size of: ", stringify!(_GTypeClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_GTypeClass>(),
        8usize,
        concat!("Alignment of ", stringify!(_GTypeClass))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GTypeClass>())).g_type as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTypeClass),
            "::",
            stringify!(g_type)
        )
    );
}
/// GTypeInstance:
///
/// An opaque structure used as the base of all type instances.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GTypeInstance {
    pub g_class: *mut GTypeClass,
}
#[test]
fn bindgen_test_layout__GTypeInstance() {
    assert_eq!(
        ::std::mem::size_of::<_GTypeInstance>(),
        8usize,
        concat!("Size of: ", stringify!(_GTypeInstance))
    );
    assert_eq!(
        ::std::mem::align_of::<_GTypeInstance>(),
        8usize,
        concat!("Alignment of ", stringify!(_GTypeInstance))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GTypeInstance>())).g_class as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTypeInstance),
            "::",
            stringify!(g_class)
        )
    );
}
/// GTypeInterface:
///
/// An opaque structure used as the base of all interface types.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GTypeInterface {
    pub g_type: GType,
    pub g_instance_type: GType,
}
#[test]
fn bindgen_test_layout__GTypeInterface() {
    assert_eq!(
        ::std::mem::size_of::<_GTypeInterface>(),
        16usize,
        concat!("Size of: ", stringify!(_GTypeInterface))
    );
    assert_eq!(
        ::std::mem::align_of::<_GTypeInterface>(),
        8usize,
        concat!("Alignment of ", stringify!(_GTypeInterface))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GTypeInterface>())).g_type as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTypeInterface),
            "::",
            stringify!(g_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GTypeInterface>())).g_instance_type as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTypeInterface),
            "::",
            stringify!(g_instance_type)
        )
    );
}
/// GTypeQuery:
/// @type: the #GType value of the type
/// @type_name: the name of the type
/// @class_size: the size of the class structure
/// @instance_size: the size of the instance structure
///
/// A structure holding information for a specific type.
/// It is filled in by the g_type_query() function.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GTypeQuery {
    pub type_: GType,
    pub type_name: *const gchar,
    pub class_size: guint,
    pub instance_size: guint,
}
#[test]
fn bindgen_test_layout__GTypeQuery() {
    assert_eq!(
        ::std::mem::size_of::<_GTypeQuery>(),
        24usize,
        concat!("Size of: ", stringify!(_GTypeQuery))
    );
    assert_eq!(
        ::std::mem::align_of::<_GTypeQuery>(),
        8usize,
        concat!("Alignment of ", stringify!(_GTypeQuery))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GTypeQuery>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTypeQuery),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GTypeQuery>())).type_name as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTypeQuery),
            "::",
            stringify!(type_name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GTypeQuery>())).class_size as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTypeQuery),
            "::",
            stringify!(class_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GTypeQuery>())).instance_size as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTypeQuery),
            "::",
            stringify!(instance_size)
        )
    );
}
pub const GTypeDebugFlags_G_TYPE_DEBUG_NONE: GTypeDebugFlags = 0;
pub const GTypeDebugFlags_G_TYPE_DEBUG_OBJECTS: GTypeDebugFlags = 1;
pub const GTypeDebugFlags_G_TYPE_DEBUG_SIGNALS: GTypeDebugFlags = 2;
pub const GTypeDebugFlags_G_TYPE_DEBUG_INSTANCE_COUNT: GTypeDebugFlags = 4;
pub const GTypeDebugFlags_G_TYPE_DEBUG_MASK: GTypeDebugFlags = 7;
/// GTypeDebugFlags:
/// @G_TYPE_DEBUG_NONE: Print no messages
/// @G_TYPE_DEBUG_OBJECTS: Print messages about object bookkeeping
/// @G_TYPE_DEBUG_SIGNALS: Print messages about signal emissions
/// @G_TYPE_DEBUG_MASK: Mask covering all debug flags
/// @G_TYPE_DEBUG_INSTANCE_COUNT: Keep a count of instances of each type
///
/// These flags used to be passed to g_type_init_with_debug_flags() which
/// is now deprecated.
///
/// If you need to enable debugging features, use the GOBJECT_DEBUG
/// environment variable.
///
/// Deprecated: 2.36: g_type_init() is now done automatically
pub type GTypeDebugFlags = u32;
extern "C" {
    #[link_name = "\u{1}_g_type_init"]
    pub fn g_type_init();
}
extern "C" {
    #[link_name = "\u{1}_g_type_init_with_debug_flags"]
    pub fn g_type_init_with_debug_flags(debug_flags: GTypeDebugFlags);
}
extern "C" {
    #[link_name = "\u{1}_g_type_name"]
    pub fn g_type_name(type_: GType) -> *const gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_type_qname"]
    pub fn g_type_qname(type_: GType) -> GQuark;
}
extern "C" {
    #[link_name = "\u{1}_g_type_from_name"]
    pub fn g_type_from_name(name: *const gchar) -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_type_parent"]
    pub fn g_type_parent(type_: GType) -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_type_depth"]
    pub fn g_type_depth(type_: GType) -> guint;
}
extern "C" {
    #[link_name = "\u{1}_g_type_next_base"]
    pub fn g_type_next_base(leaf_type: GType, root_type: GType) -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_type_is_a"]
    pub fn g_type_is_a(type_: GType, is_a_type: GType) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_type_class_ref"]
    pub fn g_type_class_ref(type_: GType) -> gpointer;
}
extern "C" {
    #[link_name = "\u{1}_g_type_class_peek"]
    pub fn g_type_class_peek(type_: GType) -> gpointer;
}
extern "C" {
    #[link_name = "\u{1}_g_type_class_peek_static"]
    pub fn g_type_class_peek_static(type_: GType) -> gpointer;
}
extern "C" {
    #[link_name = "\u{1}_g_type_class_unref"]
    pub fn g_type_class_unref(g_class: gpointer);
}
extern "C" {
    #[link_name = "\u{1}_g_type_class_peek_parent"]
    pub fn g_type_class_peek_parent(g_class: gpointer) -> gpointer;
}
extern "C" {
    #[link_name = "\u{1}_g_type_interface_peek"]
    pub fn g_type_interface_peek(instance_class: gpointer, iface_type: GType) -> gpointer;
}
extern "C" {
    #[link_name = "\u{1}_g_type_interface_peek_parent"]
    pub fn g_type_interface_peek_parent(g_iface: gpointer) -> gpointer;
}
extern "C" {
    #[link_name = "\u{1}_g_type_default_interface_ref"]
    pub fn g_type_default_interface_ref(g_type: GType) -> gpointer;
}
extern "C" {
    #[link_name = "\u{1}_g_type_default_interface_peek"]
    pub fn g_type_default_interface_peek(g_type: GType) -> gpointer;
}
extern "C" {
    #[link_name = "\u{1}_g_type_default_interface_unref"]
    pub fn g_type_default_interface_unref(g_iface: gpointer);
}
extern "C" {
    #[link_name = "\u{1}_g_type_children"]
    pub fn g_type_children(type_: GType, n_children: *mut guint) -> *mut GType;
}
extern "C" {
    #[link_name = "\u{1}_g_type_interfaces"]
    pub fn g_type_interfaces(type_: GType, n_interfaces: *mut guint) -> *mut GType;
}
extern "C" {
    #[link_name = "\u{1}_g_type_set_qdata"]
    pub fn g_type_set_qdata(type_: GType, quark: GQuark, data: gpointer);
}
extern "C" {
    #[link_name = "\u{1}_g_type_get_qdata"]
    pub fn g_type_get_qdata(type_: GType, quark: GQuark) -> gpointer;
}
extern "C" {
    #[link_name = "\u{1}_g_type_query"]
    pub fn g_type_query(type_: GType, query: *mut GTypeQuery);
}
extern "C" {
    #[link_name = "\u{1}_g_type_get_instance_count"]
    pub fn g_type_get_instance_count(type_: GType) -> ::std::os::raw::c_int;
}
/// GBaseInitFunc:
/// @g_class: (type GObject.TypeClass): The #GTypeClass structure to initialize
///
/// A callback function used by the type system to do base initialization
/// of the class structures of derived types. It is called as part of the
/// initialization process of all derived classes and should reallocate
/// or reset all dynamic class members copied over from the parent class.
/// For example, class members (such as strings) that are not sufficiently
/// handled by a plain memory copy of the parent class into the derived class
/// have to be altered. See GClassInitFunc() for a discussion of the class
/// initialization process.
pub type GBaseInitFunc = ::std::option::Option<unsafe extern "C" fn(g_class: gpointer)>;
/// GBaseFinalizeFunc:
/// @g_class: (type GObject.TypeClass): The #GTypeClass structure to finalize
///
/// A callback function used by the type system to finalize those portions
/// of a derived types class structure that were setup from the corresponding
/// GBaseInitFunc() function. Class finalization basically works the inverse
/// way in which class initialization is performed.
/// See GClassInitFunc() for a discussion of the class initialization process.
pub type GBaseFinalizeFunc = ::std::option::Option<unsafe extern "C" fn(g_class: gpointer)>;
/// GClassInitFunc:
/// @g_class: (type GObject.TypeClass): The #GTypeClass structure to initialize.
/// @class_data: The @class_data member supplied via the #GTypeInfo structure.
///
/// A callback function used by the type system to initialize the class
/// of a specific type. This function should initialize all static class
/// members.
///
/// The initialization process of a class involves:
///
/// - Copying common members from the parent class over to the
/// derived class structure.
/// - Zero initialization of the remaining members not copied
/// over from the parent class.
/// - Invocation of the GBaseInitFunc() initializers of all parent
/// types and the class' type.
/// - Invocation of the class' GClassInitFunc() initializer.
///
/// Since derived classes are partially initialized through a memory copy
/// of the parent class, the general rule is that GBaseInitFunc() and
/// GBaseFinalizeFunc() should take care of necessary reinitialization
/// and release of those class members that were introduced by the type
/// that specified these GBaseInitFunc()/GBaseFinalizeFunc().
/// GClassInitFunc() should only care about initializing static
/// class members, while dynamic class members (such as allocated strings
/// or reference counted resources) are better handled by a GBaseInitFunc()
/// for this type, so proper initialization of the dynamic class members
/// is performed for class initialization of derived types as well.
///
/// An example may help to correspond the intend of the different class
/// initializers:
///
/// |[<!-- language="C" -->
/// typedef struct {
/// GObjectClass parent_class;
/// gint         static_integer;
/// gchar       *dynamic_string;
/// } TypeAClass;
/// static void
/// type_a_base_class_init (TypeAClass *class)
/// {
/// class->dynamic_string = g_strdup ("some string");
/// }
/// static void
/// type_a_base_class_finalize (TypeAClass *class)
/// {
/// g_free (class->dynamic_string);
/// }
/// static void
/// type_a_class_init (TypeAClass *class)
/// {
/// class->static_integer = 42;
/// }
///
/// typedef struct {
/// TypeAClass   parent_class;
/// gfloat       static_float;
/// GString     *dynamic_gstring;
/// } TypeBClass;
/// static void
/// type_b_base_class_init (TypeBClass *class)
/// {
/// class->dynamic_gstring = g_string_new ("some other string");
/// }
/// static void
/// type_b_base_class_finalize (TypeBClass *class)
/// {
/// g_string_free (class->dynamic_gstring);
/// }
/// static void
/// type_b_class_init (TypeBClass *class)
/// {
/// class->static_float = 3.14159265358979323846;
/// }
/// ]|
/// Initialization of TypeBClass will first cause initialization of
/// TypeAClass (derived classes reference their parent classes, see
/// g_type_class_ref() on this).
///
/// Initialization of TypeAClass roughly involves zero-initializing its fields,
/// then calling its GBaseInitFunc() type_a_base_class_init() to allocate
/// its dynamic members (dynamic_string), and finally calling its GClassInitFunc()
/// type_a_class_init() to initialize its static members (static_integer).
/// The first step in the initialization process of TypeBClass is then
/// a plain memory copy of the contents of TypeAClass into TypeBClass and
/// zero-initialization of the remaining fields in TypeBClass.
/// The dynamic members of TypeAClass within TypeBClass now need
/// reinitialization which is performed by calling type_a_base_class_init()
/// with an argument of TypeBClass.
///
/// After that, the GBaseInitFunc() of TypeBClass, type_b_base_class_init()
/// is called to allocate the dynamic members of TypeBClass (dynamic_gstring),
/// and finally the GClassInitFunc() of TypeBClass, type_b_class_init(),
/// is called to complete the initialization process with the static members
/// (static_float).
///
/// Corresponding finalization counter parts to the GBaseInitFunc() functions
/// have to be provided to release allocated resources at class finalization
/// time.
pub type GClassInitFunc =
    ::std::option::Option<unsafe extern "C" fn(g_class: gpointer, class_data: gpointer)>;
/// GClassFinalizeFunc:
/// @g_class: (type GObject.TypeClass): The #GTypeClass structure to finalize
/// @class_data: The @class_data member supplied via the #GTypeInfo structure
///
/// A callback function used by the type system to finalize a class.
/// This function is rarely needed, as dynamically allocated class resources
/// should be handled by GBaseInitFunc() and GBaseFinalizeFunc().
/// Also, specification of a GClassFinalizeFunc() in the #GTypeInfo
/// structure of a static type is invalid, because classes of static types
/// will never be finalized (they are artificially kept alive when their
/// reference count drops to zero).
pub type GClassFinalizeFunc =
    ::std::option::Option<unsafe extern "C" fn(g_class: gpointer, class_data: gpointer)>;
/// GInstanceInitFunc:
/// @instance: The instance to initialize
/// @g_class: (type GObject.TypeClass): The class of the type the instance is
/// created for
///
/// A callback function used by the type system to initialize a new
/// instance of a type. This function initializes all instance members and
/// allocates any resources required by it.
///
/// Initialization of a derived instance involves calling all its parent
/// types instance initializers, so the class member of the instance
/// is altered during its initialization to always point to the class that
/// belongs to the type the current initializer was introduced for.
///
/// The extended members of @instance are guaranteed to have been filled with
/// zeros before this function is called.
pub type GInstanceInitFunc =
    ::std::option::Option<unsafe extern "C" fn(instance: *mut GTypeInstance, g_class: gpointer)>;
/// GInterfaceInitFunc:
/// @g_iface: (type GObject.TypeInterface): The interface structure to initialize
/// @iface_data: The @interface_data supplied via the #GInterfaceInfo structure
///
/// A callback function used by the type system to initialize a new
/// interface.  This function should initialize all internal data and
/// allocate any resources required by the interface.
///
/// The members of @iface_data are guaranteed to have been filled with
/// zeros before this function is called.
pub type GInterfaceInitFunc =
    ::std::option::Option<unsafe extern "C" fn(g_iface: gpointer, iface_data: gpointer)>;
/// GInterfaceFinalizeFunc:
/// @g_iface: (type GObject.TypeInterface): The interface structure to finalize
/// @iface_data: The @interface_data supplied via the #GInterfaceInfo structure
///
/// A callback function used by the type system to finalize an interface.
/// This function should destroy any internal data and release any resources
/// allocated by the corresponding GInterfaceInitFunc() function.
pub type GInterfaceFinalizeFunc =
    ::std::option::Option<unsafe extern "C" fn(g_iface: gpointer, iface_data: gpointer)>;
/// GTypeClassCacheFunc:
/// @cache_data: data that was given to the g_type_add_class_cache_func() call
/// @g_class: (type GObject.TypeClass): The #GTypeClass structure which is
/// unreferenced
///
/// A callback function which is called when the reference count of a class
/// drops to zero. It may use g_type_class_ref() to prevent the class from
/// being freed. You should not call g_type_class_unref() from a
/// #GTypeClassCacheFunc function to prevent infinite recursion, use
/// g_type_class_unref_uncached() instead.
///
/// The functions have to check the class id passed in to figure
/// whether they actually want to cache the class of this type, since all
/// classes are routed through the same #GTypeClassCacheFunc chain.
///
/// Returns: %TRUE to stop further #GTypeClassCacheFuncs from being
/// called, %FALSE to continue
pub type GTypeClassCacheFunc = ::std::option::Option<
    unsafe extern "C" fn(cache_data: gpointer, g_class: *mut GTypeClass) -> gboolean,
>;
/// GTypeInterfaceCheckFunc:
/// @check_data: data passed to g_type_add_interface_check()
/// @g_iface: (type GObject.TypeInterface): the interface that has been
/// initialized
///
/// A callback called after an interface vtable is initialized.
/// See g_type_add_interface_check().
///
/// Since: 2.4
pub type GTypeInterfaceCheckFunc =
    ::std::option::Option<unsafe extern "C" fn(check_data: gpointer, g_iface: gpointer)>;
pub const GTypeFundamentalFlags_G_TYPE_FLAG_CLASSED: GTypeFundamentalFlags = 1;
pub const GTypeFundamentalFlags_G_TYPE_FLAG_INSTANTIATABLE: GTypeFundamentalFlags = 2;
pub const GTypeFundamentalFlags_G_TYPE_FLAG_DERIVABLE: GTypeFundamentalFlags = 4;
pub const GTypeFundamentalFlags_G_TYPE_FLAG_DEEP_DERIVABLE: GTypeFundamentalFlags = 8;
/// GTypeFundamentalFlags:
/// @G_TYPE_FLAG_CLASSED: Indicates a classed type
/// @G_TYPE_FLAG_INSTANTIATABLE: Indicates an instantiable type (implies classed)
/// @G_TYPE_FLAG_DERIVABLE: Indicates a flat derivable type
/// @G_TYPE_FLAG_DEEP_DERIVABLE: Indicates a deep derivable type (implies derivable)
///
/// Bit masks used to check or determine specific characteristics of a
/// fundamental type.
pub type GTypeFundamentalFlags = u32;
pub const GTypeFlags_G_TYPE_FLAG_ABSTRACT: GTypeFlags = 16;
pub const GTypeFlags_G_TYPE_FLAG_VALUE_ABSTRACT: GTypeFlags = 32;
/// GTypeFlags:
/// @G_TYPE_FLAG_ABSTRACT: Indicates an abstract type. No instances can be
/// created for an abstract type
/// @G_TYPE_FLAG_VALUE_ABSTRACT: Indicates an abstract value type, i.e. a type
/// that introduces a value table, but can't be used for
/// g_value_init()
///
/// Bit masks used to check or determine characteristics of a type.
pub type GTypeFlags = u32;
/// GTypeInfo:
/// @class_size: Size of the class structure (required for interface, classed and instantiatable types)
/// @base_init: Location of the base initialization function (optional)
/// @base_finalize: Location of the base finalization function (optional)
/// @class_init: Location of the class initialization function for
/// classed and instantiatable types. Location of the default vtable
/// inititalization function for interface types. (optional) This function
/// is used both to fill in virtual functions in the class or default vtable,
/// and to do type-specific setup such as registering signals and object
/// properties.
/// @class_finalize: Location of the class finalization function for
/// classed and instantiatable types. Location of the default vtable
/// finalization function for interface types. (optional)
/// @class_data: User-supplied data passed to the class init/finalize functions
/// @instance_size: Size of the instance (object) structure (required for instantiatable types only)
/// @n_preallocs: Prior to GLib 2.10, it specified the number of pre-allocated (cached) instances to reserve memory for (0 indicates no caching). Since GLib 2.10, it is ignored, since instances are allocated with the [slice allocator][glib-Memory-Slices] now.
/// @instance_init: Location of the instance initialization function (optional, for instantiatable types only)
/// @value_table: A #GTypeValueTable function table for generic handling of GValues
/// of this type (usually only useful for fundamental types)
///
/// This structure is used to provide the type system with the information
/// required to initialize and destruct (finalize) a type's class and
/// its instances.
///
/// The initialized structure is passed to the g_type_register_static() function
/// (or is copied into the provided #GTypeInfo structure in the
/// g_type_plugin_complete_type_info()). The type system will perform a deep
/// copy of this structure, so its memory does not need to be persistent
/// across invocation of g_type_register_static().
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GTypeInfo {
    pub class_size: guint16,
    pub base_init: GBaseInitFunc,
    pub base_finalize: GBaseFinalizeFunc,
    pub class_init: GClassInitFunc,
    pub class_finalize: GClassFinalizeFunc,
    pub class_data: gconstpointer,
    pub instance_size: guint16,
    pub n_preallocs: guint16,
    pub instance_init: GInstanceInitFunc,
    pub value_table: *const GTypeValueTable,
}
#[test]
fn bindgen_test_layout__GTypeInfo() {
    assert_eq!(
        ::std::mem::size_of::<_GTypeInfo>(),
        72usize,
        concat!("Size of: ", stringify!(_GTypeInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<_GTypeInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(_GTypeInfo))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GTypeInfo>())).class_size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTypeInfo),
            "::",
            stringify!(class_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GTypeInfo>())).base_init as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTypeInfo),
            "::",
            stringify!(base_init)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GTypeInfo>())).base_finalize as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTypeInfo),
            "::",
            stringify!(base_finalize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GTypeInfo>())).class_init as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTypeInfo),
            "::",
            stringify!(class_init)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GTypeInfo>())).class_finalize as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTypeInfo),
            "::",
            stringify!(class_finalize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GTypeInfo>())).class_data as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTypeInfo),
            "::",
            stringify!(class_data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GTypeInfo>())).instance_size as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTypeInfo),
            "::",
            stringify!(instance_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GTypeInfo>())).n_preallocs as *const _ as usize },
        50usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTypeInfo),
            "::",
            stringify!(n_preallocs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GTypeInfo>())).instance_init as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTypeInfo),
            "::",
            stringify!(instance_init)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GTypeInfo>())).value_table as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTypeInfo),
            "::",
            stringify!(value_table)
        )
    );
}
/// GTypeFundamentalInfo:
/// @type_flags: #GTypeFundamentalFlags describing the characteristics of the fundamental type
///
/// A structure that provides information to the type system which is
/// used specifically for managing fundamental types.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GTypeFundamentalInfo {
    pub type_flags: GTypeFundamentalFlags,
}
#[test]
fn bindgen_test_layout__GTypeFundamentalInfo() {
    assert_eq!(
        ::std::mem::size_of::<_GTypeFundamentalInfo>(),
        4usize,
        concat!("Size of: ", stringify!(_GTypeFundamentalInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<_GTypeFundamentalInfo>(),
        4usize,
        concat!("Alignment of ", stringify!(_GTypeFundamentalInfo))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GTypeFundamentalInfo>())).type_flags as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTypeFundamentalInfo),
            "::",
            stringify!(type_flags)
        )
    );
}
/// GInterfaceInfo:
/// @interface_init: location of the interface initialization function
/// @interface_finalize: location of the interface finalization function
/// @interface_data: user-supplied data passed to the interface init/finalize functions
///
/// A structure that provides information to the type system which is
/// used specifically for managing interface types.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GInterfaceInfo {
    pub interface_init: GInterfaceInitFunc,
    pub interface_finalize: GInterfaceFinalizeFunc,
    pub interface_data: gpointer,
}
#[test]
fn bindgen_test_layout__GInterfaceInfo() {
    assert_eq!(
        ::std::mem::size_of::<_GInterfaceInfo>(),
        24usize,
        concat!("Size of: ", stringify!(_GInterfaceInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<_GInterfaceInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(_GInterfaceInfo))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GInterfaceInfo>())).interface_init as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GInterfaceInfo),
            "::",
            stringify!(interface_init)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GInterfaceInfo>())).interface_finalize as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GInterfaceInfo),
            "::",
            stringify!(interface_finalize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GInterfaceInfo>())).interface_data as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GInterfaceInfo),
            "::",
            stringify!(interface_data)
        )
    );
}
/// GTypeValueTable:
/// @value_init: Default initialize @values contents by poking values
/// directly into the value->data array. The data array of
/// the #GValue passed into this function was zero-filled
/// with `memset()`, so no care has to be taken to free any
/// old contents. E.g. for the implementation of a string
/// value that may never be %NULL, the implementation might
/// look like:
/// |[<!-- language="C" -->
/// value->data[0].v_pointer = g_strdup ("");
/// ]|
/// @value_free: Free any old contents that might be left in the
/// data array of the passed in @value. No resources may
/// remain allocated through the #GValue contents after
/// this function returns. E.g. for our above string type:
/// |[<!-- language="C" -->
/// // only free strings without a specific flag for static storage
/// if (!(value->data[1].v_uint & G_VALUE_NOCOPY_CONTENTS))
/// g_free (value->data[0].v_pointer);
/// ]|
/// @value_copy: @dest_value is a #GValue with zero-filled data section
/// and @src_value is a properly setup #GValue of same or
/// derived type.
/// The purpose of this function is to copy the contents of
/// @src_value into @dest_value in a way, that even after
/// @src_value has been freed, the contents of @dest_value
/// remain valid. String type example:
/// |[<!-- language="C" -->
/// dest_value->data[0].v_pointer = g_strdup (src_value->data[0].v_pointer);
/// ]|
/// @value_peek_pointer: If the value contents fit into a pointer, such as objects
/// or strings, return this pointer, so the caller can peek at
/// the current contents. To extend on our above string example:
/// |[<!-- language="C" -->
/// return value->data[0].v_pointer;
/// ]|
/// @collect_format: A string format describing how to collect the contents of
/// this value bit-by-bit. Each character in the format represents
/// an argument to be collected, and the characters themselves indicate
/// the type of the argument. Currently supported arguments are:
/// - 'i' - Integers. passed as collect_values[].v_int.
/// - 'l' - Longs. passed as collect_values[].v_long.
/// - 'd' - Doubles. passed as collect_values[].v_double.
/// - 'p' - Pointers. passed as collect_values[].v_pointer.
/// It should be noted that for variable argument list construction,
/// ANSI C promotes every type smaller than an integer to an int, and
/// floats to doubles. So for collection of short int or char, 'i'
/// needs to be used, and for collection of floats 'd'.
/// @collect_value: The collect_value() function is responsible for converting the
/// values collected from a variable argument list into contents
/// suitable for storage in a GValue. This function should setup
/// @value similar to value_init(); e.g. for a string value that
/// does not allow %NULL pointers, it needs to either spew an error,
/// or do an implicit conversion by storing an empty string.
/// The @value passed in to this function has a zero-filled data
/// array, so just like for value_init() it is guaranteed to not
/// contain any old contents that might need freeing.
/// @n_collect_values is exactly the string length of @collect_format,
/// and @collect_values is an array of unions #GTypeCValue with
/// length @n_collect_values, containing the collected values
/// according to @collect_format.
/// @collect_flags is an argument provided as a hint by the caller.
/// It may contain the flag %G_VALUE_NOCOPY_CONTENTS indicating,
/// that the collected value contents may be considered "static"
/// for the duration of the @value lifetime.
/// Thus an extra copy of the contents stored in @collect_values is
/// not required for assignment to @value.
/// For our above string example, we continue with:
/// |[<!-- language="C" -->
/// if (!collect_values[0].v_pointer)
/// value->data[0].v_pointer = g_strdup ("");
/// else if (collect_flags & G_VALUE_NOCOPY_CONTENTS)
/// {
/// value->data[0].v_pointer = collect_values[0].v_pointer;
/// // keep a flag for the value_free() implementation to not free this string
/// value->data[1].v_uint = G_VALUE_NOCOPY_CONTENTS;
/// }
/// else
/// value->data[0].v_pointer = g_strdup (collect_values[0].v_pointer);
/// return NULL;
/// ]|
/// It should be noted, that it is generally a bad idea to follow the
/// #G_VALUE_NOCOPY_CONTENTS hint for reference counted types. Due to
/// reentrancy requirements and reference count assertions performed
/// by the signal emission code, reference counts should always be
/// incremented for reference counted contents stored in the value->data
/// array.  To deviate from our string example for a moment, and taking
/// a look at an exemplary implementation for collect_value() of
/// #GObject:
/// |[<!-- language="C" -->
/// if (collect_values[0].v_pointer)
/// {
/// GObject *object = G_OBJECT (collect_values[0].v_pointer);
/// // never honour G_VALUE_NOCOPY_CONTENTS for ref-counted types
/// value->data[0].v_pointer = g_object_ref (object);
/// return NULL;
/// }
/// else
/// return g_strdup_printf ("Object passed as invalid NULL pointer");
/// }
/// ]|
/// The reference count for valid objects is always incremented,
/// regardless of @collect_flags. For invalid objects, the example
/// returns a newly allocated string without altering @value.
/// Upon success, collect_value() needs to return %NULL. If, however,
/// an error condition occurred, collect_value() may spew an
/// error by returning a newly allocated non-%NULL string, giving
/// a suitable description of the error condition.
/// The calling code makes no assumptions about the @value
/// contents being valid upon error returns, @value
/// is simply thrown away without further freeing. As such, it is
/// a good idea to not allocate #GValue contents, prior to returning
/// an error, however, collect_values() is not obliged to return
/// a correctly setup @value for error returns, simply because
/// any non-%NULL return is considered a fatal condition so further
/// program behaviour is undefined.
/// @lcopy_format: Format description of the arguments to collect for @lcopy_value,
/// analogous to @collect_format. Usually, @lcopy_format string consists
/// only of 'p's to provide lcopy_value() with pointers to storage locations.
/// @lcopy_value: This function is responsible for storing the @value contents into
/// arguments passed through a variable argument list which got
/// collected into @collect_values according to @lcopy_format.
/// @n_collect_values equals the string length of @lcopy_format,
/// and @collect_flags may contain %G_VALUE_NOCOPY_CONTENTS.
/// In contrast to collect_value(), lcopy_value() is obliged to
/// always properly support %G_VALUE_NOCOPY_CONTENTS.
/// Similar to collect_value() the function may prematurely abort
/// by returning a newly allocated string describing an error condition.
/// To complete the string example:
/// |[<!-- language="C" -->
/// gchar **string_p = collect_values[0].v_pointer;
/// if (!string_p)
/// return g_strdup_printf ("string location passed as NULL");
/// if (collect_flags & G_VALUE_NOCOPY_CONTENTS)
/// *string_p = value->data[0].v_pointer;
/// else
/// *string_p = g_strdup (value->data[0].v_pointer);
/// ]|
/// And an illustrative version of lcopy_value() for
/// reference-counted types:
/// |[<!-- language="C" -->
/// GObject **object_p = collect_values[0].v_pointer;
/// if (!object_p)
/// return g_strdup_printf ("object location passed as NULL");
/// if (!value->data[0].v_pointer)
/// *object_p = NULL;
/// else if (collect_flags & G_VALUE_NOCOPY_CONTENTS) // always honour
/// *object_p = value->data[0].v_pointer;
/// else
/// *object_p = g_object_ref (value->data[0].v_pointer);
/// return NULL;
/// ]|
///
/// The #GTypeValueTable provides the functions required by the #GValue
/// implementation, to serve as a container for values of a type.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GTypeValueTable {
    pub value_init: ::std::option::Option<unsafe extern "C" fn(value: *mut GValue)>,
    pub value_free: ::std::option::Option<unsafe extern "C" fn(value: *mut GValue)>,
    pub value_copy: ::std::option::Option<
        unsafe extern "C" fn(src_value: *const GValue, dest_value: *mut GValue),
    >,
    pub value_peek_pointer:
        ::std::option::Option<unsafe extern "C" fn(value: *const GValue) -> gpointer>,
    pub collect_format: *const gchar,
    pub collect_value: ::std::option::Option<
        unsafe extern "C" fn(
            value: *mut GValue,
            n_collect_values: guint,
            collect_values: *mut GTypeCValue,
            collect_flags: guint,
        ) -> *mut gchar,
    >,
    pub lcopy_format: *const gchar,
    pub lcopy_value: ::std::option::Option<
        unsafe extern "C" fn(
            value: *const GValue,
            n_collect_values: guint,
            collect_values: *mut GTypeCValue,
            collect_flags: guint,
        ) -> *mut gchar,
    >,
}
#[test]
fn bindgen_test_layout__GTypeValueTable() {
    assert_eq!(
        ::std::mem::size_of::<_GTypeValueTable>(),
        64usize,
        concat!("Size of: ", stringify!(_GTypeValueTable))
    );
    assert_eq!(
        ::std::mem::align_of::<_GTypeValueTable>(),
        8usize,
        concat!("Alignment of ", stringify!(_GTypeValueTable))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GTypeValueTable>())).value_init as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTypeValueTable),
            "::",
            stringify!(value_init)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GTypeValueTable>())).value_free as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTypeValueTable),
            "::",
            stringify!(value_free)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GTypeValueTable>())).value_copy as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTypeValueTable),
            "::",
            stringify!(value_copy)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GTypeValueTable>())).value_peek_pointer as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTypeValueTable),
            "::",
            stringify!(value_peek_pointer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GTypeValueTable>())).collect_format as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTypeValueTable),
            "::",
            stringify!(collect_format)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GTypeValueTable>())).collect_value as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTypeValueTable),
            "::",
            stringify!(collect_value)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GTypeValueTable>())).lcopy_format as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTypeValueTable),
            "::",
            stringify!(lcopy_format)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GTypeValueTable>())).lcopy_value as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTypeValueTable),
            "::",
            stringify!(lcopy_value)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_g_type_register_static"]
    pub fn g_type_register_static(
        parent_type: GType,
        type_name: *const gchar,
        info: *const GTypeInfo,
        flags: GTypeFlags,
    ) -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_type_register_static_simple"]
    pub fn g_type_register_static_simple(
        parent_type: GType,
        type_name: *const gchar,
        class_size: guint,
        class_init: GClassInitFunc,
        instance_size: guint,
        instance_init: GInstanceInitFunc,
        flags: GTypeFlags,
    ) -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_type_register_dynamic"]
    pub fn g_type_register_dynamic(
        parent_type: GType,
        type_name: *const gchar,
        plugin: *mut GTypePlugin,
        flags: GTypeFlags,
    ) -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_type_register_fundamental"]
    pub fn g_type_register_fundamental(
        type_id: GType,
        type_name: *const gchar,
        info: *const GTypeInfo,
        finfo: *const GTypeFundamentalInfo,
        flags: GTypeFlags,
    ) -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_type_add_interface_static"]
    pub fn g_type_add_interface_static(
        instance_type: GType,
        interface_type: GType,
        info: *const GInterfaceInfo,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_type_add_interface_dynamic"]
    pub fn g_type_add_interface_dynamic(
        instance_type: GType,
        interface_type: GType,
        plugin: *mut GTypePlugin,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_type_interface_add_prerequisite"]
    pub fn g_type_interface_add_prerequisite(interface_type: GType, prerequisite_type: GType);
}
extern "C" {
    #[link_name = "\u{1}_g_type_interface_prerequisites"]
    pub fn g_type_interface_prerequisites(
        interface_type: GType,
        n_prerequisites: *mut guint,
    ) -> *mut GType;
}
extern "C" {
    #[link_name = "\u{1}_g_type_class_add_private"]
    pub fn g_type_class_add_private(g_class: gpointer, private_size: gsize);
}
extern "C" {
    #[link_name = "\u{1}_g_type_add_instance_private"]
    pub fn g_type_add_instance_private(class_type: GType, private_size: gsize) -> gint;
}
extern "C" {
    #[link_name = "\u{1}_g_type_instance_get_private"]
    pub fn g_type_instance_get_private(
        instance: *mut GTypeInstance,
        private_type: GType,
    ) -> gpointer;
}
extern "C" {
    #[link_name = "\u{1}_g_type_class_adjust_private_offset"]
    pub fn g_type_class_adjust_private_offset(g_class: gpointer, private_size_or_offset: *mut gint);
}
extern "C" {
    #[link_name = "\u{1}_g_type_add_class_private"]
    pub fn g_type_add_class_private(class_type: GType, private_size: gsize);
}
extern "C" {
    #[link_name = "\u{1}_g_type_class_get_private"]
    pub fn g_type_class_get_private(klass: *mut GTypeClass, private_type: GType) -> gpointer;
}
extern "C" {
    #[link_name = "\u{1}_g_type_class_get_instance_private_offset"]
    pub fn g_type_class_get_instance_private_offset(g_class: gpointer) -> gint;
}
extern "C" {
    #[link_name = "\u{1}_g_type_ensure"]
    pub fn g_type_ensure(type_: GType);
}
extern "C" {
    #[link_name = "\u{1}_g_type_get_type_registration_serial"]
    pub fn g_type_get_type_registration_serial() -> guint;
}
extern "C" {
    #[link_name = "\u{1}_g_type_get_plugin"]
    pub fn g_type_get_plugin(type_: GType) -> *mut GTypePlugin;
}
extern "C" {
    #[link_name = "\u{1}_g_type_interface_get_plugin"]
    pub fn g_type_interface_get_plugin(
        instance_type: GType,
        interface_type: GType,
    ) -> *mut GTypePlugin;
}
extern "C" {
    #[link_name = "\u{1}_g_type_fundamental_next"]
    pub fn g_type_fundamental_next() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_type_fundamental"]
    pub fn g_type_fundamental(type_id: GType) -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_type_create_instance"]
    pub fn g_type_create_instance(type_: GType) -> *mut GTypeInstance;
}
extern "C" {
    #[link_name = "\u{1}_g_type_free_instance"]
    pub fn g_type_free_instance(instance: *mut GTypeInstance);
}
extern "C" {
    #[link_name = "\u{1}_g_type_add_class_cache_func"]
    pub fn g_type_add_class_cache_func(cache_data: gpointer, cache_func: GTypeClassCacheFunc);
}
extern "C" {
    #[link_name = "\u{1}_g_type_remove_class_cache_func"]
    pub fn g_type_remove_class_cache_func(cache_data: gpointer, cache_func: GTypeClassCacheFunc);
}
extern "C" {
    #[link_name = "\u{1}_g_type_class_unref_uncached"]
    pub fn g_type_class_unref_uncached(g_class: gpointer);
}
extern "C" {
    #[link_name = "\u{1}_g_type_add_interface_check"]
    pub fn g_type_add_interface_check(check_data: gpointer, check_func: GTypeInterfaceCheckFunc);
}
extern "C" {
    #[link_name = "\u{1}_g_type_remove_interface_check"]
    pub fn g_type_remove_interface_check(check_data: gpointer, check_func: GTypeInterfaceCheckFunc);
}
extern "C" {
    #[link_name = "\u{1}_g_type_value_table_peek"]
    pub fn g_type_value_table_peek(type_: GType) -> *mut GTypeValueTable;
}
extern "C" {
    #[link_name = "\u{1}_g_type_check_instance"]
    pub fn g_type_check_instance(instance: *mut GTypeInstance) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_type_check_instance_cast"]
    pub fn g_type_check_instance_cast(
        instance: *mut GTypeInstance,
        iface_type: GType,
    ) -> *mut GTypeInstance;
}
extern "C" {
    #[link_name = "\u{1}_g_type_check_instance_is_a"]
    pub fn g_type_check_instance_is_a(instance: *mut GTypeInstance, iface_type: GType) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_type_check_instance_is_fundamentally_a"]
    pub fn g_type_check_instance_is_fundamentally_a(
        instance: *mut GTypeInstance,
        fundamental_type: GType,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_type_check_class_cast"]
    pub fn g_type_check_class_cast(g_class: *mut GTypeClass, is_a_type: GType) -> *mut GTypeClass;
}
extern "C" {
    #[link_name = "\u{1}_g_type_check_class_is_a"]
    pub fn g_type_check_class_is_a(g_class: *mut GTypeClass, is_a_type: GType) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_type_check_is_value_type"]
    pub fn g_type_check_is_value_type(type_: GType) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_type_check_value"]
    pub fn g_type_check_value(value: *mut GValue) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_type_check_value_holds"]
    pub fn g_type_check_value_holds(value: *mut GValue, type_: GType) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_type_test_flags"]
    pub fn g_type_test_flags(type_: GType, flags: guint) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_type_name_from_instance"]
    pub fn g_type_name_from_instance(instance: *mut GTypeInstance) -> *const gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_type_name_from_class"]
    pub fn g_type_name_from_class(g_class: *mut GTypeClass) -> *const gchar;
}
/// GValueTransform:
/// @src_value: Source value.
/// @dest_value: Target value.
///
/// The type of value transformation functions which can be registered with
/// g_value_register_transform_func().
pub type GValueTransform =
    ::std::option::Option<unsafe extern "C" fn(src_value: *const GValue, dest_value: *mut GValue)>;
/// GValue:
///
/// An opaque structure used to hold different types of values.
/// The data within the structure has protected scope: it is accessible only
/// to functions within a #GTypeValueTable structure, or implementations of
/// the g_value_*() API. That is, code portions which implement new fundamental
/// types.
/// #GValue users cannot make any assumptions about how data is stored
/// within the 2 element @data union, and the @g_type member should
/// only be accessed through the G_VALUE_TYPE() macro.
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _GValue {
    pub g_type: GType,
    pub data: [_GValue__bindgen_ty_1; 2usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _GValue__bindgen_ty_1 {
    pub v_int: gint,
    pub v_uint: guint,
    pub v_long: glong,
    pub v_ulong: gulong,
    pub v_int64: gint64,
    pub v_uint64: guint64,
    pub v_float: gfloat,
    pub v_double: gdouble,
    pub v_pointer: gpointer,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout__GValue__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<_GValue__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(_GValue__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<_GValue__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(_GValue__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GValue__bindgen_ty_1>())).v_int as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GValue__bindgen_ty_1),
            "::",
            stringify!(v_int)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GValue__bindgen_ty_1>())).v_uint as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GValue__bindgen_ty_1),
            "::",
            stringify!(v_uint)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GValue__bindgen_ty_1>())).v_long as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GValue__bindgen_ty_1),
            "::",
            stringify!(v_long)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GValue__bindgen_ty_1>())).v_ulong as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GValue__bindgen_ty_1),
            "::",
            stringify!(v_ulong)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GValue__bindgen_ty_1>())).v_int64 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GValue__bindgen_ty_1),
            "::",
            stringify!(v_int64)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GValue__bindgen_ty_1>())).v_uint64 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GValue__bindgen_ty_1),
            "::",
            stringify!(v_uint64)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GValue__bindgen_ty_1>())).v_float as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GValue__bindgen_ty_1),
            "::",
            stringify!(v_float)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GValue__bindgen_ty_1>())).v_double as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GValue__bindgen_ty_1),
            "::",
            stringify!(v_double)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GValue__bindgen_ty_1>())).v_pointer as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GValue__bindgen_ty_1),
            "::",
            stringify!(v_pointer)
        )
    );
}
#[test]
fn bindgen_test_layout__GValue() {
    assert_eq!(
        ::std::mem::size_of::<_GValue>(),
        24usize,
        concat!("Size of: ", stringify!(_GValue))
    );
    assert_eq!(
        ::std::mem::align_of::<_GValue>(),
        8usize,
        concat!("Alignment of ", stringify!(_GValue))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GValue>())).g_type as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GValue),
            "::",
            stringify!(g_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GValue>())).data as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GValue),
            "::",
            stringify!(data)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_g_value_init"]
    pub fn g_value_init(value: *mut GValue, g_type: GType) -> *mut GValue;
}
extern "C" {
    #[link_name = "\u{1}_g_value_copy"]
    pub fn g_value_copy(src_value: *const GValue, dest_value: *mut GValue);
}
extern "C" {
    #[link_name = "\u{1}_g_value_reset"]
    pub fn g_value_reset(value: *mut GValue) -> *mut GValue;
}
extern "C" {
    #[link_name = "\u{1}_g_value_unset"]
    pub fn g_value_unset(value: *mut GValue);
}
extern "C" {
    #[link_name = "\u{1}_g_value_set_instance"]
    pub fn g_value_set_instance(value: *mut GValue, instance: gpointer);
}
extern "C" {
    #[link_name = "\u{1}_g_value_init_from_instance"]
    pub fn g_value_init_from_instance(value: *mut GValue, instance: gpointer);
}
extern "C" {
    #[link_name = "\u{1}_g_value_fits_pointer"]
    pub fn g_value_fits_pointer(value: *const GValue) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_value_peek_pointer"]
    pub fn g_value_peek_pointer(value: *const GValue) -> gpointer;
}
extern "C" {
    #[link_name = "\u{1}_g_value_type_compatible"]
    pub fn g_value_type_compatible(src_type: GType, dest_type: GType) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_value_type_transformable"]
    pub fn g_value_type_transformable(src_type: GType, dest_type: GType) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_value_transform"]
    pub fn g_value_transform(src_value: *const GValue, dest_value: *mut GValue) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_value_register_transform_func"]
    pub fn g_value_register_transform_func(
        src_type: GType,
        dest_type: GType,
        transform_func: GValueTransform,
    );
}
pub const GParamFlags_G_PARAM_READABLE: GParamFlags = 1;
pub const GParamFlags_G_PARAM_WRITABLE: GParamFlags = 2;
pub const GParamFlags_G_PARAM_READWRITE: GParamFlags = 3;
pub const GParamFlags_G_PARAM_CONSTRUCT: GParamFlags = 4;
pub const GParamFlags_G_PARAM_CONSTRUCT_ONLY: GParamFlags = 8;
pub const GParamFlags_G_PARAM_LAX_VALIDATION: GParamFlags = 16;
pub const GParamFlags_G_PARAM_STATIC_NAME: GParamFlags = 32;
pub const GParamFlags_G_PARAM_PRIVATE: GParamFlags = 32;
pub const GParamFlags_G_PARAM_STATIC_NICK: GParamFlags = 64;
pub const GParamFlags_G_PARAM_STATIC_BLURB: GParamFlags = 128;
pub const GParamFlags_G_PARAM_EXPLICIT_NOTIFY: GParamFlags = 1073741824;
pub const GParamFlags_G_PARAM_DEPRECATED: GParamFlags = -2147483648;
/// GParamFlags:
/// @G_PARAM_READABLE: the parameter is readable
/// @G_PARAM_WRITABLE: the parameter is writable
/// @G_PARAM_READWRITE: alias for %G_PARAM_READABLE | %G_PARAM_WRITABLE
/// @G_PARAM_CONSTRUCT: the parameter will be set upon object construction
/// @G_PARAM_CONSTRUCT_ONLY: the parameter can only be set upon object construction
/// @G_PARAM_LAX_VALIDATION: upon parameter conversion (see g_param_value_convert())
/// strict validation is not required
/// @G_PARAM_STATIC_NAME: the string used as name when constructing the
/// parameter is guaranteed to remain valid and
/// unmodified for the lifetime of the parameter.
/// Since 2.8
/// @G_PARAM_STATIC_NICK: the string used as nick when constructing the
/// parameter is guaranteed to remain valid and
/// unmmodified for the lifetime of the parameter.
/// Since 2.8
/// @G_PARAM_STATIC_BLURB: the string used as blurb when constructing the
/// parameter is guaranteed to remain valid and
/// unmodified for the lifetime of the parameter.
/// Since 2.8
/// @G_PARAM_EXPLICIT_NOTIFY: calls to g_object_set_property() for this
/// property will not automatically result in a "notify" signal being
/// emitted: the implementation must call g_object_notify() themselves
/// in case the property actually changes.  Since: 2.42.
/// @G_PARAM_PRIVATE: internal
/// @G_PARAM_DEPRECATED: the parameter is deprecated and will be removed
/// in a future version. A warning will be generated if it is used
/// while running with G_ENABLE_DIAGNOSTIC=1.
/// Since 2.26
///
/// Through the #GParamFlags flag values, certain aspects of parameters
/// can be configured. See also #G_PARAM_STATIC_STRINGS.
pub type GParamFlags = i32;
pub type GParamSpec = _GParamSpec;
pub type GParamSpecClass = _GParamSpecClass;
pub type GParameter = _GParameter;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GParamSpecPool {
    _unused: [u8; 0],
}
pub type GParamSpecPool = _GParamSpecPool;
/// GParamSpec: (ref-func g_param_spec_ref_sink) (unref-func g_param_spec_uref) (set-value-func g_value_set_param) (get-value-func g_value_get_param)
/// @g_type_instance: private #GTypeInstance portion
/// @name: name of this parameter: always an interned string
/// @flags: #GParamFlags flags for this parameter
/// @value_type: the #GValue type for this parameter
/// @owner_type: #GType type that uses (introduces) this parameter
///
/// All other fields of the GParamSpec struct are private and
/// should not be used directly.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GParamSpec {
    pub g_type_instance: GTypeInstance,
    pub name: *const gchar,
    pub flags: GParamFlags,
    pub value_type: GType,
    pub owner_type: GType,
    pub _nick: *mut gchar,
    pub _blurb: *mut gchar,
    pub qdata: *mut GData,
    pub ref_count: guint,
    pub param_id: guint,
}
#[test]
fn bindgen_test_layout__GParamSpec() {
    assert_eq!(
        ::std::mem::size_of::<_GParamSpec>(),
        72usize,
        concat!("Size of: ", stringify!(_GParamSpec))
    );
    assert_eq!(
        ::std::mem::align_of::<_GParamSpec>(),
        8usize,
        concat!("Alignment of ", stringify!(_GParamSpec))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GParamSpec>())).g_type_instance as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpec),
            "::",
            stringify!(g_type_instance)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GParamSpec>())).name as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpec),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GParamSpec>())).flags as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpec),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GParamSpec>())).value_type as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpec),
            "::",
            stringify!(value_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GParamSpec>())).owner_type as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpec),
            "::",
            stringify!(owner_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GParamSpec>()))._nick as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpec),
            "::",
            stringify!(_nick)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GParamSpec>()))._blurb as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpec),
            "::",
            stringify!(_blurb)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GParamSpec>())).qdata as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpec),
            "::",
            stringify!(qdata)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GParamSpec>())).ref_count as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpec),
            "::",
            stringify!(ref_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GParamSpec>())).param_id as *const _ as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpec),
            "::",
            stringify!(param_id)
        )
    );
}
/// GParamSpecClass:
/// @g_type_class: the parent class
/// @value_type: the #GValue type for this parameter
/// @finalize: The instance finalization function (optional), should chain
/// up to the finalize method of the parent class.
/// @value_set_default: Resets a @value to the default value for this type
/// (recommended, the default is g_value_reset()), see
/// g_param_value_set_default().
/// @value_validate: Ensures that the contents of @value comply with the
/// specifications set out by this type (optional), see
/// g_param_value_validate().
/// @values_cmp: Compares @value1 with @value2 according to this type
/// (recommended, the default is memcmp()), see g_param_values_cmp().
///
/// The class structure for the GParamSpec type.
/// Normally, GParamSpec classes are filled by
/// g_param_type_register_static().
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GParamSpecClass {
    pub g_type_class: GTypeClass,
    pub value_type: GType,
    pub finalize: ::std::option::Option<unsafe extern "C" fn(pspec: *mut GParamSpec)>,
    pub value_set_default:
        ::std::option::Option<unsafe extern "C" fn(pspec: *mut GParamSpec, value: *mut GValue)>,
    pub value_validate: ::std::option::Option<
        unsafe extern "C" fn(pspec: *mut GParamSpec, value: *mut GValue) -> gboolean,
    >,
    pub values_cmp: ::std::option::Option<
        unsafe extern "C" fn(pspec: *mut GParamSpec, value1: *const GValue, value2: *const GValue)
            -> gint,
    >,
    pub dummy: [gpointer; 4usize],
}
#[test]
fn bindgen_test_layout__GParamSpecClass() {
    assert_eq!(
        ::std::mem::size_of::<_GParamSpecClass>(),
        80usize,
        concat!("Size of: ", stringify!(_GParamSpecClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_GParamSpecClass>(),
        8usize,
        concat!("Alignment of ", stringify!(_GParamSpecClass))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GParamSpecClass>())).g_type_class as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecClass),
            "::",
            stringify!(g_type_class)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GParamSpecClass>())).value_type as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecClass),
            "::",
            stringify!(value_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GParamSpecClass>())).finalize as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecClass),
            "::",
            stringify!(finalize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GParamSpecClass>())).value_set_default as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecClass),
            "::",
            stringify!(value_set_default)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GParamSpecClass>())).value_validate as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecClass),
            "::",
            stringify!(value_validate)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GParamSpecClass>())).values_cmp as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecClass),
            "::",
            stringify!(values_cmp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GParamSpecClass>())).dummy as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecClass),
            "::",
            stringify!(dummy)
        )
    );
}
/// GParameter:
/// @name: the parameter name
/// @value: the parameter value
///
/// The GParameter struct is an auxiliary structure used
/// to hand parameter name/value pairs to g_object_newv().
///
/// Deprecated: 2.54: This type is not introspectable.
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _GParameter {
    pub name: *const gchar,
    pub value: GValue,
}
#[test]
fn bindgen_test_layout__GParameter() {
    assert_eq!(
        ::std::mem::size_of::<_GParameter>(),
        32usize,
        concat!("Size of: ", stringify!(_GParameter))
    );
    assert_eq!(
        ::std::mem::align_of::<_GParameter>(),
        8usize,
        concat!("Alignment of ", stringify!(_GParameter))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GParameter>())).name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParameter),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GParameter>())).value as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParameter),
            "::",
            stringify!(value)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_g_param_spec_ref"]
    pub fn g_param_spec_ref(pspec: *mut GParamSpec) -> *mut GParamSpec;
}
extern "C" {
    #[link_name = "\u{1}_g_param_spec_unref"]
    pub fn g_param_spec_unref(pspec: *mut GParamSpec);
}
extern "C" {
    #[link_name = "\u{1}_g_param_spec_sink"]
    pub fn g_param_spec_sink(pspec: *mut GParamSpec);
}
extern "C" {
    #[link_name = "\u{1}_g_param_spec_ref_sink"]
    pub fn g_param_spec_ref_sink(pspec: *mut GParamSpec) -> *mut GParamSpec;
}
extern "C" {
    #[link_name = "\u{1}_g_param_spec_get_qdata"]
    pub fn g_param_spec_get_qdata(pspec: *mut GParamSpec, quark: GQuark) -> gpointer;
}
extern "C" {
    #[link_name = "\u{1}_g_param_spec_set_qdata"]
    pub fn g_param_spec_set_qdata(pspec: *mut GParamSpec, quark: GQuark, data: gpointer);
}
extern "C" {
    #[link_name = "\u{1}_g_param_spec_set_qdata_full"]
    pub fn g_param_spec_set_qdata_full(
        pspec: *mut GParamSpec,
        quark: GQuark,
        data: gpointer,
        destroy: GDestroyNotify,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_param_spec_steal_qdata"]
    pub fn g_param_spec_steal_qdata(pspec: *mut GParamSpec, quark: GQuark) -> gpointer;
}
extern "C" {
    #[link_name = "\u{1}_g_param_spec_get_redirect_target"]
    pub fn g_param_spec_get_redirect_target(pspec: *mut GParamSpec) -> *mut GParamSpec;
}
extern "C" {
    #[link_name = "\u{1}_g_param_value_set_default"]
    pub fn g_param_value_set_default(pspec: *mut GParamSpec, value: *mut GValue);
}
extern "C" {
    #[link_name = "\u{1}_g_param_value_defaults"]
    pub fn g_param_value_defaults(pspec: *mut GParamSpec, value: *mut GValue) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_param_value_validate"]
    pub fn g_param_value_validate(pspec: *mut GParamSpec, value: *mut GValue) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_param_value_convert"]
    pub fn g_param_value_convert(
        pspec: *mut GParamSpec,
        src_value: *const GValue,
        dest_value: *mut GValue,
        strict_validation: gboolean,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_param_values_cmp"]
    pub fn g_param_values_cmp(
        pspec: *mut GParamSpec,
        value1: *const GValue,
        value2: *const GValue,
    ) -> gint;
}
extern "C" {
    #[link_name = "\u{1}_g_param_spec_get_name"]
    pub fn g_param_spec_get_name(pspec: *mut GParamSpec) -> *const gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_param_spec_get_nick"]
    pub fn g_param_spec_get_nick(pspec: *mut GParamSpec) -> *const gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_param_spec_get_blurb"]
    pub fn g_param_spec_get_blurb(pspec: *mut GParamSpec) -> *const gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_value_set_param"]
    pub fn g_value_set_param(value: *mut GValue, param: *mut GParamSpec);
}
extern "C" {
    #[link_name = "\u{1}_g_value_get_param"]
    pub fn g_value_get_param(value: *const GValue) -> *mut GParamSpec;
}
extern "C" {
    #[link_name = "\u{1}_g_value_dup_param"]
    pub fn g_value_dup_param(value: *const GValue) -> *mut GParamSpec;
}
extern "C" {
    #[link_name = "\u{1}_g_value_take_param"]
    pub fn g_value_take_param(value: *mut GValue, param: *mut GParamSpec);
}
extern "C" {
    #[link_name = "\u{1}_g_value_set_param_take_ownership"]
    pub fn g_value_set_param_take_ownership(value: *mut GValue, param: *mut GParamSpec);
}
extern "C" {
    #[link_name = "\u{1}_g_param_spec_get_default_value"]
    pub fn g_param_spec_get_default_value(pspec: *mut GParamSpec) -> *const GValue;
}
extern "C" {
    #[link_name = "\u{1}_g_param_spec_get_name_quark"]
    pub fn g_param_spec_get_name_quark(pspec: *mut GParamSpec) -> GQuark;
}
pub type GParamSpecTypeInfo = _GParamSpecTypeInfo;
/// GParamSpecTypeInfo:
/// @instance_size: Size of the instance (object) structure.
/// @n_preallocs: Prior to GLib 2.10, it specified the number of pre-allocated (cached) instances to reserve memory for (0 indicates no caching). Since GLib 2.10, it is ignored, since instances are allocated with the [slice allocator][glib-Memory-Slices] now.
/// @instance_init: Location of the instance initialization function (optional).
/// @value_type: The #GType of values conforming to this #GParamSpec
/// @finalize: The instance finalization function (optional).
/// @value_set_default: Resets a @value to the default value for @pspec
/// (recommended, the default is g_value_reset()), see
/// g_param_value_set_default().
/// @value_validate: Ensures that the contents of @value comply with the
/// specifications set out by @pspec (optional), see
/// g_param_value_validate().
/// @values_cmp: Compares @value1 with @value2 according to @pspec
/// (recommended, the default is memcmp()), see g_param_values_cmp().
///
/// This structure is used to provide the type system with the information
/// required to initialize and destruct (finalize) a parameter's class and
/// instances thereof.
/// The initialized structure is passed to the g_param_type_register_static()
/// The type system will perform a deep copy of this structure, so its memory
/// does not need to be persistent across invocation of
/// g_param_type_register_static().
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GParamSpecTypeInfo {
    pub instance_size: guint16,
    pub n_preallocs: guint16,
    pub instance_init: ::std::option::Option<unsafe extern "C" fn(pspec: *mut GParamSpec)>,
    pub value_type: GType,
    pub finalize: ::std::option::Option<unsafe extern "C" fn(pspec: *mut GParamSpec)>,
    pub value_set_default:
        ::std::option::Option<unsafe extern "C" fn(pspec: *mut GParamSpec, value: *mut GValue)>,
    pub value_validate: ::std::option::Option<
        unsafe extern "C" fn(pspec: *mut GParamSpec, value: *mut GValue) -> gboolean,
    >,
    pub values_cmp: ::std::option::Option<
        unsafe extern "C" fn(pspec: *mut GParamSpec, value1: *const GValue, value2: *const GValue)
            -> gint,
    >,
}
#[test]
fn bindgen_test_layout__GParamSpecTypeInfo() {
    assert_eq!(
        ::std::mem::size_of::<_GParamSpecTypeInfo>(),
        56usize,
        concat!("Size of: ", stringify!(_GParamSpecTypeInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<_GParamSpecTypeInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(_GParamSpecTypeInfo))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GParamSpecTypeInfo>())).instance_size as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecTypeInfo),
            "::",
            stringify!(instance_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GParamSpecTypeInfo>())).n_preallocs as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecTypeInfo),
            "::",
            stringify!(n_preallocs)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GParamSpecTypeInfo>())).instance_init as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecTypeInfo),
            "::",
            stringify!(instance_init)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GParamSpecTypeInfo>())).value_type as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecTypeInfo),
            "::",
            stringify!(value_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GParamSpecTypeInfo>())).finalize as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecTypeInfo),
            "::",
            stringify!(finalize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GParamSpecTypeInfo>())).value_set_default as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecTypeInfo),
            "::",
            stringify!(value_set_default)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GParamSpecTypeInfo>())).value_validate as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecTypeInfo),
            "::",
            stringify!(value_validate)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GParamSpecTypeInfo>())).values_cmp as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecTypeInfo),
            "::",
            stringify!(values_cmp)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_g_param_type_register_static"]
    pub fn g_param_type_register_static(
        name: *const gchar,
        pspec_info: *const GParamSpecTypeInfo,
    ) -> GType;
}
extern "C" {
    #[link_name = "\u{1}__g_param_type_register_static_constant"]
    pub fn _g_param_type_register_static_constant(
        name: *const gchar,
        pspec_info: *const GParamSpecTypeInfo,
        opt_type: GType,
    ) -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_param_spec_internal"]
    pub fn g_param_spec_internal(
        param_type: GType,
        name: *const gchar,
        nick: *const gchar,
        blurb: *const gchar,
        flags: GParamFlags,
    ) -> gpointer;
}
extern "C" {
    #[link_name = "\u{1}_g_param_spec_pool_new"]
    pub fn g_param_spec_pool_new(type_prefixing: gboolean) -> *mut GParamSpecPool;
}
extern "C" {
    #[link_name = "\u{1}_g_param_spec_pool_insert"]
    pub fn g_param_spec_pool_insert(
        pool: *mut GParamSpecPool,
        pspec: *mut GParamSpec,
        owner_type: GType,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_param_spec_pool_remove"]
    pub fn g_param_spec_pool_remove(pool: *mut GParamSpecPool, pspec: *mut GParamSpec);
}
extern "C" {
    #[link_name = "\u{1}_g_param_spec_pool_lookup"]
    pub fn g_param_spec_pool_lookup(
        pool: *mut GParamSpecPool,
        param_name: *const gchar,
        owner_type: GType,
        walk_ancestors: gboolean,
    ) -> *mut GParamSpec;
}
extern "C" {
    #[link_name = "\u{1}_g_param_spec_pool_list_owned"]
    pub fn g_param_spec_pool_list_owned(pool: *mut GParamSpecPool, owner_type: GType)
        -> *mut GList;
}
extern "C" {
    #[link_name = "\u{1}_g_param_spec_pool_list"]
    pub fn g_param_spec_pool_list(
        pool: *mut GParamSpecPool,
        owner_type: GType,
        n_pspecs_p: *mut guint,
    ) -> *mut *mut GParamSpec;
}
pub type GClosure = _GClosure;
pub type GClosureNotifyData = _GClosureNotifyData;
/// GCallback:
///
/// The type used for callback functions in structure definitions and function
/// signatures. This doesn't mean that all callback functions must take no
/// parameters and return void. The required signature of a callback function
/// is determined by the context in which is used (e.g. the signal to which it
/// is connected). Use G_CALLBACK() to cast the callback function to a #GCallback.
pub type GCallback = ::std::option::Option<unsafe extern "C" fn()>;
/// GClosureNotify:
/// @data: data specified when registering the notification callback
/// @closure: the #GClosure on which the notification is emitted
///
/// The type used for the various notification callbacks which can be registered
/// on closures.
pub type GClosureNotify =
    ::std::option::Option<unsafe extern "C" fn(data: gpointer, closure: *mut GClosure)>;
/// GClosureMarshal:
/// @closure: the #GClosure to which the marshaller belongs
/// @return_value: (nullable): a #GValue to store the return
/// value. May be %NULL if the callback of @closure doesn't return a
/// value.
/// @n_param_values: the length of the @param_values array
/// @param_values: (array length=n_param_values): an array of
/// #GValues holding the arguments on which to invoke the
/// callback of @closure
/// @invocation_hint: (nullable): the invocation hint given as the
/// last argument to g_closure_invoke()
/// @marshal_data: (nullable): additional data specified when
/// registering the marshaller, see g_closure_set_marshal() and
/// g_closure_set_meta_marshal()
///
/// The type used for marshaller functions.
pub type GClosureMarshal = ::std::option::Option<
    unsafe extern "C" fn(
        closure: *mut GClosure,
        return_value: *mut GValue,
        n_param_values: guint,
        param_values: *const GValue,
        invocation_hint: gpointer,
        marshal_data: gpointer,
    ),
>;
/// GVaClosureMarshal:
/// @closure: the #GClosure to which the marshaller belongs
/// @return_value: (nullable): a #GValue to store the return
/// value. May be %NULL if the callback of @closure doesn't return a
/// value.
/// @instance: (type GObject.TypeInstance): the instance on which the closure is
/// invoked.
/// @args: va_list of arguments to be passed to the closure.
/// @marshal_data: (nullable): additional data specified when
/// registering the marshaller, see g_closure_set_marshal() and
/// g_closure_set_meta_marshal()
/// @n_params: the length of the @param_types array
/// @param_types: (array length=n_params): the #GType of each argument from
/// @args.
///
/// This is the signature of va_list marshaller functions, an optional
/// marshaller that can be used in some situations to avoid
/// marshalling the signal argument into GValues.
pub type GVaClosureMarshal = ::std::option::Option<
    unsafe extern "C" fn(
        closure: *mut GClosure,
        return_value: *mut GValue,
        instance: gpointer,
        args: *mut __va_list_tag,
        marshal_data: gpointer,
        n_params: ::std::os::raw::c_int,
        param_types: *mut GType,
    ),
>;
/// GCClosure:
/// @closure: the #GClosure
/// @callback: the callback function
///
/// A #GCClosure is a specialization of #GClosure for C function callbacks.
pub type GCClosure = _GCClosure;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GClosureNotifyData {
    pub data: gpointer,
    pub notify: GClosureNotify,
}
#[test]
fn bindgen_test_layout__GClosureNotifyData() {
    assert_eq!(
        ::std::mem::size_of::<_GClosureNotifyData>(),
        16usize,
        concat!("Size of: ", stringify!(_GClosureNotifyData))
    );
    assert_eq!(
        ::std::mem::align_of::<_GClosureNotifyData>(),
        8usize,
        concat!("Alignment of ", stringify!(_GClosureNotifyData))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GClosureNotifyData>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GClosureNotifyData),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GClosureNotifyData>())).notify as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GClosureNotifyData),
            "::",
            stringify!(notify)
        )
    );
}
/// GClosure:
/// @in_marshal: Indicates whether the closure is currently being invoked with
/// g_closure_invoke()
/// @is_invalid: Indicates whether the closure has been invalidated by
/// g_closure_invalidate()
///
/// A #GClosure represents a callback supplied by the programmer.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GClosure {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u16>,
    pub marshal: ::std::option::Option<
        unsafe extern "C" fn(
            closure: *mut GClosure,
            return_value: *mut GValue,
            n_param_values: guint,
            param_values: *const GValue,
            invocation_hint: gpointer,
            marshal_data: gpointer,
        ),
    >,
    pub data: gpointer,
    pub notifiers: *mut GClosureNotifyData,
}
#[test]
fn bindgen_test_layout__GClosure() {
    assert_eq!(
        ::std::mem::size_of::<_GClosure>(),
        32usize,
        concat!("Size of: ", stringify!(_GClosure))
    );
    assert_eq!(
        ::std::mem::align_of::<_GClosure>(),
        8usize,
        concat!("Alignment of ", stringify!(_GClosure))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GClosure>())).marshal as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GClosure),
            "::",
            stringify!(marshal)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GClosure>())).data as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GClosure),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GClosure>())).notifiers as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GClosure),
            "::",
            stringify!(notifiers)
        )
    );
}
impl _GClosure {
    #[inline]
    pub fn ref_count(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 15u8) as u32) }
    }
    #[inline]
    pub fn set_ref_count(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 15u8, val as u64)
        }
    }
    #[inline]
    pub fn meta_marshal_nouse(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_meta_marshal_nouse(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn n_guards(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_n_guards(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn n_fnotifiers(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(17usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_n_fnotifiers(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(17usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn n_inotifiers(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(19usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_n_inotifiers(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(19usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn in_inotify(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(27usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_in_inotify(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(27usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn floating(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(28usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_floating(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(28usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn derivative_flag(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(29usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_derivative_flag(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(29usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn in_marshal(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(30usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_in_marshal(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(30usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn is_invalid(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is_invalid(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        ref_count: guint,
        meta_marshal_nouse: guint,
        n_guards: guint,
        n_fnotifiers: guint,
        n_inotifiers: guint,
        in_inotify: guint,
        floating: guint,
        derivative_flag: guint,
        in_marshal: guint,
        is_invalid: guint,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 15u8, {
            let ref_count: u32 = unsafe { ::std::mem::transmute(ref_count) };
            ref_count as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let meta_marshal_nouse: u32 = unsafe { ::std::mem::transmute(meta_marshal_nouse) };
            meta_marshal_nouse as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let n_guards: u32 = unsafe { ::std::mem::transmute(n_guards) };
            n_guards as u64
        });
        __bindgen_bitfield_unit.set(17usize, 2u8, {
            let n_fnotifiers: u32 = unsafe { ::std::mem::transmute(n_fnotifiers) };
            n_fnotifiers as u64
        });
        __bindgen_bitfield_unit.set(19usize, 8u8, {
            let n_inotifiers: u32 = unsafe { ::std::mem::transmute(n_inotifiers) };
            n_inotifiers as u64
        });
        __bindgen_bitfield_unit.set(27usize, 1u8, {
            let in_inotify: u32 = unsafe { ::std::mem::transmute(in_inotify) };
            in_inotify as u64
        });
        __bindgen_bitfield_unit.set(28usize, 1u8, {
            let floating: u32 = unsafe { ::std::mem::transmute(floating) };
            floating as u64
        });
        __bindgen_bitfield_unit.set(29usize, 1u8, {
            let derivative_flag: u32 = unsafe { ::std::mem::transmute(derivative_flag) };
            derivative_flag as u64
        });
        __bindgen_bitfield_unit.set(30usize, 1u8, {
            let in_marshal: u32 = unsafe { ::std::mem::transmute(in_marshal) };
            in_marshal as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let is_invalid: u32 = unsafe { ::std::mem::transmute(is_invalid) };
            is_invalid as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GCClosure {
    pub closure: GClosure,
    pub callback: gpointer,
}
#[test]
fn bindgen_test_layout__GCClosure() {
    assert_eq!(
        ::std::mem::size_of::<_GCClosure>(),
        40usize,
        concat!("Size of: ", stringify!(_GCClosure))
    );
    assert_eq!(
        ::std::mem::align_of::<_GCClosure>(),
        8usize,
        concat!("Alignment of ", stringify!(_GCClosure))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GCClosure>())).closure as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GCClosure),
            "::",
            stringify!(closure)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GCClosure>())).callback as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_GCClosure),
            "::",
            stringify!(callback)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_g_cclosure_new"]
    pub fn g_cclosure_new(
        callback_func: GCallback,
        user_data: gpointer,
        destroy_data: GClosureNotify,
    ) -> *mut GClosure;
}
extern "C" {
    #[link_name = "\u{1}_g_cclosure_new_swap"]
    pub fn g_cclosure_new_swap(
        callback_func: GCallback,
        user_data: gpointer,
        destroy_data: GClosureNotify,
    ) -> *mut GClosure;
}
extern "C" {
    #[link_name = "\u{1}_g_signal_type_cclosure_new"]
    pub fn g_signal_type_cclosure_new(itype: GType, struct_offset: guint) -> *mut GClosure;
}
extern "C" {
    #[link_name = "\u{1}_g_closure_ref"]
    pub fn g_closure_ref(closure: *mut GClosure) -> *mut GClosure;
}
extern "C" {
    #[link_name = "\u{1}_g_closure_sink"]
    pub fn g_closure_sink(closure: *mut GClosure);
}
extern "C" {
    #[link_name = "\u{1}_g_closure_unref"]
    pub fn g_closure_unref(closure: *mut GClosure);
}
extern "C" {
    #[link_name = "\u{1}_g_closure_new_simple"]
    pub fn g_closure_new_simple(sizeof_closure: guint, data: gpointer) -> *mut GClosure;
}
extern "C" {
    #[link_name = "\u{1}_g_closure_add_finalize_notifier"]
    pub fn g_closure_add_finalize_notifier(
        closure: *mut GClosure,
        notify_data: gpointer,
        notify_func: GClosureNotify,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_closure_remove_finalize_notifier"]
    pub fn g_closure_remove_finalize_notifier(
        closure: *mut GClosure,
        notify_data: gpointer,
        notify_func: GClosureNotify,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_closure_add_invalidate_notifier"]
    pub fn g_closure_add_invalidate_notifier(
        closure: *mut GClosure,
        notify_data: gpointer,
        notify_func: GClosureNotify,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_closure_remove_invalidate_notifier"]
    pub fn g_closure_remove_invalidate_notifier(
        closure: *mut GClosure,
        notify_data: gpointer,
        notify_func: GClosureNotify,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_closure_add_marshal_guards"]
    pub fn g_closure_add_marshal_guards(
        closure: *mut GClosure,
        pre_marshal_data: gpointer,
        pre_marshal_notify: GClosureNotify,
        post_marshal_data: gpointer,
        post_marshal_notify: GClosureNotify,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_closure_set_marshal"]
    pub fn g_closure_set_marshal(closure: *mut GClosure, marshal: GClosureMarshal);
}
extern "C" {
    #[link_name = "\u{1}_g_closure_set_meta_marshal"]
    pub fn g_closure_set_meta_marshal(
        closure: *mut GClosure,
        marshal_data: gpointer,
        meta_marshal: GClosureMarshal,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_closure_invalidate"]
    pub fn g_closure_invalidate(closure: *mut GClosure);
}
extern "C" {
    #[link_name = "\u{1}_g_closure_invoke"]
    pub fn g_closure_invoke(
        closure: *mut GClosure,
        return_value: *mut GValue,
        n_param_values: guint,
        param_values: *const GValue,
        invocation_hint: gpointer,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_cclosure_marshal_generic"]
    pub fn g_cclosure_marshal_generic(
        closure: *mut GClosure,
        return_gvalue: *mut GValue,
        n_param_values: guint,
        param_values: *const GValue,
        invocation_hint: gpointer,
        marshal_data: gpointer,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_cclosure_marshal_generic_va"]
    pub fn g_cclosure_marshal_generic_va(
        closure: *mut GClosure,
        return_value: *mut GValue,
        instance: gpointer,
        args_list: *mut __va_list_tag,
        marshal_data: gpointer,
        n_params: ::std::os::raw::c_int,
        param_types: *mut GType,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_cclosure_marshal_VOID__VOID"]
    pub fn g_cclosure_marshal_VOID__VOID(
        closure: *mut GClosure,
        return_value: *mut GValue,
        n_param_values: guint,
        param_values: *const GValue,
        invocation_hint: gpointer,
        marshal_data: gpointer,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_cclosure_marshal_VOID__VOIDv"]
    pub fn g_cclosure_marshal_VOID__VOIDv(
        closure: *mut GClosure,
        return_value: *mut GValue,
        instance: gpointer,
        args: *mut __va_list_tag,
        marshal_data: gpointer,
        n_params: ::std::os::raw::c_int,
        param_types: *mut GType,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_cclosure_marshal_VOID__BOOLEAN"]
    pub fn g_cclosure_marshal_VOID__BOOLEAN(
        closure: *mut GClosure,
        return_value: *mut GValue,
        n_param_values: guint,
        param_values: *const GValue,
        invocation_hint: gpointer,
        marshal_data: gpointer,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_cclosure_marshal_VOID__BOOLEANv"]
    pub fn g_cclosure_marshal_VOID__BOOLEANv(
        closure: *mut GClosure,
        return_value: *mut GValue,
        instance: gpointer,
        args: *mut __va_list_tag,
        marshal_data: gpointer,
        n_params: ::std::os::raw::c_int,
        param_types: *mut GType,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_cclosure_marshal_VOID__CHAR"]
    pub fn g_cclosure_marshal_VOID__CHAR(
        closure: *mut GClosure,
        return_value: *mut GValue,
        n_param_values: guint,
        param_values: *const GValue,
        invocation_hint: gpointer,
        marshal_data: gpointer,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_cclosure_marshal_VOID__CHARv"]
    pub fn g_cclosure_marshal_VOID__CHARv(
        closure: *mut GClosure,
        return_value: *mut GValue,
        instance: gpointer,
        args: *mut __va_list_tag,
        marshal_data: gpointer,
        n_params: ::std::os::raw::c_int,
        param_types: *mut GType,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_cclosure_marshal_VOID__UCHAR"]
    pub fn g_cclosure_marshal_VOID__UCHAR(
        closure: *mut GClosure,
        return_value: *mut GValue,
        n_param_values: guint,
        param_values: *const GValue,
        invocation_hint: gpointer,
        marshal_data: gpointer,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_cclosure_marshal_VOID__UCHARv"]
    pub fn g_cclosure_marshal_VOID__UCHARv(
        closure: *mut GClosure,
        return_value: *mut GValue,
        instance: gpointer,
        args: *mut __va_list_tag,
        marshal_data: gpointer,
        n_params: ::std::os::raw::c_int,
        param_types: *mut GType,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_cclosure_marshal_VOID__INT"]
    pub fn g_cclosure_marshal_VOID__INT(
        closure: *mut GClosure,
        return_value: *mut GValue,
        n_param_values: guint,
        param_values: *const GValue,
        invocation_hint: gpointer,
        marshal_data: gpointer,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_cclosure_marshal_VOID__INTv"]
    pub fn g_cclosure_marshal_VOID__INTv(
        closure: *mut GClosure,
        return_value: *mut GValue,
        instance: gpointer,
        args: *mut __va_list_tag,
        marshal_data: gpointer,
        n_params: ::std::os::raw::c_int,
        param_types: *mut GType,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_cclosure_marshal_VOID__UINT"]
    pub fn g_cclosure_marshal_VOID__UINT(
        closure: *mut GClosure,
        return_value: *mut GValue,
        n_param_values: guint,
        param_values: *const GValue,
        invocation_hint: gpointer,
        marshal_data: gpointer,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_cclosure_marshal_VOID__UINTv"]
    pub fn g_cclosure_marshal_VOID__UINTv(
        closure: *mut GClosure,
        return_value: *mut GValue,
        instance: gpointer,
        args: *mut __va_list_tag,
        marshal_data: gpointer,
        n_params: ::std::os::raw::c_int,
        param_types: *mut GType,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_cclosure_marshal_VOID__LONG"]
    pub fn g_cclosure_marshal_VOID__LONG(
        closure: *mut GClosure,
        return_value: *mut GValue,
        n_param_values: guint,
        param_values: *const GValue,
        invocation_hint: gpointer,
        marshal_data: gpointer,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_cclosure_marshal_VOID__LONGv"]
    pub fn g_cclosure_marshal_VOID__LONGv(
        closure: *mut GClosure,
        return_value: *mut GValue,
        instance: gpointer,
        args: *mut __va_list_tag,
        marshal_data: gpointer,
        n_params: ::std::os::raw::c_int,
        param_types: *mut GType,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_cclosure_marshal_VOID__ULONG"]
    pub fn g_cclosure_marshal_VOID__ULONG(
        closure: *mut GClosure,
        return_value: *mut GValue,
        n_param_values: guint,
        param_values: *const GValue,
        invocation_hint: gpointer,
        marshal_data: gpointer,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_cclosure_marshal_VOID__ULONGv"]
    pub fn g_cclosure_marshal_VOID__ULONGv(
        closure: *mut GClosure,
        return_value: *mut GValue,
        instance: gpointer,
        args: *mut __va_list_tag,
        marshal_data: gpointer,
        n_params: ::std::os::raw::c_int,
        param_types: *mut GType,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_cclosure_marshal_VOID__ENUM"]
    pub fn g_cclosure_marshal_VOID__ENUM(
        closure: *mut GClosure,
        return_value: *mut GValue,
        n_param_values: guint,
        param_values: *const GValue,
        invocation_hint: gpointer,
        marshal_data: gpointer,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_cclosure_marshal_VOID__ENUMv"]
    pub fn g_cclosure_marshal_VOID__ENUMv(
        closure: *mut GClosure,
        return_value: *mut GValue,
        instance: gpointer,
        args: *mut __va_list_tag,
        marshal_data: gpointer,
        n_params: ::std::os::raw::c_int,
        param_types: *mut GType,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_cclosure_marshal_VOID__FLAGS"]
    pub fn g_cclosure_marshal_VOID__FLAGS(
        closure: *mut GClosure,
        return_value: *mut GValue,
        n_param_values: guint,
        param_values: *const GValue,
        invocation_hint: gpointer,
        marshal_data: gpointer,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_cclosure_marshal_VOID__FLAGSv"]
    pub fn g_cclosure_marshal_VOID__FLAGSv(
        closure: *mut GClosure,
        return_value: *mut GValue,
        instance: gpointer,
        args: *mut __va_list_tag,
        marshal_data: gpointer,
        n_params: ::std::os::raw::c_int,
        param_types: *mut GType,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_cclosure_marshal_VOID__FLOAT"]
    pub fn g_cclosure_marshal_VOID__FLOAT(
        closure: *mut GClosure,
        return_value: *mut GValue,
        n_param_values: guint,
        param_values: *const GValue,
        invocation_hint: gpointer,
        marshal_data: gpointer,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_cclosure_marshal_VOID__FLOATv"]
    pub fn g_cclosure_marshal_VOID__FLOATv(
        closure: *mut GClosure,
        return_value: *mut GValue,
        instance: gpointer,
        args: *mut __va_list_tag,
        marshal_data: gpointer,
        n_params: ::std::os::raw::c_int,
        param_types: *mut GType,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_cclosure_marshal_VOID__DOUBLE"]
    pub fn g_cclosure_marshal_VOID__DOUBLE(
        closure: *mut GClosure,
        return_value: *mut GValue,
        n_param_values: guint,
        param_values: *const GValue,
        invocation_hint: gpointer,
        marshal_data: gpointer,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_cclosure_marshal_VOID__DOUBLEv"]
    pub fn g_cclosure_marshal_VOID__DOUBLEv(
        closure: *mut GClosure,
        return_value: *mut GValue,
        instance: gpointer,
        args: *mut __va_list_tag,
        marshal_data: gpointer,
        n_params: ::std::os::raw::c_int,
        param_types: *mut GType,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_cclosure_marshal_VOID__STRING"]
    pub fn g_cclosure_marshal_VOID__STRING(
        closure: *mut GClosure,
        return_value: *mut GValue,
        n_param_values: guint,
        param_values: *const GValue,
        invocation_hint: gpointer,
        marshal_data: gpointer,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_cclosure_marshal_VOID__STRINGv"]
    pub fn g_cclosure_marshal_VOID__STRINGv(
        closure: *mut GClosure,
        return_value: *mut GValue,
        instance: gpointer,
        args: *mut __va_list_tag,
        marshal_data: gpointer,
        n_params: ::std::os::raw::c_int,
        param_types: *mut GType,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_cclosure_marshal_VOID__PARAM"]
    pub fn g_cclosure_marshal_VOID__PARAM(
        closure: *mut GClosure,
        return_value: *mut GValue,
        n_param_values: guint,
        param_values: *const GValue,
        invocation_hint: gpointer,
        marshal_data: gpointer,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_cclosure_marshal_VOID__PARAMv"]
    pub fn g_cclosure_marshal_VOID__PARAMv(
        closure: *mut GClosure,
        return_value: *mut GValue,
        instance: gpointer,
        args: *mut __va_list_tag,
        marshal_data: gpointer,
        n_params: ::std::os::raw::c_int,
        param_types: *mut GType,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_cclosure_marshal_VOID__BOXED"]
    pub fn g_cclosure_marshal_VOID__BOXED(
        closure: *mut GClosure,
        return_value: *mut GValue,
        n_param_values: guint,
        param_values: *const GValue,
        invocation_hint: gpointer,
        marshal_data: gpointer,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_cclosure_marshal_VOID__BOXEDv"]
    pub fn g_cclosure_marshal_VOID__BOXEDv(
        closure: *mut GClosure,
        return_value: *mut GValue,
        instance: gpointer,
        args: *mut __va_list_tag,
        marshal_data: gpointer,
        n_params: ::std::os::raw::c_int,
        param_types: *mut GType,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_cclosure_marshal_VOID__POINTER"]
    pub fn g_cclosure_marshal_VOID__POINTER(
        closure: *mut GClosure,
        return_value: *mut GValue,
        n_param_values: guint,
        param_values: *const GValue,
        invocation_hint: gpointer,
        marshal_data: gpointer,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_cclosure_marshal_VOID__POINTERv"]
    pub fn g_cclosure_marshal_VOID__POINTERv(
        closure: *mut GClosure,
        return_value: *mut GValue,
        instance: gpointer,
        args: *mut __va_list_tag,
        marshal_data: gpointer,
        n_params: ::std::os::raw::c_int,
        param_types: *mut GType,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_cclosure_marshal_VOID__OBJECT"]
    pub fn g_cclosure_marshal_VOID__OBJECT(
        closure: *mut GClosure,
        return_value: *mut GValue,
        n_param_values: guint,
        param_values: *const GValue,
        invocation_hint: gpointer,
        marshal_data: gpointer,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_cclosure_marshal_VOID__OBJECTv"]
    pub fn g_cclosure_marshal_VOID__OBJECTv(
        closure: *mut GClosure,
        return_value: *mut GValue,
        instance: gpointer,
        args: *mut __va_list_tag,
        marshal_data: gpointer,
        n_params: ::std::os::raw::c_int,
        param_types: *mut GType,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_cclosure_marshal_VOID__VARIANT"]
    pub fn g_cclosure_marshal_VOID__VARIANT(
        closure: *mut GClosure,
        return_value: *mut GValue,
        n_param_values: guint,
        param_values: *const GValue,
        invocation_hint: gpointer,
        marshal_data: gpointer,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_cclosure_marshal_VOID__VARIANTv"]
    pub fn g_cclosure_marshal_VOID__VARIANTv(
        closure: *mut GClosure,
        return_value: *mut GValue,
        instance: gpointer,
        args: *mut __va_list_tag,
        marshal_data: gpointer,
        n_params: ::std::os::raw::c_int,
        param_types: *mut GType,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_cclosure_marshal_VOID__UINT_POINTER"]
    pub fn g_cclosure_marshal_VOID__UINT_POINTER(
        closure: *mut GClosure,
        return_value: *mut GValue,
        n_param_values: guint,
        param_values: *const GValue,
        invocation_hint: gpointer,
        marshal_data: gpointer,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_cclosure_marshal_VOID__UINT_POINTERv"]
    pub fn g_cclosure_marshal_VOID__UINT_POINTERv(
        closure: *mut GClosure,
        return_value: *mut GValue,
        instance: gpointer,
        args: *mut __va_list_tag,
        marshal_data: gpointer,
        n_params: ::std::os::raw::c_int,
        param_types: *mut GType,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_cclosure_marshal_BOOLEAN__FLAGS"]
    pub fn g_cclosure_marshal_BOOLEAN__FLAGS(
        closure: *mut GClosure,
        return_value: *mut GValue,
        n_param_values: guint,
        param_values: *const GValue,
        invocation_hint: gpointer,
        marshal_data: gpointer,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_cclosure_marshal_BOOLEAN__FLAGSv"]
    pub fn g_cclosure_marshal_BOOLEAN__FLAGSv(
        closure: *mut GClosure,
        return_value: *mut GValue,
        instance: gpointer,
        args: *mut __va_list_tag,
        marshal_data: gpointer,
        n_params: ::std::os::raw::c_int,
        param_types: *mut GType,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_cclosure_marshal_STRING__OBJECT_POINTER"]
    pub fn g_cclosure_marshal_STRING__OBJECT_POINTER(
        closure: *mut GClosure,
        return_value: *mut GValue,
        n_param_values: guint,
        param_values: *const GValue,
        invocation_hint: gpointer,
        marshal_data: gpointer,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_cclosure_marshal_STRING__OBJECT_POINTERv"]
    pub fn g_cclosure_marshal_STRING__OBJECT_POINTERv(
        closure: *mut GClosure,
        return_value: *mut GValue,
        instance: gpointer,
        args: *mut __va_list_tag,
        marshal_data: gpointer,
        n_params: ::std::os::raw::c_int,
        param_types: *mut GType,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_cclosure_marshal_BOOLEAN__BOXED_BOXED"]
    pub fn g_cclosure_marshal_BOOLEAN__BOXED_BOXED(
        closure: *mut GClosure,
        return_value: *mut GValue,
        n_param_values: guint,
        param_values: *const GValue,
        invocation_hint: gpointer,
        marshal_data: gpointer,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_cclosure_marshal_BOOLEAN__BOXED_BOXEDv"]
    pub fn g_cclosure_marshal_BOOLEAN__BOXED_BOXEDv(
        closure: *mut GClosure,
        return_value: *mut GValue,
        instance: gpointer,
        args: *mut __va_list_tag,
        marshal_data: gpointer,
        n_params: ::std::os::raw::c_int,
        param_types: *mut GType,
    );
}
pub type GSignalQuery = _GSignalQuery;
pub type GSignalInvocationHint = _GSignalInvocationHint;
/// GSignalCMarshaller:
///
/// This is the signature of marshaller functions, required to marshall
/// arrays of parameter values to signal emissions into C language callback
/// invocations. It is merely an alias to #GClosureMarshal since the #GClosure
/// mechanism takes over responsibility of actual function invocation for the
/// signal system.
pub type GSignalCMarshaller = GClosureMarshal;
/// GSignalCVaMarshaller:
///
/// This is the signature of va_list marshaller functions, an optional
/// marshaller that can be used in some situations to avoid
/// marshalling the signal argument into GValues.
pub type GSignalCVaMarshaller = GVaClosureMarshal;
/// GSignalEmissionHook:
/// @ihint: Signal invocation hint, see #GSignalInvocationHint.
/// @n_param_values: the number of parameters to the function, including
/// the instance on which the signal was emitted.
/// @param_values: (array length=n_param_values): the instance on which
/// the signal was emitted, followed by the parameters of the emission.
/// @data: user data associated with the hook.
///
/// A simple function pointer to get invoked when the signal is emitted. This
/// allows you to tie a hook to the signal type, so that it will trap all
/// emissions of that signal, from any object.
///
/// You may not attach these to signals created with the #G_SIGNAL_NO_HOOKS flag.
///
/// Returns: whether it wants to stay connected. If it returns %FALSE, the signal
/// hook is disconnected (and destroyed).
pub type GSignalEmissionHook = ::std::option::Option<
    unsafe extern "C" fn(
        ihint: *mut GSignalInvocationHint,
        n_param_values: guint,
        param_values: *const GValue,
        data: gpointer,
    ) -> gboolean,
>;
/// GSignalAccumulator:
/// @ihint: Signal invocation hint, see #GSignalInvocationHint.
/// @return_accu: Accumulator to collect callback return values in, this
/// is the return value of the current signal emission.
/// @handler_return: A #GValue holding the return value of the signal handler.
/// @data: Callback data that was specified when creating the signal.
///
/// The signal accumulator is a special callback function that can be used
/// to collect return values of the various callbacks that are called
/// during a signal emission. The signal accumulator is specified at signal
/// creation time, if it is left %NULL, no accumulation of callback return
/// values is performed. The return value of signal emissions is then the
/// value returned by the last callback.
///
/// Returns: The accumulator function returns whether the signal emission
/// should be aborted. Returning %FALSE means to abort the
/// current emission and %TRUE is returned for continuation.
pub type GSignalAccumulator = ::std::option::Option<
    unsafe extern "C" fn(
        ihint: *mut GSignalInvocationHint,
        return_accu: *mut GValue,
        handler_return: *const GValue,
        data: gpointer,
    ) -> gboolean,
>;
pub const GSignalFlags_G_SIGNAL_RUN_FIRST: GSignalFlags = 1;
pub const GSignalFlags_G_SIGNAL_RUN_LAST: GSignalFlags = 2;
pub const GSignalFlags_G_SIGNAL_RUN_CLEANUP: GSignalFlags = 4;
pub const GSignalFlags_G_SIGNAL_NO_RECURSE: GSignalFlags = 8;
pub const GSignalFlags_G_SIGNAL_DETAILED: GSignalFlags = 16;
pub const GSignalFlags_G_SIGNAL_ACTION: GSignalFlags = 32;
pub const GSignalFlags_G_SIGNAL_NO_HOOKS: GSignalFlags = 64;
pub const GSignalFlags_G_SIGNAL_MUST_COLLECT: GSignalFlags = 128;
pub const GSignalFlags_G_SIGNAL_DEPRECATED: GSignalFlags = 256;
/// GSignalFlags:
/// @G_SIGNAL_RUN_FIRST: Invoke the object method handler in the first emission stage.
/// @G_SIGNAL_RUN_LAST: Invoke the object method handler in the third emission stage.
/// @G_SIGNAL_RUN_CLEANUP: Invoke the object method handler in the last emission stage.
/// @G_SIGNAL_NO_RECURSE: Signals being emitted for an object while currently being in
/// emission for this very object will not be emitted recursively,
/// but instead cause the first emission to be restarted.
/// @G_SIGNAL_DETAILED: This signal supports "::detail" appendices to the signal name
/// upon handler connections and emissions.
/// @G_SIGNAL_ACTION: Action signals are signals that may freely be emitted on alive
/// objects from user code via g_signal_emit() and friends, without
/// the need of being embedded into extra code that performs pre or
/// post emission adjustments on the object. They can also be thought
/// of as object methods which can be called generically by
/// third-party code.
/// @G_SIGNAL_NO_HOOKS: No emissions hooks are supported for this signal.
/// @G_SIGNAL_MUST_COLLECT: Varargs signal emission will always collect the
/// arguments, even if there are no signal handlers connected.  Since 2.30.
/// @G_SIGNAL_DEPRECATED: The signal is deprecated and will be removed
/// in a future version. A warning will be generated if it is connected while
/// running with G_ENABLE_DIAGNOSTIC=1.  Since 2.32.
///
/// The signal flags are used to specify a signal's behaviour, the overall
/// signal description outlines how especially the RUN flags control the
/// stages of a signal emission.
pub type GSignalFlags = u32;
pub const GConnectFlags_G_CONNECT_AFTER: GConnectFlags = 1;
pub const GConnectFlags_G_CONNECT_SWAPPED: GConnectFlags = 2;
/// GConnectFlags:
/// @G_CONNECT_AFTER: whether the handler should be called before or after the
/// default handler of the signal.
/// @G_CONNECT_SWAPPED: whether the instance and data should be swapped when
/// calling the handler; see g_signal_connect_swapped() for an example.
///
/// The connection flags are used to specify the behaviour of a signal's
/// connection.
pub type GConnectFlags = u32;
pub const GSignalMatchType_G_SIGNAL_MATCH_ID: GSignalMatchType = 1;
pub const GSignalMatchType_G_SIGNAL_MATCH_DETAIL: GSignalMatchType = 2;
pub const GSignalMatchType_G_SIGNAL_MATCH_CLOSURE: GSignalMatchType = 4;
pub const GSignalMatchType_G_SIGNAL_MATCH_FUNC: GSignalMatchType = 8;
pub const GSignalMatchType_G_SIGNAL_MATCH_DATA: GSignalMatchType = 16;
pub const GSignalMatchType_G_SIGNAL_MATCH_UNBLOCKED: GSignalMatchType = 32;
/// GSignalMatchType:
/// @G_SIGNAL_MATCH_ID: The signal id must be equal.
/// @G_SIGNAL_MATCH_DETAIL: The signal detail be equal.
/// @G_SIGNAL_MATCH_CLOSURE: The closure must be the same.
/// @G_SIGNAL_MATCH_FUNC: The C closure callback must be the same.
/// @G_SIGNAL_MATCH_DATA: The closure data must be the same.
/// @G_SIGNAL_MATCH_UNBLOCKED: Only unblocked signals may matched.
///
/// The match types specify what g_signal_handlers_block_matched(),
/// g_signal_handlers_unblock_matched() and g_signal_handlers_disconnect_matched()
/// match signals by.
pub type GSignalMatchType = u32;
/// GSignalInvocationHint:
/// @signal_id: The signal id of the signal invoking the callback
/// @detail: The detail passed on for this emission
/// @run_type: The stage the signal emission is currently in, this
/// field will contain one of %G_SIGNAL_RUN_FIRST,
/// %G_SIGNAL_RUN_LAST or %G_SIGNAL_RUN_CLEANUP.
///
/// The #GSignalInvocationHint structure is used to pass on additional information
/// to callbacks during a signal emission.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GSignalInvocationHint {
    pub signal_id: guint,
    pub detail: GQuark,
    pub run_type: GSignalFlags,
}
#[test]
fn bindgen_test_layout__GSignalInvocationHint() {
    assert_eq!(
        ::std::mem::size_of::<_GSignalInvocationHint>(),
        12usize,
        concat!("Size of: ", stringify!(_GSignalInvocationHint))
    );
    assert_eq!(
        ::std::mem::align_of::<_GSignalInvocationHint>(),
        4usize,
        concat!("Alignment of ", stringify!(_GSignalInvocationHint))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GSignalInvocationHint>())).signal_id as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSignalInvocationHint),
            "::",
            stringify!(signal_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GSignalInvocationHint>())).detail as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSignalInvocationHint),
            "::",
            stringify!(detail)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GSignalInvocationHint>())).run_type as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSignalInvocationHint),
            "::",
            stringify!(run_type)
        )
    );
}
/// GSignalQuery:
/// @signal_id: The signal id of the signal being queried, or 0 if the
/// signal to be queried was unknown.
/// @signal_name: The signal name.
/// @itype: The interface/instance type that this signal can be emitted for.
/// @signal_flags: The signal flags as passed in to g_signal_new().
/// @return_type: The return type for user callbacks.
/// @n_params: The number of parameters that user callbacks take.
/// @param_types: (array length=n_params): The individual parameter types for
/// user callbacks, note that the effective callback signature is:
/// |[<!-- language="C" -->
/// @return_type callback (#gpointer     data1,
/// [param_types param_names,]
/// gpointer     data2);
/// ]|
///
/// A structure holding in-depth information for a specific signal. It is
/// filled in by the g_signal_query() function.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GSignalQuery {
    pub signal_id: guint,
    pub signal_name: *const gchar,
    pub itype: GType,
    pub signal_flags: GSignalFlags,
    pub return_type: GType,
    pub n_params: guint,
    pub param_types: *const GType,
}
#[test]
fn bindgen_test_layout__GSignalQuery() {
    assert_eq!(
        ::std::mem::size_of::<_GSignalQuery>(),
        56usize,
        concat!("Size of: ", stringify!(_GSignalQuery))
    );
    assert_eq!(
        ::std::mem::align_of::<_GSignalQuery>(),
        8usize,
        concat!("Alignment of ", stringify!(_GSignalQuery))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GSignalQuery>())).signal_id as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSignalQuery),
            "::",
            stringify!(signal_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GSignalQuery>())).signal_name as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSignalQuery),
            "::",
            stringify!(signal_name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GSignalQuery>())).itype as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSignalQuery),
            "::",
            stringify!(itype)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GSignalQuery>())).signal_flags as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSignalQuery),
            "::",
            stringify!(signal_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GSignalQuery>())).return_type as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSignalQuery),
            "::",
            stringify!(return_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GSignalQuery>())).n_params as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSignalQuery),
            "::",
            stringify!(n_params)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GSignalQuery>())).param_types as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSignalQuery),
            "::",
            stringify!(param_types)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_g_signal_newv"]
    pub fn g_signal_newv(
        signal_name: *const gchar,
        itype: GType,
        signal_flags: GSignalFlags,
        class_closure: *mut GClosure,
        accumulator: GSignalAccumulator,
        accu_data: gpointer,
        c_marshaller: GSignalCMarshaller,
        return_type: GType,
        n_params: guint,
        param_types: *mut GType,
    ) -> guint;
}
extern "C" {
    #[link_name = "\u{1}_g_signal_new_valist"]
    pub fn g_signal_new_valist(
        signal_name: *const gchar,
        itype: GType,
        signal_flags: GSignalFlags,
        class_closure: *mut GClosure,
        accumulator: GSignalAccumulator,
        accu_data: gpointer,
        c_marshaller: GSignalCMarshaller,
        return_type: GType,
        n_params: guint,
        args: *mut __va_list_tag,
    ) -> guint;
}
extern "C" {
    #[link_name = "\u{1}_g_signal_new"]
    pub fn g_signal_new(
        signal_name: *const gchar,
        itype: GType,
        signal_flags: GSignalFlags,
        class_offset: guint,
        accumulator: GSignalAccumulator,
        accu_data: gpointer,
        c_marshaller: GSignalCMarshaller,
        return_type: GType,
        n_params: guint,
        ...
    ) -> guint;
}
extern "C" {
    #[link_name = "\u{1}_g_signal_new_class_handler"]
    pub fn g_signal_new_class_handler(
        signal_name: *const gchar,
        itype: GType,
        signal_flags: GSignalFlags,
        class_handler: GCallback,
        accumulator: GSignalAccumulator,
        accu_data: gpointer,
        c_marshaller: GSignalCMarshaller,
        return_type: GType,
        n_params: guint,
        ...
    ) -> guint;
}
extern "C" {
    #[link_name = "\u{1}_g_signal_set_va_marshaller"]
    pub fn g_signal_set_va_marshaller(
        signal_id: guint,
        instance_type: GType,
        va_marshaller: GSignalCVaMarshaller,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_signal_emitv"]
    pub fn g_signal_emitv(
        instance_and_params: *const GValue,
        signal_id: guint,
        detail: GQuark,
        return_value: *mut GValue,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_signal_emit_valist"]
    pub fn g_signal_emit_valist(
        instance: gpointer,
        signal_id: guint,
        detail: GQuark,
        var_args: *mut __va_list_tag,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_signal_emit"]
    pub fn g_signal_emit(instance: gpointer, signal_id: guint, detail: GQuark, ...);
}
extern "C" {
    #[link_name = "\u{1}_g_signal_emit_by_name"]
    pub fn g_signal_emit_by_name(instance: gpointer, detailed_signal: *const gchar, ...);
}
extern "C" {
    #[link_name = "\u{1}_g_signal_lookup"]
    pub fn g_signal_lookup(name: *const gchar, itype: GType) -> guint;
}
extern "C" {
    #[link_name = "\u{1}_g_signal_name"]
    pub fn g_signal_name(signal_id: guint) -> *const gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_signal_query"]
    pub fn g_signal_query(signal_id: guint, query: *mut GSignalQuery);
}
extern "C" {
    #[link_name = "\u{1}_g_signal_list_ids"]
    pub fn g_signal_list_ids(itype: GType, n_ids: *mut guint) -> *mut guint;
}
extern "C" {
    #[link_name = "\u{1}_g_signal_parse_name"]
    pub fn g_signal_parse_name(
        detailed_signal: *const gchar,
        itype: GType,
        signal_id_p: *mut guint,
        detail_p: *mut GQuark,
        force_detail_quark: gboolean,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_signal_get_invocation_hint"]
    pub fn g_signal_get_invocation_hint(instance: gpointer) -> *mut GSignalInvocationHint;
}
extern "C" {
    #[link_name = "\u{1}_g_signal_stop_emission"]
    pub fn g_signal_stop_emission(instance: gpointer, signal_id: guint, detail: GQuark);
}
extern "C" {
    #[link_name = "\u{1}_g_signal_stop_emission_by_name"]
    pub fn g_signal_stop_emission_by_name(instance: gpointer, detailed_signal: *const gchar);
}
extern "C" {
    #[link_name = "\u{1}_g_signal_add_emission_hook"]
    pub fn g_signal_add_emission_hook(
        signal_id: guint,
        detail: GQuark,
        hook_func: GSignalEmissionHook,
        hook_data: gpointer,
        data_destroy: GDestroyNotify,
    ) -> gulong;
}
extern "C" {
    #[link_name = "\u{1}_g_signal_remove_emission_hook"]
    pub fn g_signal_remove_emission_hook(signal_id: guint, hook_id: gulong);
}
extern "C" {
    #[link_name = "\u{1}_g_signal_has_handler_pending"]
    pub fn g_signal_has_handler_pending(
        instance: gpointer,
        signal_id: guint,
        detail: GQuark,
        may_be_blocked: gboolean,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_signal_connect_closure_by_id"]
    pub fn g_signal_connect_closure_by_id(
        instance: gpointer,
        signal_id: guint,
        detail: GQuark,
        closure: *mut GClosure,
        after: gboolean,
    ) -> gulong;
}
extern "C" {
    #[link_name = "\u{1}_g_signal_connect_closure"]
    pub fn g_signal_connect_closure(
        instance: gpointer,
        detailed_signal: *const gchar,
        closure: *mut GClosure,
        after: gboolean,
    ) -> gulong;
}
extern "C" {
    #[link_name = "\u{1}_g_signal_connect_data"]
    pub fn g_signal_connect_data(
        instance: gpointer,
        detailed_signal: *const gchar,
        c_handler: GCallback,
        data: gpointer,
        destroy_data: GClosureNotify,
        connect_flags: GConnectFlags,
    ) -> gulong;
}
extern "C" {
    #[link_name = "\u{1}_g_signal_handler_block"]
    pub fn g_signal_handler_block(instance: gpointer, handler_id: gulong);
}
extern "C" {
    #[link_name = "\u{1}_g_signal_handler_unblock"]
    pub fn g_signal_handler_unblock(instance: gpointer, handler_id: gulong);
}
extern "C" {
    #[link_name = "\u{1}_g_signal_handler_disconnect"]
    pub fn g_signal_handler_disconnect(instance: gpointer, handler_id: gulong);
}
extern "C" {
    #[link_name = "\u{1}_g_signal_handler_is_connected"]
    pub fn g_signal_handler_is_connected(instance: gpointer, handler_id: gulong) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_signal_handler_find"]
    pub fn g_signal_handler_find(
        instance: gpointer,
        mask: GSignalMatchType,
        signal_id: guint,
        detail: GQuark,
        closure: *mut GClosure,
        func: gpointer,
        data: gpointer,
    ) -> gulong;
}
extern "C" {
    #[link_name = "\u{1}_g_signal_handlers_block_matched"]
    pub fn g_signal_handlers_block_matched(
        instance: gpointer,
        mask: GSignalMatchType,
        signal_id: guint,
        detail: GQuark,
        closure: *mut GClosure,
        func: gpointer,
        data: gpointer,
    ) -> guint;
}
extern "C" {
    #[link_name = "\u{1}_g_signal_handlers_unblock_matched"]
    pub fn g_signal_handlers_unblock_matched(
        instance: gpointer,
        mask: GSignalMatchType,
        signal_id: guint,
        detail: GQuark,
        closure: *mut GClosure,
        func: gpointer,
        data: gpointer,
    ) -> guint;
}
extern "C" {
    #[link_name = "\u{1}_g_signal_handlers_disconnect_matched"]
    pub fn g_signal_handlers_disconnect_matched(
        instance: gpointer,
        mask: GSignalMatchType,
        signal_id: guint,
        detail: GQuark,
        closure: *mut GClosure,
        func: gpointer,
        data: gpointer,
    ) -> guint;
}
extern "C" {
    #[link_name = "\u{1}_g_signal_override_class_closure"]
    pub fn g_signal_override_class_closure(
        signal_id: guint,
        instance_type: GType,
        class_closure: *mut GClosure,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_signal_override_class_handler"]
    pub fn g_signal_override_class_handler(
        signal_name: *const gchar,
        instance_type: GType,
        class_handler: GCallback,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_signal_chain_from_overridden"]
    pub fn g_signal_chain_from_overridden(
        instance_and_params: *const GValue,
        return_value: *mut GValue,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_signal_chain_from_overridden_handler"]
    pub fn g_signal_chain_from_overridden_handler(instance: gpointer, ...);
}
extern "C" {
    #[link_name = "\u{1}_g_signal_accumulator_true_handled"]
    pub fn g_signal_accumulator_true_handled(
        ihint: *mut GSignalInvocationHint,
        return_accu: *mut GValue,
        handler_return: *const GValue,
        dummy: gpointer,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_signal_accumulator_first_wins"]
    pub fn g_signal_accumulator_first_wins(
        ihint: *mut GSignalInvocationHint,
        return_accu: *mut GValue,
        handler_return: *const GValue,
        dummy: gpointer,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_signal_handlers_destroy"]
    pub fn g_signal_handlers_destroy(instance: gpointer);
}
extern "C" {
    #[link_name = "\u{1}__g_signals_destroy"]
    pub fn _g_signals_destroy(itype: GType);
}
extern "C" {
    #[link_name = "\u{1}_g_date_get_type"]
    pub fn g_date_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_strv_get_type"]
    pub fn g_strv_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_gstring_get_type"]
    pub fn g_gstring_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_hash_table_get_type"]
    pub fn g_hash_table_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_array_get_type"]
    pub fn g_array_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_byte_array_get_type"]
    pub fn g_byte_array_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_ptr_array_get_type"]
    pub fn g_ptr_array_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_bytes_get_type"]
    pub fn g_bytes_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_variant_type_get_gtype"]
    pub fn g_variant_type_get_gtype() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_regex_get_type"]
    pub fn g_regex_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_match_info_get_type"]
    pub fn g_match_info_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_error_get_type"]
    pub fn g_error_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_date_time_get_type"]
    pub fn g_date_time_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_time_zone_get_type"]
    pub fn g_time_zone_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_io_channel_get_type"]
    pub fn g_io_channel_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_io_condition_get_type"]
    pub fn g_io_condition_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_variant_builder_get_type"]
    pub fn g_variant_builder_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_variant_dict_get_type"]
    pub fn g_variant_dict_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_key_file_get_type"]
    pub fn g_key_file_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_main_loop_get_type"]
    pub fn g_main_loop_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_main_context_get_type"]
    pub fn g_main_context_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_source_get_type"]
    pub fn g_source_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_pollfd_get_type"]
    pub fn g_pollfd_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_thread_get_type"]
    pub fn g_thread_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_checksum_get_type"]
    pub fn g_checksum_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_markup_parse_context_get_type"]
    pub fn g_markup_parse_context_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_mapped_file_get_type"]
    pub fn g_mapped_file_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_option_group_get_type"]
    pub fn g_option_group_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_variant_get_gtype"]
    pub fn g_variant_get_gtype() -> GType;
}
/// GBoxedCopyFunc:
/// @boxed: (not nullable): The boxed structure to be copied.
///
/// This function is provided by the user and should produce a copy
/// of the passed in boxed structure.
///
/// Returns: (not nullable): The newly created copy of the boxed structure.
pub type GBoxedCopyFunc = ::std::option::Option<unsafe extern "C" fn(boxed: gpointer) -> gpointer>;
/// GBoxedFreeFunc:
/// @boxed: (not nullable): The boxed structure to be freed.
///
/// This function is provided by the user and should free the boxed
/// structure passed.
pub type GBoxedFreeFunc = ::std::option::Option<unsafe extern "C" fn(boxed: gpointer)>;
extern "C" {
    #[link_name = "\u{1}_g_boxed_copy"]
    pub fn g_boxed_copy(boxed_type: GType, src_boxed: gconstpointer) -> gpointer;
}
extern "C" {
    #[link_name = "\u{1}_g_boxed_free"]
    pub fn g_boxed_free(boxed_type: GType, boxed: gpointer);
}
extern "C" {
    #[link_name = "\u{1}_g_value_set_boxed"]
    pub fn g_value_set_boxed(value: *mut GValue, v_boxed: gconstpointer);
}
extern "C" {
    #[link_name = "\u{1}_g_value_set_static_boxed"]
    pub fn g_value_set_static_boxed(value: *mut GValue, v_boxed: gconstpointer);
}
extern "C" {
    #[link_name = "\u{1}_g_value_take_boxed"]
    pub fn g_value_take_boxed(value: *mut GValue, v_boxed: gconstpointer);
}
extern "C" {
    #[link_name = "\u{1}_g_value_set_boxed_take_ownership"]
    pub fn g_value_set_boxed_take_ownership(value: *mut GValue, v_boxed: gconstpointer);
}
extern "C" {
    #[link_name = "\u{1}_g_value_get_boxed"]
    pub fn g_value_get_boxed(value: *const GValue) -> gpointer;
}
extern "C" {
    #[link_name = "\u{1}_g_value_dup_boxed"]
    pub fn g_value_dup_boxed(value: *const GValue) -> gpointer;
}
extern "C" {
    #[link_name = "\u{1}_g_boxed_type_register_static"]
    pub fn g_boxed_type_register_static(
        name: *const gchar,
        boxed_copy: GBoxedCopyFunc,
        boxed_free: GBoxedFreeFunc,
    ) -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_closure_get_type"]
    pub fn g_closure_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_value_get_type"]
    pub fn g_value_get_type() -> GType;
}
pub type GObject = _GObject;
pub type GObjectClass = _GObjectClass;
pub type GInitiallyUnowned = _GObject;
pub type GInitiallyUnownedClass = _GObjectClass;
pub type GObjectConstructParam = _GObjectConstructParam;
/// GObjectGetPropertyFunc:
/// @object: a #GObject
/// @property_id: the numeric id under which the property was registered with
/// g_object_class_install_property().
/// @value: a #GValue to return the property value in
/// @pspec: the #GParamSpec describing the property
///
/// The type of the @get_property function of #GObjectClass.
pub type GObjectGetPropertyFunc = ::std::option::Option<
    unsafe extern "C" fn(
        object: *mut GObject,
        property_id: guint,
        value: *mut GValue,
        pspec: *mut GParamSpec,
    ),
>;
/// GObjectSetPropertyFunc:
/// @object: a #GObject
/// @property_id: the numeric id under which the property was registered with
/// g_object_class_install_property().
/// @value: the new value for the property
/// @pspec: the #GParamSpec describing the property
///
/// The type of the @set_property function of #GObjectClass.
pub type GObjectSetPropertyFunc = ::std::option::Option<
    unsafe extern "C" fn(
        object: *mut GObject,
        property_id: guint,
        value: *const GValue,
        pspec: *mut GParamSpec,
    ),
>;
/// GObjectFinalizeFunc:
/// @object: the #GObject being finalized
///
/// The type of the @finalize function of #GObjectClass.
pub type GObjectFinalizeFunc = ::std::option::Option<unsafe extern "C" fn(object: *mut GObject)>;
/// GWeakNotify:
/// @data: data that was provided when the weak reference was established
/// @where_the_object_was: the object being finalized
///
/// A #GWeakNotify function can be added to an object as a callback that gets
/// triggered when the object is finalized. Since the object is already being
/// finalized when the #GWeakNotify is called, there's not much you could do
/// with the object, apart from e.g. using its address as hash-index or the like.
pub type GWeakNotify =
    ::std::option::Option<unsafe extern "C" fn(data: gpointer, where_the_object_was: *mut GObject)>;
/// GObject:
///
/// All the fields in the GObject structure are private
/// to the #GObject implementation and should never be accessed directly.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GObject {
    pub g_type_instance: GTypeInstance,
    pub ref_count: guint,
    pub qdata: *mut GData,
}
#[test]
fn bindgen_test_layout__GObject() {
    assert_eq!(
        ::std::mem::size_of::<_GObject>(),
        24usize,
        concat!("Size of: ", stringify!(_GObject))
    );
    assert_eq!(
        ::std::mem::align_of::<_GObject>(),
        8usize,
        concat!("Alignment of ", stringify!(_GObject))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GObject>())).g_type_instance as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GObject),
            "::",
            stringify!(g_type_instance)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GObject>())).ref_count as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GObject),
            "::",
            stringify!(ref_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GObject>())).qdata as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GObject),
            "::",
            stringify!(qdata)
        )
    );
}
/// GObjectClass:
/// @g_type_class: the parent class
/// @constructor: the @constructor function is called by g_object_new () to
/// complete the object initialization after all the construction properties are
/// set. The first thing a @constructor implementation must do is chain up to the
/// @constructor of the parent class. Overriding @constructor should be rarely
/// needed, e.g. to handle construct properties, or to implement singletons.
/// @set_property: the generic setter for all properties of this type. Should be
/// overridden for every type with properties. If implementations of
/// @set_property don't emit property change notification explicitly, this will
/// be done implicitly by the type system. However, if the notify signal is
/// emitted explicitly, the type system will not emit it a second time.
/// @get_property: the generic getter for all properties of this type. Should be
/// overridden for every type with properties.
/// @dispose: the @dispose function is supposed to drop all references to other
/// objects, but keep the instance otherwise intact, so that client method
/// invocations still work. It may be run multiple times (due to reference
/// loops). Before returning, @dispose should chain up to the @dispose method
/// of the parent class.
/// @finalize: instance finalization function, should finish the finalization of
/// the instance begun in @dispose and chain up to the @finalize method of the
/// parent class.
/// @dispatch_properties_changed: emits property change notification for a bunch
/// of properties. Overriding @dispatch_properties_changed should be rarely
/// needed.
/// @notify: the class closure for the notify signal
/// @constructed: the @constructed function is called by g_object_new() as the
/// final step of the object creation process.  At the point of the call, all
/// construction properties have been set on the object.  The purpose of this
/// call is to allow for object initialisation steps that can only be performed
/// after construction properties have been set.  @constructed implementors
/// should chain up to the @constructed call of their parent class to allow it
/// to complete its initialisation.
///
/// The class structure for the GObject type.
///
/// <example>
/// <title>Implementing singletons using a constructor</title>
/// <programlisting>
/// static MySingleton *the_singleton = NULL;
///
/// static GObject*
/// my_singleton_constructor (GType                  type,
/// guint                  n_construct_params,
/// GObjectConstructParam *construct_params)
/// {
/// GObject *object;
///
/// if (!the_singleton)
/// {
/// object = G_OBJECT_CLASS (parent_class)->constructor (type,
/// n_construct_params,
/// construct_params);
/// the_singleton = MY_SINGLETON (object);
/// }
/// else
/// object = g_object_ref (G_OBJECT (the_singleton));
///
/// return object;
/// }
/// </programlisting></example>
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GObjectClass {
    pub g_type_class: GTypeClass,
    pub construct_properties: *mut GSList,
    pub constructor: ::std::option::Option<
        unsafe extern "C" fn(
            type_: GType,
            n_construct_properties: guint,
            construct_properties: *mut GObjectConstructParam,
        ) -> *mut GObject,
    >,
    pub set_property: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut GObject,
            property_id: guint,
            value: *const GValue,
            pspec: *mut GParamSpec,
        ),
    >,
    pub get_property: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut GObject,
            property_id: guint,
            value: *mut GValue,
            pspec: *mut GParamSpec,
        ),
    >,
    pub dispose: ::std::option::Option<unsafe extern "C" fn(object: *mut GObject)>,
    pub finalize: ::std::option::Option<unsafe extern "C" fn(object: *mut GObject)>,
    pub dispatch_properties_changed: ::std::option::Option<
        unsafe extern "C" fn(object: *mut GObject, n_pspecs: guint, pspecs: *mut *mut GParamSpec),
    >,
    pub notify:
        ::std::option::Option<unsafe extern "C" fn(object: *mut GObject, pspec: *mut GParamSpec)>,
    pub constructed: ::std::option::Option<unsafe extern "C" fn(object: *mut GObject)>,
    pub flags: gsize,
    pub pdummy: [gpointer; 6usize],
}
#[test]
fn bindgen_test_layout__GObjectClass() {
    assert_eq!(
        ::std::mem::size_of::<_GObjectClass>(),
        136usize,
        concat!("Size of: ", stringify!(_GObjectClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_GObjectClass>(),
        8usize,
        concat!("Alignment of ", stringify!(_GObjectClass))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GObjectClass>())).g_type_class as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GObjectClass),
            "::",
            stringify!(g_type_class)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GObjectClass>())).construct_properties as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GObjectClass),
            "::",
            stringify!(construct_properties)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GObjectClass>())).constructor as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GObjectClass),
            "::",
            stringify!(constructor)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GObjectClass>())).set_property as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GObjectClass),
            "::",
            stringify!(set_property)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GObjectClass>())).get_property as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_GObjectClass),
            "::",
            stringify!(get_property)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GObjectClass>())).dispose as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_GObjectClass),
            "::",
            stringify!(dispose)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GObjectClass>())).finalize as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_GObjectClass),
            "::",
            stringify!(finalize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GObjectClass>())).dispatch_properties_changed as *const _
                as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_GObjectClass),
            "::",
            stringify!(dispatch_properties_changed)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GObjectClass>())).notify as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_GObjectClass),
            "::",
            stringify!(notify)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GObjectClass>())).constructed as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_GObjectClass),
            "::",
            stringify!(constructed)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GObjectClass>())).flags as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_GObjectClass),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GObjectClass>())).pdummy as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_GObjectClass),
            "::",
            stringify!(pdummy)
        )
    );
}
/// GObjectConstructParam:
/// @pspec: the #GParamSpec of the construct parameter
/// @value: the value to set the parameter to
///
/// The GObjectConstructParam struct is an auxiliary
/// structure used to hand #GParamSpec/#GValue pairs to the @constructor of
/// a #GObjectClass.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GObjectConstructParam {
    pub pspec: *mut GParamSpec,
    pub value: *mut GValue,
}
#[test]
fn bindgen_test_layout__GObjectConstructParam() {
    assert_eq!(
        ::std::mem::size_of::<_GObjectConstructParam>(),
        16usize,
        concat!("Size of: ", stringify!(_GObjectConstructParam))
    );
    assert_eq!(
        ::std::mem::align_of::<_GObjectConstructParam>(),
        8usize,
        concat!("Alignment of ", stringify!(_GObjectConstructParam))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GObjectConstructParam>())).pspec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GObjectConstructParam),
            "::",
            stringify!(pspec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GObjectConstructParam>())).value as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GObjectConstructParam),
            "::",
            stringify!(value)
        )
    );
}
extern "C" {
    /// GInitiallyUnowned:
    ///
    /// All the fields in the GInitiallyUnowned structure
    /// are private to the #GInitiallyUnowned implementation and should never be
    /// accessed directly.
    /// /
    /// /**
    /// GInitiallyUnownedClass:
    ///
    /// The class structure for the GInitiallyUnowned type.
    #[link_name = "\u{1}_g_initially_unowned_get_type"]
    pub fn g_initially_unowned_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_object_class_install_property"]
    pub fn g_object_class_install_property(
        oclass: *mut GObjectClass,
        property_id: guint,
        pspec: *mut GParamSpec,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_object_class_find_property"]
    pub fn g_object_class_find_property(
        oclass: *mut GObjectClass,
        property_name: *const gchar,
    ) -> *mut GParamSpec;
}
extern "C" {
    #[link_name = "\u{1}_g_object_class_list_properties"]
    pub fn g_object_class_list_properties(
        oclass: *mut GObjectClass,
        n_properties: *mut guint,
    ) -> *mut *mut GParamSpec;
}
extern "C" {
    #[link_name = "\u{1}_g_object_class_override_property"]
    pub fn g_object_class_override_property(
        oclass: *mut GObjectClass,
        property_id: guint,
        name: *const gchar,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_object_class_install_properties"]
    pub fn g_object_class_install_properties(
        oclass: *mut GObjectClass,
        n_pspecs: guint,
        pspecs: *mut *mut GParamSpec,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_object_interface_install_property"]
    pub fn g_object_interface_install_property(g_iface: gpointer, pspec: *mut GParamSpec);
}
extern "C" {
    #[link_name = "\u{1}_g_object_interface_find_property"]
    pub fn g_object_interface_find_property(
        g_iface: gpointer,
        property_name: *const gchar,
    ) -> *mut GParamSpec;
}
extern "C" {
    #[link_name = "\u{1}_g_object_interface_list_properties"]
    pub fn g_object_interface_list_properties(
        g_iface: gpointer,
        n_properties_p: *mut guint,
    ) -> *mut *mut GParamSpec;
}
extern "C" {
    #[link_name = "\u{1}_g_object_get_type"]
    pub fn g_object_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_object_new"]
    pub fn g_object_new(object_type: GType, first_property_name: *const gchar, ...) -> gpointer;
}
extern "C" {
    #[link_name = "\u{1}_g_object_new_with_properties"]
    pub fn g_object_new_with_properties(
        object_type: GType,
        n_properties: guint,
        names: *mut *const ::std::os::raw::c_char,
        values: *const GValue,
    ) -> *mut GObject;
}
extern "C" {
    #[link_name = "\u{1}_g_object_newv"]
    pub fn g_object_newv(
        object_type: GType,
        n_parameters: guint,
        parameters: *mut GParameter,
    ) -> gpointer;
}
extern "C" {
    #[link_name = "\u{1}_g_object_new_valist"]
    pub fn g_object_new_valist(
        object_type: GType,
        first_property_name: *const gchar,
        var_args: *mut __va_list_tag,
    ) -> *mut GObject;
}
extern "C" {
    #[link_name = "\u{1}_g_object_set"]
    pub fn g_object_set(object: gpointer, first_property_name: *const gchar, ...);
}
extern "C" {
    #[link_name = "\u{1}_g_object_get"]
    pub fn g_object_get(object: gpointer, first_property_name: *const gchar, ...);
}
extern "C" {
    #[link_name = "\u{1}_g_object_connect"]
    pub fn g_object_connect(object: gpointer, signal_spec: *const gchar, ...) -> gpointer;
}
extern "C" {
    #[link_name = "\u{1}_g_object_disconnect"]
    pub fn g_object_disconnect(object: gpointer, signal_spec: *const gchar, ...);
}
extern "C" {
    #[link_name = "\u{1}_g_object_setv"]
    pub fn g_object_setv(
        object: *mut GObject,
        n_properties: guint,
        names: *mut *const gchar,
        values: *const GValue,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_object_set_valist"]
    pub fn g_object_set_valist(
        object: *mut GObject,
        first_property_name: *const gchar,
        var_args: *mut __va_list_tag,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_object_getv"]
    pub fn g_object_getv(
        object: *mut GObject,
        n_properties: guint,
        names: *mut *const gchar,
        values: *mut GValue,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_object_get_valist"]
    pub fn g_object_get_valist(
        object: *mut GObject,
        first_property_name: *const gchar,
        var_args: *mut __va_list_tag,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_object_set_property"]
    pub fn g_object_set_property(
        object: *mut GObject,
        property_name: *const gchar,
        value: *const GValue,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_object_get_property"]
    pub fn g_object_get_property(
        object: *mut GObject,
        property_name: *const gchar,
        value: *mut GValue,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_object_freeze_notify"]
    pub fn g_object_freeze_notify(object: *mut GObject);
}
extern "C" {
    #[link_name = "\u{1}_g_object_notify"]
    pub fn g_object_notify(object: *mut GObject, property_name: *const gchar);
}
extern "C" {
    #[link_name = "\u{1}_g_object_notify_by_pspec"]
    pub fn g_object_notify_by_pspec(object: *mut GObject, pspec: *mut GParamSpec);
}
extern "C" {
    #[link_name = "\u{1}_g_object_thaw_notify"]
    pub fn g_object_thaw_notify(object: *mut GObject);
}
extern "C" {
    #[link_name = "\u{1}_g_object_is_floating"]
    pub fn g_object_is_floating(object: gpointer) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_object_ref_sink"]
    pub fn g_object_ref_sink(object: gpointer) -> gpointer;
}
extern "C" {
    #[link_name = "\u{1}_g_object_ref"]
    pub fn g_object_ref(object: gpointer) -> gpointer;
}
extern "C" {
    #[link_name = "\u{1}_g_object_unref"]
    pub fn g_object_unref(object: gpointer);
}
extern "C" {
    #[link_name = "\u{1}_g_object_weak_ref"]
    pub fn g_object_weak_ref(object: *mut GObject, notify: GWeakNotify, data: gpointer);
}
extern "C" {
    #[link_name = "\u{1}_g_object_weak_unref"]
    pub fn g_object_weak_unref(object: *mut GObject, notify: GWeakNotify, data: gpointer);
}
extern "C" {
    #[link_name = "\u{1}_g_object_add_weak_pointer"]
    pub fn g_object_add_weak_pointer(object: *mut GObject, weak_pointer_location: *mut gpointer);
}
extern "C" {
    #[link_name = "\u{1}_g_object_remove_weak_pointer"]
    pub fn g_object_remove_weak_pointer(object: *mut GObject, weak_pointer_location: *mut gpointer);
}
/// GToggleNotify:
/// @data: Callback data passed to g_object_add_toggle_ref()
/// @object: The object on which g_object_add_toggle_ref() was called.
/// @is_last_ref: %TRUE if the toggle reference is now the
/// last reference to the object. %FALSE if the toggle
/// reference was the last reference and there are now other
/// references.
///
/// A callback function used for notification when the state
/// of a toggle reference changes. See g_object_add_toggle_ref().
pub type GToggleNotify = ::std::option::Option<
    unsafe extern "C" fn(data: gpointer, object: *mut GObject, is_last_ref: gboolean),
>;
extern "C" {
    #[link_name = "\u{1}_g_object_add_toggle_ref"]
    pub fn g_object_add_toggle_ref(object: *mut GObject, notify: GToggleNotify, data: gpointer);
}
extern "C" {
    #[link_name = "\u{1}_g_object_remove_toggle_ref"]
    pub fn g_object_remove_toggle_ref(object: *mut GObject, notify: GToggleNotify, data: gpointer);
}
extern "C" {
    #[link_name = "\u{1}_g_object_get_qdata"]
    pub fn g_object_get_qdata(object: *mut GObject, quark: GQuark) -> gpointer;
}
extern "C" {
    #[link_name = "\u{1}_g_object_set_qdata"]
    pub fn g_object_set_qdata(object: *mut GObject, quark: GQuark, data: gpointer);
}
extern "C" {
    #[link_name = "\u{1}_g_object_set_qdata_full"]
    pub fn g_object_set_qdata_full(
        object: *mut GObject,
        quark: GQuark,
        data: gpointer,
        destroy: GDestroyNotify,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_object_steal_qdata"]
    pub fn g_object_steal_qdata(object: *mut GObject, quark: GQuark) -> gpointer;
}
extern "C" {
    #[link_name = "\u{1}_g_object_dup_qdata"]
    pub fn g_object_dup_qdata(
        object: *mut GObject,
        quark: GQuark,
        dup_func: GDuplicateFunc,
        user_data: gpointer,
    ) -> gpointer;
}
extern "C" {
    #[link_name = "\u{1}_g_object_replace_qdata"]
    pub fn g_object_replace_qdata(
        object: *mut GObject,
        quark: GQuark,
        oldval: gpointer,
        newval: gpointer,
        destroy: GDestroyNotify,
        old_destroy: *mut GDestroyNotify,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_object_get_data"]
    pub fn g_object_get_data(object: *mut GObject, key: *const gchar) -> gpointer;
}
extern "C" {
    #[link_name = "\u{1}_g_object_set_data"]
    pub fn g_object_set_data(object: *mut GObject, key: *const gchar, data: gpointer);
}
extern "C" {
    #[link_name = "\u{1}_g_object_set_data_full"]
    pub fn g_object_set_data_full(
        object: *mut GObject,
        key: *const gchar,
        data: gpointer,
        destroy: GDestroyNotify,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_object_steal_data"]
    pub fn g_object_steal_data(object: *mut GObject, key: *const gchar) -> gpointer;
}
extern "C" {
    #[link_name = "\u{1}_g_object_dup_data"]
    pub fn g_object_dup_data(
        object: *mut GObject,
        key: *const gchar,
        dup_func: GDuplicateFunc,
        user_data: gpointer,
    ) -> gpointer;
}
extern "C" {
    #[link_name = "\u{1}_g_object_replace_data"]
    pub fn g_object_replace_data(
        object: *mut GObject,
        key: *const gchar,
        oldval: gpointer,
        newval: gpointer,
        destroy: GDestroyNotify,
        old_destroy: *mut GDestroyNotify,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_object_watch_closure"]
    pub fn g_object_watch_closure(object: *mut GObject, closure: *mut GClosure);
}
extern "C" {
    #[link_name = "\u{1}_g_cclosure_new_object"]
    pub fn g_cclosure_new_object(callback_func: GCallback, object: *mut GObject) -> *mut GClosure;
}
extern "C" {
    #[link_name = "\u{1}_g_cclosure_new_object_swap"]
    pub fn g_cclosure_new_object_swap(
        callback_func: GCallback,
        object: *mut GObject,
    ) -> *mut GClosure;
}
extern "C" {
    #[link_name = "\u{1}_g_closure_new_object"]
    pub fn g_closure_new_object(sizeof_closure: guint, object: *mut GObject) -> *mut GClosure;
}
extern "C" {
    #[link_name = "\u{1}_g_value_set_object"]
    pub fn g_value_set_object(value: *mut GValue, v_object: gpointer);
}
extern "C" {
    #[link_name = "\u{1}_g_value_get_object"]
    pub fn g_value_get_object(value: *const GValue) -> gpointer;
}
extern "C" {
    #[link_name = "\u{1}_g_value_dup_object"]
    pub fn g_value_dup_object(value: *const GValue) -> gpointer;
}
extern "C" {
    #[link_name = "\u{1}_g_signal_connect_object"]
    pub fn g_signal_connect_object(
        instance: gpointer,
        detailed_signal: *const gchar,
        c_handler: GCallback,
        gobject: gpointer,
        connect_flags: GConnectFlags,
    ) -> gulong;
}
extern "C" {
    #[link_name = "\u{1}_g_object_force_floating"]
    pub fn g_object_force_floating(object: *mut GObject);
}
extern "C" {
    #[link_name = "\u{1}_g_object_run_dispose"]
    pub fn g_object_run_dispose(object: *mut GObject);
}
extern "C" {
    #[link_name = "\u{1}_g_value_take_object"]
    pub fn g_value_take_object(value: *mut GValue, v_object: gpointer);
}
extern "C" {
    #[link_name = "\u{1}_g_value_set_object_take_ownership"]
    pub fn g_value_set_object_take_ownership(value: *mut GValue, v_object: gpointer);
}
extern "C" {
    #[link_name = "\u{1}_g_object_compat_control"]
    pub fn g_object_compat_control(what: gsize, data: gpointer) -> gsize;
}
extern "C" {
    #[link_name = "\u{1}_g_clear_object"]
    pub fn g_clear_object(object_ptr: *mut *mut GObject);
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct GWeakRef {
    pub priv_: GWeakRef__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union GWeakRef__bindgen_ty_1 {
    pub p: gpointer,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_GWeakRef__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<GWeakRef__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(GWeakRef__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<GWeakRef__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(GWeakRef__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GWeakRef__bindgen_ty_1>())).p as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GWeakRef__bindgen_ty_1),
            "::",
            stringify!(p)
        )
    );
}
#[test]
fn bindgen_test_layout_GWeakRef() {
    assert_eq!(
        ::std::mem::size_of::<GWeakRef>(),
        8usize,
        concat!("Size of: ", stringify!(GWeakRef))
    );
    assert_eq!(
        ::std::mem::align_of::<GWeakRef>(),
        8usize,
        concat!("Alignment of ", stringify!(GWeakRef))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GWeakRef>())).priv_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GWeakRef),
            "::",
            stringify!(priv_)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_g_weak_ref_init"]
    pub fn g_weak_ref_init(weak_ref: *mut GWeakRef, object: gpointer);
}
extern "C" {
    #[link_name = "\u{1}_g_weak_ref_clear"]
    pub fn g_weak_ref_clear(weak_ref: *mut GWeakRef);
}
extern "C" {
    #[link_name = "\u{1}_g_weak_ref_get"]
    pub fn g_weak_ref_get(weak_ref: *mut GWeakRef) -> gpointer;
}
extern "C" {
    #[link_name = "\u{1}_g_weak_ref_set"]
    pub fn g_weak_ref_set(weak_ref: *mut GWeakRef, object: gpointer);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GBinding {
    _unused: [u8; 0],
}
/// GBinding:
///
/// GBinding is an opaque structure whose members
/// cannot be accessed directly.
///
/// Since: 2.26
pub type GBinding = _GBinding;
/// GBindingTransformFunc:
/// @binding: a #GBinding
/// @from_value: the #GValue containing the value to transform
/// @to_value: the #GValue in which to store the transformed value
/// @user_data: data passed to the transform function
///
/// A function to be called to transform @from_value to @to_value. If
/// this is the @transform_to function of a binding, then @from_value
/// is the @source_property on the @source object, and @to_value is the
/// @target_property on the @target object. If this is the
/// @transform_from function of a %G_BINDING_BIDIRECTIONAL binding,
/// then those roles are reversed.
///
/// Returns: %TRUE if the transformation was successful, and %FALSE
/// otherwise
///
/// Since: 2.26
pub type GBindingTransformFunc = ::std::option::Option<
    unsafe extern "C" fn(
        binding: *mut GBinding,
        from_value: *const GValue,
        to_value: *mut GValue,
        user_data: gpointer,
    ) -> gboolean,
>;
pub const GBindingFlags_G_BINDING_DEFAULT: GBindingFlags = 0;
pub const GBindingFlags_G_BINDING_BIDIRECTIONAL: GBindingFlags = 1;
pub const GBindingFlags_G_BINDING_SYNC_CREATE: GBindingFlags = 2;
pub const GBindingFlags_G_BINDING_INVERT_BOOLEAN: GBindingFlags = 4;
/// GBindingFlags:
/// @G_BINDING_DEFAULT: The default binding; if the source property
/// changes, the target property is updated with its value.
/// @G_BINDING_BIDIRECTIONAL: Bidirectional binding; if either the
/// property of the source or the property of the target changes,
/// the other is updated.
/// @G_BINDING_SYNC_CREATE: Synchronize the values of the source and
/// target properties when creating the binding; the direction of
/// the synchronization is always from the source to the target.
/// @G_BINDING_INVERT_BOOLEAN: If the two properties being bound are
/// booleans, setting one to %TRUE will result in the other being
/// set to %FALSE and vice versa. This flag will only work for
/// boolean properties, and cannot be used when passing custom
/// transformation functions to g_object_bind_property_full().
///
/// Flags to be passed to g_object_bind_property() or
/// g_object_bind_property_full().
///
/// This enumeration can be extended at later date.
///
/// Since: 2.26
pub type GBindingFlags = u32;
extern "C" {
    #[link_name = "\u{1}_g_binding_flags_get_type"]
    pub fn g_binding_flags_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_binding_get_type"]
    pub fn g_binding_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_binding_get_flags"]
    pub fn g_binding_get_flags(binding: *mut GBinding) -> GBindingFlags;
}
extern "C" {
    #[link_name = "\u{1}_g_binding_get_source"]
    pub fn g_binding_get_source(binding: *mut GBinding) -> *mut GObject;
}
extern "C" {
    #[link_name = "\u{1}_g_binding_get_target"]
    pub fn g_binding_get_target(binding: *mut GBinding) -> *mut GObject;
}
extern "C" {
    #[link_name = "\u{1}_g_binding_get_source_property"]
    pub fn g_binding_get_source_property(binding: *mut GBinding) -> *const gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_binding_get_target_property"]
    pub fn g_binding_get_target_property(binding: *mut GBinding) -> *const gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_binding_unbind"]
    pub fn g_binding_unbind(binding: *mut GBinding);
}
extern "C" {
    #[link_name = "\u{1}_g_object_bind_property"]
    pub fn g_object_bind_property(
        source: gpointer,
        source_property: *const gchar,
        target: gpointer,
        target_property: *const gchar,
        flags: GBindingFlags,
    ) -> *mut GBinding;
}
extern "C" {
    #[link_name = "\u{1}_g_object_bind_property_full"]
    pub fn g_object_bind_property_full(
        source: gpointer,
        source_property: *const gchar,
        target: gpointer,
        target_property: *const gchar,
        flags: GBindingFlags,
        transform_to: GBindingTransformFunc,
        transform_from: GBindingTransformFunc,
        user_data: gpointer,
        notify: GDestroyNotify,
    ) -> *mut GBinding;
}
extern "C" {
    #[link_name = "\u{1}_g_object_bind_property_with_closures"]
    pub fn g_object_bind_property_with_closures(
        source: gpointer,
        source_property: *const gchar,
        target: gpointer,
        target_property: *const gchar,
        flags: GBindingFlags,
        transform_to: *mut GClosure,
        transform_from: *mut GClosure,
    ) -> *mut GBinding;
}
pub type GEnumClass = _GEnumClass;
pub type GFlagsClass = _GFlagsClass;
pub type GEnumValue = _GEnumValue;
pub type GFlagsValue = _GFlagsValue;
/// GEnumClass:
/// @g_type_class: the parent class
/// @minimum: the smallest possible value.
/// @maximum: the largest possible value.
/// @n_values: the number of possible values.
/// @values: an array of #GEnumValue structs describing the
/// individual values.
///
/// The class of an enumeration type holds information about its
/// possible values.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GEnumClass {
    pub g_type_class: GTypeClass,
    pub minimum: gint,
    pub maximum: gint,
    pub n_values: guint,
    pub values: *mut GEnumValue,
}
#[test]
fn bindgen_test_layout__GEnumClass() {
    assert_eq!(
        ::std::mem::size_of::<_GEnumClass>(),
        32usize,
        concat!("Size of: ", stringify!(_GEnumClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_GEnumClass>(),
        8usize,
        concat!("Alignment of ", stringify!(_GEnumClass))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GEnumClass>())).g_type_class as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GEnumClass),
            "::",
            stringify!(g_type_class)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GEnumClass>())).minimum as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GEnumClass),
            "::",
            stringify!(minimum)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GEnumClass>())).maximum as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_GEnumClass),
            "::",
            stringify!(maximum)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GEnumClass>())).n_values as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GEnumClass),
            "::",
            stringify!(n_values)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GEnumClass>())).values as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GEnumClass),
            "::",
            stringify!(values)
        )
    );
}
/// GFlagsClass:
/// @g_type_class: the parent class
/// @mask: a mask covering all possible values.
/// @n_values: the number of possible values.
/// @values: an array of #GFlagsValue structs describing the
/// individual values.
///
/// The class of a flags type holds information about its
/// possible values.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GFlagsClass {
    pub g_type_class: GTypeClass,
    pub mask: guint,
    pub n_values: guint,
    pub values: *mut GFlagsValue,
}
#[test]
fn bindgen_test_layout__GFlagsClass() {
    assert_eq!(
        ::std::mem::size_of::<_GFlagsClass>(),
        24usize,
        concat!("Size of: ", stringify!(_GFlagsClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_GFlagsClass>(),
        8usize,
        concat!("Alignment of ", stringify!(_GFlagsClass))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GFlagsClass>())).g_type_class as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFlagsClass),
            "::",
            stringify!(g_type_class)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GFlagsClass>())).mask as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFlagsClass),
            "::",
            stringify!(mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GFlagsClass>())).n_values as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFlagsClass),
            "::",
            stringify!(n_values)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GFlagsClass>())).values as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFlagsClass),
            "::",
            stringify!(values)
        )
    );
}
/// GEnumValue:
/// @value: the enum value
/// @value_name: the name of the value
/// @value_nick: the nickname of the value
///
/// A structure which contains a single enum value, its name, and its
/// nickname.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GEnumValue {
    pub value: gint,
    pub value_name: *const gchar,
    pub value_nick: *const gchar,
}
#[test]
fn bindgen_test_layout__GEnumValue() {
    assert_eq!(
        ::std::mem::size_of::<_GEnumValue>(),
        24usize,
        concat!("Size of: ", stringify!(_GEnumValue))
    );
    assert_eq!(
        ::std::mem::align_of::<_GEnumValue>(),
        8usize,
        concat!("Alignment of ", stringify!(_GEnumValue))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GEnumValue>())).value as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GEnumValue),
            "::",
            stringify!(value)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GEnumValue>())).value_name as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GEnumValue),
            "::",
            stringify!(value_name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GEnumValue>())).value_nick as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GEnumValue),
            "::",
            stringify!(value_nick)
        )
    );
}
/// GFlagsValue:
/// @value: the flags value
/// @value_name: the name of the value
/// @value_nick: the nickname of the value
///
/// A structure which contains a single flags value, its name, and its
/// nickname.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GFlagsValue {
    pub value: guint,
    pub value_name: *const gchar,
    pub value_nick: *const gchar,
}
#[test]
fn bindgen_test_layout__GFlagsValue() {
    assert_eq!(
        ::std::mem::size_of::<_GFlagsValue>(),
        24usize,
        concat!("Size of: ", stringify!(_GFlagsValue))
    );
    assert_eq!(
        ::std::mem::align_of::<_GFlagsValue>(),
        8usize,
        concat!("Alignment of ", stringify!(_GFlagsValue))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GFlagsValue>())).value as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFlagsValue),
            "::",
            stringify!(value)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GFlagsValue>())).value_name as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFlagsValue),
            "::",
            stringify!(value_name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GFlagsValue>())).value_nick as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFlagsValue),
            "::",
            stringify!(value_nick)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_g_enum_get_value"]
    pub fn g_enum_get_value(enum_class: *mut GEnumClass, value: gint) -> *mut GEnumValue;
}
extern "C" {
    #[link_name = "\u{1}_g_enum_get_value_by_name"]
    pub fn g_enum_get_value_by_name(
        enum_class: *mut GEnumClass,
        name: *const gchar,
    ) -> *mut GEnumValue;
}
extern "C" {
    #[link_name = "\u{1}_g_enum_get_value_by_nick"]
    pub fn g_enum_get_value_by_nick(
        enum_class: *mut GEnumClass,
        nick: *const gchar,
    ) -> *mut GEnumValue;
}
extern "C" {
    #[link_name = "\u{1}_g_flags_get_first_value"]
    pub fn g_flags_get_first_value(flags_class: *mut GFlagsClass, value: guint)
        -> *mut GFlagsValue;
}
extern "C" {
    #[link_name = "\u{1}_g_flags_get_value_by_name"]
    pub fn g_flags_get_value_by_name(
        flags_class: *mut GFlagsClass,
        name: *const gchar,
    ) -> *mut GFlagsValue;
}
extern "C" {
    #[link_name = "\u{1}_g_flags_get_value_by_nick"]
    pub fn g_flags_get_value_by_nick(
        flags_class: *mut GFlagsClass,
        nick: *const gchar,
    ) -> *mut GFlagsValue;
}
extern "C" {
    #[link_name = "\u{1}_g_enum_to_string"]
    pub fn g_enum_to_string(g_enum_type: GType, value: gint) -> *mut gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_flags_to_string"]
    pub fn g_flags_to_string(flags_type: GType, value: guint) -> *mut gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_value_set_enum"]
    pub fn g_value_set_enum(value: *mut GValue, v_enum: gint);
}
extern "C" {
    #[link_name = "\u{1}_g_value_get_enum"]
    pub fn g_value_get_enum(value: *const GValue) -> gint;
}
extern "C" {
    #[link_name = "\u{1}_g_value_set_flags"]
    pub fn g_value_set_flags(value: *mut GValue, v_flags: guint);
}
extern "C" {
    #[link_name = "\u{1}_g_value_get_flags"]
    pub fn g_value_get_flags(value: *const GValue) -> guint;
}
extern "C" {
    #[link_name = "\u{1}_g_enum_register_static"]
    pub fn g_enum_register_static(
        name: *const gchar,
        const_static_values: *const GEnumValue,
    ) -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_flags_register_static"]
    pub fn g_flags_register_static(
        name: *const gchar,
        const_static_values: *const GFlagsValue,
    ) -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_enum_complete_type_info"]
    pub fn g_enum_complete_type_info(
        g_enum_type: GType,
        info: *mut GTypeInfo,
        const_values: *const GEnumValue,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_flags_complete_type_info"]
    pub fn g_flags_complete_type_info(
        g_flags_type: GType,
        info: *mut GTypeInfo,
        const_values: *const GFlagsValue,
    );
}
pub type GParamSpecChar = _GParamSpecChar;
pub type GParamSpecUChar = _GParamSpecUChar;
pub type GParamSpecBoolean = _GParamSpecBoolean;
pub type GParamSpecInt = _GParamSpecInt;
pub type GParamSpecUInt = _GParamSpecUInt;
pub type GParamSpecLong = _GParamSpecLong;
pub type GParamSpecULong = _GParamSpecULong;
pub type GParamSpecInt64 = _GParamSpecInt64;
pub type GParamSpecUInt64 = _GParamSpecUInt64;
pub type GParamSpecUnichar = _GParamSpecUnichar;
pub type GParamSpecEnum = _GParamSpecEnum;
pub type GParamSpecFlags = _GParamSpecFlags;
pub type GParamSpecFloat = _GParamSpecFloat;
pub type GParamSpecDouble = _GParamSpecDouble;
pub type GParamSpecString = _GParamSpecString;
pub type GParamSpecParam = _GParamSpecParam;
pub type GParamSpecBoxed = _GParamSpecBoxed;
pub type GParamSpecPointer = _GParamSpecPointer;
pub type GParamSpecValueArray = _GParamSpecValueArray;
pub type GParamSpecObject = _GParamSpecObject;
pub type GParamSpecOverride = _GParamSpecOverride;
pub type GParamSpecGType = _GParamSpecGType;
pub type GParamSpecVariant = _GParamSpecVariant;
/// GParamSpecChar:
/// @parent_instance: private #GParamSpec portion
/// @minimum: minimum value for the property specified
/// @maximum: maximum value for the property specified
/// @default_value: default value for the property specified
///
/// A #GParamSpec derived structure that contains the meta data for character properties.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GParamSpecChar {
    pub parent_instance: GParamSpec,
    pub minimum: gint8,
    pub maximum: gint8,
    pub default_value: gint8,
}
#[test]
fn bindgen_test_layout__GParamSpecChar() {
    assert_eq!(
        ::std::mem::size_of::<_GParamSpecChar>(),
        80usize,
        concat!("Size of: ", stringify!(_GParamSpecChar))
    );
    assert_eq!(
        ::std::mem::align_of::<_GParamSpecChar>(),
        8usize,
        concat!("Alignment of ", stringify!(_GParamSpecChar))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GParamSpecChar>())).parent_instance as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecChar),
            "::",
            stringify!(parent_instance)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GParamSpecChar>())).minimum as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecChar),
            "::",
            stringify!(minimum)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GParamSpecChar>())).maximum as *const _ as usize },
        73usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecChar),
            "::",
            stringify!(maximum)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GParamSpecChar>())).default_value as *const _ as usize },
        74usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecChar),
            "::",
            stringify!(default_value)
        )
    );
}
/// GParamSpecUChar:
/// @parent_instance: private #GParamSpec portion
/// @minimum: minimum value for the property specified
/// @maximum: maximum value for the property specified
/// @default_value: default value for the property specified
///
/// A #GParamSpec derived structure that contains the meta data for unsigned character properties.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GParamSpecUChar {
    pub parent_instance: GParamSpec,
    pub minimum: guint8,
    pub maximum: guint8,
    pub default_value: guint8,
}
#[test]
fn bindgen_test_layout__GParamSpecUChar() {
    assert_eq!(
        ::std::mem::size_of::<_GParamSpecUChar>(),
        80usize,
        concat!("Size of: ", stringify!(_GParamSpecUChar))
    );
    assert_eq!(
        ::std::mem::align_of::<_GParamSpecUChar>(),
        8usize,
        concat!("Alignment of ", stringify!(_GParamSpecUChar))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GParamSpecUChar>())).parent_instance as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecUChar),
            "::",
            stringify!(parent_instance)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GParamSpecUChar>())).minimum as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecUChar),
            "::",
            stringify!(minimum)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GParamSpecUChar>())).maximum as *const _ as usize },
        73usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecUChar),
            "::",
            stringify!(maximum)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GParamSpecUChar>())).default_value as *const _ as usize },
        74usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecUChar),
            "::",
            stringify!(default_value)
        )
    );
}
/// GParamSpecBoolean:
/// @parent_instance: private #GParamSpec portion
/// @default_value: default value for the property specified
///
/// A #GParamSpec derived structure that contains the meta data for boolean properties.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GParamSpecBoolean {
    pub parent_instance: GParamSpec,
    pub default_value: gboolean,
}
#[test]
fn bindgen_test_layout__GParamSpecBoolean() {
    assert_eq!(
        ::std::mem::size_of::<_GParamSpecBoolean>(),
        80usize,
        concat!("Size of: ", stringify!(_GParamSpecBoolean))
    );
    assert_eq!(
        ::std::mem::align_of::<_GParamSpecBoolean>(),
        8usize,
        concat!("Alignment of ", stringify!(_GParamSpecBoolean))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GParamSpecBoolean>())).parent_instance as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecBoolean),
            "::",
            stringify!(parent_instance)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GParamSpecBoolean>())).default_value as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecBoolean),
            "::",
            stringify!(default_value)
        )
    );
}
/// GParamSpecInt:
/// @parent_instance: private #GParamSpec portion
/// @minimum: minimum value for the property specified
/// @maximum: maximum value for the property specified
/// @default_value: default value for the property specified
///
/// A #GParamSpec derived structure that contains the meta data for integer properties.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GParamSpecInt {
    pub parent_instance: GParamSpec,
    pub minimum: gint,
    pub maximum: gint,
    pub default_value: gint,
}
#[test]
fn bindgen_test_layout__GParamSpecInt() {
    assert_eq!(
        ::std::mem::size_of::<_GParamSpecInt>(),
        88usize,
        concat!("Size of: ", stringify!(_GParamSpecInt))
    );
    assert_eq!(
        ::std::mem::align_of::<_GParamSpecInt>(),
        8usize,
        concat!("Alignment of ", stringify!(_GParamSpecInt))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GParamSpecInt>())).parent_instance as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecInt),
            "::",
            stringify!(parent_instance)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GParamSpecInt>())).minimum as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecInt),
            "::",
            stringify!(minimum)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GParamSpecInt>())).maximum as *const _ as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecInt),
            "::",
            stringify!(maximum)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GParamSpecInt>())).default_value as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecInt),
            "::",
            stringify!(default_value)
        )
    );
}
/// GParamSpecUInt:
/// @parent_instance: private #GParamSpec portion
/// @minimum: minimum value for the property specified
/// @maximum: maximum value for the property specified
/// @default_value: default value for the property specified
///
/// A #GParamSpec derived structure that contains the meta data for unsigned integer properties.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GParamSpecUInt {
    pub parent_instance: GParamSpec,
    pub minimum: guint,
    pub maximum: guint,
    pub default_value: guint,
}
#[test]
fn bindgen_test_layout__GParamSpecUInt() {
    assert_eq!(
        ::std::mem::size_of::<_GParamSpecUInt>(),
        88usize,
        concat!("Size of: ", stringify!(_GParamSpecUInt))
    );
    assert_eq!(
        ::std::mem::align_of::<_GParamSpecUInt>(),
        8usize,
        concat!("Alignment of ", stringify!(_GParamSpecUInt))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GParamSpecUInt>())).parent_instance as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecUInt),
            "::",
            stringify!(parent_instance)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GParamSpecUInt>())).minimum as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecUInt),
            "::",
            stringify!(minimum)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GParamSpecUInt>())).maximum as *const _ as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecUInt),
            "::",
            stringify!(maximum)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GParamSpecUInt>())).default_value as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecUInt),
            "::",
            stringify!(default_value)
        )
    );
}
/// GParamSpecLong:
/// @parent_instance: private #GParamSpec portion
/// @minimum: minimum value for the property specified
/// @maximum: maximum value for the property specified
/// @default_value: default value for the property specified
///
/// A #GParamSpec derived structure that contains the meta data for long integer properties.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GParamSpecLong {
    pub parent_instance: GParamSpec,
    pub minimum: glong,
    pub maximum: glong,
    pub default_value: glong,
}
#[test]
fn bindgen_test_layout__GParamSpecLong() {
    assert_eq!(
        ::std::mem::size_of::<_GParamSpecLong>(),
        96usize,
        concat!("Size of: ", stringify!(_GParamSpecLong))
    );
    assert_eq!(
        ::std::mem::align_of::<_GParamSpecLong>(),
        8usize,
        concat!("Alignment of ", stringify!(_GParamSpecLong))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GParamSpecLong>())).parent_instance as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecLong),
            "::",
            stringify!(parent_instance)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GParamSpecLong>())).minimum as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecLong),
            "::",
            stringify!(minimum)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GParamSpecLong>())).maximum as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecLong),
            "::",
            stringify!(maximum)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GParamSpecLong>())).default_value as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecLong),
            "::",
            stringify!(default_value)
        )
    );
}
/// GParamSpecULong:
/// @parent_instance: private #GParamSpec portion
/// @minimum: minimum value for the property specified
/// @maximum: maximum value for the property specified
/// @default_value: default value for the property specified
///
/// A #GParamSpec derived structure that contains the meta data for unsigned long integer properties.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GParamSpecULong {
    pub parent_instance: GParamSpec,
    pub minimum: gulong,
    pub maximum: gulong,
    pub default_value: gulong,
}
#[test]
fn bindgen_test_layout__GParamSpecULong() {
    assert_eq!(
        ::std::mem::size_of::<_GParamSpecULong>(),
        96usize,
        concat!("Size of: ", stringify!(_GParamSpecULong))
    );
    assert_eq!(
        ::std::mem::align_of::<_GParamSpecULong>(),
        8usize,
        concat!("Alignment of ", stringify!(_GParamSpecULong))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GParamSpecULong>())).parent_instance as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecULong),
            "::",
            stringify!(parent_instance)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GParamSpecULong>())).minimum as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecULong),
            "::",
            stringify!(minimum)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GParamSpecULong>())).maximum as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecULong),
            "::",
            stringify!(maximum)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GParamSpecULong>())).default_value as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecULong),
            "::",
            stringify!(default_value)
        )
    );
}
/// GParamSpecInt64:
/// @parent_instance: private #GParamSpec portion
/// @minimum: minimum value for the property specified
/// @maximum: maximum value for the property specified
/// @default_value: default value for the property specified
///
/// A #GParamSpec derived structure that contains the meta data for 64bit integer properties.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GParamSpecInt64 {
    pub parent_instance: GParamSpec,
    pub minimum: gint64,
    pub maximum: gint64,
    pub default_value: gint64,
}
#[test]
fn bindgen_test_layout__GParamSpecInt64() {
    assert_eq!(
        ::std::mem::size_of::<_GParamSpecInt64>(),
        96usize,
        concat!("Size of: ", stringify!(_GParamSpecInt64))
    );
    assert_eq!(
        ::std::mem::align_of::<_GParamSpecInt64>(),
        8usize,
        concat!("Alignment of ", stringify!(_GParamSpecInt64))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GParamSpecInt64>())).parent_instance as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecInt64),
            "::",
            stringify!(parent_instance)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GParamSpecInt64>())).minimum as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecInt64),
            "::",
            stringify!(minimum)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GParamSpecInt64>())).maximum as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecInt64),
            "::",
            stringify!(maximum)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GParamSpecInt64>())).default_value as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecInt64),
            "::",
            stringify!(default_value)
        )
    );
}
/// GParamSpecUInt64:
/// @parent_instance: private #GParamSpec portion
/// @minimum: minimum value for the property specified
/// @maximum: maximum value for the property specified
/// @default_value: default value for the property specified
///
/// A #GParamSpec derived structure that contains the meta data for unsigned 64bit integer properties.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GParamSpecUInt64 {
    pub parent_instance: GParamSpec,
    pub minimum: guint64,
    pub maximum: guint64,
    pub default_value: guint64,
}
#[test]
fn bindgen_test_layout__GParamSpecUInt64() {
    assert_eq!(
        ::std::mem::size_of::<_GParamSpecUInt64>(),
        96usize,
        concat!("Size of: ", stringify!(_GParamSpecUInt64))
    );
    assert_eq!(
        ::std::mem::align_of::<_GParamSpecUInt64>(),
        8usize,
        concat!("Alignment of ", stringify!(_GParamSpecUInt64))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GParamSpecUInt64>())).parent_instance as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecUInt64),
            "::",
            stringify!(parent_instance)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GParamSpecUInt64>())).minimum as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecUInt64),
            "::",
            stringify!(minimum)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GParamSpecUInt64>())).maximum as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecUInt64),
            "::",
            stringify!(maximum)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GParamSpecUInt64>())).default_value as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecUInt64),
            "::",
            stringify!(default_value)
        )
    );
}
/// GParamSpecUnichar:
/// @parent_instance: private #GParamSpec portion
/// @default_value: default value for the property specified
///
/// A #GParamSpec derived structure that contains the meta data for unichar (unsigned integer) properties.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GParamSpecUnichar {
    pub parent_instance: GParamSpec,
    pub default_value: gunichar,
}
#[test]
fn bindgen_test_layout__GParamSpecUnichar() {
    assert_eq!(
        ::std::mem::size_of::<_GParamSpecUnichar>(),
        80usize,
        concat!("Size of: ", stringify!(_GParamSpecUnichar))
    );
    assert_eq!(
        ::std::mem::align_of::<_GParamSpecUnichar>(),
        8usize,
        concat!("Alignment of ", stringify!(_GParamSpecUnichar))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GParamSpecUnichar>())).parent_instance as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecUnichar),
            "::",
            stringify!(parent_instance)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GParamSpecUnichar>())).default_value as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecUnichar),
            "::",
            stringify!(default_value)
        )
    );
}
/// GParamSpecEnum:
/// @parent_instance: private #GParamSpec portion
/// @enum_class: the #GEnumClass for the enum
/// @default_value: default value for the property specified
///
/// A #GParamSpec derived structure that contains the meta data for enum
/// properties.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GParamSpecEnum {
    pub parent_instance: GParamSpec,
    pub enum_class: *mut GEnumClass,
    pub default_value: gint,
}
#[test]
fn bindgen_test_layout__GParamSpecEnum() {
    assert_eq!(
        ::std::mem::size_of::<_GParamSpecEnum>(),
        88usize,
        concat!("Size of: ", stringify!(_GParamSpecEnum))
    );
    assert_eq!(
        ::std::mem::align_of::<_GParamSpecEnum>(),
        8usize,
        concat!("Alignment of ", stringify!(_GParamSpecEnum))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GParamSpecEnum>())).parent_instance as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecEnum),
            "::",
            stringify!(parent_instance)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GParamSpecEnum>())).enum_class as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecEnum),
            "::",
            stringify!(enum_class)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GParamSpecEnum>())).default_value as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecEnum),
            "::",
            stringify!(default_value)
        )
    );
}
/// GParamSpecFlags:
/// @parent_instance: private #GParamSpec portion
/// @flags_class: the #GFlagsClass for the flags
/// @default_value: default value for the property specified
///
/// A #GParamSpec derived structure that contains the meta data for flags
/// properties.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GParamSpecFlags {
    pub parent_instance: GParamSpec,
    pub flags_class: *mut GFlagsClass,
    pub default_value: guint,
}
#[test]
fn bindgen_test_layout__GParamSpecFlags() {
    assert_eq!(
        ::std::mem::size_of::<_GParamSpecFlags>(),
        88usize,
        concat!("Size of: ", stringify!(_GParamSpecFlags))
    );
    assert_eq!(
        ::std::mem::align_of::<_GParamSpecFlags>(),
        8usize,
        concat!("Alignment of ", stringify!(_GParamSpecFlags))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GParamSpecFlags>())).parent_instance as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecFlags),
            "::",
            stringify!(parent_instance)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GParamSpecFlags>())).flags_class as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecFlags),
            "::",
            stringify!(flags_class)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GParamSpecFlags>())).default_value as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecFlags),
            "::",
            stringify!(default_value)
        )
    );
}
/// GParamSpecFloat:
/// @parent_instance: private #GParamSpec portion
/// @minimum: minimum value for the property specified
/// @maximum: maximum value for the property specified
/// @default_value: default value for the property specified
/// @epsilon: values closer than @epsilon will be considered identical
/// by g_param_values_cmp(); the default value is 1e-30.
///
/// A #GParamSpec derived structure that contains the meta data for float properties.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GParamSpecFloat {
    pub parent_instance: GParamSpec,
    pub minimum: gfloat,
    pub maximum: gfloat,
    pub default_value: gfloat,
    pub epsilon: gfloat,
}
#[test]
fn bindgen_test_layout__GParamSpecFloat() {
    assert_eq!(
        ::std::mem::size_of::<_GParamSpecFloat>(),
        88usize,
        concat!("Size of: ", stringify!(_GParamSpecFloat))
    );
    assert_eq!(
        ::std::mem::align_of::<_GParamSpecFloat>(),
        8usize,
        concat!("Alignment of ", stringify!(_GParamSpecFloat))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GParamSpecFloat>())).parent_instance as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecFloat),
            "::",
            stringify!(parent_instance)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GParamSpecFloat>())).minimum as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecFloat),
            "::",
            stringify!(minimum)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GParamSpecFloat>())).maximum as *const _ as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecFloat),
            "::",
            stringify!(maximum)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GParamSpecFloat>())).default_value as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecFloat),
            "::",
            stringify!(default_value)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GParamSpecFloat>())).epsilon as *const _ as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecFloat),
            "::",
            stringify!(epsilon)
        )
    );
}
/// GParamSpecDouble:
/// @parent_instance: private #GParamSpec portion
/// @minimum: minimum value for the property specified
/// @maximum: maximum value for the property specified
/// @default_value: default value for the property specified
/// @epsilon: values closer than @epsilon will be considered identical
/// by g_param_values_cmp(); the default value is 1e-90.
///
/// A #GParamSpec derived structure that contains the meta data for double properties.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GParamSpecDouble {
    pub parent_instance: GParamSpec,
    pub minimum: gdouble,
    pub maximum: gdouble,
    pub default_value: gdouble,
    pub epsilon: gdouble,
}
#[test]
fn bindgen_test_layout__GParamSpecDouble() {
    assert_eq!(
        ::std::mem::size_of::<_GParamSpecDouble>(),
        104usize,
        concat!("Size of: ", stringify!(_GParamSpecDouble))
    );
    assert_eq!(
        ::std::mem::align_of::<_GParamSpecDouble>(),
        8usize,
        concat!("Alignment of ", stringify!(_GParamSpecDouble))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GParamSpecDouble>())).parent_instance as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecDouble),
            "::",
            stringify!(parent_instance)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GParamSpecDouble>())).minimum as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecDouble),
            "::",
            stringify!(minimum)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GParamSpecDouble>())).maximum as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecDouble),
            "::",
            stringify!(maximum)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GParamSpecDouble>())).default_value as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecDouble),
            "::",
            stringify!(default_value)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GParamSpecDouble>())).epsilon as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecDouble),
            "::",
            stringify!(epsilon)
        )
    );
}
/// GParamSpecString:
/// @parent_instance: private #GParamSpec portion
/// @default_value: default value for the property specified
/// @cset_first: a string containing the allowed values for the first byte
/// @cset_nth: a string containing the allowed values for the subsequent bytes
/// @substitutor: the replacement byte for bytes which don't match @cset_first or @cset_nth.
/// @null_fold_if_empty: replace empty string by %NULL
/// @ensure_non_null: replace %NULL strings by an empty string
///
/// A #GParamSpec derived structure that contains the meta data for string
/// properties.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GParamSpecString {
    pub parent_instance: GParamSpec,
    pub default_value: *mut gchar,
    pub cset_first: *mut gchar,
    pub cset_nth: *mut gchar,
    pub substitutor: gchar,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub __bindgen_padding_0: [u16; 3usize],
}
#[test]
fn bindgen_test_layout__GParamSpecString() {
    assert_eq!(
        ::std::mem::size_of::<_GParamSpecString>(),
        104usize,
        concat!("Size of: ", stringify!(_GParamSpecString))
    );
    assert_eq!(
        ::std::mem::align_of::<_GParamSpecString>(),
        8usize,
        concat!("Alignment of ", stringify!(_GParamSpecString))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GParamSpecString>())).parent_instance as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecString),
            "::",
            stringify!(parent_instance)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GParamSpecString>())).default_value as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecString),
            "::",
            stringify!(default_value)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GParamSpecString>())).cset_first as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecString),
            "::",
            stringify!(cset_first)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GParamSpecString>())).cset_nth as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecString),
            "::",
            stringify!(cset_nth)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GParamSpecString>())).substitutor as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecString),
            "::",
            stringify!(substitutor)
        )
    );
}
impl _GParamSpecString {
    #[inline]
    pub fn null_fold_if_empty(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_null_fold_if_empty(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ensure_non_null(&self) -> guint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ensure_non_null(&mut self, val: guint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        null_fold_if_empty: guint,
        ensure_non_null: guint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let null_fold_if_empty: u32 = unsafe { ::std::mem::transmute(null_fold_if_empty) };
            null_fold_if_empty as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let ensure_non_null: u32 = unsafe { ::std::mem::transmute(ensure_non_null) };
            ensure_non_null as u64
        });
        __bindgen_bitfield_unit
    }
}
/// GParamSpecParam:
/// @parent_instance: private #GParamSpec portion
///
/// A #GParamSpec derived structure that contains the meta data for %G_TYPE_PARAM
/// properties.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GParamSpecParam {
    pub parent_instance: GParamSpec,
}
#[test]
fn bindgen_test_layout__GParamSpecParam() {
    assert_eq!(
        ::std::mem::size_of::<_GParamSpecParam>(),
        72usize,
        concat!("Size of: ", stringify!(_GParamSpecParam))
    );
    assert_eq!(
        ::std::mem::align_of::<_GParamSpecParam>(),
        8usize,
        concat!("Alignment of ", stringify!(_GParamSpecParam))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GParamSpecParam>())).parent_instance as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecParam),
            "::",
            stringify!(parent_instance)
        )
    );
}
/// GParamSpecBoxed:
/// @parent_instance: private #GParamSpec portion
///
/// A #GParamSpec derived structure that contains the meta data for boxed properties.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GParamSpecBoxed {
    pub parent_instance: GParamSpec,
}
#[test]
fn bindgen_test_layout__GParamSpecBoxed() {
    assert_eq!(
        ::std::mem::size_of::<_GParamSpecBoxed>(),
        72usize,
        concat!("Size of: ", stringify!(_GParamSpecBoxed))
    );
    assert_eq!(
        ::std::mem::align_of::<_GParamSpecBoxed>(),
        8usize,
        concat!("Alignment of ", stringify!(_GParamSpecBoxed))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GParamSpecBoxed>())).parent_instance as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecBoxed),
            "::",
            stringify!(parent_instance)
        )
    );
}
/// GParamSpecPointer:
/// @parent_instance: private #GParamSpec portion
///
/// A #GParamSpec derived structure that contains the meta data for pointer properties.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GParamSpecPointer {
    pub parent_instance: GParamSpec,
}
#[test]
fn bindgen_test_layout__GParamSpecPointer() {
    assert_eq!(
        ::std::mem::size_of::<_GParamSpecPointer>(),
        72usize,
        concat!("Size of: ", stringify!(_GParamSpecPointer))
    );
    assert_eq!(
        ::std::mem::align_of::<_GParamSpecPointer>(),
        8usize,
        concat!("Alignment of ", stringify!(_GParamSpecPointer))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GParamSpecPointer>())).parent_instance as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecPointer),
            "::",
            stringify!(parent_instance)
        )
    );
}
/// GParamSpecValueArray:
/// @parent_instance: private #GParamSpec portion
/// @element_spec: a #GParamSpec describing the elements contained in arrays of this property, may be %NULL
/// @fixed_n_elements: if greater than 0, arrays of this property will always have this many elements
///
/// A #GParamSpec derived structure that contains the meta data for #GValueArray properties.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GParamSpecValueArray {
    pub parent_instance: GParamSpec,
    pub element_spec: *mut GParamSpec,
    pub fixed_n_elements: guint,
}
#[test]
fn bindgen_test_layout__GParamSpecValueArray() {
    assert_eq!(
        ::std::mem::size_of::<_GParamSpecValueArray>(),
        88usize,
        concat!("Size of: ", stringify!(_GParamSpecValueArray))
    );
    assert_eq!(
        ::std::mem::align_of::<_GParamSpecValueArray>(),
        8usize,
        concat!("Alignment of ", stringify!(_GParamSpecValueArray))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GParamSpecValueArray>())).parent_instance as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecValueArray),
            "::",
            stringify!(parent_instance)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GParamSpecValueArray>())).element_spec as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecValueArray),
            "::",
            stringify!(element_spec)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GParamSpecValueArray>())).fixed_n_elements as *const _ as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecValueArray),
            "::",
            stringify!(fixed_n_elements)
        )
    );
}
/// GParamSpecObject:
/// @parent_instance: private #GParamSpec portion
///
/// A #GParamSpec derived structure that contains the meta data for object properties.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GParamSpecObject {
    pub parent_instance: GParamSpec,
}
#[test]
fn bindgen_test_layout__GParamSpecObject() {
    assert_eq!(
        ::std::mem::size_of::<_GParamSpecObject>(),
        72usize,
        concat!("Size of: ", stringify!(_GParamSpecObject))
    );
    assert_eq!(
        ::std::mem::align_of::<_GParamSpecObject>(),
        8usize,
        concat!("Alignment of ", stringify!(_GParamSpecObject))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GParamSpecObject>())).parent_instance as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecObject),
            "::",
            stringify!(parent_instance)
        )
    );
}
/// GParamSpecOverride:
///
/// This is a type of #GParamSpec type that simply redirects operations to
/// another paramspec.  All operations other than getting or
/// setting the value are redirected, including accessing the nick and
/// blurb, validating a value, and so forth. See
/// g_param_spec_get_redirect_target() for retrieving the overidden
/// property. #GParamSpecOverride is used in implementing
/// g_object_class_override_property(), and will not be directly useful
/// unless you are implementing a new base type similar to GObject.
///
/// Since: 2.4
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GParamSpecOverride {
    pub parent_instance: GParamSpec,
    pub overridden: *mut GParamSpec,
}
#[test]
fn bindgen_test_layout__GParamSpecOverride() {
    assert_eq!(
        ::std::mem::size_of::<_GParamSpecOverride>(),
        80usize,
        concat!("Size of: ", stringify!(_GParamSpecOverride))
    );
    assert_eq!(
        ::std::mem::align_of::<_GParamSpecOverride>(),
        8usize,
        concat!("Alignment of ", stringify!(_GParamSpecOverride))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GParamSpecOverride>())).parent_instance as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecOverride),
            "::",
            stringify!(parent_instance)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GParamSpecOverride>())).overridden as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecOverride),
            "::",
            stringify!(overridden)
        )
    );
}
/// GParamSpecGType:
/// @parent_instance: private #GParamSpec portion
/// @is_a_type: a #GType whose subtypes can occur as values
///
/// A #GParamSpec derived structure that contains the meta data for #GType properties.
///
/// Since: 2.10
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GParamSpecGType {
    pub parent_instance: GParamSpec,
    pub is_a_type: GType,
}
#[test]
fn bindgen_test_layout__GParamSpecGType() {
    assert_eq!(
        ::std::mem::size_of::<_GParamSpecGType>(),
        80usize,
        concat!("Size of: ", stringify!(_GParamSpecGType))
    );
    assert_eq!(
        ::std::mem::align_of::<_GParamSpecGType>(),
        8usize,
        concat!("Alignment of ", stringify!(_GParamSpecGType))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GParamSpecGType>())).parent_instance as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecGType),
            "::",
            stringify!(parent_instance)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GParamSpecGType>())).is_a_type as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecGType),
            "::",
            stringify!(is_a_type)
        )
    );
}
/// GParamSpecVariant:
/// @parent_instance: private #GParamSpec portion
/// @type: a #GVariantType, or %NULL
/// @default_value: a #GVariant, or %NULL
///
/// A #GParamSpec derived structure that contains the meta data for #GVariant properties.
///
/// Since: 2.26
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GParamSpecVariant {
    pub parent_instance: GParamSpec,
    pub type_: *mut GVariantType,
    pub default_value: *mut GVariant,
    pub padding: [gpointer; 4usize],
}
#[test]
fn bindgen_test_layout__GParamSpecVariant() {
    assert_eq!(
        ::std::mem::size_of::<_GParamSpecVariant>(),
        120usize,
        concat!("Size of: ", stringify!(_GParamSpecVariant))
    );
    assert_eq!(
        ::std::mem::align_of::<_GParamSpecVariant>(),
        8usize,
        concat!("Alignment of ", stringify!(_GParamSpecVariant))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GParamSpecVariant>())).parent_instance as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecVariant),
            "::",
            stringify!(parent_instance)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GParamSpecVariant>())).type_ as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecVariant),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GParamSpecVariant>())).default_value as *const _ as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecVariant),
            "::",
            stringify!(default_value)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GParamSpecVariant>())).padding as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_GParamSpecVariant),
            "::",
            stringify!(padding)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_g_param_spec_char"]
    pub fn g_param_spec_char(
        name: *const gchar,
        nick: *const gchar,
        blurb: *const gchar,
        minimum: gint8,
        maximum: gint8,
        default_value: gint8,
        flags: GParamFlags,
    ) -> *mut GParamSpec;
}
extern "C" {
    #[link_name = "\u{1}_g_param_spec_uchar"]
    pub fn g_param_spec_uchar(
        name: *const gchar,
        nick: *const gchar,
        blurb: *const gchar,
        minimum: guint8,
        maximum: guint8,
        default_value: guint8,
        flags: GParamFlags,
    ) -> *mut GParamSpec;
}
extern "C" {
    #[link_name = "\u{1}_g_param_spec_boolean"]
    pub fn g_param_spec_boolean(
        name: *const gchar,
        nick: *const gchar,
        blurb: *const gchar,
        default_value: gboolean,
        flags: GParamFlags,
    ) -> *mut GParamSpec;
}
extern "C" {
    #[link_name = "\u{1}_g_param_spec_int"]
    pub fn g_param_spec_int(
        name: *const gchar,
        nick: *const gchar,
        blurb: *const gchar,
        minimum: gint,
        maximum: gint,
        default_value: gint,
        flags: GParamFlags,
    ) -> *mut GParamSpec;
}
extern "C" {
    #[link_name = "\u{1}_g_param_spec_uint"]
    pub fn g_param_spec_uint(
        name: *const gchar,
        nick: *const gchar,
        blurb: *const gchar,
        minimum: guint,
        maximum: guint,
        default_value: guint,
        flags: GParamFlags,
    ) -> *mut GParamSpec;
}
extern "C" {
    #[link_name = "\u{1}_g_param_spec_long"]
    pub fn g_param_spec_long(
        name: *const gchar,
        nick: *const gchar,
        blurb: *const gchar,
        minimum: glong,
        maximum: glong,
        default_value: glong,
        flags: GParamFlags,
    ) -> *mut GParamSpec;
}
extern "C" {
    #[link_name = "\u{1}_g_param_spec_ulong"]
    pub fn g_param_spec_ulong(
        name: *const gchar,
        nick: *const gchar,
        blurb: *const gchar,
        minimum: gulong,
        maximum: gulong,
        default_value: gulong,
        flags: GParamFlags,
    ) -> *mut GParamSpec;
}
extern "C" {
    #[link_name = "\u{1}_g_param_spec_int64"]
    pub fn g_param_spec_int64(
        name: *const gchar,
        nick: *const gchar,
        blurb: *const gchar,
        minimum: gint64,
        maximum: gint64,
        default_value: gint64,
        flags: GParamFlags,
    ) -> *mut GParamSpec;
}
extern "C" {
    #[link_name = "\u{1}_g_param_spec_uint64"]
    pub fn g_param_spec_uint64(
        name: *const gchar,
        nick: *const gchar,
        blurb: *const gchar,
        minimum: guint64,
        maximum: guint64,
        default_value: guint64,
        flags: GParamFlags,
    ) -> *mut GParamSpec;
}
extern "C" {
    #[link_name = "\u{1}_g_param_spec_unichar"]
    pub fn g_param_spec_unichar(
        name: *const gchar,
        nick: *const gchar,
        blurb: *const gchar,
        default_value: gunichar,
        flags: GParamFlags,
    ) -> *mut GParamSpec;
}
extern "C" {
    #[link_name = "\u{1}_g_param_spec_enum"]
    pub fn g_param_spec_enum(
        name: *const gchar,
        nick: *const gchar,
        blurb: *const gchar,
        enum_type: GType,
        default_value: gint,
        flags: GParamFlags,
    ) -> *mut GParamSpec;
}
extern "C" {
    #[link_name = "\u{1}_g_param_spec_flags"]
    pub fn g_param_spec_flags(
        name: *const gchar,
        nick: *const gchar,
        blurb: *const gchar,
        flags_type: GType,
        default_value: guint,
        flags: GParamFlags,
    ) -> *mut GParamSpec;
}
extern "C" {
    #[link_name = "\u{1}_g_param_spec_float"]
    pub fn g_param_spec_float(
        name: *const gchar,
        nick: *const gchar,
        blurb: *const gchar,
        minimum: gfloat,
        maximum: gfloat,
        default_value: gfloat,
        flags: GParamFlags,
    ) -> *mut GParamSpec;
}
extern "C" {
    #[link_name = "\u{1}_g_param_spec_double"]
    pub fn g_param_spec_double(
        name: *const gchar,
        nick: *const gchar,
        blurb: *const gchar,
        minimum: gdouble,
        maximum: gdouble,
        default_value: gdouble,
        flags: GParamFlags,
    ) -> *mut GParamSpec;
}
extern "C" {
    #[link_name = "\u{1}_g_param_spec_string"]
    pub fn g_param_spec_string(
        name: *const gchar,
        nick: *const gchar,
        blurb: *const gchar,
        default_value: *const gchar,
        flags: GParamFlags,
    ) -> *mut GParamSpec;
}
extern "C" {
    #[link_name = "\u{1}_g_param_spec_param"]
    pub fn g_param_spec_param(
        name: *const gchar,
        nick: *const gchar,
        blurb: *const gchar,
        param_type: GType,
        flags: GParamFlags,
    ) -> *mut GParamSpec;
}
extern "C" {
    #[link_name = "\u{1}_g_param_spec_boxed"]
    pub fn g_param_spec_boxed(
        name: *const gchar,
        nick: *const gchar,
        blurb: *const gchar,
        boxed_type: GType,
        flags: GParamFlags,
    ) -> *mut GParamSpec;
}
extern "C" {
    #[link_name = "\u{1}_g_param_spec_pointer"]
    pub fn g_param_spec_pointer(
        name: *const gchar,
        nick: *const gchar,
        blurb: *const gchar,
        flags: GParamFlags,
    ) -> *mut GParamSpec;
}
extern "C" {
    #[link_name = "\u{1}_g_param_spec_value_array"]
    pub fn g_param_spec_value_array(
        name: *const gchar,
        nick: *const gchar,
        blurb: *const gchar,
        element_spec: *mut GParamSpec,
        flags: GParamFlags,
    ) -> *mut GParamSpec;
}
extern "C" {
    #[link_name = "\u{1}_g_param_spec_object"]
    pub fn g_param_spec_object(
        name: *const gchar,
        nick: *const gchar,
        blurb: *const gchar,
        object_type: GType,
        flags: GParamFlags,
    ) -> *mut GParamSpec;
}
extern "C" {
    #[link_name = "\u{1}_g_param_spec_override"]
    pub fn g_param_spec_override(
        name: *const gchar,
        overridden: *mut GParamSpec,
    ) -> *mut GParamSpec;
}
extern "C" {
    #[link_name = "\u{1}_g_param_spec_gtype"]
    pub fn g_param_spec_gtype(
        name: *const gchar,
        nick: *const gchar,
        blurb: *const gchar,
        is_a_type: GType,
        flags: GParamFlags,
    ) -> *mut GParamSpec;
}
extern "C" {
    #[link_name = "\u{1}_g_param_spec_variant"]
    pub fn g_param_spec_variant(
        name: *const gchar,
        nick: *const gchar,
        blurb: *const gchar,
        type_: *const GVariantType,
        default_value: *mut GVariant,
        flags: GParamFlags,
    ) -> *mut GParamSpec;
}
extern "C" {
    #[link_name = "\u{1}_g_param_spec_types"]
    pub static mut g_param_spec_types: *mut GType;
}
extern "C" {
    #[link_name = "\u{1}_g_source_set_closure"]
    pub fn g_source_set_closure(source: *mut GSource, closure: *mut GClosure);
}
extern "C" {
    #[link_name = "\u{1}_g_source_set_dummy_callback"]
    pub fn g_source_set_dummy_callback(source: *mut GSource);
}
pub type GTypeModule = _GTypeModule;
pub type GTypeModuleClass = _GTypeModuleClass;
pub type GTypeModule_autoptr = *mut GTypeModule;
/// GTypeModule:
/// @name: the name of the module
///
/// The members of the GTypeModule structure should not
/// be accessed directly, except for the @name field.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GTypeModule {
    pub parent_instance: GObject,
    pub use_count: guint,
    pub type_infos: *mut GSList,
    pub interface_infos: *mut GSList,
    pub name: *mut gchar,
}
#[test]
fn bindgen_test_layout__GTypeModule() {
    assert_eq!(
        ::std::mem::size_of::<_GTypeModule>(),
        56usize,
        concat!("Size of: ", stringify!(_GTypeModule))
    );
    assert_eq!(
        ::std::mem::align_of::<_GTypeModule>(),
        8usize,
        concat!("Alignment of ", stringify!(_GTypeModule))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GTypeModule>())).parent_instance as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTypeModule),
            "::",
            stringify!(parent_instance)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GTypeModule>())).use_count as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTypeModule),
            "::",
            stringify!(use_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GTypeModule>())).type_infos as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTypeModule),
            "::",
            stringify!(type_infos)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GTypeModule>())).interface_infos as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTypeModule),
            "::",
            stringify!(interface_infos)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GTypeModule>())).name as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTypeModule),
            "::",
            stringify!(name)
        )
    );
}
/// GTypeModuleClass:
/// @parent_class: the parent class
/// @load: loads the module and registers one or more types using
/// g_type_module_register_type().
/// @unload: unloads the module
///
/// In order to implement dynamic loading of types based on #GTypeModule,
/// the @load and @unload functions in #GTypeModuleClass must be implemented.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GTypeModuleClass {
    pub parent_class: GObjectClass,
    pub load: ::std::option::Option<unsafe extern "C" fn(module: *mut GTypeModule) -> gboolean>,
    pub unload: ::std::option::Option<unsafe extern "C" fn(module: *mut GTypeModule)>,
    pub reserved1: ::std::option::Option<unsafe extern "C" fn()>,
    pub reserved2: ::std::option::Option<unsafe extern "C" fn()>,
    pub reserved3: ::std::option::Option<unsafe extern "C" fn()>,
    pub reserved4: ::std::option::Option<unsafe extern "C" fn()>,
}
#[test]
fn bindgen_test_layout__GTypeModuleClass() {
    assert_eq!(
        ::std::mem::size_of::<_GTypeModuleClass>(),
        184usize,
        concat!("Size of: ", stringify!(_GTypeModuleClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_GTypeModuleClass>(),
        8usize,
        concat!("Alignment of ", stringify!(_GTypeModuleClass))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GTypeModuleClass>())).parent_class as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTypeModuleClass),
            "::",
            stringify!(parent_class)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GTypeModuleClass>())).load as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTypeModuleClass),
            "::",
            stringify!(load)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GTypeModuleClass>())).unload as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTypeModuleClass),
            "::",
            stringify!(unload)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GTypeModuleClass>())).reserved1 as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTypeModuleClass),
            "::",
            stringify!(reserved1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GTypeModuleClass>())).reserved2 as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTypeModuleClass),
            "::",
            stringify!(reserved2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GTypeModuleClass>())).reserved3 as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTypeModuleClass),
            "::",
            stringify!(reserved3)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GTypeModuleClass>())).reserved4 as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTypeModuleClass),
            "::",
            stringify!(reserved4)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_g_type_module_get_type"]
    pub fn g_type_module_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_type_module_use"]
    pub fn g_type_module_use(module: *mut GTypeModule) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_type_module_unuse"]
    pub fn g_type_module_unuse(module: *mut GTypeModule);
}
extern "C" {
    #[link_name = "\u{1}_g_type_module_set_name"]
    pub fn g_type_module_set_name(module: *mut GTypeModule, name: *const gchar);
}
extern "C" {
    #[link_name = "\u{1}_g_type_module_register_type"]
    pub fn g_type_module_register_type(
        module: *mut GTypeModule,
        parent_type: GType,
        type_name: *const gchar,
        type_info: *const GTypeInfo,
        flags: GTypeFlags,
    ) -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_type_module_add_interface"]
    pub fn g_type_module_add_interface(
        module: *mut GTypeModule,
        instance_type: GType,
        interface_type: GType,
        interface_info: *const GInterfaceInfo,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_type_module_register_enum"]
    pub fn g_type_module_register_enum(
        module: *mut GTypeModule,
        name: *const gchar,
        const_static_values: *const GEnumValue,
    ) -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_type_module_register_flags"]
    pub fn g_type_module_register_flags(
        module: *mut GTypeModule,
        name: *const gchar,
        const_static_values: *const GFlagsValue,
    ) -> GType;
}
pub type GTypePluginClass = _GTypePluginClass;
/// GTypePluginUse:
/// @plugin: the #GTypePlugin whose use count should be increased
///
/// The type of the @use_plugin function of #GTypePluginClass, which gets called
/// to increase the use count of @plugin.
pub type GTypePluginUse = ::std::option::Option<unsafe extern "C" fn(plugin: *mut GTypePlugin)>;
/// GTypePluginUnuse:
/// @plugin: the #GTypePlugin whose use count should be decreased
///
/// The type of the @unuse_plugin function of #GTypePluginClass.
pub type GTypePluginUnuse = ::std::option::Option<unsafe extern "C" fn(plugin: *mut GTypePlugin)>;
/// GTypePluginCompleteTypeInfo:
/// @plugin: the #GTypePlugin
/// @g_type: the #GType whose info is completed
/// @info: the #GTypeInfo struct to fill in
/// @value_table: the #GTypeValueTable to fill in
///
/// The type of the @complete_type_info function of #GTypePluginClass.
pub type GTypePluginCompleteTypeInfo = ::std::option::Option<
    unsafe extern "C" fn(
        plugin: *mut GTypePlugin,
        g_type: GType,
        info: *mut GTypeInfo,
        value_table: *mut GTypeValueTable,
    ),
>;
/// GTypePluginCompleteInterfaceInfo:
/// @plugin: the #GTypePlugin
/// @instance_type: the #GType of an instantiable type to which the interface
/// is added
/// @interface_type: the #GType of the interface whose info is completed
/// @info: the #GInterfaceInfo to fill in
///
/// The type of the @complete_interface_info function of #GTypePluginClass.
pub type GTypePluginCompleteInterfaceInfo = ::std::option::Option<
    unsafe extern "C" fn(
        plugin: *mut GTypePlugin,
        instance_type: GType,
        interface_type: GType,
        info: *mut GInterfaceInfo,
    ),
>;
/// GTypePlugin:
///
/// The GTypePlugin typedef is used as a placeholder
/// for objects that implement the GTypePlugin interface.
/// /
/// /**
/// GTypePluginClass:
/// @use_plugin: Increases the use count of the plugin.
/// @unuse_plugin: Decreases the use count of the plugin.
/// @complete_type_info: Fills in the #GTypeInfo and
/// #GTypeValueTable structs for the type. The structs are initialized
/// with `memset(s, 0, sizeof (s))` before calling this function.
/// @complete_interface_info: Fills in missing parts of the #GInterfaceInfo
/// for the interface. The structs is initialized with
/// `memset(s, 0, sizeof (s))` before calling this function.
///
/// The #GTypePlugin interface is used by the type system in order to handle
/// the lifecycle of dynamically loaded types.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GTypePluginClass {
    pub base_iface: GTypeInterface,
    pub use_plugin: GTypePluginUse,
    pub unuse_plugin: GTypePluginUnuse,
    pub complete_type_info: GTypePluginCompleteTypeInfo,
    pub complete_interface_info: GTypePluginCompleteInterfaceInfo,
}
#[test]
fn bindgen_test_layout__GTypePluginClass() {
    assert_eq!(
        ::std::mem::size_of::<_GTypePluginClass>(),
        48usize,
        concat!("Size of: ", stringify!(_GTypePluginClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_GTypePluginClass>(),
        8usize,
        concat!("Alignment of ", stringify!(_GTypePluginClass))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GTypePluginClass>())).base_iface as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTypePluginClass),
            "::",
            stringify!(base_iface)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GTypePluginClass>())).use_plugin as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTypePluginClass),
            "::",
            stringify!(use_plugin)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GTypePluginClass>())).unuse_plugin as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTypePluginClass),
            "::",
            stringify!(unuse_plugin)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GTypePluginClass>())).complete_type_info as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTypePluginClass),
            "::",
            stringify!(complete_type_info)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GTypePluginClass>())).complete_interface_info as *const _
                as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTypePluginClass),
            "::",
            stringify!(complete_interface_info)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_g_type_plugin_get_type"]
    pub fn g_type_plugin_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_type_plugin_use"]
    pub fn g_type_plugin_use(plugin: *mut GTypePlugin);
}
extern "C" {
    #[link_name = "\u{1}_g_type_plugin_unuse"]
    pub fn g_type_plugin_unuse(plugin: *mut GTypePlugin);
}
extern "C" {
    #[link_name = "\u{1}_g_type_plugin_complete_type_info"]
    pub fn g_type_plugin_complete_type_info(
        plugin: *mut GTypePlugin,
        g_type: GType,
        info: *mut GTypeInfo,
        value_table: *mut GTypeValueTable,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_type_plugin_complete_interface_info"]
    pub fn g_type_plugin_complete_interface_info(
        plugin: *mut GTypePlugin,
        instance_type: GType,
        interface_type: GType,
        info: *mut GInterfaceInfo,
    );
}
pub type GValueArray = _GValueArray;
/// GValueArray:
/// @n_values: number of values contained in the array
/// @values: array of values
///
/// A #GValueArray contains an array of #GValue elements.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GValueArray {
    pub n_values: guint,
    pub values: *mut GValue,
    pub n_prealloced: guint,
}
#[test]
fn bindgen_test_layout__GValueArray() {
    assert_eq!(
        ::std::mem::size_of::<_GValueArray>(),
        24usize,
        concat!("Size of: ", stringify!(_GValueArray))
    );
    assert_eq!(
        ::std::mem::align_of::<_GValueArray>(),
        8usize,
        concat!("Alignment of ", stringify!(_GValueArray))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GValueArray>())).n_values as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GValueArray),
            "::",
            stringify!(n_values)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GValueArray>())).values as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GValueArray),
            "::",
            stringify!(values)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GValueArray>())).n_prealloced as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GValueArray),
            "::",
            stringify!(n_prealloced)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_g_value_array_get_type"]
    pub fn g_value_array_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_value_array_get_nth"]
    pub fn g_value_array_get_nth(value_array: *mut GValueArray, index_: guint) -> *mut GValue;
}
extern "C" {
    #[link_name = "\u{1}_g_value_array_new"]
    pub fn g_value_array_new(n_prealloced: guint) -> *mut GValueArray;
}
extern "C" {
    #[link_name = "\u{1}_g_value_array_free"]
    pub fn g_value_array_free(value_array: *mut GValueArray);
}
extern "C" {
    #[link_name = "\u{1}_g_value_array_copy"]
    pub fn g_value_array_copy(value_array: *const GValueArray) -> *mut GValueArray;
}
extern "C" {
    #[link_name = "\u{1}_g_value_array_prepend"]
    pub fn g_value_array_prepend(
        value_array: *mut GValueArray,
        value: *const GValue,
    ) -> *mut GValueArray;
}
extern "C" {
    #[link_name = "\u{1}_g_value_array_append"]
    pub fn g_value_array_append(
        value_array: *mut GValueArray,
        value: *const GValue,
    ) -> *mut GValueArray;
}
extern "C" {
    #[link_name = "\u{1}_g_value_array_insert"]
    pub fn g_value_array_insert(
        value_array: *mut GValueArray,
        index_: guint,
        value: *const GValue,
    ) -> *mut GValueArray;
}
extern "C" {
    #[link_name = "\u{1}_g_value_array_remove"]
    pub fn g_value_array_remove(value_array: *mut GValueArray, index_: guint) -> *mut GValueArray;
}
extern "C" {
    #[link_name = "\u{1}_g_value_array_sort"]
    pub fn g_value_array_sort(
        value_array: *mut GValueArray,
        compare_func: GCompareFunc,
    ) -> *mut GValueArray;
}
extern "C" {
    #[link_name = "\u{1}_g_value_array_sort_with_data"]
    pub fn g_value_array_sort_with_data(
        value_array: *mut GValueArray,
        compare_func: GCompareDataFunc,
        user_data: gpointer,
    ) -> *mut GValueArray;
}
extern "C" {
    #[link_name = "\u{1}_g_value_set_char"]
    pub fn g_value_set_char(value: *mut GValue, v_char: gchar);
}
extern "C" {
    #[link_name = "\u{1}_g_value_get_char"]
    pub fn g_value_get_char(value: *const GValue) -> gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_value_set_schar"]
    pub fn g_value_set_schar(value: *mut GValue, v_char: gint8);
}
extern "C" {
    #[link_name = "\u{1}_g_value_get_schar"]
    pub fn g_value_get_schar(value: *const GValue) -> gint8;
}
extern "C" {
    #[link_name = "\u{1}_g_value_set_uchar"]
    pub fn g_value_set_uchar(value: *mut GValue, v_uchar: guchar);
}
extern "C" {
    #[link_name = "\u{1}_g_value_get_uchar"]
    pub fn g_value_get_uchar(value: *const GValue) -> guchar;
}
extern "C" {
    #[link_name = "\u{1}_g_value_set_boolean"]
    pub fn g_value_set_boolean(value: *mut GValue, v_boolean: gboolean);
}
extern "C" {
    #[link_name = "\u{1}_g_value_get_boolean"]
    pub fn g_value_get_boolean(value: *const GValue) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_value_set_int"]
    pub fn g_value_set_int(value: *mut GValue, v_int: gint);
}
extern "C" {
    #[link_name = "\u{1}_g_value_get_int"]
    pub fn g_value_get_int(value: *const GValue) -> gint;
}
extern "C" {
    #[link_name = "\u{1}_g_value_set_uint"]
    pub fn g_value_set_uint(value: *mut GValue, v_uint: guint);
}
extern "C" {
    #[link_name = "\u{1}_g_value_get_uint"]
    pub fn g_value_get_uint(value: *const GValue) -> guint;
}
extern "C" {
    #[link_name = "\u{1}_g_value_set_long"]
    pub fn g_value_set_long(value: *mut GValue, v_long: glong);
}
extern "C" {
    #[link_name = "\u{1}_g_value_get_long"]
    pub fn g_value_get_long(value: *const GValue) -> glong;
}
extern "C" {
    #[link_name = "\u{1}_g_value_set_ulong"]
    pub fn g_value_set_ulong(value: *mut GValue, v_ulong: gulong);
}
extern "C" {
    #[link_name = "\u{1}_g_value_get_ulong"]
    pub fn g_value_get_ulong(value: *const GValue) -> gulong;
}
extern "C" {
    #[link_name = "\u{1}_g_value_set_int64"]
    pub fn g_value_set_int64(value: *mut GValue, v_int64: gint64);
}
extern "C" {
    #[link_name = "\u{1}_g_value_get_int64"]
    pub fn g_value_get_int64(value: *const GValue) -> gint64;
}
extern "C" {
    #[link_name = "\u{1}_g_value_set_uint64"]
    pub fn g_value_set_uint64(value: *mut GValue, v_uint64: guint64);
}
extern "C" {
    #[link_name = "\u{1}_g_value_get_uint64"]
    pub fn g_value_get_uint64(value: *const GValue) -> guint64;
}
extern "C" {
    #[link_name = "\u{1}_g_value_set_float"]
    pub fn g_value_set_float(value: *mut GValue, v_float: gfloat);
}
extern "C" {
    #[link_name = "\u{1}_g_value_get_float"]
    pub fn g_value_get_float(value: *const GValue) -> gfloat;
}
extern "C" {
    #[link_name = "\u{1}_g_value_set_double"]
    pub fn g_value_set_double(value: *mut GValue, v_double: gdouble);
}
extern "C" {
    #[link_name = "\u{1}_g_value_get_double"]
    pub fn g_value_get_double(value: *const GValue) -> gdouble;
}
extern "C" {
    #[link_name = "\u{1}_g_value_set_string"]
    pub fn g_value_set_string(value: *mut GValue, v_string: *const gchar);
}
extern "C" {
    #[link_name = "\u{1}_g_value_set_static_string"]
    pub fn g_value_set_static_string(value: *mut GValue, v_string: *const gchar);
}
extern "C" {
    #[link_name = "\u{1}_g_value_get_string"]
    pub fn g_value_get_string(value: *const GValue) -> *const gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_value_dup_string"]
    pub fn g_value_dup_string(value: *const GValue) -> *mut gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_value_set_pointer"]
    pub fn g_value_set_pointer(value: *mut GValue, v_pointer: gpointer);
}
extern "C" {
    #[link_name = "\u{1}_g_value_get_pointer"]
    pub fn g_value_get_pointer(value: *const GValue) -> gpointer;
}
extern "C" {
    #[link_name = "\u{1}_g_gtype_get_type"]
    pub fn g_gtype_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_value_set_gtype"]
    pub fn g_value_set_gtype(value: *mut GValue, v_gtype: GType);
}
extern "C" {
    #[link_name = "\u{1}_g_value_get_gtype"]
    pub fn g_value_get_gtype(value: *const GValue) -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_value_set_variant"]
    pub fn g_value_set_variant(value: *mut GValue, variant: *mut GVariant);
}
extern "C" {
    #[link_name = "\u{1}_g_value_take_variant"]
    pub fn g_value_take_variant(value: *mut GValue, variant: *mut GVariant);
}
extern "C" {
    #[link_name = "\u{1}_g_value_get_variant"]
    pub fn g_value_get_variant(value: *const GValue) -> *mut GVariant;
}
extern "C" {
    #[link_name = "\u{1}_g_value_dup_variant"]
    pub fn g_value_dup_variant(value: *const GValue) -> *mut GVariant;
}
extern "C" {
    #[link_name = "\u{1}_g_pointer_type_register_static"]
    pub fn g_pointer_type_register_static(name: *const gchar) -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_strdup_value_contents"]
    pub fn g_strdup_value_contents(value: *const GValue) -> *mut gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_value_take_string"]
    pub fn g_value_take_string(value: *mut GValue, v_string: *mut gchar);
}
extern "C" {
    #[link_name = "\u{1}_g_value_set_string_take_ownership"]
    pub fn g_value_set_string_take_ownership(value: *mut GValue, v_string: *mut gchar);
}
/// gchararray:
///
/// A C representable type name for #G_TYPE_STRING.
pub type gchararray = *mut gchar;
pub type GClosure_autoptr = *mut GClosure;
pub type GObject_autoptr = *mut GObject;
pub type GInitiallyUnowned_autoptr = *mut GInitiallyUnowned;
pub const GAppInfoCreateFlags_G_APP_INFO_CREATE_NONE: GAppInfoCreateFlags = 0;
pub const GAppInfoCreateFlags_G_APP_INFO_CREATE_NEEDS_TERMINAL: GAppInfoCreateFlags = 1;
pub const GAppInfoCreateFlags_G_APP_INFO_CREATE_SUPPORTS_URIS: GAppInfoCreateFlags = 2;
pub const GAppInfoCreateFlags_G_APP_INFO_CREATE_SUPPORTS_STARTUP_NOTIFICATION: GAppInfoCreateFlags =
    4;
/// GAppInfoCreateFlags:
/// @G_APP_INFO_CREATE_NONE: No flags.
/// @G_APP_INFO_CREATE_NEEDS_TERMINAL: Application opens in a terminal window.
/// @G_APP_INFO_CREATE_SUPPORTS_URIS: Application supports URI arguments.
/// @G_APP_INFO_CREATE_SUPPORTS_STARTUP_NOTIFICATION: Application supports startup notification. Since 2.26
///
/// Flags used when creating a #GAppInfo.
pub type GAppInfoCreateFlags = u32;
pub const GConverterFlags_G_CONVERTER_NO_FLAGS: GConverterFlags = 0;
pub const GConverterFlags_G_CONVERTER_INPUT_AT_END: GConverterFlags = 1;
pub const GConverterFlags_G_CONVERTER_FLUSH: GConverterFlags = 2;
/// GConverterFlags:
/// @G_CONVERTER_NO_FLAGS: No flags.
/// @G_CONVERTER_INPUT_AT_END: At end of input data
/// @G_CONVERTER_FLUSH: Flush data
///
/// Flags used when calling a g_converter_convert().
///
/// Since: 2.24
pub type GConverterFlags = u32;
pub const GConverterResult_G_CONVERTER_ERROR: GConverterResult = 0;
pub const GConverterResult_G_CONVERTER_CONVERTED: GConverterResult = 1;
pub const GConverterResult_G_CONVERTER_FINISHED: GConverterResult = 2;
pub const GConverterResult_G_CONVERTER_FLUSHED: GConverterResult = 3;
/// GConverterResult:
/// @G_CONVERTER_ERROR: There was an error during conversion.
/// @G_CONVERTER_CONVERTED: Some data was consumed or produced
/// @G_CONVERTER_FINISHED: The conversion is finished
/// @G_CONVERTER_FLUSHED: Flushing is finished
///
/// Results returned from g_converter_convert().
///
/// Since: 2.24
pub type GConverterResult = u32;
pub const GDataStreamByteOrder_G_DATA_STREAM_BYTE_ORDER_BIG_ENDIAN: GDataStreamByteOrder = 0;
pub const GDataStreamByteOrder_G_DATA_STREAM_BYTE_ORDER_LITTLE_ENDIAN: GDataStreamByteOrder = 1;
pub const GDataStreamByteOrder_G_DATA_STREAM_BYTE_ORDER_HOST_ENDIAN: GDataStreamByteOrder = 2;
/// GDataStreamByteOrder:
/// @G_DATA_STREAM_BYTE_ORDER_BIG_ENDIAN: Selects Big Endian byte order.
/// @G_DATA_STREAM_BYTE_ORDER_LITTLE_ENDIAN: Selects Little Endian byte order.
/// @G_DATA_STREAM_BYTE_ORDER_HOST_ENDIAN: Selects endianness based on host machine's architecture.
///
/// #GDataStreamByteOrder is used to ensure proper endianness of streaming data sources
/// across various machine architectures.
///
pub type GDataStreamByteOrder = u32;
pub const GDataStreamNewlineType_G_DATA_STREAM_NEWLINE_TYPE_LF: GDataStreamNewlineType = 0;
pub const GDataStreamNewlineType_G_DATA_STREAM_NEWLINE_TYPE_CR: GDataStreamNewlineType = 1;
pub const GDataStreamNewlineType_G_DATA_STREAM_NEWLINE_TYPE_CR_LF: GDataStreamNewlineType = 2;
pub const GDataStreamNewlineType_G_DATA_STREAM_NEWLINE_TYPE_ANY: GDataStreamNewlineType = 3;
/// GDataStreamNewlineType:
/// @G_DATA_STREAM_NEWLINE_TYPE_LF: Selects "LF" line endings, common on most modern UNIX platforms.
/// @G_DATA_STREAM_NEWLINE_TYPE_CR: Selects "CR" line endings.
/// @G_DATA_STREAM_NEWLINE_TYPE_CR_LF: Selects "CR, LF" line ending, common on Microsoft Windows.
/// @G_DATA_STREAM_NEWLINE_TYPE_ANY: Automatically try to handle any line ending type.
///
/// #GDataStreamNewlineType is used when checking for or setting the line endings for a given file.
pub type GDataStreamNewlineType = u32;
pub const GFileAttributeType_G_FILE_ATTRIBUTE_TYPE_INVALID: GFileAttributeType = 0;
pub const GFileAttributeType_G_FILE_ATTRIBUTE_TYPE_STRING: GFileAttributeType = 1;
pub const GFileAttributeType_G_FILE_ATTRIBUTE_TYPE_BYTE_STRING: GFileAttributeType = 2;
pub const GFileAttributeType_G_FILE_ATTRIBUTE_TYPE_BOOLEAN: GFileAttributeType = 3;
pub const GFileAttributeType_G_FILE_ATTRIBUTE_TYPE_UINT32: GFileAttributeType = 4;
pub const GFileAttributeType_G_FILE_ATTRIBUTE_TYPE_INT32: GFileAttributeType = 5;
pub const GFileAttributeType_G_FILE_ATTRIBUTE_TYPE_UINT64: GFileAttributeType = 6;
pub const GFileAttributeType_G_FILE_ATTRIBUTE_TYPE_INT64: GFileAttributeType = 7;
pub const GFileAttributeType_G_FILE_ATTRIBUTE_TYPE_OBJECT: GFileAttributeType = 8;
pub const GFileAttributeType_G_FILE_ATTRIBUTE_TYPE_STRINGV: GFileAttributeType = 9;
/// GFileAttributeType:
/// @G_FILE_ATTRIBUTE_TYPE_INVALID: indicates an invalid or uninitalized type.
/// @G_FILE_ATTRIBUTE_TYPE_STRING: a null terminated UTF8 string.
/// @G_FILE_ATTRIBUTE_TYPE_BYTE_STRING: a zero terminated string of non-zero bytes.
/// @G_FILE_ATTRIBUTE_TYPE_BOOLEAN: a boolean value.
/// @G_FILE_ATTRIBUTE_TYPE_UINT32: an unsigned 4-byte/32-bit integer.
/// @G_FILE_ATTRIBUTE_TYPE_INT32: a signed 4-byte/32-bit integer.
/// @G_FILE_ATTRIBUTE_TYPE_UINT64: an unsigned 8-byte/64-bit integer.
/// @G_FILE_ATTRIBUTE_TYPE_INT64: a signed 8-byte/64-bit integer.
/// @G_FILE_ATTRIBUTE_TYPE_OBJECT: a #GObject.
/// @G_FILE_ATTRIBUTE_TYPE_STRINGV: a %NULL terminated char **. Since 2.22
///
/// The data types for file attributes.
pub type GFileAttributeType = u32;
pub const GFileAttributeInfoFlags_G_FILE_ATTRIBUTE_INFO_NONE: GFileAttributeInfoFlags = 0;
pub const GFileAttributeInfoFlags_G_FILE_ATTRIBUTE_INFO_COPY_WITH_FILE: GFileAttributeInfoFlags = 1;
pub const GFileAttributeInfoFlags_G_FILE_ATTRIBUTE_INFO_COPY_WHEN_MOVED: GFileAttributeInfoFlags =
    2;
/// GFileAttributeInfoFlags:
/// @G_FILE_ATTRIBUTE_INFO_NONE: no flags set.
/// @G_FILE_ATTRIBUTE_INFO_COPY_WITH_FILE: copy the attribute values when the file is copied.
/// @G_FILE_ATTRIBUTE_INFO_COPY_WHEN_MOVED: copy the attribute values when the file is moved.
///
/// Flags specifying the behaviour of an attribute.
pub type GFileAttributeInfoFlags = u32;
pub const GFileAttributeStatus_G_FILE_ATTRIBUTE_STATUS_UNSET: GFileAttributeStatus = 0;
pub const GFileAttributeStatus_G_FILE_ATTRIBUTE_STATUS_SET: GFileAttributeStatus = 1;
pub const GFileAttributeStatus_G_FILE_ATTRIBUTE_STATUS_ERROR_SETTING: GFileAttributeStatus = 2;
/// GFileAttributeStatus:
/// @G_FILE_ATTRIBUTE_STATUS_UNSET: Attribute value is unset (empty).
/// @G_FILE_ATTRIBUTE_STATUS_SET: Attribute value is set.
/// @G_FILE_ATTRIBUTE_STATUS_ERROR_SETTING: Indicates an error in setting the value.
///
/// Used by g_file_set_attributes_from_info() when setting file attributes.
pub type GFileAttributeStatus = u32;
pub const GFileQueryInfoFlags_G_FILE_QUERY_INFO_NONE: GFileQueryInfoFlags = 0;
pub const GFileQueryInfoFlags_G_FILE_QUERY_INFO_NOFOLLOW_SYMLINKS: GFileQueryInfoFlags = 1;
/// GFileQueryInfoFlags:
/// @G_FILE_QUERY_INFO_NONE: No flags set.
/// @G_FILE_QUERY_INFO_NOFOLLOW_SYMLINKS: Don't follow symlinks.
///
/// Flags used when querying a #GFileInfo.
pub type GFileQueryInfoFlags = u32;
pub const GFileCreateFlags_G_FILE_CREATE_NONE: GFileCreateFlags = 0;
pub const GFileCreateFlags_G_FILE_CREATE_PRIVATE: GFileCreateFlags = 1;
pub const GFileCreateFlags_G_FILE_CREATE_REPLACE_DESTINATION: GFileCreateFlags = 2;
/// GFileCreateFlags:
/// @G_FILE_CREATE_NONE: No flags set.
/// @G_FILE_CREATE_PRIVATE: Create a file that can only be
/// accessed by the current user.
/// @G_FILE_CREATE_REPLACE_DESTINATION: Replace the destination
/// as if it didn't exist before. Don't try to keep any old
/// permissions, replace instead of following links. This
/// is generally useful if you're doing a "copy over"
/// rather than a "save new version of" replace operation.
/// You can think of it as "unlink destination" before
/// writing to it, although the implementation may not
/// be exactly like that. Since 2.20
///
/// Flags used when an operation may create a file.
pub type GFileCreateFlags = u32;
pub const GFileMeasureFlags_G_FILE_MEASURE_NONE: GFileMeasureFlags = 0;
pub const GFileMeasureFlags_G_FILE_MEASURE_REPORT_ANY_ERROR: GFileMeasureFlags = 2;
pub const GFileMeasureFlags_G_FILE_MEASURE_APPARENT_SIZE: GFileMeasureFlags = 4;
pub const GFileMeasureFlags_G_FILE_MEASURE_NO_XDEV: GFileMeasureFlags = 8;
/// GFileMeasureFlags:
/// @G_FILE_MEASURE_NONE: No flags set.
/// @G_FILE_MEASURE_REPORT_ANY_ERROR: Report any error encountered
/// while traversing the directory tree.  Normally errors are only
/// reported for the toplevel file.
/// @G_FILE_MEASURE_APPARENT_SIZE: Tally usage based on apparent file
/// sizes.  Normally, the block-size is used, if available, as this is a
/// more accurate representation of disk space used.
/// Compare with `du --apparent-size`.
/// @G_FILE_MEASURE_NO_XDEV: Do not cross mount point boundaries.
/// Compare with `du -x`.
///
/// Flags that can be used with g_file_measure_disk_usage().
///
/// Since: 2.38
pub type GFileMeasureFlags = u32;
pub const GMountMountFlags_G_MOUNT_MOUNT_NONE: GMountMountFlags = 0;
/// GMountMountFlags:
/// @G_MOUNT_MOUNT_NONE: No flags set.
///
/// Flags used when mounting a mount.
pub type GMountMountFlags = u32;
pub const GMountUnmountFlags_G_MOUNT_UNMOUNT_NONE: GMountUnmountFlags = 0;
pub const GMountUnmountFlags_G_MOUNT_UNMOUNT_FORCE: GMountUnmountFlags = 1;
/// GMountUnmountFlags:
/// @G_MOUNT_UNMOUNT_NONE: No flags set.
/// @G_MOUNT_UNMOUNT_FORCE: Unmount even if there are outstanding
/// file operations on the mount.
///
/// Flags used when an unmounting a mount.
pub type GMountUnmountFlags = u32;
pub const GDriveStartFlags_G_DRIVE_START_NONE: GDriveStartFlags = 0;
/// GDriveStartFlags:
/// @G_DRIVE_START_NONE: No flags set.
///
/// Flags used when starting a drive.
///
/// Since: 2.22
pub type GDriveStartFlags = u32;
pub const GDriveStartStopType_G_DRIVE_START_STOP_TYPE_UNKNOWN: GDriveStartStopType = 0;
pub const GDriveStartStopType_G_DRIVE_START_STOP_TYPE_SHUTDOWN: GDriveStartStopType = 1;
pub const GDriveStartStopType_G_DRIVE_START_STOP_TYPE_NETWORK: GDriveStartStopType = 2;
pub const GDriveStartStopType_G_DRIVE_START_STOP_TYPE_MULTIDISK: GDriveStartStopType = 3;
pub const GDriveStartStopType_G_DRIVE_START_STOP_TYPE_PASSWORD: GDriveStartStopType = 4;
/// GDriveStartStopType:
/// @G_DRIVE_START_STOP_TYPE_UNKNOWN: Unknown or drive doesn't support
/// start/stop.
/// @G_DRIVE_START_STOP_TYPE_SHUTDOWN: The stop method will physically
/// shut down the drive and e.g. power down the port the drive is
/// attached to.
/// @G_DRIVE_START_STOP_TYPE_NETWORK: The start/stop methods are used
/// for connecting/disconnect to the drive over the network.
/// @G_DRIVE_START_STOP_TYPE_MULTIDISK: The start/stop methods will
/// assemble/disassemble a virtual drive from several physical
/// drives.
/// @G_DRIVE_START_STOP_TYPE_PASSWORD: The start/stop methods will
/// unlock/lock the disk (for example using the ATA <quote>SECURITY
/// UNLOCK DEVICE</quote> command)
///
/// Enumeration describing how a drive can be started/stopped.
///
/// Since: 2.22
pub type GDriveStartStopType = u32;
pub const GFileCopyFlags_G_FILE_COPY_NONE: GFileCopyFlags = 0;
pub const GFileCopyFlags_G_FILE_COPY_OVERWRITE: GFileCopyFlags = 1;
pub const GFileCopyFlags_G_FILE_COPY_BACKUP: GFileCopyFlags = 2;
pub const GFileCopyFlags_G_FILE_COPY_NOFOLLOW_SYMLINKS: GFileCopyFlags = 4;
pub const GFileCopyFlags_G_FILE_COPY_ALL_METADATA: GFileCopyFlags = 8;
pub const GFileCopyFlags_G_FILE_COPY_NO_FALLBACK_FOR_MOVE: GFileCopyFlags = 16;
pub const GFileCopyFlags_G_FILE_COPY_TARGET_DEFAULT_PERMS: GFileCopyFlags = 32;
/// GFileCopyFlags:
/// @G_FILE_COPY_NONE: No flags set.
/// @G_FILE_COPY_OVERWRITE: Overwrite any existing files
/// @G_FILE_COPY_BACKUP: Make a backup of any existing files.
/// @G_FILE_COPY_NOFOLLOW_SYMLINKS: Don't follow symlinks.
/// @G_FILE_COPY_ALL_METADATA: Copy all file metadata instead of just default set used for copy (see #GFileInfo).
/// @G_FILE_COPY_NO_FALLBACK_FOR_MOVE: Don't use copy and delete fallback if native move not supported.
/// @G_FILE_COPY_TARGET_DEFAULT_PERMS: Leaves target file with default perms, instead of setting the source file perms.
///
/// Flags used when copying or moving files.
pub type GFileCopyFlags = u32;
pub const GFileMonitorFlags_G_FILE_MONITOR_NONE: GFileMonitorFlags = 0;
pub const GFileMonitorFlags_G_FILE_MONITOR_WATCH_MOUNTS: GFileMonitorFlags = 1;
pub const GFileMonitorFlags_G_FILE_MONITOR_SEND_MOVED: GFileMonitorFlags = 2;
pub const GFileMonitorFlags_G_FILE_MONITOR_WATCH_HARD_LINKS: GFileMonitorFlags = 4;
pub const GFileMonitorFlags_G_FILE_MONITOR_WATCH_MOVES: GFileMonitorFlags = 8;
/// GFileMonitorFlags:
/// @G_FILE_MONITOR_NONE: No flags set.
/// @G_FILE_MONITOR_WATCH_MOUNTS: Watch for mount events.
/// @G_FILE_MONITOR_SEND_MOVED: Pair DELETED and CREATED events caused
/// by file renames (moves) and send a single G_FILE_MONITOR_EVENT_MOVED
/// event instead (NB: not supported on all backends; the default
/// behaviour -without specifying this flag- is to send single DELETED
/// and CREATED events).  Deprecated since 2.46: use
/// %G_FILE_MONITOR_WATCH_MOVES instead.
/// @G_FILE_MONITOR_WATCH_HARD_LINKS: Watch for changes to the file made
/// via another hard link. Since 2.36.
/// @G_FILE_MONITOR_WATCH_MOVES: Watch for rename operations on a
/// monitored directory.  This causes %G_FILE_MONITOR_EVENT_RENAMED,
/// %G_FILE_MONITOR_EVENT_MOVED_IN and %G_FILE_MONITOR_EVENT_MOVED_OUT
/// events to be emitted when possible.  Since: 2.46.
///
/// Flags used to set what a #GFileMonitor will watch for.
pub type GFileMonitorFlags = u32;
pub const GFileType_G_FILE_TYPE_UNKNOWN: GFileType = 0;
pub const GFileType_G_FILE_TYPE_REGULAR: GFileType = 1;
pub const GFileType_G_FILE_TYPE_DIRECTORY: GFileType = 2;
pub const GFileType_G_FILE_TYPE_SYMBOLIC_LINK: GFileType = 3;
pub const GFileType_G_FILE_TYPE_SPECIAL: GFileType = 4;
pub const GFileType_G_FILE_TYPE_SHORTCUT: GFileType = 5;
pub const GFileType_G_FILE_TYPE_MOUNTABLE: GFileType = 6;
/// GFileType:
/// @G_FILE_TYPE_UNKNOWN: File's type is unknown.
/// @G_FILE_TYPE_REGULAR: File handle represents a regular file.
/// @G_FILE_TYPE_DIRECTORY: File handle represents a directory.
/// @G_FILE_TYPE_SYMBOLIC_LINK: File handle represents a symbolic link
/// (Unix systems).
/// @G_FILE_TYPE_SPECIAL: File is a "special" file, such as a socket, fifo,
/// block device, or character device.
/// @G_FILE_TYPE_SHORTCUT: File is a shortcut (Windows systems).
/// @G_FILE_TYPE_MOUNTABLE: File is a mountable location.
///
/// Indicates the file's on-disk type.
pub type GFileType = u32;
pub const GFilesystemPreviewType_G_FILESYSTEM_PREVIEW_TYPE_IF_ALWAYS: GFilesystemPreviewType = 0;
pub const GFilesystemPreviewType_G_FILESYSTEM_PREVIEW_TYPE_IF_LOCAL: GFilesystemPreviewType = 1;
pub const GFilesystemPreviewType_G_FILESYSTEM_PREVIEW_TYPE_NEVER: GFilesystemPreviewType = 2;
/// GFilesystemPreviewType:
/// @G_FILESYSTEM_PREVIEW_TYPE_IF_ALWAYS: Only preview files if user has explicitly requested it.
/// @G_FILESYSTEM_PREVIEW_TYPE_IF_LOCAL: Preview files if user has requested preview of "local" files.
/// @G_FILESYSTEM_PREVIEW_TYPE_NEVER: Never preview files.
///
/// Indicates a hint from the file system whether files should be
/// previewed in a file manager. Returned as the value of the key
/// #G_FILE_ATTRIBUTE_FILESYSTEM_USE_PREVIEW.
pub type GFilesystemPreviewType = u32;
pub const GFileMonitorEvent_G_FILE_MONITOR_EVENT_CHANGED: GFileMonitorEvent = 0;
pub const GFileMonitorEvent_G_FILE_MONITOR_EVENT_CHANGES_DONE_HINT: GFileMonitorEvent = 1;
pub const GFileMonitorEvent_G_FILE_MONITOR_EVENT_DELETED: GFileMonitorEvent = 2;
pub const GFileMonitorEvent_G_FILE_MONITOR_EVENT_CREATED: GFileMonitorEvent = 3;
pub const GFileMonitorEvent_G_FILE_MONITOR_EVENT_ATTRIBUTE_CHANGED: GFileMonitorEvent = 4;
pub const GFileMonitorEvent_G_FILE_MONITOR_EVENT_PRE_UNMOUNT: GFileMonitorEvent = 5;
pub const GFileMonitorEvent_G_FILE_MONITOR_EVENT_UNMOUNTED: GFileMonitorEvent = 6;
pub const GFileMonitorEvent_G_FILE_MONITOR_EVENT_MOVED: GFileMonitorEvent = 7;
pub const GFileMonitorEvent_G_FILE_MONITOR_EVENT_RENAMED: GFileMonitorEvent = 8;
pub const GFileMonitorEvent_G_FILE_MONITOR_EVENT_MOVED_IN: GFileMonitorEvent = 9;
pub const GFileMonitorEvent_G_FILE_MONITOR_EVENT_MOVED_OUT: GFileMonitorEvent = 10;
/// GFileMonitorEvent:
/// @G_FILE_MONITOR_EVENT_CHANGED: a file changed.
/// @G_FILE_MONITOR_EVENT_CHANGES_DONE_HINT: a hint that this was probably the last change in a set of changes.
/// @G_FILE_MONITOR_EVENT_DELETED: a file was deleted.
/// @G_FILE_MONITOR_EVENT_CREATED: a file was created.
/// @G_FILE_MONITOR_EVENT_ATTRIBUTE_CHANGED: a file attribute was changed.
/// @G_FILE_MONITOR_EVENT_PRE_UNMOUNT: the file location will soon be unmounted.
/// @G_FILE_MONITOR_EVENT_UNMOUNTED: the file location was unmounted.
/// @G_FILE_MONITOR_EVENT_MOVED: the file was moved -- only sent if the
/// (deprecated) %G_FILE_MONITOR_SEND_MOVED flag is set
/// @G_FILE_MONITOR_EVENT_RENAMED: the file was renamed within the
/// current directory -- only sent if the %G_FILE_MONITOR_WATCH_MOVES
/// flag is set.  Since: 2.46.
/// @G_FILE_MONITOR_EVENT_MOVED_IN: the file was moved into the
/// monitored directory from another location -- only sent if the
/// %G_FILE_MONITOR_WATCH_MOVES flag is set.  Since: 2.46.
/// @G_FILE_MONITOR_EVENT_MOVED_OUT: the file was moved out of the
/// monitored directory to another location -- only sent if the
/// %G_FILE_MONITOR_WATCH_MOVES flag is set.  Since: 2.46
///
/// Specifies what type of event a monitor event is.
pub type GFileMonitorEvent = u32;
pub const GIOErrorEnum_G_IO_ERROR_FAILED: GIOErrorEnum = 0;
pub const GIOErrorEnum_G_IO_ERROR_NOT_FOUND: GIOErrorEnum = 1;
pub const GIOErrorEnum_G_IO_ERROR_EXISTS: GIOErrorEnum = 2;
pub const GIOErrorEnum_G_IO_ERROR_IS_DIRECTORY: GIOErrorEnum = 3;
pub const GIOErrorEnum_G_IO_ERROR_NOT_DIRECTORY: GIOErrorEnum = 4;
pub const GIOErrorEnum_G_IO_ERROR_NOT_EMPTY: GIOErrorEnum = 5;
pub const GIOErrorEnum_G_IO_ERROR_NOT_REGULAR_FILE: GIOErrorEnum = 6;
pub const GIOErrorEnum_G_IO_ERROR_NOT_SYMBOLIC_LINK: GIOErrorEnum = 7;
pub const GIOErrorEnum_G_IO_ERROR_NOT_MOUNTABLE_FILE: GIOErrorEnum = 8;
pub const GIOErrorEnum_G_IO_ERROR_FILENAME_TOO_LONG: GIOErrorEnum = 9;
pub const GIOErrorEnum_G_IO_ERROR_INVALID_FILENAME: GIOErrorEnum = 10;
pub const GIOErrorEnum_G_IO_ERROR_TOO_MANY_LINKS: GIOErrorEnum = 11;
pub const GIOErrorEnum_G_IO_ERROR_NO_SPACE: GIOErrorEnum = 12;
pub const GIOErrorEnum_G_IO_ERROR_INVALID_ARGUMENT: GIOErrorEnum = 13;
pub const GIOErrorEnum_G_IO_ERROR_PERMISSION_DENIED: GIOErrorEnum = 14;
pub const GIOErrorEnum_G_IO_ERROR_NOT_SUPPORTED: GIOErrorEnum = 15;
pub const GIOErrorEnum_G_IO_ERROR_NOT_MOUNTED: GIOErrorEnum = 16;
pub const GIOErrorEnum_G_IO_ERROR_ALREADY_MOUNTED: GIOErrorEnum = 17;
pub const GIOErrorEnum_G_IO_ERROR_CLOSED: GIOErrorEnum = 18;
pub const GIOErrorEnum_G_IO_ERROR_CANCELLED: GIOErrorEnum = 19;
pub const GIOErrorEnum_G_IO_ERROR_PENDING: GIOErrorEnum = 20;
pub const GIOErrorEnum_G_IO_ERROR_READ_ONLY: GIOErrorEnum = 21;
pub const GIOErrorEnum_G_IO_ERROR_CANT_CREATE_BACKUP: GIOErrorEnum = 22;
pub const GIOErrorEnum_G_IO_ERROR_WRONG_ETAG: GIOErrorEnum = 23;
pub const GIOErrorEnum_G_IO_ERROR_TIMED_OUT: GIOErrorEnum = 24;
pub const GIOErrorEnum_G_IO_ERROR_WOULD_RECURSE: GIOErrorEnum = 25;
pub const GIOErrorEnum_G_IO_ERROR_BUSY: GIOErrorEnum = 26;
pub const GIOErrorEnum_G_IO_ERROR_WOULD_BLOCK: GIOErrorEnum = 27;
pub const GIOErrorEnum_G_IO_ERROR_HOST_NOT_FOUND: GIOErrorEnum = 28;
pub const GIOErrorEnum_G_IO_ERROR_WOULD_MERGE: GIOErrorEnum = 29;
pub const GIOErrorEnum_G_IO_ERROR_FAILED_HANDLED: GIOErrorEnum = 30;
pub const GIOErrorEnum_G_IO_ERROR_TOO_MANY_OPEN_FILES: GIOErrorEnum = 31;
pub const GIOErrorEnum_G_IO_ERROR_NOT_INITIALIZED: GIOErrorEnum = 32;
pub const GIOErrorEnum_G_IO_ERROR_ADDRESS_IN_USE: GIOErrorEnum = 33;
pub const GIOErrorEnum_G_IO_ERROR_PARTIAL_INPUT: GIOErrorEnum = 34;
pub const GIOErrorEnum_G_IO_ERROR_INVALID_DATA: GIOErrorEnum = 35;
pub const GIOErrorEnum_G_IO_ERROR_DBUS_ERROR: GIOErrorEnum = 36;
pub const GIOErrorEnum_G_IO_ERROR_HOST_UNREACHABLE: GIOErrorEnum = 37;
pub const GIOErrorEnum_G_IO_ERROR_NETWORK_UNREACHABLE: GIOErrorEnum = 38;
pub const GIOErrorEnum_G_IO_ERROR_CONNECTION_REFUSED: GIOErrorEnum = 39;
pub const GIOErrorEnum_G_IO_ERROR_PROXY_FAILED: GIOErrorEnum = 40;
pub const GIOErrorEnum_G_IO_ERROR_PROXY_AUTH_FAILED: GIOErrorEnum = 41;
pub const GIOErrorEnum_G_IO_ERROR_PROXY_NEED_AUTH: GIOErrorEnum = 42;
pub const GIOErrorEnum_G_IO_ERROR_PROXY_NOT_ALLOWED: GIOErrorEnum = 43;
pub const GIOErrorEnum_G_IO_ERROR_BROKEN_PIPE: GIOErrorEnum = 44;
pub const GIOErrorEnum_G_IO_ERROR_CONNECTION_CLOSED: GIOErrorEnum = 44;
pub const GIOErrorEnum_G_IO_ERROR_NOT_CONNECTED: GIOErrorEnum = 45;
pub const GIOErrorEnum_G_IO_ERROR_MESSAGE_TOO_LARGE: GIOErrorEnum = 46;
/// GIOErrorEnum:
/// @G_IO_ERROR_FAILED: Generic error condition for when an operation fails
/// and no more specific #GIOErrorEnum value is defined.
/// @G_IO_ERROR_NOT_FOUND: File not found.
/// @G_IO_ERROR_EXISTS: File already exists.
/// @G_IO_ERROR_IS_DIRECTORY: File is a directory.
/// @G_IO_ERROR_NOT_DIRECTORY: File is not a directory.
/// @G_IO_ERROR_NOT_EMPTY: File is a directory that isn't empty.
/// @G_IO_ERROR_NOT_REGULAR_FILE: File is not a regular file.
/// @G_IO_ERROR_NOT_SYMBOLIC_LINK: File is not a symbolic link.
/// @G_IO_ERROR_NOT_MOUNTABLE_FILE: File cannot be mounted.
/// @G_IO_ERROR_FILENAME_TOO_LONG: Filename is too many characters.
/// @G_IO_ERROR_INVALID_FILENAME: Filename is invalid or contains invalid characters.
/// @G_IO_ERROR_TOO_MANY_LINKS: File contains too many symbolic links.
/// @G_IO_ERROR_NO_SPACE: No space left on drive.
/// @G_IO_ERROR_INVALID_ARGUMENT: Invalid argument.
/// @G_IO_ERROR_PERMISSION_DENIED: Permission denied.
/// @G_IO_ERROR_NOT_SUPPORTED: Operation (or one of its parameters) not supported
/// @G_IO_ERROR_NOT_MOUNTED: File isn't mounted.
/// @G_IO_ERROR_ALREADY_MOUNTED: File is already mounted.
/// @G_IO_ERROR_CLOSED: File was closed.
/// @G_IO_ERROR_CANCELLED: Operation was cancelled. See #GCancellable.
/// @G_IO_ERROR_PENDING: Operations are still pending.
/// @G_IO_ERROR_READ_ONLY: File is read only.
/// @G_IO_ERROR_CANT_CREATE_BACKUP: Backup couldn't be created.
/// @G_IO_ERROR_WRONG_ETAG: File's Entity Tag was incorrect.
/// @G_IO_ERROR_TIMED_OUT: Operation timed out.
/// @G_IO_ERROR_WOULD_RECURSE: Operation would be recursive.
/// @G_IO_ERROR_BUSY: File is busy.
/// @G_IO_ERROR_WOULD_BLOCK: Operation would block.
/// @G_IO_ERROR_HOST_NOT_FOUND: Host couldn't be found (remote operations).
/// @G_IO_ERROR_WOULD_MERGE: Operation would merge files.
/// @G_IO_ERROR_FAILED_HANDLED: Operation failed and a helper program has
/// already interacted with the user. Do not display any error dialog.
/// @G_IO_ERROR_TOO_MANY_OPEN_FILES: The current process has too many files
/// open and can't open any more. Duplicate descriptors do count toward
/// this limit. Since 2.20
/// @G_IO_ERROR_NOT_INITIALIZED: The object has not been initialized. Since 2.22
/// @G_IO_ERROR_ADDRESS_IN_USE: The requested address is already in use. Since 2.22
/// @G_IO_ERROR_PARTIAL_INPUT: Need more input to finish operation. Since 2.24
/// @G_IO_ERROR_INVALID_DATA: The input data was invalid. Since 2.24
/// @G_IO_ERROR_DBUS_ERROR: A remote object generated an error that
/// doesn't correspond to a locally registered #GError error
/// domain. Use g_dbus_error_get_remote_error() to extract the D-Bus
/// error name and g_dbus_error_strip_remote_error() to fix up the
/// message so it matches what was received on the wire. Since 2.26.
/// @G_IO_ERROR_HOST_UNREACHABLE: Host unreachable. Since 2.26
/// @G_IO_ERROR_NETWORK_UNREACHABLE: Network unreachable. Since 2.26
/// @G_IO_ERROR_CONNECTION_REFUSED: Connection refused. Since 2.26
/// @G_IO_ERROR_PROXY_FAILED: Connection to proxy server failed. Since 2.26
/// @G_IO_ERROR_PROXY_AUTH_FAILED: Proxy authentication failed. Since 2.26
/// @G_IO_ERROR_PROXY_NEED_AUTH: Proxy server needs authentication. Since 2.26
/// @G_IO_ERROR_PROXY_NOT_ALLOWED: Proxy connection is not allowed by ruleset.
/// Since 2.26
/// @G_IO_ERROR_BROKEN_PIPE: Broken pipe. Since 2.36
/// @G_IO_ERROR_CONNECTION_CLOSED: Connection closed by peer. Note that this
/// is the same code as %G_IO_ERROR_BROKEN_PIPE; before 2.44 some
/// "connection closed" errors returned %G_IO_ERROR_BROKEN_PIPE, but others
/// returned %G_IO_ERROR_FAILED. Now they should all return the same
/// value, which has this more logical name. Since 2.44.
/// @G_IO_ERROR_NOT_CONNECTED: Transport endpoint is not connected. Since 2.44
/// @G_IO_ERROR_MESSAGE_TOO_LARGE: Message too large. Since 2.48.
///
/// Error codes returned by GIO functions.
///
/// Note that this domain may be extended in future GLib releases. In
/// general, new error codes either only apply to new APIs, or else
/// replace %G_IO_ERROR_FAILED in cases that were not explicitly
/// distinguished before. You should therefore avoid writing code like
/// |[<!-- language="C" -->
/// if (g_error_matches (error, G_IO_ERROR, G_IO_ERROR_FAILED))
/// {
/// // Assume that this is EPRINTERONFIRE
/// ...
/// }
/// ]|
/// but should instead treat all unrecognized error codes the same as
/// #G_IO_ERROR_FAILED.
pub type GIOErrorEnum = u32;
pub const GAskPasswordFlags_G_ASK_PASSWORD_NEED_PASSWORD: GAskPasswordFlags = 1;
pub const GAskPasswordFlags_G_ASK_PASSWORD_NEED_USERNAME: GAskPasswordFlags = 2;
pub const GAskPasswordFlags_G_ASK_PASSWORD_NEED_DOMAIN: GAskPasswordFlags = 4;
pub const GAskPasswordFlags_G_ASK_PASSWORD_SAVING_SUPPORTED: GAskPasswordFlags = 8;
pub const GAskPasswordFlags_G_ASK_PASSWORD_ANONYMOUS_SUPPORTED: GAskPasswordFlags = 16;
/// GAskPasswordFlags:
/// @G_ASK_PASSWORD_NEED_PASSWORD: operation requires a password.
/// @G_ASK_PASSWORD_NEED_USERNAME: operation requires a username.
/// @G_ASK_PASSWORD_NEED_DOMAIN: operation requires a domain.
/// @G_ASK_PASSWORD_SAVING_SUPPORTED: operation supports saving settings.
/// @G_ASK_PASSWORD_ANONYMOUS_SUPPORTED: operation supports anonymous users.
///
/// #GAskPasswordFlags are used to request specific information from the
/// user, or to notify the user of their choices in an authentication
/// situation.
pub type GAskPasswordFlags = u32;
pub const GPasswordSave_G_PASSWORD_SAVE_NEVER: GPasswordSave = 0;
pub const GPasswordSave_G_PASSWORD_SAVE_FOR_SESSION: GPasswordSave = 1;
pub const GPasswordSave_G_PASSWORD_SAVE_PERMANENTLY: GPasswordSave = 2;
/// GPasswordSave:
/// @G_PASSWORD_SAVE_NEVER: never save a password.
/// @G_PASSWORD_SAVE_FOR_SESSION: save a password for the session.
/// @G_PASSWORD_SAVE_PERMANENTLY: save a password permanently.
///
/// #GPasswordSave is used to indicate the lifespan of a saved password.
///
/// #Gvfs stores passwords in the Gnome keyring when this flag allows it
/// to, and later retrieves it again from there.
pub type GPasswordSave = u32;
pub const GMountOperationResult_G_MOUNT_OPERATION_HANDLED: GMountOperationResult = 0;
pub const GMountOperationResult_G_MOUNT_OPERATION_ABORTED: GMountOperationResult = 1;
pub const GMountOperationResult_G_MOUNT_OPERATION_UNHANDLED: GMountOperationResult = 2;
/// GMountOperationResult:
/// @G_MOUNT_OPERATION_HANDLED: The request was fulfilled and the
/// user specified data is now available
/// @G_MOUNT_OPERATION_ABORTED: The user requested the mount operation
/// to be aborted
/// @G_MOUNT_OPERATION_UNHANDLED: The request was unhandled (i.e. not
/// implemented)
///
/// #GMountOperationResult is returned as a result when a request for
/// information is send by the mounting operation.
pub type GMountOperationResult = u32;
pub const GOutputStreamSpliceFlags_G_OUTPUT_STREAM_SPLICE_NONE: GOutputStreamSpliceFlags = 0;
pub const GOutputStreamSpliceFlags_G_OUTPUT_STREAM_SPLICE_CLOSE_SOURCE: GOutputStreamSpliceFlags =
    1;
pub const GOutputStreamSpliceFlags_G_OUTPUT_STREAM_SPLICE_CLOSE_TARGET: GOutputStreamSpliceFlags =
    2;
/// GOutputStreamSpliceFlags:
/// @G_OUTPUT_STREAM_SPLICE_NONE: Do not close either stream.
/// @G_OUTPUT_STREAM_SPLICE_CLOSE_SOURCE: Close the source stream after
/// the splice.
/// @G_OUTPUT_STREAM_SPLICE_CLOSE_TARGET: Close the target stream after
/// the splice.
///
/// GOutputStreamSpliceFlags determine how streams should be spliced.
pub type GOutputStreamSpliceFlags = u32;
pub const GIOStreamSpliceFlags_G_IO_STREAM_SPLICE_NONE: GIOStreamSpliceFlags = 0;
pub const GIOStreamSpliceFlags_G_IO_STREAM_SPLICE_CLOSE_STREAM1: GIOStreamSpliceFlags = 1;
pub const GIOStreamSpliceFlags_G_IO_STREAM_SPLICE_CLOSE_STREAM2: GIOStreamSpliceFlags = 2;
pub const GIOStreamSpliceFlags_G_IO_STREAM_SPLICE_WAIT_FOR_BOTH: GIOStreamSpliceFlags = 4;
/// GIOStreamSpliceFlags:
/// @G_IO_STREAM_SPLICE_NONE: Do not close either stream.
/// @G_IO_STREAM_SPLICE_CLOSE_STREAM1: Close the first stream after
/// the splice.
/// @G_IO_STREAM_SPLICE_CLOSE_STREAM2: Close the second stream after
/// the splice.
/// @G_IO_STREAM_SPLICE_WAIT_FOR_BOTH: Wait for both splice operations to finish
/// before calling the callback.
///
/// GIOStreamSpliceFlags determine how streams should be spliced.
///
/// Since: 2.28
pub type GIOStreamSpliceFlags = u32;
pub const GEmblemOrigin_G_EMBLEM_ORIGIN_UNKNOWN: GEmblemOrigin = 0;
pub const GEmblemOrigin_G_EMBLEM_ORIGIN_DEVICE: GEmblemOrigin = 1;
pub const GEmblemOrigin_G_EMBLEM_ORIGIN_LIVEMETADATA: GEmblemOrigin = 2;
pub const GEmblemOrigin_G_EMBLEM_ORIGIN_TAG: GEmblemOrigin = 3;
/// GEmblemOrigin:
/// @G_EMBLEM_ORIGIN_UNKNOWN: Emblem of unknown origin
/// @G_EMBLEM_ORIGIN_DEVICE: Emblem adds device-specific information
/// @G_EMBLEM_ORIGIN_LIVEMETADATA: Emblem depicts live metadata, such as "readonly"
/// @G_EMBLEM_ORIGIN_TAG: Emblem comes from a user-defined tag, e.g. set by nautilus (in the future)
///
/// GEmblemOrigin is used to add information about the origin of the emblem
/// to #GEmblem.
///
/// Since: 2.18
pub type GEmblemOrigin = u32;
pub const GResolverError_G_RESOLVER_ERROR_NOT_FOUND: GResolverError = 0;
pub const GResolverError_G_RESOLVER_ERROR_TEMPORARY_FAILURE: GResolverError = 1;
pub const GResolverError_G_RESOLVER_ERROR_INTERNAL: GResolverError = 2;
/// GResolverError:
/// @G_RESOLVER_ERROR_NOT_FOUND: the requested name/address/service was not
/// found
/// @G_RESOLVER_ERROR_TEMPORARY_FAILURE: the requested information could not
/// be looked up due to a network error or similar problem
/// @G_RESOLVER_ERROR_INTERNAL: unknown error
///
/// An error code used with %G_RESOLVER_ERROR in a #GError returned
/// from a #GResolver routine.
///
/// Since: 2.22
pub type GResolverError = u32;
pub const GResolverRecordType_G_RESOLVER_RECORD_SRV: GResolverRecordType = 1;
pub const GResolverRecordType_G_RESOLVER_RECORD_MX: GResolverRecordType = 2;
pub const GResolverRecordType_G_RESOLVER_RECORD_TXT: GResolverRecordType = 3;
pub const GResolverRecordType_G_RESOLVER_RECORD_SOA: GResolverRecordType = 4;
pub const GResolverRecordType_G_RESOLVER_RECORD_NS: GResolverRecordType = 5;
/// GResolverRecordType:
/// @G_RESOLVER_RECORD_SRV: lookup DNS SRV records for a domain
/// @G_RESOLVER_RECORD_MX: lookup DNS MX records for a domain
/// @G_RESOLVER_RECORD_TXT: lookup DNS TXT records for a name
/// @G_RESOLVER_RECORD_SOA: lookup DNS SOA records for a zone
/// @G_RESOLVER_RECORD_NS: lookup DNS NS records for a domain
///
/// The type of record that g_resolver_lookup_records() or
/// g_resolver_lookup_records_async() should retrieve. The records are returned
/// as lists of #GVariant tuples. Each record type has different values in
/// the variant tuples returned.
///
/// %G_RESOLVER_RECORD_SRV records are returned as variants with the signature
/// '(qqqs)', containing a guint16 with the priority, a guint16 with the
/// weight, a guint16 with the port, and a string of the hostname.
///
/// %G_RESOLVER_RECORD_MX records are returned as variants with the signature
/// '(qs)', representing a guint16 with the preference, and a string containing
/// the mail exchanger hostname.
///
/// %G_RESOLVER_RECORD_TXT records are returned as variants with the signature
/// '(as)', representing an array of the strings in the text record.
///
/// %G_RESOLVER_RECORD_SOA records are returned as variants with the signature
/// '(ssuuuuu)', representing a string containing the primary name server, a
/// string containing the administrator, the serial as a guint32, the refresh
/// interval as guint32, the retry interval as a guint32, the expire timeout
/// as a guint32, and the ttl as a guint32.
///
/// %G_RESOLVER_RECORD_NS records are returned as variants with the signature
/// '(s)', representing a string of the hostname of the name server.
///
/// Since: 2.34
pub type GResolverRecordType = u32;
pub const GResourceError_G_RESOURCE_ERROR_NOT_FOUND: GResourceError = 0;
pub const GResourceError_G_RESOURCE_ERROR_INTERNAL: GResourceError = 1;
/// GResourceError:
/// @G_RESOURCE_ERROR_NOT_FOUND: no file was found at the requested path
/// @G_RESOURCE_ERROR_INTERNAL: unknown error
///
/// An error code used with %G_RESOURCE_ERROR in a #GError returned
/// from a #GResource routine.
///
/// Since: 2.32
pub type GResourceError = u32;
pub const GResourceFlags_G_RESOURCE_FLAGS_NONE: GResourceFlags = 0;
pub const GResourceFlags_G_RESOURCE_FLAGS_COMPRESSED: GResourceFlags = 1;
/// GResourceFlags:
/// @G_RESOURCE_FLAGS_NONE: No flags set.
/// @G_RESOURCE_FLAGS_COMPRESSED: The file is compressed.
///
/// GResourceFlags give information about a particular file inside a resource
/// bundle.
///
/// Since: 2.32
pub type GResourceFlags = u32;
pub const GResourceLookupFlags_G_RESOURCE_LOOKUP_FLAGS_NONE: GResourceLookupFlags = 0;
/// GResourceLookupFlags:
/// @G_RESOURCE_LOOKUP_FLAGS_NONE: No flags set.
///
/// GResourceLookupFlags determine how resource path lookups are handled.
///
/// Since: 2.32
pub type GResourceLookupFlags = u32;
pub const GSocketFamily_G_SOCKET_FAMILY_INVALID: GSocketFamily = 0;
pub const GSocketFamily_G_SOCKET_FAMILY_UNIX: GSocketFamily = 1;
pub const GSocketFamily_G_SOCKET_FAMILY_IPV4: GSocketFamily = 2;
pub const GSocketFamily_G_SOCKET_FAMILY_IPV6: GSocketFamily = 30;
/// GSocketFamily:
/// @G_SOCKET_FAMILY_INVALID: no address family
/// @G_SOCKET_FAMILY_IPV4: the IPv4 family
/// @G_SOCKET_FAMILY_IPV6: the IPv6 family
/// @G_SOCKET_FAMILY_UNIX: the UNIX domain family
///
/// The protocol family of a #GSocketAddress. (These values are
/// identical to the system defines %AF_INET, %AF_INET6 and %AF_UNIX,
/// if available.)
///
/// Since: 2.22
pub type GSocketFamily = u32;
pub const GSocketType_G_SOCKET_TYPE_INVALID: GSocketType = 0;
pub const GSocketType_G_SOCKET_TYPE_STREAM: GSocketType = 1;
pub const GSocketType_G_SOCKET_TYPE_DATAGRAM: GSocketType = 2;
pub const GSocketType_G_SOCKET_TYPE_SEQPACKET: GSocketType = 3;
/// GSocketType:
/// @G_SOCKET_TYPE_INVALID: Type unknown or wrong
/// @G_SOCKET_TYPE_STREAM: Reliable connection-based byte streams (e.g. TCP).
/// @G_SOCKET_TYPE_DATAGRAM: Connectionless, unreliable datagram passing.
/// (e.g. UDP)
/// @G_SOCKET_TYPE_SEQPACKET: Reliable connection-based passing of datagrams
/// of fixed maximum length (e.g. SCTP).
///
/// Flags used when creating a #GSocket. Some protocols may not implement
/// all the socket types.
///
/// Since: 2.22
pub type GSocketType = u32;
pub const GSocketMsgFlags_G_SOCKET_MSG_NONE: GSocketMsgFlags = 0;
pub const GSocketMsgFlags_G_SOCKET_MSG_OOB: GSocketMsgFlags = 1;
pub const GSocketMsgFlags_G_SOCKET_MSG_PEEK: GSocketMsgFlags = 2;
pub const GSocketMsgFlags_G_SOCKET_MSG_DONTROUTE: GSocketMsgFlags = 4;
/// GSocketMsgFlags:
/// @G_SOCKET_MSG_NONE: No flags.
/// @G_SOCKET_MSG_OOB: Request to send/receive out of band data.
/// @G_SOCKET_MSG_PEEK: Read data from the socket without removing it from
/// the queue.
/// @G_SOCKET_MSG_DONTROUTE: Don't use a gateway to send out the packet,
/// only send to hosts on directly connected networks.
///
/// Flags used in g_socket_receive_message() and g_socket_send_message().
/// The flags listed in the enum are some commonly available flags, but the
/// values used for them are the same as on the platform, and any other flags
/// are passed in/out as is. So to use a platform specific flag, just include
/// the right system header and pass in the flag.
///
/// Since: 2.22
pub type GSocketMsgFlags = u32;
pub const GSocketProtocol_G_SOCKET_PROTOCOL_UNKNOWN: GSocketProtocol = -1;
pub const GSocketProtocol_G_SOCKET_PROTOCOL_DEFAULT: GSocketProtocol = 0;
pub const GSocketProtocol_G_SOCKET_PROTOCOL_TCP: GSocketProtocol = 6;
pub const GSocketProtocol_G_SOCKET_PROTOCOL_UDP: GSocketProtocol = 17;
pub const GSocketProtocol_G_SOCKET_PROTOCOL_SCTP: GSocketProtocol = 132;
/// GSocketProtocol:
/// @G_SOCKET_PROTOCOL_UNKNOWN: The protocol type is unknown
/// @G_SOCKET_PROTOCOL_DEFAULT: The default protocol for the family/type
/// @G_SOCKET_PROTOCOL_TCP: TCP over IP
/// @G_SOCKET_PROTOCOL_UDP: UDP over IP
/// @G_SOCKET_PROTOCOL_SCTP: SCTP over IP
///
/// A protocol identifier is specified when creating a #GSocket, which is a
/// family/type specific identifier, where 0 means the default protocol for
/// the particular family/type.
///
/// This enum contains a set of commonly available and used protocols. You
/// can also pass any other identifiers handled by the platform in order to
/// use protocols not listed here.
///
/// Since: 2.22
pub type GSocketProtocol = i32;
pub const GZlibCompressorFormat_G_ZLIB_COMPRESSOR_FORMAT_ZLIB: GZlibCompressorFormat = 0;
pub const GZlibCompressorFormat_G_ZLIB_COMPRESSOR_FORMAT_GZIP: GZlibCompressorFormat = 1;
pub const GZlibCompressorFormat_G_ZLIB_COMPRESSOR_FORMAT_RAW: GZlibCompressorFormat = 2;
/// GZlibCompressorFormat:
/// @G_ZLIB_COMPRESSOR_FORMAT_ZLIB: deflate compression with zlib header
/// @G_ZLIB_COMPRESSOR_FORMAT_GZIP: gzip file format
/// @G_ZLIB_COMPRESSOR_FORMAT_RAW: deflate compression with no header
///
/// Used to select the type of data format to use for #GZlibDecompressor
/// and #GZlibCompressor.
///
/// Since: 2.24
pub type GZlibCompressorFormat = u32;
pub const GUnixSocketAddressType_G_UNIX_SOCKET_ADDRESS_INVALID: GUnixSocketAddressType = 0;
pub const GUnixSocketAddressType_G_UNIX_SOCKET_ADDRESS_ANONYMOUS: GUnixSocketAddressType = 1;
pub const GUnixSocketAddressType_G_UNIX_SOCKET_ADDRESS_PATH: GUnixSocketAddressType = 2;
pub const GUnixSocketAddressType_G_UNIX_SOCKET_ADDRESS_ABSTRACT: GUnixSocketAddressType = 3;
pub const GUnixSocketAddressType_G_UNIX_SOCKET_ADDRESS_ABSTRACT_PADDED: GUnixSocketAddressType = 4;
/// GUnixSocketAddressType:
/// @G_UNIX_SOCKET_ADDRESS_INVALID: invalid
/// @G_UNIX_SOCKET_ADDRESS_ANONYMOUS: anonymous
/// @G_UNIX_SOCKET_ADDRESS_PATH: a filesystem path
/// @G_UNIX_SOCKET_ADDRESS_ABSTRACT: an abstract name
/// @G_UNIX_SOCKET_ADDRESS_ABSTRACT_PADDED: an abstract name, 0-padded
/// to the full length of a unix socket name
///
/// The type of name used by a #GUnixSocketAddress.
/// %G_UNIX_SOCKET_ADDRESS_PATH indicates a traditional unix domain
/// socket bound to a filesystem path. %G_UNIX_SOCKET_ADDRESS_ANONYMOUS
/// indicates a socket not bound to any name (eg, a client-side socket,
/// or a socket created with socketpair()).
///
/// For abstract sockets, there are two incompatible ways of naming
/// them; the man pages suggest using the entire `struct sockaddr_un`
/// as the name, padding the unused parts of the %sun_path field with
/// zeroes; this corresponds to %G_UNIX_SOCKET_ADDRESS_ABSTRACT_PADDED.
/// However, many programs instead just use a portion of %sun_path, and
/// pass an appropriate smaller length to bind() or connect(). This is
/// %G_UNIX_SOCKET_ADDRESS_ABSTRACT.
///
/// Since: 2.26
pub type GUnixSocketAddressType = u32;
pub const GBusType_G_BUS_TYPE_STARTER: GBusType = -1;
pub const GBusType_G_BUS_TYPE_NONE: GBusType = 0;
pub const GBusType_G_BUS_TYPE_SYSTEM: GBusType = 1;
pub const GBusType_G_BUS_TYPE_SESSION: GBusType = 2;
/// GBusType:
/// @G_BUS_TYPE_STARTER: An alias for the message bus that activated the process, if any.
/// @G_BUS_TYPE_NONE: Not a message bus.
/// @G_BUS_TYPE_SYSTEM: The system-wide message bus.
/// @G_BUS_TYPE_SESSION: The login session message bus.
///
/// An enumeration for well-known message buses.
///
/// Since: 2.26
pub type GBusType = i32;
pub const GBusNameOwnerFlags_G_BUS_NAME_OWNER_FLAGS_NONE: GBusNameOwnerFlags = 0;
pub const GBusNameOwnerFlags_G_BUS_NAME_OWNER_FLAGS_ALLOW_REPLACEMENT: GBusNameOwnerFlags = 1;
pub const GBusNameOwnerFlags_G_BUS_NAME_OWNER_FLAGS_REPLACE: GBusNameOwnerFlags = 2;
pub const GBusNameOwnerFlags_G_BUS_NAME_OWNER_FLAGS_DO_NOT_QUEUE: GBusNameOwnerFlags = 4;
/// GBusNameOwnerFlags:
/// @G_BUS_NAME_OWNER_FLAGS_NONE: No flags set.
/// @G_BUS_NAME_OWNER_FLAGS_ALLOW_REPLACEMENT: Allow another message bus connection to claim the name.
/// @G_BUS_NAME_OWNER_FLAGS_REPLACE: If another message bus connection owns the name and have
/// specified #G_BUS_NAME_OWNER_FLAGS_ALLOW_REPLACEMENT, then take the name from the other connection.
/// @G_BUS_NAME_OWNER_FLAGS_DO_NOT_QUEUE: If another message bus connection owns the name, immediately
/// return an error from g_bus_own_name() rather than entering the waiting queue for that name. (Since 2.54)
///
/// Flags used in g_bus_own_name().
///
/// Since: 2.26
pub type GBusNameOwnerFlags = u32;
pub const GBusNameWatcherFlags_G_BUS_NAME_WATCHER_FLAGS_NONE: GBusNameWatcherFlags = 0;
pub const GBusNameWatcherFlags_G_BUS_NAME_WATCHER_FLAGS_AUTO_START: GBusNameWatcherFlags = 1;
/// GBusNameWatcherFlags:
/// @G_BUS_NAME_WATCHER_FLAGS_NONE: No flags set.
/// @G_BUS_NAME_WATCHER_FLAGS_AUTO_START: If no-one owns the name when
/// beginning to watch the name, ask the bus to launch an owner for the
/// name.
///
/// Flags used in g_bus_watch_name().
///
/// Since: 2.26
pub type GBusNameWatcherFlags = u32;
pub const GDBusProxyFlags_G_DBUS_PROXY_FLAGS_NONE: GDBusProxyFlags = 0;
pub const GDBusProxyFlags_G_DBUS_PROXY_FLAGS_DO_NOT_LOAD_PROPERTIES: GDBusProxyFlags = 1;
pub const GDBusProxyFlags_G_DBUS_PROXY_FLAGS_DO_NOT_CONNECT_SIGNALS: GDBusProxyFlags = 2;
pub const GDBusProxyFlags_G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START: GDBusProxyFlags = 4;
pub const GDBusProxyFlags_G_DBUS_PROXY_FLAGS_GET_INVALIDATED_PROPERTIES: GDBusProxyFlags = 8;
pub const GDBusProxyFlags_G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START_AT_CONSTRUCTION: GDBusProxyFlags =
    16;
/// GDBusProxyFlags:
/// @G_DBUS_PROXY_FLAGS_NONE: No flags set.
/// @G_DBUS_PROXY_FLAGS_DO_NOT_LOAD_PROPERTIES: Don't load properties.
/// @G_DBUS_PROXY_FLAGS_DO_NOT_CONNECT_SIGNALS: Don't connect to signals on the remote object.
/// @G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START: If the proxy is for a well-known name,
/// do not ask the bus to launch an owner during proxy initialization or a method call.
/// This flag is only meaningful in proxies for well-known names.
/// @G_DBUS_PROXY_FLAGS_GET_INVALIDATED_PROPERTIES: If set, the property value for any __invalidated property__ will be (asynchronously) retrieved upon receiving the [`PropertiesChanged`](http://dbus.freedesktop.org/doc/dbus-specification.html#standard-interfaces-properties) D-Bus signal and the property will not cause emission of the #GDBusProxy::g-properties-changed signal. When the value is received the #GDBusProxy::g-properties-changed signal is emitted for the property along with the retrieved value. Since 2.32.
/// @G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START_AT_CONSTRUCTION: If the proxy is for a well-known name,
/// do not ask the bus to launch an owner during proxy initialization, but allow it to be
/// autostarted by a method call. This flag is only meaningful in proxies for well-known names,
/// and only if %G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START is not also specified.
///
/// Flags used when constructing an instance of a #GDBusProxy derived class.
///
/// Since: 2.26
pub type GDBusProxyFlags = u32;
pub const GDBusError_G_DBUS_ERROR_FAILED: GDBusError = 0;
pub const GDBusError_G_DBUS_ERROR_NO_MEMORY: GDBusError = 1;
pub const GDBusError_G_DBUS_ERROR_SERVICE_UNKNOWN: GDBusError = 2;
pub const GDBusError_G_DBUS_ERROR_NAME_HAS_NO_OWNER: GDBusError = 3;
pub const GDBusError_G_DBUS_ERROR_NO_REPLY: GDBusError = 4;
pub const GDBusError_G_DBUS_ERROR_IO_ERROR: GDBusError = 5;
pub const GDBusError_G_DBUS_ERROR_BAD_ADDRESS: GDBusError = 6;
pub const GDBusError_G_DBUS_ERROR_NOT_SUPPORTED: GDBusError = 7;
pub const GDBusError_G_DBUS_ERROR_LIMITS_EXCEEDED: GDBusError = 8;
pub const GDBusError_G_DBUS_ERROR_ACCESS_DENIED: GDBusError = 9;
pub const GDBusError_G_DBUS_ERROR_AUTH_FAILED: GDBusError = 10;
pub const GDBusError_G_DBUS_ERROR_NO_SERVER: GDBusError = 11;
pub const GDBusError_G_DBUS_ERROR_TIMEOUT: GDBusError = 12;
pub const GDBusError_G_DBUS_ERROR_NO_NETWORK: GDBusError = 13;
pub const GDBusError_G_DBUS_ERROR_ADDRESS_IN_USE: GDBusError = 14;
pub const GDBusError_G_DBUS_ERROR_DISCONNECTED: GDBusError = 15;
pub const GDBusError_G_DBUS_ERROR_INVALID_ARGS: GDBusError = 16;
pub const GDBusError_G_DBUS_ERROR_FILE_NOT_FOUND: GDBusError = 17;
pub const GDBusError_G_DBUS_ERROR_FILE_EXISTS: GDBusError = 18;
pub const GDBusError_G_DBUS_ERROR_UNKNOWN_METHOD: GDBusError = 19;
pub const GDBusError_G_DBUS_ERROR_TIMED_OUT: GDBusError = 20;
pub const GDBusError_G_DBUS_ERROR_MATCH_RULE_NOT_FOUND: GDBusError = 21;
pub const GDBusError_G_DBUS_ERROR_MATCH_RULE_INVALID: GDBusError = 22;
pub const GDBusError_G_DBUS_ERROR_SPAWN_EXEC_FAILED: GDBusError = 23;
pub const GDBusError_G_DBUS_ERROR_SPAWN_FORK_FAILED: GDBusError = 24;
pub const GDBusError_G_DBUS_ERROR_SPAWN_CHILD_EXITED: GDBusError = 25;
pub const GDBusError_G_DBUS_ERROR_SPAWN_CHILD_SIGNALED: GDBusError = 26;
pub const GDBusError_G_DBUS_ERROR_SPAWN_FAILED: GDBusError = 27;
pub const GDBusError_G_DBUS_ERROR_SPAWN_SETUP_FAILED: GDBusError = 28;
pub const GDBusError_G_DBUS_ERROR_SPAWN_CONFIG_INVALID: GDBusError = 29;
pub const GDBusError_G_DBUS_ERROR_SPAWN_SERVICE_INVALID: GDBusError = 30;
pub const GDBusError_G_DBUS_ERROR_SPAWN_SERVICE_NOT_FOUND: GDBusError = 31;
pub const GDBusError_G_DBUS_ERROR_SPAWN_PERMISSIONS_INVALID: GDBusError = 32;
pub const GDBusError_G_DBUS_ERROR_SPAWN_FILE_INVALID: GDBusError = 33;
pub const GDBusError_G_DBUS_ERROR_SPAWN_NO_MEMORY: GDBusError = 34;
pub const GDBusError_G_DBUS_ERROR_UNIX_PROCESS_ID_UNKNOWN: GDBusError = 35;
pub const GDBusError_G_DBUS_ERROR_INVALID_SIGNATURE: GDBusError = 36;
pub const GDBusError_G_DBUS_ERROR_INVALID_FILE_CONTENT: GDBusError = 37;
pub const GDBusError_G_DBUS_ERROR_SELINUX_SECURITY_CONTEXT_UNKNOWN: GDBusError = 38;
pub const GDBusError_G_DBUS_ERROR_ADT_AUDIT_DATA_UNKNOWN: GDBusError = 39;
pub const GDBusError_G_DBUS_ERROR_OBJECT_PATH_IN_USE: GDBusError = 40;
pub const GDBusError_G_DBUS_ERROR_UNKNOWN_OBJECT: GDBusError = 41;
pub const GDBusError_G_DBUS_ERROR_UNKNOWN_INTERFACE: GDBusError = 42;
pub const GDBusError_G_DBUS_ERROR_UNKNOWN_PROPERTY: GDBusError = 43;
pub const GDBusError_G_DBUS_ERROR_PROPERTY_READ_ONLY: GDBusError = 44;
/// GDBusError:
/// @G_DBUS_ERROR_FAILED:
/// A generic error; "something went wrong" - see the error message for
/// more.
/// @G_DBUS_ERROR_NO_MEMORY:
/// There was not enough memory to complete an operation.
/// @G_DBUS_ERROR_SERVICE_UNKNOWN:
/// The bus doesn't know how to launch a service to supply the bus name
/// you wanted.
/// @G_DBUS_ERROR_NAME_HAS_NO_OWNER:
/// The bus name you referenced doesn't exist (i.e. no application owns
/// it).
/// @G_DBUS_ERROR_NO_REPLY:
/// No reply to a message expecting one, usually means a timeout occurred.
/// @G_DBUS_ERROR_IO_ERROR:
/// Something went wrong reading or writing to a socket, for example.
/// @G_DBUS_ERROR_BAD_ADDRESS:
/// A D-Bus bus address was malformed.
/// @G_DBUS_ERROR_NOT_SUPPORTED:
/// Requested operation isn't supported (like ENOSYS on UNIX).
/// @G_DBUS_ERROR_LIMITS_EXCEEDED:
/// Some limited resource is exhausted.
/// @G_DBUS_ERROR_ACCESS_DENIED:
/// Security restrictions don't allow doing what you're trying to do.
/// @G_DBUS_ERROR_AUTH_FAILED:
/// Authentication didn't work.
/// @G_DBUS_ERROR_NO_SERVER:
/// Unable to connect to server (probably caused by ECONNREFUSED on a
/// socket).
/// @G_DBUS_ERROR_TIMEOUT:
/// Certain timeout errors, possibly ETIMEDOUT on a socket.  Note that
/// %G_DBUS_ERROR_NO_REPLY is used for message reply timeouts. Warning:
/// this is confusingly-named given that %G_DBUS_ERROR_TIMED_OUT also
/// exists. We can't fix it for compatibility reasons so just be
/// careful.
/// @G_DBUS_ERROR_NO_NETWORK:
/// No network access (probably ENETUNREACH on a socket).
/// @G_DBUS_ERROR_ADDRESS_IN_USE:
/// Can't bind a socket since its address is in use (i.e. EADDRINUSE).
/// @G_DBUS_ERROR_DISCONNECTED:
/// The connection is disconnected and you're trying to use it.
/// @G_DBUS_ERROR_INVALID_ARGS:
/// Invalid arguments passed to a method call.
/// @G_DBUS_ERROR_FILE_NOT_FOUND:
/// Missing file.
/// @G_DBUS_ERROR_FILE_EXISTS:
/// Existing file and the operation you're using does not silently overwrite.
/// @G_DBUS_ERROR_UNKNOWN_METHOD:
/// Method name you invoked isn't known by the object you invoked it on.
/// @G_DBUS_ERROR_UNKNOWN_OBJECT:
/// Object you invoked a method on isn't known. Since 2.42
/// @G_DBUS_ERROR_UNKNOWN_INTERFACE:
/// Interface you invoked a method on isn't known by the object. Since 2.42
/// @G_DBUS_ERROR_UNKNOWN_PROPERTY:
/// Property you tried to access isn't known by the object. Since 2.42
/// @G_DBUS_ERROR_PROPERTY_READ_ONLY:
/// Property you tried to set is read-only. Since 2.42
/// @G_DBUS_ERROR_TIMED_OUT:
/// Certain timeout errors, e.g. while starting a service. Warning: this is
/// confusingly-named given that %G_DBUS_ERROR_TIMEOUT also exists. We
/// can't fix it for compatibility reasons so just be careful.
/// @G_DBUS_ERROR_MATCH_RULE_NOT_FOUND:
/// Tried to remove or modify a match rule that didn't exist.
/// @G_DBUS_ERROR_MATCH_RULE_INVALID:
/// The match rule isn't syntactically valid.
/// @G_DBUS_ERROR_SPAWN_EXEC_FAILED:
/// While starting a new process, the exec() call failed.
/// @G_DBUS_ERROR_SPAWN_FORK_FAILED:
/// While starting a new process, the fork() call failed.
/// @G_DBUS_ERROR_SPAWN_CHILD_EXITED:
/// While starting a new process, the child exited with a status code.
/// @G_DBUS_ERROR_SPAWN_CHILD_SIGNALED:
/// While starting a new process, the child exited on a signal.
/// @G_DBUS_ERROR_SPAWN_FAILED:
/// While starting a new process, something went wrong.
/// @G_DBUS_ERROR_SPAWN_SETUP_FAILED:
/// We failed to setup the environment correctly.
/// @G_DBUS_ERROR_SPAWN_CONFIG_INVALID:
/// We failed to setup the config parser correctly.
/// @G_DBUS_ERROR_SPAWN_SERVICE_INVALID:
/// Bus name was not valid.
/// @G_DBUS_ERROR_SPAWN_SERVICE_NOT_FOUND:
/// Service file not found in system-services directory.
/// @G_DBUS_ERROR_SPAWN_PERMISSIONS_INVALID:
/// Permissions are incorrect on the setuid helper.
/// @G_DBUS_ERROR_SPAWN_FILE_INVALID:
/// Service file invalid (Name, User or Exec missing).
/// @G_DBUS_ERROR_SPAWN_NO_MEMORY:
/// Tried to get a UNIX process ID and it wasn't available.
/// @G_DBUS_ERROR_UNIX_PROCESS_ID_UNKNOWN:
/// Tried to get a UNIX process ID and it wasn't available.
/// @G_DBUS_ERROR_INVALID_SIGNATURE:
/// A type signature is not valid.
/// @G_DBUS_ERROR_INVALID_FILE_CONTENT:
/// A file contains invalid syntax or is otherwise broken.
/// @G_DBUS_ERROR_SELINUX_SECURITY_CONTEXT_UNKNOWN:
/// Asked for SELinux security context and it wasn't available.
/// @G_DBUS_ERROR_ADT_AUDIT_DATA_UNKNOWN:
/// Asked for ADT audit data and it wasn't available.
/// @G_DBUS_ERROR_OBJECT_PATH_IN_USE:
/// There's already an object with the requested object path.
///
/// Error codes for the %G_DBUS_ERROR error domain.
///
/// Since: 2.26
pub type GDBusError = u32;
pub const GDBusConnectionFlags_G_DBUS_CONNECTION_FLAGS_NONE: GDBusConnectionFlags = 0;
pub const GDBusConnectionFlags_G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_CLIENT: GDBusConnectionFlags =
    1;
pub const GDBusConnectionFlags_G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_SERVER: GDBusConnectionFlags =
    2;
pub const GDBusConnectionFlags_G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_ALLOW_ANONYMOUS : GDBusConnectionFlags = 4 ;
pub const GDBusConnectionFlags_G_DBUS_CONNECTION_FLAGS_MESSAGE_BUS_CONNECTION : GDBusConnectionFlags = 8 ;
pub const GDBusConnectionFlags_G_DBUS_CONNECTION_FLAGS_DELAY_MESSAGE_PROCESSING : GDBusConnectionFlags = 16 ;
/// GDBusConnectionFlags:
/// @G_DBUS_CONNECTION_FLAGS_NONE: No flags set.
/// @G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_CLIENT: Perform authentication against server.
/// @G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_SERVER: Perform authentication against client.
/// @G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_ALLOW_ANONYMOUS: When
/// authenticating as a server, allow the anonymous authentication
/// method.
/// @G_DBUS_CONNECTION_FLAGS_MESSAGE_BUS_CONNECTION: Pass this flag if connecting to a peer that is a
/// message bus. This means that the Hello() method will be invoked as part of the connection setup.
/// @G_DBUS_CONNECTION_FLAGS_DELAY_MESSAGE_PROCESSING: If set, processing of D-Bus messages is
/// delayed until g_dbus_connection_start_message_processing() is called.
///
/// Flags used when creating a new #GDBusConnection.
///
/// Since: 2.26
pub type GDBusConnectionFlags = u32;
pub const GDBusCapabilityFlags_G_DBUS_CAPABILITY_FLAGS_NONE: GDBusCapabilityFlags = 0;
pub const GDBusCapabilityFlags_G_DBUS_CAPABILITY_FLAGS_UNIX_FD_PASSING: GDBusCapabilityFlags = 1;
/// GDBusCapabilityFlags:
/// @G_DBUS_CAPABILITY_FLAGS_NONE: No flags set.
/// @G_DBUS_CAPABILITY_FLAGS_UNIX_FD_PASSING: The connection
/// supports exchanging UNIX file descriptors with the remote peer.
///
/// Capabilities negotiated with the remote peer.
///
/// Since: 2.26
pub type GDBusCapabilityFlags = u32;
pub const GDBusCallFlags_G_DBUS_CALL_FLAGS_NONE: GDBusCallFlags = 0;
pub const GDBusCallFlags_G_DBUS_CALL_FLAGS_NO_AUTO_START: GDBusCallFlags = 1;
pub const GDBusCallFlags_G_DBUS_CALL_FLAGS_ALLOW_INTERACTIVE_AUTHORIZATION: GDBusCallFlags = 2;
/// GDBusCallFlags:
/// @G_DBUS_CALL_FLAGS_NONE: No flags set.
/// @G_DBUS_CALL_FLAGS_NO_AUTO_START: The bus must not launch
/// an owner for the destination name in response to this method
/// invocation.
/// @G_DBUS_CALL_FLAGS_ALLOW_INTERACTIVE_AUTHORIZATION: the caller is prepared to
/// wait for interactive authorization. Since 2.46.
///
/// Flags used in g_dbus_connection_call() and similar APIs.
///
/// Since: 2.26
pub type GDBusCallFlags = u32;
pub const GDBusMessageType_G_DBUS_MESSAGE_TYPE_INVALID: GDBusMessageType = 0;
pub const GDBusMessageType_G_DBUS_MESSAGE_TYPE_METHOD_CALL: GDBusMessageType = 1;
pub const GDBusMessageType_G_DBUS_MESSAGE_TYPE_METHOD_RETURN: GDBusMessageType = 2;
pub const GDBusMessageType_G_DBUS_MESSAGE_TYPE_ERROR: GDBusMessageType = 3;
pub const GDBusMessageType_G_DBUS_MESSAGE_TYPE_SIGNAL: GDBusMessageType = 4;
/// GDBusMessageType:
/// @G_DBUS_MESSAGE_TYPE_INVALID: Message is of invalid type.
/// @G_DBUS_MESSAGE_TYPE_METHOD_CALL: Method call.
/// @G_DBUS_MESSAGE_TYPE_METHOD_RETURN: Method reply.
/// @G_DBUS_MESSAGE_TYPE_ERROR: Error reply.
/// @G_DBUS_MESSAGE_TYPE_SIGNAL: Signal emission.
///
/// Message types used in #GDBusMessage.
///
/// Since: 2.26
pub type GDBusMessageType = u32;
pub const GDBusMessageFlags_G_DBUS_MESSAGE_FLAGS_NONE: GDBusMessageFlags = 0;
pub const GDBusMessageFlags_G_DBUS_MESSAGE_FLAGS_NO_REPLY_EXPECTED: GDBusMessageFlags = 1;
pub const GDBusMessageFlags_G_DBUS_MESSAGE_FLAGS_NO_AUTO_START: GDBusMessageFlags = 2;
pub const GDBusMessageFlags_G_DBUS_MESSAGE_FLAGS_ALLOW_INTERACTIVE_AUTHORIZATION : GDBusMessageFlags = 4 ;
/// GDBusMessageFlags:
/// @G_DBUS_MESSAGE_FLAGS_NONE: No flags set.
/// @G_DBUS_MESSAGE_FLAGS_NO_REPLY_EXPECTED: A reply is not expected.
/// @G_DBUS_MESSAGE_FLAGS_NO_AUTO_START: The bus must not launch an
/// owner for the destination name in response to this message.
/// @G_DBUS_MESSAGE_FLAGS_ALLOW_INTERACTIVE_AUTHORIZATION: If set on a method
/// call, this flag means that the caller is prepared to wait for interactive
/// authorization. Since 2.46.
///
/// Message flags used in #GDBusMessage.
///
/// Since: 2.26
pub type GDBusMessageFlags = u32;
pub const GDBusMessageHeaderField_G_DBUS_MESSAGE_HEADER_FIELD_INVALID: GDBusMessageHeaderField = 0;
pub const GDBusMessageHeaderField_G_DBUS_MESSAGE_HEADER_FIELD_PATH: GDBusMessageHeaderField = 1;
pub const GDBusMessageHeaderField_G_DBUS_MESSAGE_HEADER_FIELD_INTERFACE: GDBusMessageHeaderField =
    2;
pub const GDBusMessageHeaderField_G_DBUS_MESSAGE_HEADER_FIELD_MEMBER: GDBusMessageHeaderField = 3;
pub const GDBusMessageHeaderField_G_DBUS_MESSAGE_HEADER_FIELD_ERROR_NAME: GDBusMessageHeaderField =
    4;
pub const GDBusMessageHeaderField_G_DBUS_MESSAGE_HEADER_FIELD_REPLY_SERIAL : GDBusMessageHeaderField = 5 ;
pub const GDBusMessageHeaderField_G_DBUS_MESSAGE_HEADER_FIELD_DESTINATION: GDBusMessageHeaderField =
    6;
pub const GDBusMessageHeaderField_G_DBUS_MESSAGE_HEADER_FIELD_SENDER: GDBusMessageHeaderField = 7;
pub const GDBusMessageHeaderField_G_DBUS_MESSAGE_HEADER_FIELD_SIGNATURE: GDBusMessageHeaderField =
    8;
pub const GDBusMessageHeaderField_G_DBUS_MESSAGE_HEADER_FIELD_NUM_UNIX_FDS : GDBusMessageHeaderField = 9 ;
/// GDBusMessageHeaderField:
/// @G_DBUS_MESSAGE_HEADER_FIELD_INVALID: Not a valid header field.
/// @G_DBUS_MESSAGE_HEADER_FIELD_PATH: The object path.
/// @G_DBUS_MESSAGE_HEADER_FIELD_INTERFACE: The interface name.
/// @G_DBUS_MESSAGE_HEADER_FIELD_MEMBER: The method or signal name.
/// @G_DBUS_MESSAGE_HEADER_FIELD_ERROR_NAME: The name of the error that occurred.
/// @G_DBUS_MESSAGE_HEADER_FIELD_REPLY_SERIAL: The serial number the message is a reply to.
/// @G_DBUS_MESSAGE_HEADER_FIELD_DESTINATION: The name the message is intended for.
/// @G_DBUS_MESSAGE_HEADER_FIELD_SENDER: Unique name of the sender of the message (filled in by the bus).
/// @G_DBUS_MESSAGE_HEADER_FIELD_SIGNATURE: The signature of the message body.
/// @G_DBUS_MESSAGE_HEADER_FIELD_NUM_UNIX_FDS: The number of UNIX file descriptors that accompany the message.
///
/// Header fields used in #GDBusMessage.
///
/// Since: 2.26
pub type GDBusMessageHeaderField = u32;
pub const GDBusPropertyInfoFlags_G_DBUS_PROPERTY_INFO_FLAGS_NONE: GDBusPropertyInfoFlags = 0;
pub const GDBusPropertyInfoFlags_G_DBUS_PROPERTY_INFO_FLAGS_READABLE: GDBusPropertyInfoFlags = 1;
pub const GDBusPropertyInfoFlags_G_DBUS_PROPERTY_INFO_FLAGS_WRITABLE: GDBusPropertyInfoFlags = 2;
/// GDBusPropertyInfoFlags:
/// @G_DBUS_PROPERTY_INFO_FLAGS_NONE: No flags set.
/// @G_DBUS_PROPERTY_INFO_FLAGS_READABLE: Property is readable.
/// @G_DBUS_PROPERTY_INFO_FLAGS_WRITABLE: Property is writable.
///
/// Flags describing the access control of a D-Bus property.
///
/// Since: 2.26
pub type GDBusPropertyInfoFlags = u32;
pub const GDBusSubtreeFlags_G_DBUS_SUBTREE_FLAGS_NONE: GDBusSubtreeFlags = 0;
pub const GDBusSubtreeFlags_G_DBUS_SUBTREE_FLAGS_DISPATCH_TO_UNENUMERATED_NODES: GDBusSubtreeFlags =
    1;
/// GDBusSubtreeFlags:
/// @G_DBUS_SUBTREE_FLAGS_NONE: No flags set.
/// @G_DBUS_SUBTREE_FLAGS_DISPATCH_TO_UNENUMERATED_NODES: Method calls to objects not in the enumerated range
/// will still be dispatched. This is useful if you want
/// to dynamically spawn objects in the subtree.
///
/// Flags passed to g_dbus_connection_register_subtree().
///
/// Since: 2.26
pub type GDBusSubtreeFlags = u32;
pub const GDBusServerFlags_G_DBUS_SERVER_FLAGS_NONE: GDBusServerFlags = 0;
pub const GDBusServerFlags_G_DBUS_SERVER_FLAGS_RUN_IN_THREAD: GDBusServerFlags = 1;
pub const GDBusServerFlags_G_DBUS_SERVER_FLAGS_AUTHENTICATION_ALLOW_ANONYMOUS: GDBusServerFlags = 2;
/// GDBusServerFlags:
/// @G_DBUS_SERVER_FLAGS_NONE: No flags set.
/// @G_DBUS_SERVER_FLAGS_RUN_IN_THREAD: All #GDBusServer::new-connection
/// signals will run in separated dedicated threads (see signal for
/// details).
/// @G_DBUS_SERVER_FLAGS_AUTHENTICATION_ALLOW_ANONYMOUS: Allow the anonymous
/// authentication method.
///
/// Flags used when creating a #GDBusServer.
///
/// Since: 2.26
pub type GDBusServerFlags = u32;
pub const GDBusSignalFlags_G_DBUS_SIGNAL_FLAGS_NONE: GDBusSignalFlags = 0;
pub const GDBusSignalFlags_G_DBUS_SIGNAL_FLAGS_NO_MATCH_RULE: GDBusSignalFlags = 1;
pub const GDBusSignalFlags_G_DBUS_SIGNAL_FLAGS_MATCH_ARG0_NAMESPACE: GDBusSignalFlags = 2;
pub const GDBusSignalFlags_G_DBUS_SIGNAL_FLAGS_MATCH_ARG0_PATH: GDBusSignalFlags = 4;
/// GDBusSignalFlags:
/// @G_DBUS_SIGNAL_FLAGS_NONE: No flags set.
/// @G_DBUS_SIGNAL_FLAGS_NO_MATCH_RULE: Don't actually send the AddMatch
/// D-Bus call for this signal subscription.  This gives you more control
/// over which match rules you add (but you must add them manually).
/// @G_DBUS_SIGNAL_FLAGS_MATCH_ARG0_NAMESPACE: Match first arguments that
/// contain a bus or interface name with the given namespace.
/// @G_DBUS_SIGNAL_FLAGS_MATCH_ARG0_PATH: Match first arguments that
/// contain an object path that is either equivalent to the given path,
/// or one of the paths is a subpath of the other.
///
/// Flags used when subscribing to signals via g_dbus_connection_signal_subscribe().
///
/// Since: 2.26
pub type GDBusSignalFlags = u32;
pub const GDBusSendMessageFlags_G_DBUS_SEND_MESSAGE_FLAGS_NONE: GDBusSendMessageFlags = 0;
pub const GDBusSendMessageFlags_G_DBUS_SEND_MESSAGE_FLAGS_PRESERVE_SERIAL: GDBusSendMessageFlags =
    1;
/// GDBusSendMessageFlags:
/// @G_DBUS_SEND_MESSAGE_FLAGS_NONE: No flags set.
/// @G_DBUS_SEND_MESSAGE_FLAGS_PRESERVE_SERIAL: Do not automatically
/// assign a serial number from the #GDBusConnection object when
/// sending a message.
///
/// Flags used when sending #GDBusMessages on a #GDBusConnection.
///
/// Since: 2.26
pub type GDBusSendMessageFlags = u32;
pub const GCredentialsType_G_CREDENTIALS_TYPE_INVALID: GCredentialsType = 0;
pub const GCredentialsType_G_CREDENTIALS_TYPE_LINUX_UCRED: GCredentialsType = 1;
pub const GCredentialsType_G_CREDENTIALS_TYPE_FREEBSD_CMSGCRED: GCredentialsType = 2;
pub const GCredentialsType_G_CREDENTIALS_TYPE_OPENBSD_SOCKPEERCRED: GCredentialsType = 3;
pub const GCredentialsType_G_CREDENTIALS_TYPE_SOLARIS_UCRED: GCredentialsType = 4;
pub const GCredentialsType_G_CREDENTIALS_TYPE_NETBSD_UNPCBID: GCredentialsType = 5;
/// GCredentialsType:
/// @G_CREDENTIALS_TYPE_INVALID: Indicates an invalid native credential type.
/// @G_CREDENTIALS_TYPE_LINUX_UCRED: The native credentials type is a struct ucred.
/// @G_CREDENTIALS_TYPE_FREEBSD_CMSGCRED: The native credentials type is a struct cmsgcred.
/// @G_CREDENTIALS_TYPE_OPENBSD_SOCKPEERCRED: The native credentials type is a struct sockpeercred. Added in 2.30.
/// @G_CREDENTIALS_TYPE_SOLARIS_UCRED: The native credentials type is a ucred_t. Added in 2.40.
/// @G_CREDENTIALS_TYPE_NETBSD_UNPCBID: The native credentials type is a struct unpcbid.
///
/// Enumeration describing different kinds of native credential types.
///
/// Since: 2.26
pub type GCredentialsType = u32;
pub const GDBusMessageByteOrder_G_DBUS_MESSAGE_BYTE_ORDER_BIG_ENDIAN: GDBusMessageByteOrder = 66;
pub const GDBusMessageByteOrder_G_DBUS_MESSAGE_BYTE_ORDER_LITTLE_ENDIAN: GDBusMessageByteOrder =
    108;
/// GDBusMessageByteOrder:
/// @G_DBUS_MESSAGE_BYTE_ORDER_BIG_ENDIAN: The byte order is big endian.
/// @G_DBUS_MESSAGE_BYTE_ORDER_LITTLE_ENDIAN: The byte order is little endian.
///
/// Enumeration used to describe the byte order of a D-Bus message.
///
/// Since: 2.26
pub type GDBusMessageByteOrder = u32;
pub const GApplicationFlags_G_APPLICATION_FLAGS_NONE: GApplicationFlags = 0;
pub const GApplicationFlags_G_APPLICATION_IS_SERVICE: GApplicationFlags = 1;
pub const GApplicationFlags_G_APPLICATION_IS_LAUNCHER: GApplicationFlags = 2;
pub const GApplicationFlags_G_APPLICATION_HANDLES_OPEN: GApplicationFlags = 4;
pub const GApplicationFlags_G_APPLICATION_HANDLES_COMMAND_LINE: GApplicationFlags = 8;
pub const GApplicationFlags_G_APPLICATION_SEND_ENVIRONMENT: GApplicationFlags = 16;
pub const GApplicationFlags_G_APPLICATION_NON_UNIQUE: GApplicationFlags = 32;
pub const GApplicationFlags_G_APPLICATION_CAN_OVERRIDE_APP_ID: GApplicationFlags = 64;
/// GApplicationFlags:
/// @G_APPLICATION_FLAGS_NONE: Default
/// @G_APPLICATION_IS_SERVICE: Run as a service. In this mode, registration
/// fails if the service is already running, and the application
/// will initially wait up to 10 seconds for an initial activation
/// message to arrive.
/// @G_APPLICATION_IS_LAUNCHER: Don't try to become the primary instance.
/// @G_APPLICATION_HANDLES_OPEN: This application handles opening files (in
/// the primary instance). Note that this flag only affects the default
/// implementation of local_command_line(), and has no effect if
/// %G_APPLICATION_HANDLES_COMMAND_LINE is given.
/// See g_application_run() for details.
/// @G_APPLICATION_HANDLES_COMMAND_LINE: This application handles command line
/// arguments (in the primary instance). Note that this flag only affect
/// the default implementation of local_command_line().
/// See g_application_run() for details.
/// @G_APPLICATION_SEND_ENVIRONMENT: Send the environment of the
/// launching process to the primary instance. Set this flag if your
/// application is expected to behave differently depending on certain
/// environment variables. For instance, an editor might be expected
/// to use the `GIT_COMMITTER_NAME` environment variable
/// when editing a git commit message. The environment is available
/// to the #GApplication::command-line signal handler, via
/// g_application_command_line_getenv().
/// @G_APPLICATION_NON_UNIQUE: Make no attempts to do any of the typical
/// single-instance application negotiation, even if the application
/// ID is given.  The application neither attempts to become the
/// owner of the application ID nor does it check if an existing
/// owner already exists.  Everything occurs in the local process.
/// Since: 2.30.
/// @G_APPLICATION_CAN_OVERRIDE_APP_ID: Allow users to override the
/// application ID from the command line with `--gapplication-app-id`.
/// Since: 2.48
///
/// Flags used to define the behaviour of a #GApplication.
///
/// Since: 2.28
pub type GApplicationFlags = u32;
pub const GTlsError_G_TLS_ERROR_UNAVAILABLE: GTlsError = 0;
pub const GTlsError_G_TLS_ERROR_MISC: GTlsError = 1;
pub const GTlsError_G_TLS_ERROR_BAD_CERTIFICATE: GTlsError = 2;
pub const GTlsError_G_TLS_ERROR_NOT_TLS: GTlsError = 3;
pub const GTlsError_G_TLS_ERROR_HANDSHAKE: GTlsError = 4;
pub const GTlsError_G_TLS_ERROR_CERTIFICATE_REQUIRED: GTlsError = 5;
pub const GTlsError_G_TLS_ERROR_EOF: GTlsError = 6;
/// GTlsError:
/// @G_TLS_ERROR_UNAVAILABLE: No TLS provider is available
/// @G_TLS_ERROR_MISC: Miscellaneous TLS error
/// @G_TLS_ERROR_BAD_CERTIFICATE: A certificate could not be parsed
/// @G_TLS_ERROR_NOT_TLS: The TLS handshake failed because the
/// peer does not seem to be a TLS server.
/// @G_TLS_ERROR_HANDSHAKE: The TLS handshake failed because the
/// peer's certificate was not acceptable.
/// @G_TLS_ERROR_CERTIFICATE_REQUIRED: The TLS handshake failed because
/// the server requested a client-side certificate, but none was
/// provided. See g_tls_connection_set_certificate().
/// @G_TLS_ERROR_EOF: The TLS connection was closed without proper
/// notice, which may indicate an attack. See
/// g_tls_connection_set_require_close_notify().
///
/// An error code used with %G_TLS_ERROR in a #GError returned from a
/// TLS-related routine.
///
/// Since: 2.28
pub type GTlsError = u32;
pub const GTlsCertificateFlags_G_TLS_CERTIFICATE_UNKNOWN_CA: GTlsCertificateFlags = 1;
pub const GTlsCertificateFlags_G_TLS_CERTIFICATE_BAD_IDENTITY: GTlsCertificateFlags = 2;
pub const GTlsCertificateFlags_G_TLS_CERTIFICATE_NOT_ACTIVATED: GTlsCertificateFlags = 4;
pub const GTlsCertificateFlags_G_TLS_CERTIFICATE_EXPIRED: GTlsCertificateFlags = 8;
pub const GTlsCertificateFlags_G_TLS_CERTIFICATE_REVOKED: GTlsCertificateFlags = 16;
pub const GTlsCertificateFlags_G_TLS_CERTIFICATE_INSECURE: GTlsCertificateFlags = 32;
pub const GTlsCertificateFlags_G_TLS_CERTIFICATE_GENERIC_ERROR: GTlsCertificateFlags = 64;
pub const GTlsCertificateFlags_G_TLS_CERTIFICATE_VALIDATE_ALL: GTlsCertificateFlags = 127;
/// GTlsCertificateFlags:
/// @G_TLS_CERTIFICATE_UNKNOWN_CA: The signing certificate authority is
/// not known.
/// @G_TLS_CERTIFICATE_BAD_IDENTITY: The certificate does not match the
/// expected identity of the site that it was retrieved from.
/// @G_TLS_CERTIFICATE_NOT_ACTIVATED: The certificate's activation time
/// is still in the future
/// @G_TLS_CERTIFICATE_EXPIRED: The certificate has expired
/// @G_TLS_CERTIFICATE_REVOKED: The certificate has been revoked
/// according to the #GTlsConnection's certificate revocation list.
/// @G_TLS_CERTIFICATE_INSECURE: The certificate's algorithm is
/// considered insecure.
/// @G_TLS_CERTIFICATE_GENERIC_ERROR: Some other error occurred validating
/// the certificate
/// @G_TLS_CERTIFICATE_VALIDATE_ALL: the combination of all of the above
/// flags
///
/// A set of flags describing TLS certification validation. This can be
/// used to set which validation steps to perform (eg, with
/// g_tls_client_connection_set_validation_flags()), or to describe why
/// a particular certificate was rejected (eg, in
/// #GTlsConnection::accept-certificate).
///
/// Since: 2.28
pub type GTlsCertificateFlags = u32;
pub const GTlsAuthenticationMode_G_TLS_AUTHENTICATION_NONE: GTlsAuthenticationMode = 0;
pub const GTlsAuthenticationMode_G_TLS_AUTHENTICATION_REQUESTED: GTlsAuthenticationMode = 1;
pub const GTlsAuthenticationMode_G_TLS_AUTHENTICATION_REQUIRED: GTlsAuthenticationMode = 2;
/// GTlsAuthenticationMode:
/// @G_TLS_AUTHENTICATION_NONE: client authentication not required
/// @G_TLS_AUTHENTICATION_REQUESTED: client authentication is requested
/// @G_TLS_AUTHENTICATION_REQUIRED: client authentication is required
///
/// The client authentication mode for a #GTlsServerConnection.
///
/// Since: 2.28
pub type GTlsAuthenticationMode = u32;
pub const GTlsRehandshakeMode_G_TLS_REHANDSHAKE_NEVER: GTlsRehandshakeMode = 0;
pub const GTlsRehandshakeMode_G_TLS_REHANDSHAKE_SAFELY: GTlsRehandshakeMode = 1;
pub const GTlsRehandshakeMode_G_TLS_REHANDSHAKE_UNSAFELY: GTlsRehandshakeMode = 2;
/// GTlsRehandshakeMode:
/// @G_TLS_REHANDSHAKE_NEVER: Never allow rehandshaking
/// @G_TLS_REHANDSHAKE_SAFELY: Allow safe rehandshaking only
/// @G_TLS_REHANDSHAKE_UNSAFELY: Allow unsafe rehandshaking
///
/// When to allow rehandshaking. See
/// g_tls_connection_set_rehandshake_mode().
///
/// Since: 2.28
pub type GTlsRehandshakeMode = u32;
pub const _GTlsPasswordFlags_G_TLS_PASSWORD_NONE: _GTlsPasswordFlags = 0;
pub const _GTlsPasswordFlags_G_TLS_PASSWORD_RETRY: _GTlsPasswordFlags = 2;
pub const _GTlsPasswordFlags_G_TLS_PASSWORD_MANY_TRIES: _GTlsPasswordFlags = 4;
pub const _GTlsPasswordFlags_G_TLS_PASSWORD_FINAL_TRY: _GTlsPasswordFlags = 8;
/// GTlsPasswordFlags:
/// @G_TLS_PASSWORD_NONE: No flags
/// @G_TLS_PASSWORD_RETRY: The password was wrong, and the user should retry.
/// @G_TLS_PASSWORD_MANY_TRIES: Hint to the user that the password has been
/// wrong many times, and the user may not have many chances left.
/// @G_TLS_PASSWORD_FINAL_TRY: Hint to the user that this is the last try to get
/// this password right.
///
/// Various flags for the password.
///
/// Since: 2.30
pub type _GTlsPasswordFlags = u32;
pub use self::_GTlsPasswordFlags as GTlsPasswordFlags;
pub const GTlsInteractionResult_G_TLS_INTERACTION_UNHANDLED: GTlsInteractionResult = 0;
pub const GTlsInteractionResult_G_TLS_INTERACTION_HANDLED: GTlsInteractionResult = 1;
pub const GTlsInteractionResult_G_TLS_INTERACTION_FAILED: GTlsInteractionResult = 2;
/// GTlsInteractionResult:
/// @G_TLS_INTERACTION_UNHANDLED: The interaction was unhandled (i.e. not
/// implemented).
/// @G_TLS_INTERACTION_HANDLED: The interaction completed, and resulting data
/// is available.
/// @G_TLS_INTERACTION_FAILED: The interaction has failed, or was cancelled.
/// and the operation should be aborted.
///
/// #GTlsInteractionResult is returned by various functions in #GTlsInteraction
/// when finishing an interaction request.
///
/// Since: 2.30
pub type GTlsInteractionResult = u32;
pub const GDBusInterfaceSkeletonFlags_G_DBUS_INTERFACE_SKELETON_FLAGS_NONE : GDBusInterfaceSkeletonFlags = 0 ;
pub const GDBusInterfaceSkeletonFlags_G_DBUS_INTERFACE_SKELETON_FLAGS_HANDLE_METHOD_INVOCATIONS_IN_THREAD : GDBusInterfaceSkeletonFlags = 1 ;
/// GDBusInterfaceSkeletonFlags:
/// @G_DBUS_INTERFACE_SKELETON_FLAGS_NONE: No flags set.
/// @G_DBUS_INTERFACE_SKELETON_FLAGS_HANDLE_METHOD_INVOCATIONS_IN_THREAD: Each method invocation is handled in
/// a thread dedicated to the invocation. This means that the method implementation can use blocking IO
/// without blocking any other part of the process. It also means that the method implementation must
/// use locking to access data structures used by other threads.
///
/// Flags describing the behavior of a #GDBusInterfaceSkeleton instance.
///
/// Since: 2.30
pub type GDBusInterfaceSkeletonFlags = u32;
pub const GDBusObjectManagerClientFlags_G_DBUS_OBJECT_MANAGER_CLIENT_FLAGS_NONE : GDBusObjectManagerClientFlags = 0 ;
pub const GDBusObjectManagerClientFlags_G_DBUS_OBJECT_MANAGER_CLIENT_FLAGS_DO_NOT_AUTO_START : GDBusObjectManagerClientFlags = 1 ;
/// GDBusObjectManagerClientFlags:
/// @G_DBUS_OBJECT_MANAGER_CLIENT_FLAGS_NONE: No flags set.
/// @G_DBUS_OBJECT_MANAGER_CLIENT_FLAGS_DO_NOT_AUTO_START: If not set and the
/// manager is for a well-known name, then request the bus to launch
/// an owner for the name if no-one owns the name. This flag can only
/// be used in managers for well-known names.
///
/// Flags used when constructing a #GDBusObjectManagerClient.
///
/// Since: 2.30
pub type GDBusObjectManagerClientFlags = u32;
pub const GTlsDatabaseVerifyFlags_G_TLS_DATABASE_VERIFY_NONE: GTlsDatabaseVerifyFlags = 0;
/// GTlsDatabaseVerifyFlags:
/// @G_TLS_DATABASE_VERIFY_NONE: No verification flags
///
/// Flags for g_tls_database_verify_chain().
///
/// Since: 2.30
pub type GTlsDatabaseVerifyFlags = u32;
pub const GTlsDatabaseLookupFlags_G_TLS_DATABASE_LOOKUP_NONE: GTlsDatabaseLookupFlags = 0;
pub const GTlsDatabaseLookupFlags_G_TLS_DATABASE_LOOKUP_KEYPAIR: GTlsDatabaseLookupFlags = 1;
/// GTlsDatabaseLookupFlags:
/// @G_TLS_DATABASE_LOOKUP_NONE: No lookup flags
/// @G_TLS_DATABASE_LOOKUP_KEYPAIR: Restrict lookup to certificates that have
/// a private key.
///
/// Flags for g_tls_database_lookup_certificate_handle(),
/// g_tls_database_lookup_certificate_issuer(),
/// and g_tls_database_lookup_certificates_issued_by().
///
/// Since: 2.30
pub type GTlsDatabaseLookupFlags = u32;
pub const GTlsCertificateRequestFlags_G_TLS_CERTIFICATE_REQUEST_NONE: GTlsCertificateRequestFlags =
    0;
/// GTlsCertificateRequestFlags:
/// @G_TLS_CERTIFICATE_REQUEST_NONE: No flags
///
/// Flags for g_tls_interaction_request_certificate(),
/// g_tls_interaction_request_certificate_async(), and
/// g_tls_interaction_invoke_request_certificate().
///
/// Since: 2.40
pub type GTlsCertificateRequestFlags = u32;
pub const GIOModuleScopeFlags_G_IO_MODULE_SCOPE_NONE: GIOModuleScopeFlags = 0;
pub const GIOModuleScopeFlags_G_IO_MODULE_SCOPE_BLOCK_DUPLICATES: GIOModuleScopeFlags = 1;
/// GIOModuleScopeFlags:
/// @G_IO_MODULE_SCOPE_NONE: No module scan flags
/// @G_IO_MODULE_SCOPE_BLOCK_DUPLICATES: When using this scope to load or
/// scan modules, automatically block a modules which has the same base
/// basename as previously loaded module.
///
/// Flags for use with g_io_module_scope_new().
///
/// Since: 2.30
pub type GIOModuleScopeFlags = u32;
pub const GSocketClientEvent_G_SOCKET_CLIENT_RESOLVING: GSocketClientEvent = 0;
pub const GSocketClientEvent_G_SOCKET_CLIENT_RESOLVED: GSocketClientEvent = 1;
pub const GSocketClientEvent_G_SOCKET_CLIENT_CONNECTING: GSocketClientEvent = 2;
pub const GSocketClientEvent_G_SOCKET_CLIENT_CONNECTED: GSocketClientEvent = 3;
pub const GSocketClientEvent_G_SOCKET_CLIENT_PROXY_NEGOTIATING: GSocketClientEvent = 4;
pub const GSocketClientEvent_G_SOCKET_CLIENT_PROXY_NEGOTIATED: GSocketClientEvent = 5;
pub const GSocketClientEvent_G_SOCKET_CLIENT_TLS_HANDSHAKING: GSocketClientEvent = 6;
pub const GSocketClientEvent_G_SOCKET_CLIENT_TLS_HANDSHAKED: GSocketClientEvent = 7;
pub const GSocketClientEvent_G_SOCKET_CLIENT_COMPLETE: GSocketClientEvent = 8;
/// GSocketClientEvent:
/// @G_SOCKET_CLIENT_RESOLVING: The client is doing a DNS lookup.
/// @G_SOCKET_CLIENT_RESOLVED: The client has completed a DNS lookup.
/// @G_SOCKET_CLIENT_CONNECTING: The client is connecting to a remote
/// host (either a proxy or the destination server).
/// @G_SOCKET_CLIENT_CONNECTED: The client has connected to a remote
/// host.
/// @G_SOCKET_CLIENT_PROXY_NEGOTIATING: The client is negotiating
/// with a proxy to connect to the destination server.
/// @G_SOCKET_CLIENT_PROXY_NEGOTIATED: The client has negotiated
/// with the proxy server.
/// @G_SOCKET_CLIENT_TLS_HANDSHAKING: The client is performing a
/// TLS handshake.
/// @G_SOCKET_CLIENT_TLS_HANDSHAKED: The client has performed a
/// TLS handshake.
/// @G_SOCKET_CLIENT_COMPLETE: The client is done with a particular
/// #GSocketConnectable.
///
/// Describes an event occurring on a #GSocketClient. See the
/// #GSocketClient::event signal for more details.
///
/// Additional values may be added to this type in the future.
///
/// Since: 2.32
pub type GSocketClientEvent = u32;
pub const GSocketListenerEvent_G_SOCKET_LISTENER_BINDING: GSocketListenerEvent = 0;
pub const GSocketListenerEvent_G_SOCKET_LISTENER_BOUND: GSocketListenerEvent = 1;
pub const GSocketListenerEvent_G_SOCKET_LISTENER_LISTENING: GSocketListenerEvent = 2;
pub const GSocketListenerEvent_G_SOCKET_LISTENER_LISTENED: GSocketListenerEvent = 3;
/// GSocketListenerEvent:
/// @G_SOCKET_LISTENER_BINDING: The listener is about to bind a socket.
/// @G_SOCKET_LISTENER_BOUND: The listener has bound a socket.
/// @G_SOCKET_LISTENER_LISTENING: The listener is about to start
/// listening on this socket.
/// @G_SOCKET_LISTENER_LISTENED: The listener is now listening on
/// this socket.
///
/// Describes an event occurring on a #GSocketListener. See the
/// #GSocketListener::event signal for more details.
///
/// Additional values may be added to this type in the future.
///
/// Since: 2.46
pub type GSocketListenerEvent = u32;
pub const GTestDBusFlags_G_TEST_DBUS_NONE: GTestDBusFlags = 0;
/// GTestDBusFlags:
/// @G_TEST_DBUS_NONE: No flags.
///
/// Flags to define future #GTestDBus behaviour.
///
/// Since: 2.34
pub type GTestDBusFlags = u32;
pub const GSubprocessFlags_G_SUBPROCESS_FLAGS_NONE: GSubprocessFlags = 0;
pub const GSubprocessFlags_G_SUBPROCESS_FLAGS_STDIN_PIPE: GSubprocessFlags = 1;
pub const GSubprocessFlags_G_SUBPROCESS_FLAGS_STDIN_INHERIT: GSubprocessFlags = 2;
pub const GSubprocessFlags_G_SUBPROCESS_FLAGS_STDOUT_PIPE: GSubprocessFlags = 4;
pub const GSubprocessFlags_G_SUBPROCESS_FLAGS_STDOUT_SILENCE: GSubprocessFlags = 8;
pub const GSubprocessFlags_G_SUBPROCESS_FLAGS_STDERR_PIPE: GSubprocessFlags = 16;
pub const GSubprocessFlags_G_SUBPROCESS_FLAGS_STDERR_SILENCE: GSubprocessFlags = 32;
pub const GSubprocessFlags_G_SUBPROCESS_FLAGS_STDERR_MERGE: GSubprocessFlags = 64;
pub const GSubprocessFlags_G_SUBPROCESS_FLAGS_INHERIT_FDS: GSubprocessFlags = 128;
/// GSubprocessFlags:
/// @G_SUBPROCESS_FLAGS_NONE: No flags.
/// @G_SUBPROCESS_FLAGS_STDIN_PIPE: create a pipe for the stdin of the
/// spawned process that can be accessed with
/// g_subprocess_get_stdin_pipe().
/// @G_SUBPROCESS_FLAGS_STDIN_INHERIT: stdin is inherited from the
/// calling process.
/// @G_SUBPROCESS_FLAGS_STDOUT_PIPE: create a pipe for the stdout of the
/// spawned process that can be accessed with
/// g_subprocess_get_stdout_pipe().
/// @G_SUBPROCESS_FLAGS_STDOUT_SILENCE: silence the stdout of the spawned
/// process (ie: redirect to /dev/null).
/// @G_SUBPROCESS_FLAGS_STDERR_PIPE: create a pipe for the stderr of the
/// spawned process that can be accessed with
/// g_subprocess_get_stderr_pipe().
/// @G_SUBPROCESS_FLAGS_STDERR_SILENCE: silence the stderr of the spawned
/// process (ie: redirect to /dev/null).
/// @G_SUBPROCESS_FLAGS_STDERR_MERGE: merge the stderr of the spawned
/// process with whatever the stdout happens to be.  This is a good way
/// of directing both streams to a common log file, for example.
/// @G_SUBPROCESS_FLAGS_INHERIT_FDS: spawned processes will inherit the
/// file descriptors of their parent, unless those descriptors have
/// been explicitly marked as close-on-exec.  This flag has no effect
/// over the "standard" file descriptors (stdin, stdout, stderr).
///
/// Flags to define the behaviour of a #GSubprocess.
///
/// Note that the default for stdin is to redirect from /dev/null.  For
/// stdout and stderr the default are for them to inherit the
/// corresponding descriptor from the calling process.
///
/// Note that it is a programmer error to mix 'incompatible' flags.  For
/// example, you may not request both %G_SUBPROCESS_FLAGS_STDOUT_PIPE and
/// %G_SUBPROCESS_FLAGS_STDOUT_SILENCE.
///
/// Since: 2.40
pub type GSubprocessFlags = u32;
pub const GNotificationPriority_G_NOTIFICATION_PRIORITY_NORMAL: GNotificationPriority = 0;
pub const GNotificationPriority_G_NOTIFICATION_PRIORITY_LOW: GNotificationPriority = 1;
pub const GNotificationPriority_G_NOTIFICATION_PRIORITY_HIGH: GNotificationPriority = 2;
pub const GNotificationPriority_G_NOTIFICATION_PRIORITY_URGENT: GNotificationPriority = 3;
/// GNotificationPriority:
/// @G_NOTIFICATION_PRIORITY_LOW: for notifications that do not require
/// immediate attention - typically used for contextual background
/// information, such as contact birthdays or local weather
/// @G_NOTIFICATION_PRIORITY_NORMAL: the default priority, to be used for the
/// majority of notifications (for example email messages, software updates,
/// completed download/sync operations)
/// @G_NOTIFICATION_PRIORITY_HIGH: for events that require more attention,
/// usually because responses are time-sensitive (for example chat and SMS
/// messages or alarms)
/// @G_NOTIFICATION_PRIORITY_URGENT: for urgent notifications, or notifications
/// that require a response in a short space of time (for example phone calls
/// or emergency warnings)
///
/// Priority levels for #GNotifications.
///
/// Since: 2.42
pub type GNotificationPriority = u32;
pub const GNetworkConnectivity_G_NETWORK_CONNECTIVITY_LOCAL: GNetworkConnectivity = 1;
pub const GNetworkConnectivity_G_NETWORK_CONNECTIVITY_LIMITED: GNetworkConnectivity = 2;
pub const GNetworkConnectivity_G_NETWORK_CONNECTIVITY_PORTAL: GNetworkConnectivity = 3;
pub const GNetworkConnectivity_G_NETWORK_CONNECTIVITY_FULL: GNetworkConnectivity = 4;
/// GNetworkConnectivity:
/// @G_NETWORK_CONNECTIVITY_LOCAL: The host is not configured with a
/// route to the Internet; it may or may not be connected to a local
/// network.
/// @G_NETWORK_CONNECTIVITY_LIMITED: The host is connected to a network, but
/// does not appear to be able to reach the full Internet, perhaps
/// due to upstream network problems.
/// @G_NETWORK_CONNECTIVITY_PORTAL: The host is behind a captive portal and
/// cannot reach the full Internet.
/// @G_NETWORK_CONNECTIVITY_FULL: The host is connected to a network, and
/// appears to be able to reach the full Internet.
///
/// The host's network connectivity state, as reported by #GNetworkMonitor.
///
/// Since: 2.44
pub type GNetworkConnectivity = u32;
pub type GAppLaunchContext = _GAppLaunchContext;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GAppInfo {
    _unused: [u8; 0],
}
pub type GAppInfo = _GAppInfo;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GAsyncResult {
    _unused: [u8; 0],
}
pub type GAsyncResult = _GAsyncResult;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GAsyncInitable {
    _unused: [u8; 0],
}
pub type GAsyncInitable = _GAsyncInitable;
pub type GBufferedInputStream = _GBufferedInputStream;
pub type GBufferedOutputStream = _GBufferedOutputStream;
pub type GCancellable = _GCancellable;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GCharsetConverter {
    _unused: [u8; 0],
}
pub type GCharsetConverter = _GCharsetConverter;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GConverter {
    _unused: [u8; 0],
}
pub type GConverter = _GConverter;
pub type GConverterInputStream = _GConverterInputStream;
pub type GConverterOutputStream = _GConverterOutputStream;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GDatagramBased {
    _unused: [u8; 0],
}
pub type GDatagramBased = _GDatagramBased;
pub type GDataInputStream = _GDataInputStream;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GSimplePermission {
    _unused: [u8; 0],
}
pub type GSimplePermission = _GSimplePermission;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GZlibCompressor {
    _unused: [u8; 0],
}
pub type GZlibCompressor = _GZlibCompressor;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GZlibDecompressor {
    _unused: [u8; 0],
}
pub type GZlibDecompressor = _GZlibDecompressor;
pub type GSimpleActionGroup = _GSimpleActionGroup;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GRemoteActionGroup {
    _unused: [u8; 0],
}
pub type GRemoteActionGroup = _GRemoteActionGroup;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GDBusActionGroup {
    _unused: [u8; 0],
}
pub type GDBusActionGroup = _GDBusActionGroup;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GActionMap {
    _unused: [u8; 0],
}
pub type GActionMap = _GActionMap;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GActionGroup {
    _unused: [u8; 0],
}
pub type GActionGroup = _GActionGroup;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GPropertyAction {
    _unused: [u8; 0],
}
pub type GPropertyAction = _GPropertyAction;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GSimpleAction {
    _unused: [u8; 0],
}
pub type GSimpleAction = _GSimpleAction;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GAction {
    _unused: [u8; 0],
}
pub type GAction = _GAction;
pub type GApplication = _GApplication;
pub type GApplicationCommandLine = _GApplicationCommandLine;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GSettingsBackend {
    _unused: [u8; 0],
}
pub type GSettingsBackend = _GSettingsBackend;
pub type GSettings = _GSettings;
pub type GPermission = _GPermission;
pub type GMenuModel = _GMenuModel;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GNotification {
    _unused: [u8; 0],
}
pub type GNotification = _GNotification;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GDrive {
    _unused: [u8; 0],
}
/// GDrive:
///
/// Opaque drive object.
pub type GDrive = _GDrive;
pub type GFileEnumerator = _GFileEnumerator;
pub type GFileMonitor = _GFileMonitor;
pub type GFilterInputStream = _GFilterInputStream;
pub type GFilterOutputStream = _GFilterOutputStream;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GFile {
    _unused: [u8; 0],
}
/// GFile:
///
/// A handle to an object implementing the #GFileIface interface.
/// Generally stores a location within the file system. Handles do not
/// necessarily represent files or directories that currently exist.
pub type GFile = _GFile;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GFileInfo {
    _unused: [u8; 0],
}
pub type GFileInfo = _GFileInfo;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GFileAttributeMatcher {
    _unused: [u8; 0],
}
/// GFileAttributeMatcher:
///
/// Determines if a string matches a file attribute.
pub type GFileAttributeMatcher = _GFileAttributeMatcher;
pub type GFileAttributeInfo = _GFileAttributeInfo;
pub type GFileAttributeInfoList = _GFileAttributeInfoList;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GFileDescriptorBased {
    _unused: [u8; 0],
}
pub type GFileDescriptorBased = _GFileDescriptorBased;
pub type GFileInputStream = _GFileInputStream;
pub type GFileOutputStream = _GFileOutputStream;
pub type GFileIOStream = _GFileIOStream;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GFileIcon {
    _unused: [u8; 0],
}
pub type GFileIcon = _GFileIcon;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GFilenameCompleter {
    _unused: [u8; 0],
}
pub type GFilenameCompleter = _GFilenameCompleter;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GIcon {
    _unused: [u8; 0],
}
pub type GIcon = _GIcon;
pub type GInetAddress = _GInetAddress;
pub type GInetAddressMask = _GInetAddressMask;
pub type GInetSocketAddress = _GInetSocketAddress;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GNativeSocketAddress {
    _unused: [u8; 0],
}
pub type GNativeSocketAddress = _GNativeSocketAddress;
pub type GInputStream = _GInputStream;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GInitable {
    _unused: [u8; 0],
}
pub type GInitable = _GInitable;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GIOModule {
    _unused: [u8; 0],
}
pub type GIOModule = _GIOModule;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GIOExtensionPoint {
    _unused: [u8; 0],
}
pub type GIOExtensionPoint = _GIOExtensionPoint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GIOExtension {
    _unused: [u8; 0],
}
pub type GIOExtension = _GIOExtension;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GIOSchedulerJob {
    _unused: [u8; 0],
}
/// GIOSchedulerJob:
///
/// Opaque class for defining and scheduling IO jobs.
pub type GIOSchedulerJob = _GIOSchedulerJob;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GIOStreamAdapter {
    _unused: [u8; 0],
}
pub type GIOStreamAdapter = _GIOStreamAdapter;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GLoadableIcon {
    _unused: [u8; 0],
}
pub type GLoadableIcon = _GLoadableIcon;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GBytesIcon {
    _unused: [u8; 0],
}
pub type GBytesIcon = _GBytesIcon;
pub type GMemoryInputStream = _GMemoryInputStream;
pub type GMemoryOutputStream = _GMemoryOutputStream;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GMount {
    _unused: [u8; 0],
}
/// GMount:
///
/// A handle to an object implementing the #GMountIface interface.
pub type GMount = _GMount;
pub type GMountOperation = _GMountOperation;
pub type GNetworkAddress = _GNetworkAddress;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GNetworkMonitor {
    _unused: [u8; 0],
}
pub type GNetworkMonitor = _GNetworkMonitor;
pub type GNetworkService = _GNetworkService;
pub type GOutputStream = _GOutputStream;
pub type GIOStream = _GIOStream;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GSimpleIOStream {
    _unused: [u8; 0],
}
pub type GSimpleIOStream = _GSimpleIOStream;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GPollableInputStream {
    _unused: [u8; 0],
}
pub type GPollableInputStream = _GPollableInputStream;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GPollableOutputStream {
    _unused: [u8; 0],
}
pub type GPollableOutputStream = _GPollableOutputStream;
pub type GResolver = _GResolver;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GResource {
    _unused: [u8; 0],
}
/// GResource:
///
/// A resource bundle.
///
/// Since: 2.32
pub type GResource = _GResource;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GSeekable {
    _unused: [u8; 0],
}
pub type GSeekable = _GSeekable;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GSimpleAsyncResult {
    _unused: [u8; 0],
}
pub type GSimpleAsyncResult = _GSimpleAsyncResult;
/// GSocket:
///
/// A lowlevel network socket object.
///
/// Since: 2.22
pub type GSocket = _GSocket;
/// GSocketControlMessage:
///
/// Base class for socket-type specific control messages that can be sent and
/// received over #GSocket.
pub type GSocketControlMessage = _GSocketControlMessage;
/// GSocketClient:
///
/// A helper class for network clients to make connections.
///
/// Since: 2.22
pub type GSocketClient = _GSocketClient;
/// GSocketConnection:
///
/// A socket connection GIOStream object for connection-oriented sockets.
///
/// Since: 2.22
pub type GSocketConnection = _GSocketConnection;
/// GSocketListener:
///
/// A helper class for network servers to listen for and accept connections.
///
/// Since: 2.22
pub type GSocketListener = _GSocketListener;
/// GSocketService:
///
/// A helper class for handling accepting incomming connections in the
/// glib mainloop.
///
/// Since: 2.22
pub type GSocketService = _GSocketService;
pub type GSocketAddress = _GSocketAddress;
pub type GSocketAddressEnumerator = _GSocketAddressEnumerator;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GSocketConnectable {
    _unused: [u8; 0],
}
pub type GSocketConnectable = _GSocketConnectable;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GSrvTarget {
    _unused: [u8; 0],
}
pub type GSrvTarget = _GSrvTarget;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GTask {
    _unused: [u8; 0],
}
pub type GTask = _GTask;
/// GTcpConnection:
///
/// A #GSocketConnection for TCP/IP connections.
///
/// Since: 2.22
pub type GTcpConnection = _GTcpConnection;
pub type GTcpWrapperConnection = _GTcpWrapperConnection;
/// GThreadedSocketService:
///
/// A helper class for handling accepting incoming connections in the
/// glib mainloop and handling them in a thread.
///
/// Since: 2.22
pub type GThreadedSocketService = _GThreadedSocketService;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GDtlsConnection {
    _unused: [u8; 0],
}
pub type GDtlsConnection = _GDtlsConnection;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GDtlsClientConnection {
    _unused: [u8; 0],
}
pub type GDtlsClientConnection = _GDtlsClientConnection;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GDtlsServerConnection {
    _unused: [u8; 0],
}
pub type GDtlsServerConnection = _GDtlsServerConnection;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GThemedIcon {
    _unused: [u8; 0],
}
pub type GThemedIcon = _GThemedIcon;
pub type GTlsCertificate = _GTlsCertificate;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GTlsClientConnection {
    _unused: [u8; 0],
}
pub type GTlsClientConnection = _GTlsClientConnection;
pub type GTlsConnection = _GTlsConnection;
pub type GTlsDatabase = _GTlsDatabase;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GTlsFileDatabase {
    _unused: [u8; 0],
}
pub type GTlsFileDatabase = _GTlsFileDatabase;
pub type GTlsInteraction = _GTlsInteraction;
pub type GTlsPassword = _GTlsPassword;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GTlsServerConnection {
    _unused: [u8; 0],
}
pub type GTlsServerConnection = _GTlsServerConnection;
pub type GVfs = _GVfs;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GProxyResolver {
    _unused: [u8; 0],
}
/// GProxyResolver:
///
/// A helper class to enumerate proxies base on URI.
///
/// Since: 2.26
pub type GProxyResolver = _GProxyResolver;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GProxy {
    _unused: [u8; 0],
}
pub type GProxy = _GProxy;
pub type GProxyAddress = _GProxyAddress;
pub type GProxyAddressEnumerator = _GProxyAddressEnumerator;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GVolume {
    _unused: [u8; 0],
}
/// GVolume:
///
/// Opaque mountable volume object.
pub type GVolume = _GVolume;
pub type GVolumeMonitor = _GVolumeMonitor;
/// GAsyncReadyCallback:
/// @source_object: the object the asynchronous operation was started with.
/// @res: a #GAsyncResult.
/// @user_data: user data passed to the callback.
///
/// Type definition for a function that will be called back when an asynchronous
/// operation within GIO has been completed.
pub type GAsyncReadyCallback = ::std::option::Option<
    unsafe extern "C" fn(source_object: *mut GObject, res: *mut GAsyncResult, user_data: gpointer),
>;
/// GFileProgressCallback:
/// @current_num_bytes: the current number of bytes in the operation.
/// @total_num_bytes: the total number of bytes in the operation.
/// @user_data: user data passed to the callback.
///
/// When doing file operations that may take a while, such as moving
/// a file or copying a file, a progress callback is used to pass how
/// far along that operation is to the application.
pub type GFileProgressCallback = ::std::option::Option<
    unsafe extern "C" fn(current_num_bytes: goffset, total_num_bytes: goffset, user_data: gpointer),
>;
/// GFileReadMoreCallback:
/// @file_contents: the data as currently read.
/// @file_size: the size of the data currently read.
/// @callback_data: data passed to the callback.
///
/// When loading the partial contents of a file with g_file_load_partial_contents_async(),
/// it may become necessary to determine if any more data from the file should be loaded.
/// A #GFileReadMoreCallback function facilitates this by returning %TRUE if more data
/// should be read, or %FALSE otherwise.
///
/// Returns: %TRUE if more data should be read back. %FALSE otherwise.
pub type GFileReadMoreCallback = ::std::option::Option<
    unsafe extern "C" fn(
        file_contents: *const ::std::os::raw::c_char,
        file_size: goffset,
        callback_data: gpointer,
    ) -> gboolean,
>;
/// GFileMeasureProgressCallback:
/// @reporting: %TRUE if more reports will come
/// @current_size: the current cumulative size measurement
/// @num_dirs: the number of directories visited so far
/// @num_files: the number of non-directory files encountered
/// @user_data: the data passed to the original request for this callback
///
/// This callback type is used by g_file_measure_disk_usage() to make
/// periodic progress reports when measuring the amount of disk spaced
/// used by a directory.
///
/// These calls are made on a best-effort basis and not all types of
/// #GFile will support them.  At the minimum, however, one call will
/// always be made immediately.
///
/// In the case that there is no support, @reporting will be set to
/// %FALSE (and the other values undefined) and no further calls will be
/// made.  Otherwise, the @reporting will be %TRUE and the other values
/// all-zeros during the first (immediate) call.  In this way, you can
/// know which type of progress UI to show without a delay.
///
/// For g_file_measure_disk_usage() the callback is made directly.  For
/// g_file_measure_disk_usage_async() the callback is made via the
/// default main context of the calling thread (ie: the same way that the
/// final async result would be reported).
///
/// @current_size is in the same units as requested by the operation (see
/// %G_FILE_DISK_USAGE_APPARENT_SIZE).
///
/// The frequency of the updates is implementation defined, but is
/// ideally about once every 200ms.
///
/// The last progress callback may or may not be equal to the final
/// result.  Always check the async result to get the final value.
///
/// Since: 2.38
pub type GFileMeasureProgressCallback = ::std::option::Option<
    unsafe extern "C" fn(
        reporting: gboolean,
        current_size: guint64,
        num_dirs: guint64,
        num_files: guint64,
        user_data: gpointer,
    ),
>;
/// GIOSchedulerJobFunc:
/// @job: a #GIOSchedulerJob.
/// @cancellable: optional #GCancellable object, %NULL to ignore.
/// @user_data: the data to pass to callback function
///
/// I/O Job function.
///
/// Long-running jobs should periodically check the @cancellable
/// to see if they have been cancelled.
///
/// Returns: %TRUE if this function should be called again to
/// complete the job, %FALSE if the job is complete (or cancelled)
pub type GIOSchedulerJobFunc = ::std::option::Option<
    unsafe extern "C" fn(
        job: *mut GIOSchedulerJob,
        cancellable: *mut GCancellable,
        user_data: gpointer,
    ) -> gboolean,
>;
/// GSimpleAsyncThreadFunc:
/// @res: a #GSimpleAsyncResult.
/// @object: a #GObject.
/// @cancellable: optional #GCancellable object, %NULL to ignore.
///
/// Simple thread function that runs an asynchronous operation and
/// checks for cancellation.
pub type GSimpleAsyncThreadFunc = ::std::option::Option<
    unsafe extern "C" fn(
        res: *mut GSimpleAsyncResult,
        object: *mut GObject,
        cancellable: *mut GCancellable,
    ),
>;
/// GSocketSourceFunc:
/// @socket: the #GSocket
/// @condition: the current condition at the source fired.
/// @user_data: data passed in by the user.
///
/// This is the function type of the callback used for the #GSource
/// returned by g_socket_create_source().
///
/// Returns: it should return %FALSE if the source should be removed.
///
/// Since: 2.22
pub type GSocketSourceFunc = ::std::option::Option<
    unsafe extern "C" fn(socket: *mut GSocket, condition: GIOCondition, user_data: gpointer)
        -> gboolean,
>;
/// GDatagramBasedSourceFunc:
/// @datagram_based: the #GDatagramBased
/// @condition: the current condition at the source fired
/// @user_data: data passed in by the user
///
/// This is the function type of the callback used for the #GSource
/// returned by g_datagram_based_create_source().
///
/// Returns: %G_SOURCE_REMOVE if the source should be removed,
/// %G_SOURCE_CONTINUE otherwise
///
/// Since: 2.48
pub type GDatagramBasedSourceFunc = ::std::option::Option<
    unsafe extern "C" fn(
        datagram_based: *mut GDatagramBased,
        condition: GIOCondition,
        user_data: gpointer,
    ) -> gboolean,
>;
/// GInputVector:
/// @buffer: Pointer to a buffer where data will be written.
/// @size: the available size in @buffer.
///
/// Structure used for scatter/gather data input.
/// You generally pass in an array of #GInputVectors
/// and the operation will store the read data starting in the
/// first buffer, switching to the next as needed.
///
/// Since: 2.22
pub type GInputVector = _GInputVector;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GInputVector {
    pub buffer: gpointer,
    pub size: gsize,
}
#[test]
fn bindgen_test_layout__GInputVector() {
    assert_eq!(
        ::std::mem::size_of::<_GInputVector>(),
        16usize,
        concat!("Size of: ", stringify!(_GInputVector))
    );
    assert_eq!(
        ::std::mem::align_of::<_GInputVector>(),
        8usize,
        concat!("Alignment of ", stringify!(_GInputVector))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GInputVector>())).buffer as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GInputVector),
            "::",
            stringify!(buffer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GInputVector>())).size as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GInputVector),
            "::",
            stringify!(size)
        )
    );
}
/// GInputMessage:
/// @address: (optional) (out) (transfer full): return location
/// for a #GSocketAddress, or %NULL
/// @vectors: (array length=num_vectors) (out): pointer to an
/// array of input vectors
/// @num_vectors: the number of input vectors pointed to by @vectors
/// @bytes_received: (out): will be set to the number of bytes that have been
/// received
/// @flags: (out): collection of #GSocketMsgFlags for the received message,
/// outputted by the call
/// @control_messages: (array length=num_control_messages) (optional)
/// (out) (transfer full): return location for a
/// caller-allocated array of #GSocketControlMessages, or %NULL
/// @num_control_messages: (out) (optional): return location for the number of
/// elements in @control_messages
///
/// Structure used for scatter/gather data input when receiving multiple
/// messages or packets in one go. You generally pass in an array of empty
/// #GInputVectors and the operation will use all the buffers as if they
/// were one buffer, and will set @bytes_received to the total number of bytes
/// received across all #GInputVectors.
///
/// This structure closely mirrors `struct mmsghdr` and `struct msghdr` from
/// the POSIX sockets API (see `man 2 recvmmsg`).
///
/// If @address is non-%NULL then it is set to the source address the message
/// was received from, and the caller must free it afterwards.
///
/// If @control_messages is non-%NULL then it is set to an array of control
/// messages received with the message (if any), and the caller must free it
/// afterwards. @num_control_messages is set to the number of elements in
/// this array, which may be zero.
///
/// Flags relevant to this message will be returned in @flags. For example,
/// `MSG_EOR` or `MSG_TRUNC`.
///
/// Since: 2.48
pub type GInputMessage = _GInputMessage;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GInputMessage {
    pub address: *mut *mut GSocketAddress,
    pub vectors: *mut GInputVector,
    pub num_vectors: guint,
    pub bytes_received: gsize,
    pub flags: gint,
    pub control_messages: *mut *mut *mut GSocketControlMessage,
    pub num_control_messages: *mut guint,
}
#[test]
fn bindgen_test_layout__GInputMessage() {
    assert_eq!(
        ::std::mem::size_of::<_GInputMessage>(),
        56usize,
        concat!("Size of: ", stringify!(_GInputMessage))
    );
    assert_eq!(
        ::std::mem::align_of::<_GInputMessage>(),
        8usize,
        concat!("Alignment of ", stringify!(_GInputMessage))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GInputMessage>())).address as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GInputMessage),
            "::",
            stringify!(address)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GInputMessage>())).vectors as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GInputMessage),
            "::",
            stringify!(vectors)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GInputMessage>())).num_vectors as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GInputMessage),
            "::",
            stringify!(num_vectors)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GInputMessage>())).bytes_received as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GInputMessage),
            "::",
            stringify!(bytes_received)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GInputMessage>())).flags as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_GInputMessage),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GInputMessage>())).control_messages as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_GInputMessage),
            "::",
            stringify!(control_messages)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GInputMessage>())).num_control_messages as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_GInputMessage),
            "::",
            stringify!(num_control_messages)
        )
    );
}
/// GOutputVector:
/// @buffer: Pointer to a buffer of data to read.
/// @size: the size of @buffer.
///
/// Structure used for scatter/gather data output.
/// You generally pass in an array of #GOutputVectors
/// and the operation will use all the buffers as if they were
/// one buffer.
///
/// Since: 2.22
pub type GOutputVector = _GOutputVector;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GOutputVector {
    pub buffer: gconstpointer,
    pub size: gsize,
}
#[test]
fn bindgen_test_layout__GOutputVector() {
    assert_eq!(
        ::std::mem::size_of::<_GOutputVector>(),
        16usize,
        concat!("Size of: ", stringify!(_GOutputVector))
    );
    assert_eq!(
        ::std::mem::align_of::<_GOutputVector>(),
        8usize,
        concat!("Alignment of ", stringify!(_GOutputVector))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GOutputVector>())).buffer as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GOutputVector),
            "::",
            stringify!(buffer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GOutputVector>())).size as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GOutputVector),
            "::",
            stringify!(size)
        )
    );
}
/// GOutputMessage:
/// @address: (nullable): a #GSocketAddress, or %NULL
/// @vectors: pointer to an array of output vectors
/// @num_vectors: the number of output vectors pointed to by @vectors.
/// @bytes_sent: initialize to 0. Will be set to the number of bytes
/// that have been sent
/// @control_messages: (array length=num_control_messages) (nullable): a pointer
/// to an array of #GSocketControlMessages, or %NULL.
/// @num_control_messages: number of elements in @control_messages.
///
/// Structure used for scatter/gather data output when sending multiple
/// messages or packets in one go. You generally pass in an array of
/// #GOutputVectors and the operation will use all the buffers as if they
/// were one buffer.
///
/// If @address is %NULL then the message is sent to the default receiver
/// (as previously set by g_socket_connect()).
///
/// Since: 2.44
pub type GOutputMessage = _GOutputMessage;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GOutputMessage {
    pub address: *mut GSocketAddress,
    pub vectors: *mut GOutputVector,
    pub num_vectors: guint,
    pub bytes_sent: guint,
    pub control_messages: *mut *mut GSocketControlMessage,
    pub num_control_messages: guint,
}
#[test]
fn bindgen_test_layout__GOutputMessage() {
    assert_eq!(
        ::std::mem::size_of::<_GOutputMessage>(),
        40usize,
        concat!("Size of: ", stringify!(_GOutputMessage))
    );
    assert_eq!(
        ::std::mem::align_of::<_GOutputMessage>(),
        8usize,
        concat!("Alignment of ", stringify!(_GOutputMessage))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GOutputMessage>())).address as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GOutputMessage),
            "::",
            stringify!(address)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GOutputMessage>())).vectors as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GOutputMessage),
            "::",
            stringify!(vectors)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GOutputMessage>())).num_vectors as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GOutputMessage),
            "::",
            stringify!(num_vectors)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GOutputMessage>())).bytes_sent as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_GOutputMessage),
            "::",
            stringify!(bytes_sent)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GOutputMessage>())).control_messages as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GOutputMessage),
            "::",
            stringify!(control_messages)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GOutputMessage>())).num_control_messages as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_GOutputMessage),
            "::",
            stringify!(num_control_messages)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GCredentials {
    _unused: [u8; 0],
}
pub type GCredentials = _GCredentials;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GUnixCredentialsMessage {
    _unused: [u8; 0],
}
pub type GUnixCredentialsMessage = _GUnixCredentialsMessage;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GUnixFDList {
    _unused: [u8; 0],
}
pub type GUnixFDList = _GUnixFDList;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GDBusMessage {
    _unused: [u8; 0],
}
pub type GDBusMessage = _GDBusMessage;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GDBusConnection {
    _unused: [u8; 0],
}
pub type GDBusConnection = _GDBusConnection;
pub type GDBusProxy = _GDBusProxy;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GDBusMethodInvocation {
    _unused: [u8; 0],
}
pub type GDBusMethodInvocation = _GDBusMethodInvocation;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GDBusServer {
    _unused: [u8; 0],
}
pub type GDBusServer = _GDBusServer;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GDBusAuthObserver {
    _unused: [u8; 0],
}
pub type GDBusAuthObserver = _GDBusAuthObserver;
pub type GDBusErrorEntry = _GDBusErrorEntry;
pub type GDBusInterfaceVTable = _GDBusInterfaceVTable;
pub type GDBusSubtreeVTable = _GDBusSubtreeVTable;
pub type GDBusAnnotationInfo = _GDBusAnnotationInfo;
pub type GDBusArgInfo = _GDBusArgInfo;
pub type GDBusMethodInfo = _GDBusMethodInfo;
pub type GDBusSignalInfo = _GDBusSignalInfo;
pub type GDBusPropertyInfo = _GDBusPropertyInfo;
pub type GDBusInterfaceInfo = _GDBusInterfaceInfo;
pub type GDBusNodeInfo = _GDBusNodeInfo;
/// GCancellableSourceFunc:
/// @cancellable: the #GCancellable
/// @user_data: data passed in by the user.
///
/// This is the function type of the callback used for the #GSource
/// returned by g_cancellable_source_new().
///
/// Returns: it should return %FALSE if the source should be removed.
///
/// Since: 2.28
pub type GCancellableSourceFunc = ::std::option::Option<
    unsafe extern "C" fn(cancellable: *mut GCancellable, user_data: gpointer) -> gboolean,
>;
/// GPollableSourceFunc:
/// @pollable_stream: the #GPollableInputStream or #GPollableOutputStream
/// @user_data: data passed in by the user.
///
/// This is the function type of the callback used for the #GSource
/// returned by g_pollable_input_stream_create_source() and
/// g_pollable_output_stream_create_source().
///
/// Returns: it should return %FALSE if the source should be removed.
///
/// Since: 2.28
pub type GPollableSourceFunc = ::std::option::Option<
    unsafe extern "C" fn(pollable_stream: *mut GObject, user_data: gpointer) -> gboolean,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GDBusInterface {
    _unused: [u8; 0],
}
pub type GDBusInterface = _GDBusInterface;
pub type GDBusInterfaceSkeleton = _GDBusInterfaceSkeleton;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GDBusObject {
    _unused: [u8; 0],
}
pub type GDBusObject = _GDBusObject;
pub type GDBusObjectSkeleton = _GDBusObjectSkeleton;
pub type GDBusObjectProxy = _GDBusObjectProxy;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GDBusObjectManager {
    _unused: [u8; 0],
}
pub type GDBusObjectManager = _GDBusObjectManager;
pub type GDBusObjectManagerClient = _GDBusObjectManagerClient;
pub type GDBusObjectManagerServer = _GDBusObjectManagerServer;
/// GDBusProxyTypeFunc:
/// @manager: A #GDBusObjectManagerClient.
/// @object_path: The object path of the remote object.
/// @interface_name: (nullable): The interface name of the remote object or %NULL if a #GDBusObjectProxy #GType is requested.
/// @user_data: User data.
///
/// Function signature for a function used to determine the #GType to
/// use for an interface proxy (if @interface_name is not %NULL) or
/// object proxy (if @interface_name is %NULL).
///
/// This function is called in the
/// [thread-default main loop][g-main-context-push-thread-default]
/// that @manager was constructed in.
///
/// Returns: A #GType to use for the remote object. The returned type
/// must be a #GDBusProxy or #GDBusObjectProxy -derived
/// type.
///
/// Since: 2.30
pub type GDBusProxyTypeFunc = ::std::option::Option<
    unsafe extern "C" fn(
        manager: *mut GDBusObjectManagerClient,
        object_path: *const gchar,
        interface_name: *const gchar,
        user_data: gpointer,
    ) -> GType,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GTestDBus {
    _unused: [u8; 0],
}
pub type GTestDBus = _GTestDBus;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GSubprocess {
    _unused: [u8; 0],
}
/// GSubprocess:
///
/// A child process.
///
/// Since: 2.40
pub type GSubprocess = _GSubprocess;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GSubprocessLauncher {
    _unused: [u8; 0],
}
/// GSubprocessLauncher:
///
/// Options for launching a child process.
///
/// Since: 2.40
pub type GSubprocessLauncher = _GSubprocessLauncher;
pub type GActionInterface = _GActionInterface;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GActionInterface {
    pub g_iface: GTypeInterface,
    pub get_name: ::std::option::Option<unsafe extern "C" fn(action: *mut GAction) -> *const gchar>,
    pub get_parameter_type:
        ::std::option::Option<unsafe extern "C" fn(action: *mut GAction) -> *const GVariantType>,
    pub get_state_type:
        ::std::option::Option<unsafe extern "C" fn(action: *mut GAction) -> *const GVariantType>,
    pub get_state_hint:
        ::std::option::Option<unsafe extern "C" fn(action: *mut GAction) -> *mut GVariant>,
    pub get_enabled: ::std::option::Option<unsafe extern "C" fn(action: *mut GAction) -> gboolean>,
    pub get_state:
        ::std::option::Option<unsafe extern "C" fn(action: *mut GAction) -> *mut GVariant>,
    pub change_state:
        ::std::option::Option<unsafe extern "C" fn(action: *mut GAction, value: *mut GVariant)>,
    pub activate:
        ::std::option::Option<unsafe extern "C" fn(action: *mut GAction, parameter: *mut GVariant)>,
}
#[test]
fn bindgen_test_layout__GActionInterface() {
    assert_eq!(
        ::std::mem::size_of::<_GActionInterface>(),
        80usize,
        concat!("Size of: ", stringify!(_GActionInterface))
    );
    assert_eq!(
        ::std::mem::align_of::<_GActionInterface>(),
        8usize,
        concat!("Alignment of ", stringify!(_GActionInterface))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GActionInterface>())).g_iface as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GActionInterface),
            "::",
            stringify!(g_iface)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GActionInterface>())).get_name as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GActionInterface),
            "::",
            stringify!(get_name)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GActionInterface>())).get_parameter_type as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GActionInterface),
            "::",
            stringify!(get_parameter_type)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GActionInterface>())).get_state_type as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_GActionInterface),
            "::",
            stringify!(get_state_type)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GActionInterface>())).get_state_hint as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_GActionInterface),
            "::",
            stringify!(get_state_hint)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GActionInterface>())).get_enabled as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_GActionInterface),
            "::",
            stringify!(get_enabled)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GActionInterface>())).get_state as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_GActionInterface),
            "::",
            stringify!(get_state)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GActionInterface>())).change_state as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_GActionInterface),
            "::",
            stringify!(change_state)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GActionInterface>())).activate as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_GActionInterface),
            "::",
            stringify!(activate)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_g_action_get_type"]
    pub fn g_action_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_action_get_name"]
    pub fn g_action_get_name(action: *mut GAction) -> *const gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_action_get_parameter_type"]
    pub fn g_action_get_parameter_type(action: *mut GAction) -> *const GVariantType;
}
extern "C" {
    #[link_name = "\u{1}_g_action_get_state_type"]
    pub fn g_action_get_state_type(action: *mut GAction) -> *const GVariantType;
}
extern "C" {
    #[link_name = "\u{1}_g_action_get_state_hint"]
    pub fn g_action_get_state_hint(action: *mut GAction) -> *mut GVariant;
}
extern "C" {
    #[link_name = "\u{1}_g_action_get_enabled"]
    pub fn g_action_get_enabled(action: *mut GAction) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_action_get_state"]
    pub fn g_action_get_state(action: *mut GAction) -> *mut GVariant;
}
extern "C" {
    #[link_name = "\u{1}_g_action_change_state"]
    pub fn g_action_change_state(action: *mut GAction, value: *mut GVariant);
}
extern "C" {
    #[link_name = "\u{1}_g_action_activate"]
    pub fn g_action_activate(action: *mut GAction, parameter: *mut GVariant);
}
extern "C" {
    #[link_name = "\u{1}_g_action_name_is_valid"]
    pub fn g_action_name_is_valid(action_name: *const gchar) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_action_parse_detailed_name"]
    pub fn g_action_parse_detailed_name(
        detailed_name: *const gchar,
        action_name: *mut *mut gchar,
        target_value: *mut *mut GVariant,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_action_print_detailed_name"]
    pub fn g_action_print_detailed_name(
        action_name: *const gchar,
        target_value: *mut GVariant,
    ) -> *mut gchar;
}
pub type GActionGroupInterface = _GActionGroupInterface;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GActionGroupInterface {
    pub g_iface: GTypeInterface,
    pub has_action: ::std::option::Option<
        unsafe extern "C" fn(action_group: *mut GActionGroup, action_name: *const gchar)
            -> gboolean,
    >,
    pub list_actions: ::std::option::Option<
        unsafe extern "C" fn(action_group: *mut GActionGroup) -> *mut *mut gchar,
    >,
    pub get_action_enabled: ::std::option::Option<
        unsafe extern "C" fn(action_group: *mut GActionGroup, action_name: *const gchar)
            -> gboolean,
    >,
    pub get_action_parameter_type: ::std::option::Option<
        unsafe extern "C" fn(action_group: *mut GActionGroup, action_name: *const gchar)
            -> *const GVariantType,
    >,
    pub get_action_state_type: ::std::option::Option<
        unsafe extern "C" fn(action_group: *mut GActionGroup, action_name: *const gchar)
            -> *const GVariantType,
    >,
    pub get_action_state_hint: ::std::option::Option<
        unsafe extern "C" fn(action_group: *mut GActionGroup, action_name: *const gchar)
            -> *mut GVariant,
    >,
    pub get_action_state: ::std::option::Option<
        unsafe extern "C" fn(action_group: *mut GActionGroup, action_name: *const gchar)
            -> *mut GVariant,
    >,
    pub change_action_state: ::std::option::Option<
        unsafe extern "C" fn(
            action_group: *mut GActionGroup,
            action_name: *const gchar,
            value: *mut GVariant,
        ),
    >,
    pub activate_action: ::std::option::Option<
        unsafe extern "C" fn(
            action_group: *mut GActionGroup,
            action_name: *const gchar,
            parameter: *mut GVariant,
        ),
    >,
    pub action_added: ::std::option::Option<
        unsafe extern "C" fn(action_group: *mut GActionGroup, action_name: *const gchar),
    >,
    pub action_removed: ::std::option::Option<
        unsafe extern "C" fn(action_group: *mut GActionGroup, action_name: *const gchar),
    >,
    pub action_enabled_changed: ::std::option::Option<
        unsafe extern "C" fn(
            action_group: *mut GActionGroup,
            action_name: *const gchar,
            enabled: gboolean,
        ),
    >,
    pub action_state_changed: ::std::option::Option<
        unsafe extern "C" fn(
            action_group: *mut GActionGroup,
            action_name: *const gchar,
            state: *mut GVariant,
        ),
    >,
    pub query_action: ::std::option::Option<
        unsafe extern "C" fn(
            action_group: *mut GActionGroup,
            action_name: *const gchar,
            enabled: *mut gboolean,
            parameter_type: *mut *const GVariantType,
            state_type: *mut *const GVariantType,
            state_hint: *mut *mut GVariant,
            state: *mut *mut GVariant,
        ) -> gboolean,
    >,
}
#[test]
fn bindgen_test_layout__GActionGroupInterface() {
    assert_eq!(
        ::std::mem::size_of::<_GActionGroupInterface>(),
        128usize,
        concat!("Size of: ", stringify!(_GActionGroupInterface))
    );
    assert_eq!(
        ::std::mem::align_of::<_GActionGroupInterface>(),
        8usize,
        concat!("Alignment of ", stringify!(_GActionGroupInterface))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GActionGroupInterface>())).g_iface as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GActionGroupInterface),
            "::",
            stringify!(g_iface)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GActionGroupInterface>())).has_action as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GActionGroupInterface),
            "::",
            stringify!(has_action)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GActionGroupInterface>())).list_actions as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GActionGroupInterface),
            "::",
            stringify!(list_actions)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GActionGroupInterface>())).get_action_enabled as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_GActionGroupInterface),
            "::",
            stringify!(get_action_enabled)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GActionGroupInterface>())).get_action_parameter_type as *const _
                as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_GActionGroupInterface),
            "::",
            stringify!(get_action_parameter_type)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GActionGroupInterface>())).get_action_state_type as *const _
                as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_GActionGroupInterface),
            "::",
            stringify!(get_action_state_type)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GActionGroupInterface>())).get_action_state_hint as *const _
                as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_GActionGroupInterface),
            "::",
            stringify!(get_action_state_hint)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GActionGroupInterface>())).get_action_state as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_GActionGroupInterface),
            "::",
            stringify!(get_action_state)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GActionGroupInterface>())).change_action_state as *const _
                as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_GActionGroupInterface),
            "::",
            stringify!(change_action_state)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GActionGroupInterface>())).activate_action as *const _ as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_GActionGroupInterface),
            "::",
            stringify!(activate_action)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GActionGroupInterface>())).action_added as *const _ as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_GActionGroupInterface),
            "::",
            stringify!(action_added)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GActionGroupInterface>())).action_removed as *const _ as usize
        },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_GActionGroupInterface),
            "::",
            stringify!(action_removed)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GActionGroupInterface>())).action_enabled_changed as *const _
                as usize
        },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_GActionGroupInterface),
            "::",
            stringify!(action_enabled_changed)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GActionGroupInterface>())).action_state_changed as *const _
                as usize
        },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(_GActionGroupInterface),
            "::",
            stringify!(action_state_changed)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GActionGroupInterface>())).query_action as *const _ as usize
        },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(_GActionGroupInterface),
            "::",
            stringify!(query_action)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_g_action_group_get_type"]
    pub fn g_action_group_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_action_group_has_action"]
    pub fn g_action_group_has_action(
        action_group: *mut GActionGroup,
        action_name: *const gchar,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_action_group_list_actions"]
    pub fn g_action_group_list_actions(action_group: *mut GActionGroup) -> *mut *mut gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_action_group_get_action_parameter_type"]
    pub fn g_action_group_get_action_parameter_type(
        action_group: *mut GActionGroup,
        action_name: *const gchar,
    ) -> *const GVariantType;
}
extern "C" {
    #[link_name = "\u{1}_g_action_group_get_action_state_type"]
    pub fn g_action_group_get_action_state_type(
        action_group: *mut GActionGroup,
        action_name: *const gchar,
    ) -> *const GVariantType;
}
extern "C" {
    #[link_name = "\u{1}_g_action_group_get_action_state_hint"]
    pub fn g_action_group_get_action_state_hint(
        action_group: *mut GActionGroup,
        action_name: *const gchar,
    ) -> *mut GVariant;
}
extern "C" {
    #[link_name = "\u{1}_g_action_group_get_action_enabled"]
    pub fn g_action_group_get_action_enabled(
        action_group: *mut GActionGroup,
        action_name: *const gchar,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_action_group_get_action_state"]
    pub fn g_action_group_get_action_state(
        action_group: *mut GActionGroup,
        action_name: *const gchar,
    ) -> *mut GVariant;
}
extern "C" {
    #[link_name = "\u{1}_g_action_group_change_action_state"]
    pub fn g_action_group_change_action_state(
        action_group: *mut GActionGroup,
        action_name: *const gchar,
        value: *mut GVariant,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_action_group_activate_action"]
    pub fn g_action_group_activate_action(
        action_group: *mut GActionGroup,
        action_name: *const gchar,
        parameter: *mut GVariant,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_action_group_action_added"]
    pub fn g_action_group_action_added(action_group: *mut GActionGroup, action_name: *const gchar);
}
extern "C" {
    #[link_name = "\u{1}_g_action_group_action_removed"]
    pub fn g_action_group_action_removed(
        action_group: *mut GActionGroup,
        action_name: *const gchar,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_action_group_action_enabled_changed"]
    pub fn g_action_group_action_enabled_changed(
        action_group: *mut GActionGroup,
        action_name: *const gchar,
        enabled: gboolean,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_action_group_action_state_changed"]
    pub fn g_action_group_action_state_changed(
        action_group: *mut GActionGroup,
        action_name: *const gchar,
        state: *mut GVariant,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_action_group_query_action"]
    pub fn g_action_group_query_action(
        action_group: *mut GActionGroup,
        action_name: *const gchar,
        enabled: *mut gboolean,
        parameter_type: *mut *const GVariantType,
        state_type: *mut *const GVariantType,
        state_hint: *mut *mut GVariant,
        state: *mut *mut GVariant,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_dbus_connection_export_action_group"]
    pub fn g_dbus_connection_export_action_group(
        connection: *mut GDBusConnection,
        object_path: *const gchar,
        action_group: *mut GActionGroup,
        error: *mut *mut GError,
    ) -> guint;
}
extern "C" {
    #[link_name = "\u{1}_g_dbus_connection_unexport_action_group"]
    pub fn g_dbus_connection_unexport_action_group(
        connection: *mut GDBusConnection,
        export_id: guint,
    );
}
pub type GActionMapInterface = _GActionMapInterface;
pub type GActionEntry = _GActionEntry;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GActionMapInterface {
    pub g_iface: GTypeInterface,
    pub lookup_action: ::std::option::Option<
        unsafe extern "C" fn(action_map: *mut GActionMap, action_name: *const gchar)
            -> *mut GAction,
    >,
    pub add_action: ::std::option::Option<
        unsafe extern "C" fn(action_map: *mut GActionMap, action: *mut GAction),
    >,
    pub remove_action: ::std::option::Option<
        unsafe extern "C" fn(action_map: *mut GActionMap, action_name: *const gchar),
    >,
}
#[test]
fn bindgen_test_layout__GActionMapInterface() {
    assert_eq!(
        ::std::mem::size_of::<_GActionMapInterface>(),
        40usize,
        concat!("Size of: ", stringify!(_GActionMapInterface))
    );
    assert_eq!(
        ::std::mem::align_of::<_GActionMapInterface>(),
        8usize,
        concat!("Alignment of ", stringify!(_GActionMapInterface))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GActionMapInterface>())).g_iface as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GActionMapInterface),
            "::",
            stringify!(g_iface)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GActionMapInterface>())).lookup_action as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GActionMapInterface),
            "::",
            stringify!(lookup_action)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GActionMapInterface>())).add_action as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GActionMapInterface),
            "::",
            stringify!(add_action)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GActionMapInterface>())).remove_action as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_GActionMapInterface),
            "::",
            stringify!(remove_action)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GActionEntry {
    pub name: *const gchar,
    pub activate: ::std::option::Option<
        unsafe extern "C" fn(
            action: *mut GSimpleAction,
            parameter: *mut GVariant,
            user_data: gpointer,
        ),
    >,
    pub parameter_type: *const gchar,
    pub state: *const gchar,
    pub change_state: ::std::option::Option<
        unsafe extern "C" fn(action: *mut GSimpleAction, value: *mut GVariant, user_data: gpointer),
    >,
    pub padding: [gsize; 3usize],
}
#[test]
fn bindgen_test_layout__GActionEntry() {
    assert_eq!(
        ::std::mem::size_of::<_GActionEntry>(),
        64usize,
        concat!("Size of: ", stringify!(_GActionEntry))
    );
    assert_eq!(
        ::std::mem::align_of::<_GActionEntry>(),
        8usize,
        concat!("Alignment of ", stringify!(_GActionEntry))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GActionEntry>())).name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GActionEntry),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GActionEntry>())).activate as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GActionEntry),
            "::",
            stringify!(activate)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GActionEntry>())).parameter_type as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GActionEntry),
            "::",
            stringify!(parameter_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GActionEntry>())).state as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GActionEntry),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GActionEntry>())).change_state as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_GActionEntry),
            "::",
            stringify!(change_state)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GActionEntry>())).padding as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_GActionEntry),
            "::",
            stringify!(padding)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_g_action_map_get_type"]
    pub fn g_action_map_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_action_map_lookup_action"]
    pub fn g_action_map_lookup_action(
        action_map: *mut GActionMap,
        action_name: *const gchar,
    ) -> *mut GAction;
}
extern "C" {
    #[link_name = "\u{1}_g_action_map_add_action"]
    pub fn g_action_map_add_action(action_map: *mut GActionMap, action: *mut GAction);
}
extern "C" {
    #[link_name = "\u{1}_g_action_map_remove_action"]
    pub fn g_action_map_remove_action(action_map: *mut GActionMap, action_name: *const gchar);
}
extern "C" {
    #[link_name = "\u{1}_g_action_map_add_action_entries"]
    pub fn g_action_map_add_action_entries(
        action_map: *mut GActionMap,
        entries: *const GActionEntry,
        n_entries: gint,
        user_data: gpointer,
    );
}
pub type GAppLaunchContextClass = _GAppLaunchContextClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GAppLaunchContextPrivate {
    _unused: [u8; 0],
}
pub type GAppLaunchContextPrivate = _GAppLaunchContextPrivate;
/// GAppInfoIface:
/// @g_iface: The parent interface.
/// @dup: Copies a #GAppInfo.
/// @equal: Checks two #GAppInfos for equality.
/// @get_id: Gets a string identifier for a #GAppInfo.
/// @get_name: Gets the name of the application for a #GAppInfo.
/// @get_description: Gets a short description for the application described by the #GAppInfo.
/// @get_executable: Gets the executable name for the #GAppInfo.
/// @get_icon: Gets the #GIcon for the #GAppInfo.
/// @launch: Launches an application specified by the #GAppInfo.
/// @supports_uris: Indicates whether the application specified supports launching URIs.
/// @supports_files: Indicates whether the application specified accepts filename arguments.
/// @launch_uris: Launches an application with a list of URIs.
/// @should_show: Returns whether an application should be shown (e.g. when getting a list of installed applications).
/// [FreeDesktop.Org Startup Notification Specification](http://standards.freedesktop.org/startup-notification-spec/startup-notification-latest.txt).
/// @set_as_default_for_type: Sets an application as default for a given content type.
/// @set_as_default_for_extension: Sets an application as default for a given file extension.
/// @add_supports_type: Adds to the #GAppInfo information about supported file types.
/// @can_remove_supports_type: Checks for support for removing supported file types from a #GAppInfo.
/// @remove_supports_type: Removes a supported application type from a #GAppInfo.
/// @can_delete: Checks if a #GAppInfo can be deleted. Since 2.20
/// @do_delete: Deletes a #GAppInfo. Since 2.20
/// @get_commandline: Gets the commandline for the #GAppInfo. Since 2.20
/// @get_display_name: Gets the display name for the #GAppInfo. Since 2.24
/// @set_as_last_used_for_type: Sets the application as the last used. See g_app_info_set_as_last_used_for_type().
/// @get_supported_types: Retrieves the list of content types that @app_info claims to support.
///
/// Application Information interface, for operating system portability.
pub type GAppInfoIface = _GAppInfoIface;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GAppInfoIface {
    pub g_iface: GTypeInterface,
    pub dup: ::std::option::Option<unsafe extern "C" fn(appinfo: *mut GAppInfo) -> *mut GAppInfo>,
    pub equal: ::std::option::Option<
        unsafe extern "C" fn(appinfo1: *mut GAppInfo, appinfo2: *mut GAppInfo) -> gboolean,
    >,
    pub get_id: ::std::option::Option<
        unsafe extern "C" fn(appinfo: *mut GAppInfo) -> *const ::std::os::raw::c_char,
    >,
    pub get_name: ::std::option::Option<
        unsafe extern "C" fn(appinfo: *mut GAppInfo) -> *const ::std::os::raw::c_char,
    >,
    pub get_description: ::std::option::Option<
        unsafe extern "C" fn(appinfo: *mut GAppInfo) -> *const ::std::os::raw::c_char,
    >,
    pub get_executable: ::std::option::Option<
        unsafe extern "C" fn(appinfo: *mut GAppInfo) -> *const ::std::os::raw::c_char,
    >,
    pub get_icon: ::std::option::Option<unsafe extern "C" fn(appinfo: *mut GAppInfo) -> *mut GIcon>,
    pub launch: ::std::option::Option<
        unsafe extern "C" fn(
            appinfo: *mut GAppInfo,
            files: *mut GList,
            launch_context: *mut GAppLaunchContext,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
    pub supports_uris:
        ::std::option::Option<unsafe extern "C" fn(appinfo: *mut GAppInfo) -> gboolean>,
    pub supports_files:
        ::std::option::Option<unsafe extern "C" fn(appinfo: *mut GAppInfo) -> gboolean>,
    pub launch_uris: ::std::option::Option<
        unsafe extern "C" fn(
            appinfo: *mut GAppInfo,
            uris: *mut GList,
            launch_context: *mut GAppLaunchContext,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
    pub should_show:
        ::std::option::Option<unsafe extern "C" fn(appinfo: *mut GAppInfo) -> gboolean>,
    pub set_as_default_for_type: ::std::option::Option<
        unsafe extern "C" fn(
            appinfo: *mut GAppInfo,
            content_type: *const ::std::os::raw::c_char,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
    pub set_as_default_for_extension: ::std::option::Option<
        unsafe extern "C" fn(
            appinfo: *mut GAppInfo,
            extension: *const ::std::os::raw::c_char,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
    pub add_supports_type: ::std::option::Option<
        unsafe extern "C" fn(
            appinfo: *mut GAppInfo,
            content_type: *const ::std::os::raw::c_char,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
    pub can_remove_supports_type:
        ::std::option::Option<unsafe extern "C" fn(appinfo: *mut GAppInfo) -> gboolean>,
    pub remove_supports_type: ::std::option::Option<
        unsafe extern "C" fn(
            appinfo: *mut GAppInfo,
            content_type: *const ::std::os::raw::c_char,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
    pub can_delete: ::std::option::Option<unsafe extern "C" fn(appinfo: *mut GAppInfo) -> gboolean>,
    pub do_delete: ::std::option::Option<unsafe extern "C" fn(appinfo: *mut GAppInfo) -> gboolean>,
    pub get_commandline: ::std::option::Option<
        unsafe extern "C" fn(appinfo: *mut GAppInfo) -> *const ::std::os::raw::c_char,
    >,
    pub get_display_name: ::std::option::Option<
        unsafe extern "C" fn(appinfo: *mut GAppInfo) -> *const ::std::os::raw::c_char,
    >,
    pub set_as_last_used_for_type: ::std::option::Option<
        unsafe extern "C" fn(
            appinfo: *mut GAppInfo,
            content_type: *const ::std::os::raw::c_char,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
    pub get_supported_types: ::std::option::Option<
        unsafe extern "C" fn(appinfo: *mut GAppInfo) -> *mut *const ::std::os::raw::c_char,
    >,
}
#[test]
fn bindgen_test_layout__GAppInfoIface() {
    assert_eq!(
        ::std::mem::size_of::<_GAppInfoIface>(),
        200usize,
        concat!("Size of: ", stringify!(_GAppInfoIface))
    );
    assert_eq!(
        ::std::mem::align_of::<_GAppInfoIface>(),
        8usize,
        concat!("Alignment of ", stringify!(_GAppInfoIface))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GAppInfoIface>())).g_iface as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GAppInfoIface),
            "::",
            stringify!(g_iface)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GAppInfoIface>())).dup as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GAppInfoIface),
            "::",
            stringify!(dup)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GAppInfoIface>())).equal as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GAppInfoIface),
            "::",
            stringify!(equal)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GAppInfoIface>())).get_id as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_GAppInfoIface),
            "::",
            stringify!(get_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GAppInfoIface>())).get_name as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_GAppInfoIface),
            "::",
            stringify!(get_name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GAppInfoIface>())).get_description as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_GAppInfoIface),
            "::",
            stringify!(get_description)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GAppInfoIface>())).get_executable as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_GAppInfoIface),
            "::",
            stringify!(get_executable)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GAppInfoIface>())).get_icon as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_GAppInfoIface),
            "::",
            stringify!(get_icon)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GAppInfoIface>())).launch as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_GAppInfoIface),
            "::",
            stringify!(launch)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GAppInfoIface>())).supports_uris as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_GAppInfoIface),
            "::",
            stringify!(supports_uris)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GAppInfoIface>())).supports_files as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_GAppInfoIface),
            "::",
            stringify!(supports_files)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GAppInfoIface>())).launch_uris as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_GAppInfoIface),
            "::",
            stringify!(launch_uris)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GAppInfoIface>())).should_show as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_GAppInfoIface),
            "::",
            stringify!(should_show)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GAppInfoIface>())).set_as_default_for_type as *const _ as usize
        },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(_GAppInfoIface),
            "::",
            stringify!(set_as_default_for_type)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GAppInfoIface>())).set_as_default_for_extension as *const _
                as usize
        },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(_GAppInfoIface),
            "::",
            stringify!(set_as_default_for_extension)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GAppInfoIface>())).add_supports_type as *const _ as usize
        },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(_GAppInfoIface),
            "::",
            stringify!(add_supports_type)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GAppInfoIface>())).can_remove_supports_type as *const _ as usize
        },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_GAppInfoIface),
            "::",
            stringify!(can_remove_supports_type)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GAppInfoIface>())).remove_supports_type as *const _ as usize
        },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_GAppInfoIface),
            "::",
            stringify!(remove_supports_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GAppInfoIface>())).can_delete as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(_GAppInfoIface),
            "::",
            stringify!(can_delete)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GAppInfoIface>())).do_delete as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_GAppInfoIface),
            "::",
            stringify!(do_delete)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GAppInfoIface>())).get_commandline as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(_GAppInfoIface),
            "::",
            stringify!(get_commandline)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GAppInfoIface>())).get_display_name as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(_GAppInfoIface),
            "::",
            stringify!(get_display_name)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GAppInfoIface>())).set_as_last_used_for_type as *const _
                as usize
        },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(_GAppInfoIface),
            "::",
            stringify!(set_as_last_used_for_type)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GAppInfoIface>())).get_supported_types as *const _ as usize
        },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(_GAppInfoIface),
            "::",
            stringify!(get_supported_types)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_g_app_info_get_type"]
    pub fn g_app_info_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_app_info_create_from_commandline"]
    pub fn g_app_info_create_from_commandline(
        commandline: *const ::std::os::raw::c_char,
        application_name: *const ::std::os::raw::c_char,
        flags: GAppInfoCreateFlags,
        error: *mut *mut GError,
    ) -> *mut GAppInfo;
}
extern "C" {
    #[link_name = "\u{1}_g_app_info_dup"]
    pub fn g_app_info_dup(appinfo: *mut GAppInfo) -> *mut GAppInfo;
}
extern "C" {
    #[link_name = "\u{1}_g_app_info_equal"]
    pub fn g_app_info_equal(appinfo1: *mut GAppInfo, appinfo2: *mut GAppInfo) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_app_info_get_id"]
    pub fn g_app_info_get_id(appinfo: *mut GAppInfo) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_g_app_info_get_name"]
    pub fn g_app_info_get_name(appinfo: *mut GAppInfo) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_g_app_info_get_display_name"]
    pub fn g_app_info_get_display_name(appinfo: *mut GAppInfo) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_g_app_info_get_description"]
    pub fn g_app_info_get_description(appinfo: *mut GAppInfo) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_g_app_info_get_executable"]
    pub fn g_app_info_get_executable(appinfo: *mut GAppInfo) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_g_app_info_get_commandline"]
    pub fn g_app_info_get_commandline(appinfo: *mut GAppInfo) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_g_app_info_get_icon"]
    pub fn g_app_info_get_icon(appinfo: *mut GAppInfo) -> *mut GIcon;
}
extern "C" {
    #[link_name = "\u{1}_g_app_info_launch"]
    pub fn g_app_info_launch(
        appinfo: *mut GAppInfo,
        files: *mut GList,
        launch_context: *mut GAppLaunchContext,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_app_info_supports_uris"]
    pub fn g_app_info_supports_uris(appinfo: *mut GAppInfo) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_app_info_supports_files"]
    pub fn g_app_info_supports_files(appinfo: *mut GAppInfo) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_app_info_launch_uris"]
    pub fn g_app_info_launch_uris(
        appinfo: *mut GAppInfo,
        uris: *mut GList,
        launch_context: *mut GAppLaunchContext,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_app_info_should_show"]
    pub fn g_app_info_should_show(appinfo: *mut GAppInfo) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_app_info_set_as_default_for_type"]
    pub fn g_app_info_set_as_default_for_type(
        appinfo: *mut GAppInfo,
        content_type: *const ::std::os::raw::c_char,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_app_info_set_as_default_for_extension"]
    pub fn g_app_info_set_as_default_for_extension(
        appinfo: *mut GAppInfo,
        extension: *const ::std::os::raw::c_char,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_app_info_add_supports_type"]
    pub fn g_app_info_add_supports_type(
        appinfo: *mut GAppInfo,
        content_type: *const ::std::os::raw::c_char,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_app_info_can_remove_supports_type"]
    pub fn g_app_info_can_remove_supports_type(appinfo: *mut GAppInfo) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_app_info_remove_supports_type"]
    pub fn g_app_info_remove_supports_type(
        appinfo: *mut GAppInfo,
        content_type: *const ::std::os::raw::c_char,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_app_info_get_supported_types"]
    pub fn g_app_info_get_supported_types(
        appinfo: *mut GAppInfo,
    ) -> *mut *const ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_g_app_info_can_delete"]
    pub fn g_app_info_can_delete(appinfo: *mut GAppInfo) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_app_info_delete"]
    pub fn g_app_info_delete(appinfo: *mut GAppInfo) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_app_info_set_as_last_used_for_type"]
    pub fn g_app_info_set_as_last_used_for_type(
        appinfo: *mut GAppInfo,
        content_type: *const ::std::os::raw::c_char,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_app_info_get_all"]
    pub fn g_app_info_get_all() -> *mut GList;
}
extern "C" {
    #[link_name = "\u{1}_g_app_info_get_all_for_type"]
    pub fn g_app_info_get_all_for_type(content_type: *const ::std::os::raw::c_char) -> *mut GList;
}
extern "C" {
    #[link_name = "\u{1}_g_app_info_get_recommended_for_type"]
    pub fn g_app_info_get_recommended_for_type(content_type: *const gchar) -> *mut GList;
}
extern "C" {
    #[link_name = "\u{1}_g_app_info_get_fallback_for_type"]
    pub fn g_app_info_get_fallback_for_type(content_type: *const gchar) -> *mut GList;
}
extern "C" {
    #[link_name = "\u{1}_g_app_info_reset_type_associations"]
    pub fn g_app_info_reset_type_associations(content_type: *const ::std::os::raw::c_char);
}
extern "C" {
    #[link_name = "\u{1}_g_app_info_get_default_for_type"]
    pub fn g_app_info_get_default_for_type(
        content_type: *const ::std::os::raw::c_char,
        must_support_uris: gboolean,
    ) -> *mut GAppInfo;
}
extern "C" {
    #[link_name = "\u{1}_g_app_info_get_default_for_uri_scheme"]
    pub fn g_app_info_get_default_for_uri_scheme(
        uri_scheme: *const ::std::os::raw::c_char,
    ) -> *mut GAppInfo;
}
extern "C" {
    #[link_name = "\u{1}_g_app_info_launch_default_for_uri"]
    pub fn g_app_info_launch_default_for_uri(
        uri: *const ::std::os::raw::c_char,
        launch_context: *mut GAppLaunchContext,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_app_info_launch_default_for_uri_async"]
    pub fn g_app_info_launch_default_for_uri_async(
        uri: *const ::std::os::raw::c_char,
        launch_context: *mut GAppLaunchContext,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_app_info_launch_default_for_uri_finish"]
    pub fn g_app_info_launch_default_for_uri_finish(
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> gboolean;
}
/// GAppLaunchContext:
///
/// Integrating the launch with the launching application. This is used to
/// handle for instance startup notification and launching the new application
/// on the same screen as the launching window.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GAppLaunchContext {
    pub parent_instance: GObject,
    pub priv_: *mut GAppLaunchContextPrivate,
}
#[test]
fn bindgen_test_layout__GAppLaunchContext() {
    assert_eq!(
        ::std::mem::size_of::<_GAppLaunchContext>(),
        32usize,
        concat!("Size of: ", stringify!(_GAppLaunchContext))
    );
    assert_eq!(
        ::std::mem::align_of::<_GAppLaunchContext>(),
        8usize,
        concat!("Alignment of ", stringify!(_GAppLaunchContext))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GAppLaunchContext>())).parent_instance as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GAppLaunchContext),
            "::",
            stringify!(parent_instance)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GAppLaunchContext>())).priv_ as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GAppLaunchContext),
            "::",
            stringify!(priv_)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GAppLaunchContextClass {
    pub parent_class: GObjectClass,
    pub get_display: ::std::option::Option<
        unsafe extern "C" fn(
            context: *mut GAppLaunchContext,
            info: *mut GAppInfo,
            files: *mut GList,
        ) -> *mut ::std::os::raw::c_char,
    >,
    pub get_startup_notify_id: ::std::option::Option<
        unsafe extern "C" fn(
            context: *mut GAppLaunchContext,
            info: *mut GAppInfo,
            files: *mut GList,
        ) -> *mut ::std::os::raw::c_char,
    >,
    pub launch_failed: ::std::option::Option<
        unsafe extern "C" fn(
            context: *mut GAppLaunchContext,
            startup_notify_id: *const ::std::os::raw::c_char,
        ),
    >,
    pub launched: ::std::option::Option<
        unsafe extern "C" fn(
            context: *mut GAppLaunchContext,
            info: *mut GAppInfo,
            platform_data: *mut GVariant,
        ),
    >,
    pub _g_reserved1: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved2: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved3: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved4: ::std::option::Option<unsafe extern "C" fn()>,
}
#[test]
fn bindgen_test_layout__GAppLaunchContextClass() {
    assert_eq!(
        ::std::mem::size_of::<_GAppLaunchContextClass>(),
        200usize,
        concat!("Size of: ", stringify!(_GAppLaunchContextClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_GAppLaunchContextClass>(),
        8usize,
        concat!("Alignment of ", stringify!(_GAppLaunchContextClass))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GAppLaunchContextClass>())).parent_class as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GAppLaunchContextClass),
            "::",
            stringify!(parent_class)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GAppLaunchContextClass>())).get_display as *const _ as usize
        },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_GAppLaunchContextClass),
            "::",
            stringify!(get_display)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GAppLaunchContextClass>())).get_startup_notify_id as *const _
                as usize
        },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_GAppLaunchContextClass),
            "::",
            stringify!(get_startup_notify_id)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GAppLaunchContextClass>())).launch_failed as *const _ as usize
        },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(_GAppLaunchContextClass),
            "::",
            stringify!(launch_failed)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GAppLaunchContextClass>())).launched as *const _ as usize
        },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_GAppLaunchContextClass),
            "::",
            stringify!(launched)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GAppLaunchContextClass>()))._g_reserved1 as *const _ as usize
        },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(_GAppLaunchContextClass),
            "::",
            stringify!(_g_reserved1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GAppLaunchContextClass>()))._g_reserved2 as *const _ as usize
        },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(_GAppLaunchContextClass),
            "::",
            stringify!(_g_reserved2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GAppLaunchContextClass>()))._g_reserved3 as *const _ as usize
        },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(_GAppLaunchContextClass),
            "::",
            stringify!(_g_reserved3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GAppLaunchContextClass>()))._g_reserved4 as *const _ as usize
        },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(_GAppLaunchContextClass),
            "::",
            stringify!(_g_reserved4)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_g_app_launch_context_get_type"]
    pub fn g_app_launch_context_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_app_launch_context_new"]
    pub fn g_app_launch_context_new() -> *mut GAppLaunchContext;
}
extern "C" {
    #[link_name = "\u{1}_g_app_launch_context_setenv"]
    pub fn g_app_launch_context_setenv(
        context: *mut GAppLaunchContext,
        variable: *const ::std::os::raw::c_char,
        value: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_app_launch_context_unsetenv"]
    pub fn g_app_launch_context_unsetenv(
        context: *mut GAppLaunchContext,
        variable: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_app_launch_context_get_environment"]
    pub fn g_app_launch_context_get_environment(
        context: *mut GAppLaunchContext,
    ) -> *mut *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_g_app_launch_context_get_display"]
    pub fn g_app_launch_context_get_display(
        context: *mut GAppLaunchContext,
        info: *mut GAppInfo,
        files: *mut GList,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_g_app_launch_context_get_startup_notify_id"]
    pub fn g_app_launch_context_get_startup_notify_id(
        context: *mut GAppLaunchContext,
        info: *mut GAppInfo,
        files: *mut GList,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_g_app_launch_context_launch_failed"]
    pub fn g_app_launch_context_launch_failed(
        context: *mut GAppLaunchContext,
        startup_notify_id: *const ::std::os::raw::c_char,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GAppInfoMonitor {
    _unused: [u8; 0],
}
pub type GAppInfoMonitor = _GAppInfoMonitor;
extern "C" {
    #[link_name = "\u{1}_g_app_info_monitor_get_type"]
    pub fn g_app_info_monitor_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_app_info_monitor_get"]
    pub fn g_app_info_monitor_get() -> *mut GAppInfoMonitor;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GApplicationPrivate {
    _unused: [u8; 0],
}
pub type GApplicationPrivate = _GApplicationPrivate;
pub type GApplicationClass = _GApplicationClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GApplication {
    pub parent_instance: GObject,
    pub priv_: *mut GApplicationPrivate,
}
#[test]
fn bindgen_test_layout__GApplication() {
    assert_eq!(
        ::std::mem::size_of::<_GApplication>(),
        32usize,
        concat!("Size of: ", stringify!(_GApplication))
    );
    assert_eq!(
        ::std::mem::align_of::<_GApplication>(),
        8usize,
        concat!("Alignment of ", stringify!(_GApplication))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GApplication>())).parent_instance as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GApplication),
            "::",
            stringify!(parent_instance)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GApplication>())).priv_ as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GApplication),
            "::",
            stringify!(priv_)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GApplicationClass {
    pub parent_class: GObjectClass,
    pub startup: ::std::option::Option<unsafe extern "C" fn(application: *mut GApplication)>,
    pub activate: ::std::option::Option<unsafe extern "C" fn(application: *mut GApplication)>,
    pub open: ::std::option::Option<
        unsafe extern "C" fn(
            application: *mut GApplication,
            files: *mut *mut GFile,
            n_files: gint,
            hint: *const gchar,
        ),
    >,
    pub command_line: ::std::option::Option<
        unsafe extern "C" fn(
            application: *mut GApplication,
            command_line: *mut GApplicationCommandLine,
        ) -> ::std::os::raw::c_int,
    >,
    /// GApplicationClass::local_command_line:
    /// @application: a #GApplication
    /// @arguments: (inout) (array zero-terminated=1): array of command line arguments
    /// @exit_status: (out): exit status to fill after processing the command line.
    ///
    /// This virtual function is always invoked in the local instance. It
    /// gets passed a pointer to a %NULL-terminated copy of @argv and is
    /// expected to remove arguments that it handled (shifting up remaining
    /// arguments).
    ///
    /// The last argument to local_command_line() is a pointer to the @status
    /// variable which can used to set the exit status that is returned from
    /// g_application_run().
    ///
    /// See g_application_run() for more details on #GApplication startup.
    ///
    /// Returns: %TRUE if the commandline has been completely handled
    pub local_command_line: ::std::option::Option<
        unsafe extern "C" fn(
            application: *mut GApplication,
            arguments: *mut *mut *mut gchar,
            exit_status: *mut ::std::os::raw::c_int,
        ) -> gboolean,
    >,
    pub before_emit: ::std::option::Option<
        unsafe extern "C" fn(application: *mut GApplication, platform_data: *mut GVariant),
    >,
    pub after_emit: ::std::option::Option<
        unsafe extern "C" fn(application: *mut GApplication, platform_data: *mut GVariant),
    >,
    pub add_platform_data: ::std::option::Option<
        unsafe extern "C" fn(application: *mut GApplication, builder: *mut GVariantBuilder),
    >,
    pub quit_mainloop: ::std::option::Option<unsafe extern "C" fn(application: *mut GApplication)>,
    pub run_mainloop: ::std::option::Option<unsafe extern "C" fn(application: *mut GApplication)>,
    pub shutdown: ::std::option::Option<unsafe extern "C" fn(application: *mut GApplication)>,
    pub dbus_register: ::std::option::Option<
        unsafe extern "C" fn(
            application: *mut GApplication,
            connection: *mut GDBusConnection,
            object_path: *const gchar,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
    pub dbus_unregister: ::std::option::Option<
        unsafe extern "C" fn(
            application: *mut GApplication,
            connection: *mut GDBusConnection,
            object_path: *const gchar,
        ),
    >,
    pub handle_local_options: ::std::option::Option<
        unsafe extern "C" fn(application: *mut GApplication, options: *mut GVariantDict) -> gint,
    >,
    pub padding: [gpointer; 8usize],
}
#[test]
fn bindgen_test_layout__GApplicationClass() {
    assert_eq!(
        ::std::mem::size_of::<_GApplicationClass>(),
        312usize,
        concat!("Size of: ", stringify!(_GApplicationClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_GApplicationClass>(),
        8usize,
        concat!("Alignment of ", stringify!(_GApplicationClass))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GApplicationClass>())).parent_class as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GApplicationClass),
            "::",
            stringify!(parent_class)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GApplicationClass>())).startup as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_GApplicationClass),
            "::",
            stringify!(startup)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GApplicationClass>())).activate as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_GApplicationClass),
            "::",
            stringify!(activate)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GApplicationClass>())).open as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(_GApplicationClass),
            "::",
            stringify!(open)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GApplicationClass>())).command_line as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_GApplicationClass),
            "::",
            stringify!(command_line)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GApplicationClass>())).local_command_line as *const _ as usize
        },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(_GApplicationClass),
            "::",
            stringify!(local_command_line)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GApplicationClass>())).before_emit as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(_GApplicationClass),
            "::",
            stringify!(before_emit)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GApplicationClass>())).after_emit as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(_GApplicationClass),
            "::",
            stringify!(after_emit)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GApplicationClass>())).add_platform_data as *const _ as usize
        },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(_GApplicationClass),
            "::",
            stringify!(add_platform_data)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GApplicationClass>())).quit_mainloop as *const _ as usize
        },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(_GApplicationClass),
            "::",
            stringify!(quit_mainloop)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GApplicationClass>())).run_mainloop as *const _ as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(_GApplicationClass),
            "::",
            stringify!(run_mainloop)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GApplicationClass>())).shutdown as *const _ as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(_GApplicationClass),
            "::",
            stringify!(shutdown)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GApplicationClass>())).dbus_register as *const _ as usize
        },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(_GApplicationClass),
            "::",
            stringify!(dbus_register)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GApplicationClass>())).dbus_unregister as *const _ as usize
        },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(_GApplicationClass),
            "::",
            stringify!(dbus_unregister)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GApplicationClass>())).handle_local_options as *const _ as usize
        },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(_GApplicationClass),
            "::",
            stringify!(handle_local_options)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GApplicationClass>())).padding as *const _ as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(_GApplicationClass),
            "::",
            stringify!(padding)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_g_application_get_type"]
    pub fn g_application_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_application_id_is_valid"]
    pub fn g_application_id_is_valid(application_id: *const gchar) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_application_new"]
    pub fn g_application_new(
        application_id: *const gchar,
        flags: GApplicationFlags,
    ) -> *mut GApplication;
}
extern "C" {
    #[link_name = "\u{1}_g_application_get_application_id"]
    pub fn g_application_get_application_id(application: *mut GApplication) -> *const gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_application_set_application_id"]
    pub fn g_application_set_application_id(
        application: *mut GApplication,
        application_id: *const gchar,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_application_get_dbus_connection"]
    pub fn g_application_get_dbus_connection(
        application: *mut GApplication,
    ) -> *mut GDBusConnection;
}
extern "C" {
    #[link_name = "\u{1}_g_application_get_dbus_object_path"]
    pub fn g_application_get_dbus_object_path(application: *mut GApplication) -> *const gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_application_get_inactivity_timeout"]
    pub fn g_application_get_inactivity_timeout(application: *mut GApplication) -> guint;
}
extern "C" {
    #[link_name = "\u{1}_g_application_set_inactivity_timeout"]
    pub fn g_application_set_inactivity_timeout(
        application: *mut GApplication,
        inactivity_timeout: guint,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_application_get_flags"]
    pub fn g_application_get_flags(application: *mut GApplication) -> GApplicationFlags;
}
extern "C" {
    #[link_name = "\u{1}_g_application_set_flags"]
    pub fn g_application_set_flags(application: *mut GApplication, flags: GApplicationFlags);
}
extern "C" {
    #[link_name = "\u{1}_g_application_get_resource_base_path"]
    pub fn g_application_get_resource_base_path(application: *mut GApplication) -> *const gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_application_set_resource_base_path"]
    pub fn g_application_set_resource_base_path(
        application: *mut GApplication,
        resource_path: *const gchar,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_application_set_action_group"]
    pub fn g_application_set_action_group(
        application: *mut GApplication,
        action_group: *mut GActionGroup,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_application_add_main_option_entries"]
    pub fn g_application_add_main_option_entries(
        application: *mut GApplication,
        entries: *const GOptionEntry,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_application_add_main_option"]
    pub fn g_application_add_main_option(
        application: *mut GApplication,
        long_name: *const ::std::os::raw::c_char,
        short_name: ::std::os::raw::c_char,
        flags: GOptionFlags,
        arg: GOptionArg,
        description: *const ::std::os::raw::c_char,
        arg_description: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_application_add_option_group"]
    pub fn g_application_add_option_group(application: *mut GApplication, group: *mut GOptionGroup);
}
extern "C" {
    #[link_name = "\u{1}_g_application_get_is_registered"]
    pub fn g_application_get_is_registered(application: *mut GApplication) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_application_get_is_remote"]
    pub fn g_application_get_is_remote(application: *mut GApplication) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_application_register"]
    pub fn g_application_register(
        application: *mut GApplication,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_application_hold"]
    pub fn g_application_hold(application: *mut GApplication);
}
extern "C" {
    #[link_name = "\u{1}_g_application_release"]
    pub fn g_application_release(application: *mut GApplication);
}
extern "C" {
    #[link_name = "\u{1}_g_application_activate"]
    pub fn g_application_activate(application: *mut GApplication);
}
extern "C" {
    #[link_name = "\u{1}_g_application_open"]
    pub fn g_application_open(
        application: *mut GApplication,
        files: *mut *mut GFile,
        n_files: gint,
        hint: *const gchar,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_application_run"]
    pub fn g_application_run(
        application: *mut GApplication,
        argc: ::std::os::raw::c_int,
        argv: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_g_application_quit"]
    pub fn g_application_quit(application: *mut GApplication);
}
extern "C" {
    #[link_name = "\u{1}_g_application_get_default"]
    pub fn g_application_get_default() -> *mut GApplication;
}
extern "C" {
    #[link_name = "\u{1}_g_application_set_default"]
    pub fn g_application_set_default(application: *mut GApplication);
}
extern "C" {
    #[link_name = "\u{1}_g_application_mark_busy"]
    pub fn g_application_mark_busy(application: *mut GApplication);
}
extern "C" {
    #[link_name = "\u{1}_g_application_unmark_busy"]
    pub fn g_application_unmark_busy(application: *mut GApplication);
}
extern "C" {
    #[link_name = "\u{1}_g_application_get_is_busy"]
    pub fn g_application_get_is_busy(application: *mut GApplication) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_application_send_notification"]
    pub fn g_application_send_notification(
        application: *mut GApplication,
        id: *const gchar,
        notification: *mut GNotification,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_application_withdraw_notification"]
    pub fn g_application_withdraw_notification(application: *mut GApplication, id: *const gchar);
}
extern "C" {
    #[link_name = "\u{1}_g_application_bind_busy_property"]
    pub fn g_application_bind_busy_property(
        application: *mut GApplication,
        object: gpointer,
        property: *const gchar,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_application_unbind_busy_property"]
    pub fn g_application_unbind_busy_property(
        application: *mut GApplication,
        object: gpointer,
        property: *const gchar,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GApplicationCommandLinePrivate {
    _unused: [u8; 0],
}
pub type GApplicationCommandLinePrivate = _GApplicationCommandLinePrivate;
pub type GApplicationCommandLineClass = _GApplicationCommandLineClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GApplicationCommandLine {
    pub parent_instance: GObject,
    pub priv_: *mut GApplicationCommandLinePrivate,
}
#[test]
fn bindgen_test_layout__GApplicationCommandLine() {
    assert_eq!(
        ::std::mem::size_of::<_GApplicationCommandLine>(),
        32usize,
        concat!("Size of: ", stringify!(_GApplicationCommandLine))
    );
    assert_eq!(
        ::std::mem::align_of::<_GApplicationCommandLine>(),
        8usize,
        concat!("Alignment of ", stringify!(_GApplicationCommandLine))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GApplicationCommandLine>())).parent_instance as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GApplicationCommandLine),
            "::",
            stringify!(parent_instance)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GApplicationCommandLine>())).priv_ as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GApplicationCommandLine),
            "::",
            stringify!(priv_)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GApplicationCommandLineClass {
    pub parent_class: GObjectClass,
    pub print_literal: ::std::option::Option<
        unsafe extern "C" fn(cmdline: *mut GApplicationCommandLine, message: *const gchar),
    >,
    pub printerr_literal: ::std::option::Option<
        unsafe extern "C" fn(cmdline: *mut GApplicationCommandLine, message: *const gchar),
    >,
    pub get_stdin: ::std::option::Option<
        unsafe extern "C" fn(cmdline: *mut GApplicationCommandLine) -> *mut GInputStream,
    >,
    pub padding: [gpointer; 11usize],
}
#[test]
fn bindgen_test_layout__GApplicationCommandLineClass() {
    assert_eq!(
        ::std::mem::size_of::<_GApplicationCommandLineClass>(),
        248usize,
        concat!("Size of: ", stringify!(_GApplicationCommandLineClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_GApplicationCommandLineClass>(),
        8usize,
        concat!("Alignment of ", stringify!(_GApplicationCommandLineClass))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GApplicationCommandLineClass>())).parent_class as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GApplicationCommandLineClass),
            "::",
            stringify!(parent_class)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GApplicationCommandLineClass>())).print_literal as *const _
                as usize
        },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_GApplicationCommandLineClass),
            "::",
            stringify!(print_literal)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GApplicationCommandLineClass>())).printerr_literal as *const _
                as usize
        },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_GApplicationCommandLineClass),
            "::",
            stringify!(printerr_literal)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GApplicationCommandLineClass>())).get_stdin as *const _ as usize
        },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(_GApplicationCommandLineClass),
            "::",
            stringify!(get_stdin)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GApplicationCommandLineClass>())).padding as *const _ as usize
        },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_GApplicationCommandLineClass),
            "::",
            stringify!(padding)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_g_application_command_line_get_type"]
    pub fn g_application_command_line_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_application_command_line_get_arguments"]
    pub fn g_application_command_line_get_arguments(
        cmdline: *mut GApplicationCommandLine,
        argc: *mut ::std::os::raw::c_int,
    ) -> *mut *mut gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_application_command_line_get_options_dict"]
    pub fn g_application_command_line_get_options_dict(
        cmdline: *mut GApplicationCommandLine,
    ) -> *mut GVariantDict;
}
extern "C" {
    #[link_name = "\u{1}_g_application_command_line_get_stdin"]
    pub fn g_application_command_line_get_stdin(
        cmdline: *mut GApplicationCommandLine,
    ) -> *mut GInputStream;
}
extern "C" {
    #[link_name = "\u{1}_g_application_command_line_get_environ"]
    pub fn g_application_command_line_get_environ(
        cmdline: *mut GApplicationCommandLine,
    ) -> *const *const gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_application_command_line_getenv"]
    pub fn g_application_command_line_getenv(
        cmdline: *mut GApplicationCommandLine,
        name: *const gchar,
    ) -> *const gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_application_command_line_get_cwd"]
    pub fn g_application_command_line_get_cwd(
        cmdline: *mut GApplicationCommandLine,
    ) -> *const gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_application_command_line_get_is_remote"]
    pub fn g_application_command_line_get_is_remote(
        cmdline: *mut GApplicationCommandLine,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_application_command_line_print"]
    pub fn g_application_command_line_print(
        cmdline: *mut GApplicationCommandLine,
        format: *const gchar,
        ...
    );
}
extern "C" {
    #[link_name = "\u{1}_g_application_command_line_printerr"]
    pub fn g_application_command_line_printerr(
        cmdline: *mut GApplicationCommandLine,
        format: *const gchar,
        ...
    );
}
extern "C" {
    #[link_name = "\u{1}_g_application_command_line_get_exit_status"]
    pub fn g_application_command_line_get_exit_status(
        cmdline: *mut GApplicationCommandLine,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_g_application_command_line_set_exit_status"]
    pub fn g_application_command_line_set_exit_status(
        cmdline: *mut GApplicationCommandLine,
        exit_status: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_application_command_line_get_platform_data"]
    pub fn g_application_command_line_get_platform_data(
        cmdline: *mut GApplicationCommandLine,
    ) -> *mut GVariant;
}
extern "C" {
    #[link_name = "\u{1}_g_application_command_line_create_file_for_arg"]
    pub fn g_application_command_line_create_file_for_arg(
        cmdline: *mut GApplicationCommandLine,
        arg: *const gchar,
    ) -> *mut GFile;
}
/// GInitable:
///
/// Interface for initializable objects.
///
/// Since: 2.22
pub type GInitableIface = _GInitableIface;
/// GInitableIface:
/// @g_iface: The parent interface.
/// @init: Initializes the object.
///
/// Provides an interface for initializing object such that initialization
/// may fail.
///
/// Since: 2.22
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GInitableIface {
    pub g_iface: GTypeInterface,
    pub init: ::std::option::Option<
        unsafe extern "C" fn(
            initable: *mut GInitable,
            cancellable: *mut GCancellable,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
}
#[test]
fn bindgen_test_layout__GInitableIface() {
    assert_eq!(
        ::std::mem::size_of::<_GInitableIface>(),
        24usize,
        concat!("Size of: ", stringify!(_GInitableIface))
    );
    assert_eq!(
        ::std::mem::align_of::<_GInitableIface>(),
        8usize,
        concat!("Alignment of ", stringify!(_GInitableIface))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GInitableIface>())).g_iface as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GInitableIface),
            "::",
            stringify!(g_iface)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GInitableIface>())).init as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GInitableIface),
            "::",
            stringify!(init)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_g_initable_get_type"]
    pub fn g_initable_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_initable_init"]
    pub fn g_initable_init(
        initable: *mut GInitable,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_initable_new"]
    pub fn g_initable_new(
        object_type: GType,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
        first_property_name: *const gchar,
        ...
    ) -> gpointer;
}
extern "C" {
    #[link_name = "\u{1}_g_initable_newv"]
    pub fn g_initable_newv(
        object_type: GType,
        n_parameters: guint,
        parameters: *mut GParameter,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gpointer;
}
extern "C" {
    #[link_name = "\u{1}_g_initable_new_valist"]
    pub fn g_initable_new_valist(
        object_type: GType,
        first_property_name: *const gchar,
        var_args: *mut __va_list_tag,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> *mut GObject;
}
/// GAsyncInitable:
///
/// Interface for asynchronously initializable objects.
///
/// Since: 2.22
pub type GAsyncInitableIface = _GAsyncInitableIface;
/// GAsyncInitableIface:
/// @g_iface: The parent interface.
/// @init_async: Starts initialization of the object.
/// @init_finish: Finishes initialization of the object.
///
/// Provides an interface for asynchronous initializing object such that
/// initialization may fail.
///
/// Since: 2.22
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GAsyncInitableIface {
    pub g_iface: GTypeInterface,
    pub init_async: ::std::option::Option<
        unsafe extern "C" fn(
            initable: *mut GAsyncInitable,
            io_priority: ::std::os::raw::c_int,
            cancellable: *mut GCancellable,
            callback: GAsyncReadyCallback,
            user_data: gpointer,
        ),
    >,
    pub init_finish: ::std::option::Option<
        unsafe extern "C" fn(
            initable: *mut GAsyncInitable,
            res: *mut GAsyncResult,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
}
#[test]
fn bindgen_test_layout__GAsyncInitableIface() {
    assert_eq!(
        ::std::mem::size_of::<_GAsyncInitableIface>(),
        32usize,
        concat!("Size of: ", stringify!(_GAsyncInitableIface))
    );
    assert_eq!(
        ::std::mem::align_of::<_GAsyncInitableIface>(),
        8usize,
        concat!("Alignment of ", stringify!(_GAsyncInitableIface))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GAsyncInitableIface>())).g_iface as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GAsyncInitableIface),
            "::",
            stringify!(g_iface)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GAsyncInitableIface>())).init_async as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GAsyncInitableIface),
            "::",
            stringify!(init_async)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GAsyncInitableIface>())).init_finish as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GAsyncInitableIface),
            "::",
            stringify!(init_finish)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_g_async_initable_get_type"]
    pub fn g_async_initable_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_async_initable_init_async"]
    pub fn g_async_initable_init_async(
        initable: *mut GAsyncInitable,
        io_priority: ::std::os::raw::c_int,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_async_initable_init_finish"]
    pub fn g_async_initable_init_finish(
        initable: *mut GAsyncInitable,
        res: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_async_initable_new_async"]
    pub fn g_async_initable_new_async(
        object_type: GType,
        io_priority: ::std::os::raw::c_int,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
        first_property_name: *const gchar,
        ...
    );
}
extern "C" {
    #[link_name = "\u{1}_g_async_initable_newv_async"]
    pub fn g_async_initable_newv_async(
        object_type: GType,
        n_parameters: guint,
        parameters: *mut GParameter,
        io_priority: ::std::os::raw::c_int,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_async_initable_new_valist_async"]
    pub fn g_async_initable_new_valist_async(
        object_type: GType,
        first_property_name: *const gchar,
        var_args: *mut __va_list_tag,
        io_priority: ::std::os::raw::c_int,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_async_initable_new_finish"]
    pub fn g_async_initable_new_finish(
        initable: *mut GAsyncInitable,
        res: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> *mut GObject;
}
/// GAsyncResult:
///
/// Holds results information for an asynchronous operation,
/// usually passed directly to a asynchronous _finish() operation.
pub type GAsyncResultIface = _GAsyncResultIface;
/// GAsyncResultIface:
/// @g_iface: The parent interface.
/// @get_user_data: Gets the user data passed to the callback.
/// @get_source_object: Gets the source object that issued the asynchronous operation.
/// @is_tagged: Checks if a result is tagged with a particular source.
///
/// Interface definition for #GAsyncResult.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GAsyncResultIface {
    pub g_iface: GTypeInterface,
    pub get_user_data:
        ::std::option::Option<unsafe extern "C" fn(res: *mut GAsyncResult) -> gpointer>,
    pub get_source_object:
        ::std::option::Option<unsafe extern "C" fn(res: *mut GAsyncResult) -> *mut GObject>,
    pub is_tagged: ::std::option::Option<
        unsafe extern "C" fn(res: *mut GAsyncResult, source_tag: gpointer) -> gboolean,
    >,
}
#[test]
fn bindgen_test_layout__GAsyncResultIface() {
    assert_eq!(
        ::std::mem::size_of::<_GAsyncResultIface>(),
        40usize,
        concat!("Size of: ", stringify!(_GAsyncResultIface))
    );
    assert_eq!(
        ::std::mem::align_of::<_GAsyncResultIface>(),
        8usize,
        concat!("Alignment of ", stringify!(_GAsyncResultIface))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GAsyncResultIface>())).g_iface as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GAsyncResultIface),
            "::",
            stringify!(g_iface)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GAsyncResultIface>())).get_user_data as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GAsyncResultIface),
            "::",
            stringify!(get_user_data)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GAsyncResultIface>())).get_source_object as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GAsyncResultIface),
            "::",
            stringify!(get_source_object)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GAsyncResultIface>())).is_tagged as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_GAsyncResultIface),
            "::",
            stringify!(is_tagged)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_g_async_result_get_type"]
    pub fn g_async_result_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_async_result_get_user_data"]
    pub fn g_async_result_get_user_data(res: *mut GAsyncResult) -> gpointer;
}
extern "C" {
    #[link_name = "\u{1}_g_async_result_get_source_object"]
    pub fn g_async_result_get_source_object(res: *mut GAsyncResult) -> *mut GObject;
}
extern "C" {
    #[link_name = "\u{1}_g_async_result_legacy_propagate_error"]
    pub fn g_async_result_legacy_propagate_error(
        res: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_async_result_is_tagged"]
    pub fn g_async_result_is_tagged(res: *mut GAsyncResult, source_tag: gpointer) -> gboolean;
}
/// GInputStream:
///
/// Base class for streaming input operations.
pub type GInputStreamClass = _GInputStreamClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GInputStreamPrivate {
    _unused: [u8; 0],
}
pub type GInputStreamPrivate = _GInputStreamPrivate;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GInputStream {
    pub parent_instance: GObject,
    pub priv_: *mut GInputStreamPrivate,
}
#[test]
fn bindgen_test_layout__GInputStream() {
    assert_eq!(
        ::std::mem::size_of::<_GInputStream>(),
        32usize,
        concat!("Size of: ", stringify!(_GInputStream))
    );
    assert_eq!(
        ::std::mem::align_of::<_GInputStream>(),
        8usize,
        concat!("Alignment of ", stringify!(_GInputStream))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GInputStream>())).parent_instance as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GInputStream),
            "::",
            stringify!(parent_instance)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GInputStream>())).priv_ as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GInputStream),
            "::",
            stringify!(priv_)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GInputStreamClass {
    pub parent_class: GObjectClass,
    pub read_fn: ::std::option::Option<
        unsafe extern "C" fn(
            stream: *mut GInputStream,
            buffer: *mut ::std::os::raw::c_void,
            count: gsize,
            cancellable: *mut GCancellable,
            error: *mut *mut GError,
        ) -> gssize,
    >,
    pub skip: ::std::option::Option<
        unsafe extern "C" fn(
            stream: *mut GInputStream,
            count: gsize,
            cancellable: *mut GCancellable,
            error: *mut *mut GError,
        ) -> gssize,
    >,
    pub close_fn: ::std::option::Option<
        unsafe extern "C" fn(
            stream: *mut GInputStream,
            cancellable: *mut GCancellable,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
    pub read_async: ::std::option::Option<
        unsafe extern "C" fn(
            stream: *mut GInputStream,
            buffer: *mut ::std::os::raw::c_void,
            count: gsize,
            io_priority: ::std::os::raw::c_int,
            cancellable: *mut GCancellable,
            callback: GAsyncReadyCallback,
            user_data: gpointer,
        ),
    >,
    pub read_finish: ::std::option::Option<
        unsafe extern "C" fn(
            stream: *mut GInputStream,
            result: *mut GAsyncResult,
            error: *mut *mut GError,
        ) -> gssize,
    >,
    pub skip_async: ::std::option::Option<
        unsafe extern "C" fn(
            stream: *mut GInputStream,
            count: gsize,
            io_priority: ::std::os::raw::c_int,
            cancellable: *mut GCancellable,
            callback: GAsyncReadyCallback,
            user_data: gpointer,
        ),
    >,
    pub skip_finish: ::std::option::Option<
        unsafe extern "C" fn(
            stream: *mut GInputStream,
            result: *mut GAsyncResult,
            error: *mut *mut GError,
        ) -> gssize,
    >,
    pub close_async: ::std::option::Option<
        unsafe extern "C" fn(
            stream: *mut GInputStream,
            io_priority: ::std::os::raw::c_int,
            cancellable: *mut GCancellable,
            callback: GAsyncReadyCallback,
            user_data: gpointer,
        ),
    >,
    pub close_finish: ::std::option::Option<
        unsafe extern "C" fn(
            stream: *mut GInputStream,
            result: *mut GAsyncResult,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
    pub _g_reserved1: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved2: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved3: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved4: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved5: ::std::option::Option<unsafe extern "C" fn()>,
}
#[test]
fn bindgen_test_layout__GInputStreamClass() {
    assert_eq!(
        ::std::mem::size_of::<_GInputStreamClass>(),
        248usize,
        concat!("Size of: ", stringify!(_GInputStreamClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_GInputStreamClass>(),
        8usize,
        concat!("Alignment of ", stringify!(_GInputStreamClass))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GInputStreamClass>())).parent_class as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GInputStreamClass),
            "::",
            stringify!(parent_class)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GInputStreamClass>())).read_fn as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_GInputStreamClass),
            "::",
            stringify!(read_fn)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GInputStreamClass>())).skip as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_GInputStreamClass),
            "::",
            stringify!(skip)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GInputStreamClass>())).close_fn as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(_GInputStreamClass),
            "::",
            stringify!(close_fn)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GInputStreamClass>())).read_async as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_GInputStreamClass),
            "::",
            stringify!(read_async)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GInputStreamClass>())).read_finish as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(_GInputStreamClass),
            "::",
            stringify!(read_finish)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GInputStreamClass>())).skip_async as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(_GInputStreamClass),
            "::",
            stringify!(skip_async)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GInputStreamClass>())).skip_finish as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(_GInputStreamClass),
            "::",
            stringify!(skip_finish)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GInputStreamClass>())).close_async as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(_GInputStreamClass),
            "::",
            stringify!(close_async)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GInputStreamClass>())).close_finish as *const _ as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(_GInputStreamClass),
            "::",
            stringify!(close_finish)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GInputStreamClass>()))._g_reserved1 as *const _ as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(_GInputStreamClass),
            "::",
            stringify!(_g_reserved1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GInputStreamClass>()))._g_reserved2 as *const _ as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(_GInputStreamClass),
            "::",
            stringify!(_g_reserved2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GInputStreamClass>()))._g_reserved3 as *const _ as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(_GInputStreamClass),
            "::",
            stringify!(_g_reserved3)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GInputStreamClass>()))._g_reserved4 as *const _ as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(_GInputStreamClass),
            "::",
            stringify!(_g_reserved4)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GInputStreamClass>()))._g_reserved5 as *const _ as usize },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(_GInputStreamClass),
            "::",
            stringify!(_g_reserved5)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_g_input_stream_get_type"]
    pub fn g_input_stream_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_input_stream_read"]
    pub fn g_input_stream_read(
        stream: *mut GInputStream,
        buffer: *mut ::std::os::raw::c_void,
        count: gsize,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gssize;
}
extern "C" {
    #[link_name = "\u{1}_g_input_stream_read_all"]
    pub fn g_input_stream_read_all(
        stream: *mut GInputStream,
        buffer: *mut ::std::os::raw::c_void,
        count: gsize,
        bytes_read: *mut gsize,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_input_stream_read_bytes"]
    pub fn g_input_stream_read_bytes(
        stream: *mut GInputStream,
        count: gsize,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> *mut GBytes;
}
extern "C" {
    #[link_name = "\u{1}_g_input_stream_skip"]
    pub fn g_input_stream_skip(
        stream: *mut GInputStream,
        count: gsize,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gssize;
}
extern "C" {
    #[link_name = "\u{1}_g_input_stream_close"]
    pub fn g_input_stream_close(
        stream: *mut GInputStream,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_input_stream_read_async"]
    pub fn g_input_stream_read_async(
        stream: *mut GInputStream,
        buffer: *mut ::std::os::raw::c_void,
        count: gsize,
        io_priority: ::std::os::raw::c_int,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_input_stream_read_finish"]
    pub fn g_input_stream_read_finish(
        stream: *mut GInputStream,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> gssize;
}
extern "C" {
    #[link_name = "\u{1}_g_input_stream_read_all_async"]
    pub fn g_input_stream_read_all_async(
        stream: *mut GInputStream,
        buffer: *mut ::std::os::raw::c_void,
        count: gsize,
        io_priority: ::std::os::raw::c_int,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_input_stream_read_all_finish"]
    pub fn g_input_stream_read_all_finish(
        stream: *mut GInputStream,
        result: *mut GAsyncResult,
        bytes_read: *mut gsize,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_input_stream_read_bytes_async"]
    pub fn g_input_stream_read_bytes_async(
        stream: *mut GInputStream,
        count: gsize,
        io_priority: ::std::os::raw::c_int,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_input_stream_read_bytes_finish"]
    pub fn g_input_stream_read_bytes_finish(
        stream: *mut GInputStream,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> *mut GBytes;
}
extern "C" {
    #[link_name = "\u{1}_g_input_stream_skip_async"]
    pub fn g_input_stream_skip_async(
        stream: *mut GInputStream,
        count: gsize,
        io_priority: ::std::os::raw::c_int,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_input_stream_skip_finish"]
    pub fn g_input_stream_skip_finish(
        stream: *mut GInputStream,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> gssize;
}
extern "C" {
    #[link_name = "\u{1}_g_input_stream_close_async"]
    pub fn g_input_stream_close_async(
        stream: *mut GInputStream,
        io_priority: ::std::os::raw::c_int,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_input_stream_close_finish"]
    pub fn g_input_stream_close_finish(
        stream: *mut GInputStream,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_input_stream_is_closed"]
    pub fn g_input_stream_is_closed(stream: *mut GInputStream) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_input_stream_has_pending"]
    pub fn g_input_stream_has_pending(stream: *mut GInputStream) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_input_stream_set_pending"]
    pub fn g_input_stream_set_pending(
        stream: *mut GInputStream,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_input_stream_clear_pending"]
    pub fn g_input_stream_clear_pending(stream: *mut GInputStream);
}
/// GFilterInputStream:
///
/// A base class for all input streams that work on an underlying stream.
pub type GFilterInputStreamClass = _GFilterInputStreamClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GFilterInputStream {
    pub parent_instance: GInputStream,
    pub base_stream: *mut GInputStream,
}
#[test]
fn bindgen_test_layout__GFilterInputStream() {
    assert_eq!(
        ::std::mem::size_of::<_GFilterInputStream>(),
        40usize,
        concat!("Size of: ", stringify!(_GFilterInputStream))
    );
    assert_eq!(
        ::std::mem::align_of::<_GFilterInputStream>(),
        8usize,
        concat!("Alignment of ", stringify!(_GFilterInputStream))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GFilterInputStream>())).parent_instance as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFilterInputStream),
            "::",
            stringify!(parent_instance)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GFilterInputStream>())).base_stream as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFilterInputStream),
            "::",
            stringify!(base_stream)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GFilterInputStreamClass {
    pub parent_class: GInputStreamClass,
    pub _g_reserved1: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved2: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved3: ::std::option::Option<unsafe extern "C" fn()>,
}
#[test]
fn bindgen_test_layout__GFilterInputStreamClass() {
    assert_eq!(
        ::std::mem::size_of::<_GFilterInputStreamClass>(),
        272usize,
        concat!("Size of: ", stringify!(_GFilterInputStreamClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_GFilterInputStreamClass>(),
        8usize,
        concat!("Alignment of ", stringify!(_GFilterInputStreamClass))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GFilterInputStreamClass>())).parent_class as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFilterInputStreamClass),
            "::",
            stringify!(parent_class)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GFilterInputStreamClass>()))._g_reserved1 as *const _ as usize
        },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFilterInputStreamClass),
            "::",
            stringify!(_g_reserved1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GFilterInputStreamClass>()))._g_reserved2 as *const _ as usize
        },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFilterInputStreamClass),
            "::",
            stringify!(_g_reserved2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GFilterInputStreamClass>()))._g_reserved3 as *const _ as usize
        },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFilterInputStreamClass),
            "::",
            stringify!(_g_reserved3)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_g_filter_input_stream_get_type"]
    pub fn g_filter_input_stream_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_filter_input_stream_get_base_stream"]
    pub fn g_filter_input_stream_get_base_stream(
        stream: *mut GFilterInputStream,
    ) -> *mut GInputStream;
}
extern "C" {
    #[link_name = "\u{1}_g_filter_input_stream_get_close_base_stream"]
    pub fn g_filter_input_stream_get_close_base_stream(stream: *mut GFilterInputStream)
        -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_filter_input_stream_set_close_base_stream"]
    pub fn g_filter_input_stream_set_close_base_stream(
        stream: *mut GFilterInputStream,
        close_base: gboolean,
    );
}
/// GBufferedInputStream:
///
/// Implements #GFilterInputStream with a sized input buffer.
pub type GBufferedInputStreamClass = _GBufferedInputStreamClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GBufferedInputStreamPrivate {
    _unused: [u8; 0],
}
pub type GBufferedInputStreamPrivate = _GBufferedInputStreamPrivate;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GBufferedInputStream {
    pub parent_instance: GFilterInputStream,
    pub priv_: *mut GBufferedInputStreamPrivate,
}
#[test]
fn bindgen_test_layout__GBufferedInputStream() {
    assert_eq!(
        ::std::mem::size_of::<_GBufferedInputStream>(),
        48usize,
        concat!("Size of: ", stringify!(_GBufferedInputStream))
    );
    assert_eq!(
        ::std::mem::align_of::<_GBufferedInputStream>(),
        8usize,
        concat!("Alignment of ", stringify!(_GBufferedInputStream))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GBufferedInputStream>())).parent_instance as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GBufferedInputStream),
            "::",
            stringify!(parent_instance)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GBufferedInputStream>())).priv_ as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_GBufferedInputStream),
            "::",
            stringify!(priv_)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GBufferedInputStreamClass {
    pub parent_class: GFilterInputStreamClass,
    pub fill: ::std::option::Option<
        unsafe extern "C" fn(
            stream: *mut GBufferedInputStream,
            count: gssize,
            cancellable: *mut GCancellable,
            error: *mut *mut GError,
        ) -> gssize,
    >,
    pub fill_async: ::std::option::Option<
        unsafe extern "C" fn(
            stream: *mut GBufferedInputStream,
            count: gssize,
            io_priority: ::std::os::raw::c_int,
            cancellable: *mut GCancellable,
            callback: GAsyncReadyCallback,
            user_data: gpointer,
        ),
    >,
    pub fill_finish: ::std::option::Option<
        unsafe extern "C" fn(
            stream: *mut GBufferedInputStream,
            result: *mut GAsyncResult,
            error: *mut *mut GError,
        ) -> gssize,
    >,
    pub _g_reserved1: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved2: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved3: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved4: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved5: ::std::option::Option<unsafe extern "C" fn()>,
}
#[test]
fn bindgen_test_layout__GBufferedInputStreamClass() {
    assert_eq!(
        ::std::mem::size_of::<_GBufferedInputStreamClass>(),
        336usize,
        concat!("Size of: ", stringify!(_GBufferedInputStreamClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_GBufferedInputStreamClass>(),
        8usize,
        concat!("Alignment of ", stringify!(_GBufferedInputStreamClass))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GBufferedInputStreamClass>())).parent_class as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GBufferedInputStreamClass),
            "::",
            stringify!(parent_class)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GBufferedInputStreamClass>())).fill as *const _ as usize },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(_GBufferedInputStreamClass),
            "::",
            stringify!(fill)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GBufferedInputStreamClass>())).fill_async as *const _ as usize
        },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(_GBufferedInputStreamClass),
            "::",
            stringify!(fill_async)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GBufferedInputStreamClass>())).fill_finish as *const _ as usize
        },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(_GBufferedInputStreamClass),
            "::",
            stringify!(fill_finish)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GBufferedInputStreamClass>()))._g_reserved1 as *const _ as usize
        },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(_GBufferedInputStreamClass),
            "::",
            stringify!(_g_reserved1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GBufferedInputStreamClass>()))._g_reserved2 as *const _ as usize
        },
        304usize,
        concat!(
            "Offset of field: ",
            stringify!(_GBufferedInputStreamClass),
            "::",
            stringify!(_g_reserved2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GBufferedInputStreamClass>()))._g_reserved3 as *const _ as usize
        },
        312usize,
        concat!(
            "Offset of field: ",
            stringify!(_GBufferedInputStreamClass),
            "::",
            stringify!(_g_reserved3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GBufferedInputStreamClass>()))._g_reserved4 as *const _ as usize
        },
        320usize,
        concat!(
            "Offset of field: ",
            stringify!(_GBufferedInputStreamClass),
            "::",
            stringify!(_g_reserved4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GBufferedInputStreamClass>()))._g_reserved5 as *const _ as usize
        },
        328usize,
        concat!(
            "Offset of field: ",
            stringify!(_GBufferedInputStreamClass),
            "::",
            stringify!(_g_reserved5)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_g_buffered_input_stream_get_type"]
    pub fn g_buffered_input_stream_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_buffered_input_stream_new"]
    pub fn g_buffered_input_stream_new(base_stream: *mut GInputStream) -> *mut GInputStream;
}
extern "C" {
    #[link_name = "\u{1}_g_buffered_input_stream_new_sized"]
    pub fn g_buffered_input_stream_new_sized(
        base_stream: *mut GInputStream,
        size: gsize,
    ) -> *mut GInputStream;
}
extern "C" {
    #[link_name = "\u{1}_g_buffered_input_stream_get_buffer_size"]
    pub fn g_buffered_input_stream_get_buffer_size(stream: *mut GBufferedInputStream) -> gsize;
}
extern "C" {
    #[link_name = "\u{1}_g_buffered_input_stream_set_buffer_size"]
    pub fn g_buffered_input_stream_set_buffer_size(stream: *mut GBufferedInputStream, size: gsize);
}
extern "C" {
    #[link_name = "\u{1}_g_buffered_input_stream_get_available"]
    pub fn g_buffered_input_stream_get_available(stream: *mut GBufferedInputStream) -> gsize;
}
extern "C" {
    #[link_name = "\u{1}_g_buffered_input_stream_peek"]
    pub fn g_buffered_input_stream_peek(
        stream: *mut GBufferedInputStream,
        buffer: *mut ::std::os::raw::c_void,
        offset: gsize,
        count: gsize,
    ) -> gsize;
}
extern "C" {
    #[link_name = "\u{1}_g_buffered_input_stream_peek_buffer"]
    pub fn g_buffered_input_stream_peek_buffer(
        stream: *mut GBufferedInputStream,
        count: *mut gsize,
    ) -> *const ::std::os::raw::c_void;
}
extern "C" {
    #[link_name = "\u{1}_g_buffered_input_stream_fill"]
    pub fn g_buffered_input_stream_fill(
        stream: *mut GBufferedInputStream,
        count: gssize,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gssize;
}
extern "C" {
    #[link_name = "\u{1}_g_buffered_input_stream_fill_async"]
    pub fn g_buffered_input_stream_fill_async(
        stream: *mut GBufferedInputStream,
        count: gssize,
        io_priority: ::std::os::raw::c_int,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_buffered_input_stream_fill_finish"]
    pub fn g_buffered_input_stream_fill_finish(
        stream: *mut GBufferedInputStream,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> gssize;
}
extern "C" {
    #[link_name = "\u{1}_g_buffered_input_stream_read_byte"]
    pub fn g_buffered_input_stream_read_byte(
        stream: *mut GBufferedInputStream,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> ::std::os::raw::c_int;
}
/// GOutputStream:
///
/// Base class for writing output.
///
/// All classes derived from GOutputStream should implement synchronous
/// writing, splicing, flushing and closing streams, but may implement
/// asynchronous versions.
pub type GOutputStreamClass = _GOutputStreamClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GOutputStreamPrivate {
    _unused: [u8; 0],
}
pub type GOutputStreamPrivate = _GOutputStreamPrivate;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GOutputStream {
    pub parent_instance: GObject,
    pub priv_: *mut GOutputStreamPrivate,
}
#[test]
fn bindgen_test_layout__GOutputStream() {
    assert_eq!(
        ::std::mem::size_of::<_GOutputStream>(),
        32usize,
        concat!("Size of: ", stringify!(_GOutputStream))
    );
    assert_eq!(
        ::std::mem::align_of::<_GOutputStream>(),
        8usize,
        concat!("Alignment of ", stringify!(_GOutputStream))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GOutputStream>())).parent_instance as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GOutputStream),
            "::",
            stringify!(parent_instance)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GOutputStream>())).priv_ as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GOutputStream),
            "::",
            stringify!(priv_)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GOutputStreamClass {
    pub parent_class: GObjectClass,
    pub write_fn: ::std::option::Option<
        unsafe extern "C" fn(
            stream: *mut GOutputStream,
            buffer: *const ::std::os::raw::c_void,
            count: gsize,
            cancellable: *mut GCancellable,
            error: *mut *mut GError,
        ) -> gssize,
    >,
    pub splice: ::std::option::Option<
        unsafe extern "C" fn(
            stream: *mut GOutputStream,
            source: *mut GInputStream,
            flags: GOutputStreamSpliceFlags,
            cancellable: *mut GCancellable,
            error: *mut *mut GError,
        ) -> gssize,
    >,
    pub flush: ::std::option::Option<
        unsafe extern "C" fn(
            stream: *mut GOutputStream,
            cancellable: *mut GCancellable,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
    pub close_fn: ::std::option::Option<
        unsafe extern "C" fn(
            stream: *mut GOutputStream,
            cancellable: *mut GCancellable,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
    pub write_async: ::std::option::Option<
        unsafe extern "C" fn(
            stream: *mut GOutputStream,
            buffer: *const ::std::os::raw::c_void,
            count: gsize,
            io_priority: ::std::os::raw::c_int,
            cancellable: *mut GCancellable,
            callback: GAsyncReadyCallback,
            user_data: gpointer,
        ),
    >,
    pub write_finish: ::std::option::Option<
        unsafe extern "C" fn(
            stream: *mut GOutputStream,
            result: *mut GAsyncResult,
            error: *mut *mut GError,
        ) -> gssize,
    >,
    pub splice_async: ::std::option::Option<
        unsafe extern "C" fn(
            stream: *mut GOutputStream,
            source: *mut GInputStream,
            flags: GOutputStreamSpliceFlags,
            io_priority: ::std::os::raw::c_int,
            cancellable: *mut GCancellable,
            callback: GAsyncReadyCallback,
            user_data: gpointer,
        ),
    >,
    pub splice_finish: ::std::option::Option<
        unsafe extern "C" fn(
            stream: *mut GOutputStream,
            result: *mut GAsyncResult,
            error: *mut *mut GError,
        ) -> gssize,
    >,
    pub flush_async: ::std::option::Option<
        unsafe extern "C" fn(
            stream: *mut GOutputStream,
            io_priority: ::std::os::raw::c_int,
            cancellable: *mut GCancellable,
            callback: GAsyncReadyCallback,
            user_data: gpointer,
        ),
    >,
    pub flush_finish: ::std::option::Option<
        unsafe extern "C" fn(
            stream: *mut GOutputStream,
            result: *mut GAsyncResult,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
    pub close_async: ::std::option::Option<
        unsafe extern "C" fn(
            stream: *mut GOutputStream,
            io_priority: ::std::os::raw::c_int,
            cancellable: *mut GCancellable,
            callback: GAsyncReadyCallback,
            user_data: gpointer,
        ),
    >,
    pub close_finish: ::std::option::Option<
        unsafe extern "C" fn(
            stream: *mut GOutputStream,
            result: *mut GAsyncResult,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
    pub _g_reserved1: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved2: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved3: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved4: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved5: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved6: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved7: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved8: ::std::option::Option<unsafe extern "C" fn()>,
}
#[test]
fn bindgen_test_layout__GOutputStreamClass() {
    assert_eq!(
        ::std::mem::size_of::<_GOutputStreamClass>(),
        296usize,
        concat!("Size of: ", stringify!(_GOutputStreamClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_GOutputStreamClass>(),
        8usize,
        concat!("Alignment of ", stringify!(_GOutputStreamClass))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GOutputStreamClass>())).parent_class as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GOutputStreamClass),
            "::",
            stringify!(parent_class)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GOutputStreamClass>())).write_fn as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_GOutputStreamClass),
            "::",
            stringify!(write_fn)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GOutputStreamClass>())).splice as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_GOutputStreamClass),
            "::",
            stringify!(splice)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GOutputStreamClass>())).flush as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(_GOutputStreamClass),
            "::",
            stringify!(flush)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GOutputStreamClass>())).close_fn as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_GOutputStreamClass),
            "::",
            stringify!(close_fn)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GOutputStreamClass>())).write_async as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(_GOutputStreamClass),
            "::",
            stringify!(write_async)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GOutputStreamClass>())).write_finish as *const _ as usize
        },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(_GOutputStreamClass),
            "::",
            stringify!(write_finish)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GOutputStreamClass>())).splice_async as *const _ as usize
        },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(_GOutputStreamClass),
            "::",
            stringify!(splice_async)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GOutputStreamClass>())).splice_finish as *const _ as usize
        },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(_GOutputStreamClass),
            "::",
            stringify!(splice_finish)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GOutputStreamClass>())).flush_async as *const _ as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(_GOutputStreamClass),
            "::",
            stringify!(flush_async)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GOutputStreamClass>())).flush_finish as *const _ as usize
        },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(_GOutputStreamClass),
            "::",
            stringify!(flush_finish)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GOutputStreamClass>())).close_async as *const _ as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(_GOutputStreamClass),
            "::",
            stringify!(close_async)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GOutputStreamClass>())).close_finish as *const _ as usize
        },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(_GOutputStreamClass),
            "::",
            stringify!(close_finish)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GOutputStreamClass>()))._g_reserved1 as *const _ as usize
        },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(_GOutputStreamClass),
            "::",
            stringify!(_g_reserved1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GOutputStreamClass>()))._g_reserved2 as *const _ as usize
        },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(_GOutputStreamClass),
            "::",
            stringify!(_g_reserved2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GOutputStreamClass>()))._g_reserved3 as *const _ as usize
        },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(_GOutputStreamClass),
            "::",
            stringify!(_g_reserved3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GOutputStreamClass>()))._g_reserved4 as *const _ as usize
        },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(_GOutputStreamClass),
            "::",
            stringify!(_g_reserved4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GOutputStreamClass>()))._g_reserved5 as *const _ as usize
        },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(_GOutputStreamClass),
            "::",
            stringify!(_g_reserved5)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GOutputStreamClass>()))._g_reserved6 as *const _ as usize
        },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(_GOutputStreamClass),
            "::",
            stringify!(_g_reserved6)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GOutputStreamClass>()))._g_reserved7 as *const _ as usize
        },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(_GOutputStreamClass),
            "::",
            stringify!(_g_reserved7)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GOutputStreamClass>()))._g_reserved8 as *const _ as usize
        },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(_GOutputStreamClass),
            "::",
            stringify!(_g_reserved8)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_g_output_stream_get_type"]
    pub fn g_output_stream_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_output_stream_write"]
    pub fn g_output_stream_write(
        stream: *mut GOutputStream,
        buffer: *const ::std::os::raw::c_void,
        count: gsize,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gssize;
}
extern "C" {
    #[link_name = "\u{1}_g_output_stream_write_all"]
    pub fn g_output_stream_write_all(
        stream: *mut GOutputStream,
        buffer: *const ::std::os::raw::c_void,
        count: gsize,
        bytes_written: *mut gsize,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_output_stream_printf"]
    pub fn g_output_stream_printf(
        stream: *mut GOutputStream,
        bytes_written: *mut gsize,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
        format: *const gchar,
        ...
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_output_stream_vprintf"]
    pub fn g_output_stream_vprintf(
        stream: *mut GOutputStream,
        bytes_written: *mut gsize,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
        format: *const gchar,
        args: *mut __va_list_tag,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_output_stream_write_bytes"]
    pub fn g_output_stream_write_bytes(
        stream: *mut GOutputStream,
        bytes: *mut GBytes,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gssize;
}
extern "C" {
    #[link_name = "\u{1}_g_output_stream_splice"]
    pub fn g_output_stream_splice(
        stream: *mut GOutputStream,
        source: *mut GInputStream,
        flags: GOutputStreamSpliceFlags,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gssize;
}
extern "C" {
    #[link_name = "\u{1}_g_output_stream_flush"]
    pub fn g_output_stream_flush(
        stream: *mut GOutputStream,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_output_stream_close"]
    pub fn g_output_stream_close(
        stream: *mut GOutputStream,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_output_stream_write_async"]
    pub fn g_output_stream_write_async(
        stream: *mut GOutputStream,
        buffer: *const ::std::os::raw::c_void,
        count: gsize,
        io_priority: ::std::os::raw::c_int,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_output_stream_write_finish"]
    pub fn g_output_stream_write_finish(
        stream: *mut GOutputStream,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> gssize;
}
extern "C" {
    #[link_name = "\u{1}_g_output_stream_write_all_async"]
    pub fn g_output_stream_write_all_async(
        stream: *mut GOutputStream,
        buffer: *const ::std::os::raw::c_void,
        count: gsize,
        io_priority: ::std::os::raw::c_int,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_output_stream_write_all_finish"]
    pub fn g_output_stream_write_all_finish(
        stream: *mut GOutputStream,
        result: *mut GAsyncResult,
        bytes_written: *mut gsize,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_output_stream_write_bytes_async"]
    pub fn g_output_stream_write_bytes_async(
        stream: *mut GOutputStream,
        bytes: *mut GBytes,
        io_priority: ::std::os::raw::c_int,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_output_stream_write_bytes_finish"]
    pub fn g_output_stream_write_bytes_finish(
        stream: *mut GOutputStream,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> gssize;
}
extern "C" {
    #[link_name = "\u{1}_g_output_stream_splice_async"]
    pub fn g_output_stream_splice_async(
        stream: *mut GOutputStream,
        source: *mut GInputStream,
        flags: GOutputStreamSpliceFlags,
        io_priority: ::std::os::raw::c_int,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_output_stream_splice_finish"]
    pub fn g_output_stream_splice_finish(
        stream: *mut GOutputStream,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> gssize;
}
extern "C" {
    #[link_name = "\u{1}_g_output_stream_flush_async"]
    pub fn g_output_stream_flush_async(
        stream: *mut GOutputStream,
        io_priority: ::std::os::raw::c_int,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_output_stream_flush_finish"]
    pub fn g_output_stream_flush_finish(
        stream: *mut GOutputStream,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_output_stream_close_async"]
    pub fn g_output_stream_close_async(
        stream: *mut GOutputStream,
        io_priority: ::std::os::raw::c_int,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_output_stream_close_finish"]
    pub fn g_output_stream_close_finish(
        stream: *mut GOutputStream,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_output_stream_is_closed"]
    pub fn g_output_stream_is_closed(stream: *mut GOutputStream) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_output_stream_is_closing"]
    pub fn g_output_stream_is_closing(stream: *mut GOutputStream) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_output_stream_has_pending"]
    pub fn g_output_stream_has_pending(stream: *mut GOutputStream) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_output_stream_set_pending"]
    pub fn g_output_stream_set_pending(
        stream: *mut GOutputStream,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_output_stream_clear_pending"]
    pub fn g_output_stream_clear_pending(stream: *mut GOutputStream);
}
/// GFilterOutputStream:
///
/// A base class for all output streams that work on an underlying stream.
pub type GFilterOutputStreamClass = _GFilterOutputStreamClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GFilterOutputStream {
    pub parent_instance: GOutputStream,
    pub base_stream: *mut GOutputStream,
}
#[test]
fn bindgen_test_layout__GFilterOutputStream() {
    assert_eq!(
        ::std::mem::size_of::<_GFilterOutputStream>(),
        40usize,
        concat!("Size of: ", stringify!(_GFilterOutputStream))
    );
    assert_eq!(
        ::std::mem::align_of::<_GFilterOutputStream>(),
        8usize,
        concat!("Alignment of ", stringify!(_GFilterOutputStream))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GFilterOutputStream>())).parent_instance as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFilterOutputStream),
            "::",
            stringify!(parent_instance)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GFilterOutputStream>())).base_stream as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFilterOutputStream),
            "::",
            stringify!(base_stream)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GFilterOutputStreamClass {
    pub parent_class: GOutputStreamClass,
    pub _g_reserved1: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved2: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved3: ::std::option::Option<unsafe extern "C" fn()>,
}
#[test]
fn bindgen_test_layout__GFilterOutputStreamClass() {
    assert_eq!(
        ::std::mem::size_of::<_GFilterOutputStreamClass>(),
        320usize,
        concat!("Size of: ", stringify!(_GFilterOutputStreamClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_GFilterOutputStreamClass>(),
        8usize,
        concat!("Alignment of ", stringify!(_GFilterOutputStreamClass))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GFilterOutputStreamClass>())).parent_class as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFilterOutputStreamClass),
            "::",
            stringify!(parent_class)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GFilterOutputStreamClass>()))._g_reserved1 as *const _ as usize
        },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFilterOutputStreamClass),
            "::",
            stringify!(_g_reserved1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GFilterOutputStreamClass>()))._g_reserved2 as *const _ as usize
        },
        304usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFilterOutputStreamClass),
            "::",
            stringify!(_g_reserved2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GFilterOutputStreamClass>()))._g_reserved3 as *const _ as usize
        },
        312usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFilterOutputStreamClass),
            "::",
            stringify!(_g_reserved3)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_g_filter_output_stream_get_type"]
    pub fn g_filter_output_stream_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_filter_output_stream_get_base_stream"]
    pub fn g_filter_output_stream_get_base_stream(
        stream: *mut GFilterOutputStream,
    ) -> *mut GOutputStream;
}
extern "C" {
    #[link_name = "\u{1}_g_filter_output_stream_get_close_base_stream"]
    pub fn g_filter_output_stream_get_close_base_stream(
        stream: *mut GFilterOutputStream,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_filter_output_stream_set_close_base_stream"]
    pub fn g_filter_output_stream_set_close_base_stream(
        stream: *mut GFilterOutputStream,
        close_base: gboolean,
    );
}
/// GBufferedOutputStream:
///
/// An implementation of #GFilterOutputStream with a sized buffer.
pub type GBufferedOutputStreamClass = _GBufferedOutputStreamClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GBufferedOutputStreamPrivate {
    _unused: [u8; 0],
}
pub type GBufferedOutputStreamPrivate = _GBufferedOutputStreamPrivate;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GBufferedOutputStream {
    pub parent_instance: GFilterOutputStream,
    pub priv_: *mut GBufferedOutputStreamPrivate,
}
#[test]
fn bindgen_test_layout__GBufferedOutputStream() {
    assert_eq!(
        ::std::mem::size_of::<_GBufferedOutputStream>(),
        48usize,
        concat!("Size of: ", stringify!(_GBufferedOutputStream))
    );
    assert_eq!(
        ::std::mem::align_of::<_GBufferedOutputStream>(),
        8usize,
        concat!("Alignment of ", stringify!(_GBufferedOutputStream))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GBufferedOutputStream>())).parent_instance as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GBufferedOutputStream),
            "::",
            stringify!(parent_instance)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GBufferedOutputStream>())).priv_ as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_GBufferedOutputStream),
            "::",
            stringify!(priv_)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GBufferedOutputStreamClass {
    pub parent_class: GFilterOutputStreamClass,
    pub _g_reserved1: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved2: ::std::option::Option<unsafe extern "C" fn()>,
}
#[test]
fn bindgen_test_layout__GBufferedOutputStreamClass() {
    assert_eq!(
        ::std::mem::size_of::<_GBufferedOutputStreamClass>(),
        336usize,
        concat!("Size of: ", stringify!(_GBufferedOutputStreamClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_GBufferedOutputStreamClass>(),
        8usize,
        concat!("Alignment of ", stringify!(_GBufferedOutputStreamClass))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GBufferedOutputStreamClass>())).parent_class as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GBufferedOutputStreamClass),
            "::",
            stringify!(parent_class)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GBufferedOutputStreamClass>()))._g_reserved1 as *const _
                as usize
        },
        320usize,
        concat!(
            "Offset of field: ",
            stringify!(_GBufferedOutputStreamClass),
            "::",
            stringify!(_g_reserved1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GBufferedOutputStreamClass>()))._g_reserved2 as *const _
                as usize
        },
        328usize,
        concat!(
            "Offset of field: ",
            stringify!(_GBufferedOutputStreamClass),
            "::",
            stringify!(_g_reserved2)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_g_buffered_output_stream_get_type"]
    pub fn g_buffered_output_stream_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_buffered_output_stream_new"]
    pub fn g_buffered_output_stream_new(base_stream: *mut GOutputStream) -> *mut GOutputStream;
}
extern "C" {
    #[link_name = "\u{1}_g_buffered_output_stream_new_sized"]
    pub fn g_buffered_output_stream_new_sized(
        base_stream: *mut GOutputStream,
        size: gsize,
    ) -> *mut GOutputStream;
}
extern "C" {
    #[link_name = "\u{1}_g_buffered_output_stream_get_buffer_size"]
    pub fn g_buffered_output_stream_get_buffer_size(stream: *mut GBufferedOutputStream) -> gsize;
}
extern "C" {
    #[link_name = "\u{1}_g_buffered_output_stream_set_buffer_size"]
    pub fn g_buffered_output_stream_set_buffer_size(
        stream: *mut GBufferedOutputStream,
        size: gsize,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_buffered_output_stream_get_auto_grow"]
    pub fn g_buffered_output_stream_get_auto_grow(stream: *mut GBufferedOutputStream) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_buffered_output_stream_set_auto_grow"]
    pub fn g_buffered_output_stream_set_auto_grow(
        stream: *mut GBufferedOutputStream,
        auto_grow: gboolean,
    );
}
extern "C" {
    /// GBytesIcon:
    ///
    /// Gets an icon for a #GBytes. Implements #GLoadableIcon.
    #[link_name = "\u{1}_g_bytes_icon_get_type"]
    pub fn g_bytes_icon_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_bytes_icon_new"]
    pub fn g_bytes_icon_new(bytes: *mut GBytes) -> *mut GIcon;
}
extern "C" {
    #[link_name = "\u{1}_g_bytes_icon_get_bytes"]
    pub fn g_bytes_icon_get_bytes(icon: *mut GBytesIcon) -> *mut GBytes;
}
/// GCancellable:
///
/// Allows actions to be cancelled.
pub type GCancellableClass = _GCancellableClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GCancellablePrivate {
    _unused: [u8; 0],
}
pub type GCancellablePrivate = _GCancellablePrivate;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GCancellable {
    pub parent_instance: GObject,
    pub priv_: *mut GCancellablePrivate,
}
#[test]
fn bindgen_test_layout__GCancellable() {
    assert_eq!(
        ::std::mem::size_of::<_GCancellable>(),
        32usize,
        concat!("Size of: ", stringify!(_GCancellable))
    );
    assert_eq!(
        ::std::mem::align_of::<_GCancellable>(),
        8usize,
        concat!("Alignment of ", stringify!(_GCancellable))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GCancellable>())).parent_instance as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GCancellable),
            "::",
            stringify!(parent_instance)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GCancellable>())).priv_ as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GCancellable),
            "::",
            stringify!(priv_)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GCancellableClass {
    pub parent_class: GObjectClass,
    pub cancelled: ::std::option::Option<unsafe extern "C" fn(cancellable: *mut GCancellable)>,
    pub _g_reserved1: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved2: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved3: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved4: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved5: ::std::option::Option<unsafe extern "C" fn()>,
}
#[test]
fn bindgen_test_layout__GCancellableClass() {
    assert_eq!(
        ::std::mem::size_of::<_GCancellableClass>(),
        184usize,
        concat!("Size of: ", stringify!(_GCancellableClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_GCancellableClass>(),
        8usize,
        concat!("Alignment of ", stringify!(_GCancellableClass))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GCancellableClass>())).parent_class as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GCancellableClass),
            "::",
            stringify!(parent_class)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GCancellableClass>())).cancelled as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_GCancellableClass),
            "::",
            stringify!(cancelled)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GCancellableClass>()))._g_reserved1 as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_GCancellableClass),
            "::",
            stringify!(_g_reserved1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GCancellableClass>()))._g_reserved2 as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(_GCancellableClass),
            "::",
            stringify!(_g_reserved2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GCancellableClass>()))._g_reserved3 as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_GCancellableClass),
            "::",
            stringify!(_g_reserved3)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GCancellableClass>()))._g_reserved4 as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(_GCancellableClass),
            "::",
            stringify!(_g_reserved4)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GCancellableClass>()))._g_reserved5 as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(_GCancellableClass),
            "::",
            stringify!(_g_reserved5)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_g_cancellable_get_type"]
    pub fn g_cancellable_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_cancellable_new"]
    pub fn g_cancellable_new() -> *mut GCancellable;
}
extern "C" {
    #[link_name = "\u{1}_g_cancellable_is_cancelled"]
    pub fn g_cancellable_is_cancelled(cancellable: *mut GCancellable) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_cancellable_set_error_if_cancelled"]
    pub fn g_cancellable_set_error_if_cancelled(
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_cancellable_get_fd"]
    pub fn g_cancellable_get_fd(cancellable: *mut GCancellable) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_g_cancellable_make_pollfd"]
    pub fn g_cancellable_make_pollfd(
        cancellable: *mut GCancellable,
        pollfd: *mut GPollFD,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_cancellable_release_fd"]
    pub fn g_cancellable_release_fd(cancellable: *mut GCancellable);
}
extern "C" {
    #[link_name = "\u{1}_g_cancellable_source_new"]
    pub fn g_cancellable_source_new(cancellable: *mut GCancellable) -> *mut GSource;
}
extern "C" {
    #[link_name = "\u{1}_g_cancellable_get_current"]
    pub fn g_cancellable_get_current() -> *mut GCancellable;
}
extern "C" {
    #[link_name = "\u{1}_g_cancellable_push_current"]
    pub fn g_cancellable_push_current(cancellable: *mut GCancellable);
}
extern "C" {
    #[link_name = "\u{1}_g_cancellable_pop_current"]
    pub fn g_cancellable_pop_current(cancellable: *mut GCancellable);
}
extern "C" {
    #[link_name = "\u{1}_g_cancellable_reset"]
    pub fn g_cancellable_reset(cancellable: *mut GCancellable);
}
extern "C" {
    #[link_name = "\u{1}_g_cancellable_connect"]
    pub fn g_cancellable_connect(
        cancellable: *mut GCancellable,
        callback: GCallback,
        data: gpointer,
        data_destroy_func: GDestroyNotify,
    ) -> gulong;
}
extern "C" {
    #[link_name = "\u{1}_g_cancellable_disconnect"]
    pub fn g_cancellable_disconnect(cancellable: *mut GCancellable, handler_id: gulong);
}
extern "C" {
    #[link_name = "\u{1}_g_cancellable_cancel"]
    pub fn g_cancellable_cancel(cancellable: *mut GCancellable);
}
/// GConverter:
///
/// Seek object for streaming operations.
///
/// Since: 2.24
pub type GConverterIface = _GConverterIface;
/// GConverterIface:
/// @g_iface: The parent interface.
/// @convert: Converts data.
/// @reset: Reverts the internal state of the converter to its initial state.
///
/// Provides an interface for converting data from one type
/// to another type. The conversion can be stateful
/// and may fail at any place.
///
/// Since: 2.24
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GConverterIface {
    pub g_iface: GTypeInterface,
    pub convert: ::std::option::Option<
        unsafe extern "C" fn(
            converter: *mut GConverter,
            inbuf: *const ::std::os::raw::c_void,
            inbuf_size: gsize,
            outbuf: *mut ::std::os::raw::c_void,
            outbuf_size: gsize,
            flags: GConverterFlags,
            bytes_read: *mut gsize,
            bytes_written: *mut gsize,
            error: *mut *mut GError,
        ) -> GConverterResult,
    >,
    pub reset: ::std::option::Option<unsafe extern "C" fn(converter: *mut GConverter)>,
}
#[test]
fn bindgen_test_layout__GConverterIface() {
    assert_eq!(
        ::std::mem::size_of::<_GConverterIface>(),
        32usize,
        concat!("Size of: ", stringify!(_GConverterIface))
    );
    assert_eq!(
        ::std::mem::align_of::<_GConverterIface>(),
        8usize,
        concat!("Alignment of ", stringify!(_GConverterIface))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GConverterIface>())).g_iface as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GConverterIface),
            "::",
            stringify!(g_iface)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GConverterIface>())).convert as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GConverterIface),
            "::",
            stringify!(convert)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GConverterIface>())).reset as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GConverterIface),
            "::",
            stringify!(reset)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_g_converter_get_type"]
    pub fn g_converter_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_converter_convert"]
    pub fn g_converter_convert(
        converter: *mut GConverter,
        inbuf: *const ::std::os::raw::c_void,
        inbuf_size: gsize,
        outbuf: *mut ::std::os::raw::c_void,
        outbuf_size: gsize,
        flags: GConverterFlags,
        bytes_read: *mut gsize,
        bytes_written: *mut gsize,
        error: *mut *mut GError,
    ) -> GConverterResult;
}
extern "C" {
    #[link_name = "\u{1}_g_converter_reset"]
    pub fn g_converter_reset(converter: *mut GConverter);
}
pub type GCharsetConverterClass = _GCharsetConverterClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GCharsetConverterClass {
    pub parent_class: GObjectClass,
}
#[test]
fn bindgen_test_layout__GCharsetConverterClass() {
    assert_eq!(
        ::std::mem::size_of::<_GCharsetConverterClass>(),
        136usize,
        concat!("Size of: ", stringify!(_GCharsetConverterClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_GCharsetConverterClass>(),
        8usize,
        concat!("Alignment of ", stringify!(_GCharsetConverterClass))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GCharsetConverterClass>())).parent_class as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GCharsetConverterClass),
            "::",
            stringify!(parent_class)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_g_charset_converter_get_type"]
    pub fn g_charset_converter_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_charset_converter_new"]
    pub fn g_charset_converter_new(
        to_charset: *const gchar,
        from_charset: *const gchar,
        error: *mut *mut GError,
    ) -> *mut GCharsetConverter;
}
extern "C" {
    #[link_name = "\u{1}_g_charset_converter_set_use_fallback"]
    pub fn g_charset_converter_set_use_fallback(
        converter: *mut GCharsetConverter,
        use_fallback: gboolean,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_charset_converter_get_use_fallback"]
    pub fn g_charset_converter_get_use_fallback(converter: *mut GCharsetConverter) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_charset_converter_get_num_fallbacks"]
    pub fn g_charset_converter_get_num_fallbacks(converter: *mut GCharsetConverter) -> guint;
}
extern "C" {
    #[link_name = "\u{1}_g_content_type_equals"]
    pub fn g_content_type_equals(type1: *const gchar, type2: *const gchar) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_content_type_is_a"]
    pub fn g_content_type_is_a(type_: *const gchar, supertype: *const gchar) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_content_type_is_mime_type"]
    pub fn g_content_type_is_mime_type(type_: *const gchar, mime_type: *const gchar) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_content_type_is_unknown"]
    pub fn g_content_type_is_unknown(type_: *const gchar) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_content_type_get_description"]
    pub fn g_content_type_get_description(type_: *const gchar) -> *mut gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_content_type_get_mime_type"]
    pub fn g_content_type_get_mime_type(type_: *const gchar) -> *mut gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_content_type_get_icon"]
    pub fn g_content_type_get_icon(type_: *const gchar) -> *mut GIcon;
}
extern "C" {
    #[link_name = "\u{1}_g_content_type_get_symbolic_icon"]
    pub fn g_content_type_get_symbolic_icon(type_: *const gchar) -> *mut GIcon;
}
extern "C" {
    #[link_name = "\u{1}_g_content_type_get_generic_icon_name"]
    pub fn g_content_type_get_generic_icon_name(type_: *const gchar) -> *mut gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_content_type_can_be_executable"]
    pub fn g_content_type_can_be_executable(type_: *const gchar) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_content_type_from_mime_type"]
    pub fn g_content_type_from_mime_type(mime_type: *const gchar) -> *mut gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_content_type_guess"]
    pub fn g_content_type_guess(
        filename: *const gchar,
        data: *const guchar,
        data_size: gsize,
        result_uncertain: *mut gboolean,
    ) -> *mut gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_content_type_guess_for_tree"]
    pub fn g_content_type_guess_for_tree(root: *mut GFile) -> *mut *mut gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_content_types_get_registered"]
    pub fn g_content_types_get_registered() -> *mut GList;
}
/// GConverterInputStream:
///
/// An implementation of #GFilterInputStream that allows data
/// conversion.
pub type GConverterInputStreamClass = _GConverterInputStreamClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GConverterInputStreamPrivate {
    _unused: [u8; 0],
}
pub type GConverterInputStreamPrivate = _GConverterInputStreamPrivate;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GConverterInputStream {
    pub parent_instance: GFilterInputStream,
    pub priv_: *mut GConverterInputStreamPrivate,
}
#[test]
fn bindgen_test_layout__GConverterInputStream() {
    assert_eq!(
        ::std::mem::size_of::<_GConverterInputStream>(),
        48usize,
        concat!("Size of: ", stringify!(_GConverterInputStream))
    );
    assert_eq!(
        ::std::mem::align_of::<_GConverterInputStream>(),
        8usize,
        concat!("Alignment of ", stringify!(_GConverterInputStream))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GConverterInputStream>())).parent_instance as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GConverterInputStream),
            "::",
            stringify!(parent_instance)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GConverterInputStream>())).priv_ as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_GConverterInputStream),
            "::",
            stringify!(priv_)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GConverterInputStreamClass {
    pub parent_class: GFilterInputStreamClass,
    pub _g_reserved1: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved2: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved3: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved4: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved5: ::std::option::Option<unsafe extern "C" fn()>,
}
#[test]
fn bindgen_test_layout__GConverterInputStreamClass() {
    assert_eq!(
        ::std::mem::size_of::<_GConverterInputStreamClass>(),
        312usize,
        concat!("Size of: ", stringify!(_GConverterInputStreamClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_GConverterInputStreamClass>(),
        8usize,
        concat!("Alignment of ", stringify!(_GConverterInputStreamClass))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GConverterInputStreamClass>())).parent_class as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GConverterInputStreamClass),
            "::",
            stringify!(parent_class)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GConverterInputStreamClass>()))._g_reserved1 as *const _
                as usize
        },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(_GConverterInputStreamClass),
            "::",
            stringify!(_g_reserved1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GConverterInputStreamClass>()))._g_reserved2 as *const _
                as usize
        },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(_GConverterInputStreamClass),
            "::",
            stringify!(_g_reserved2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GConverterInputStreamClass>()))._g_reserved3 as *const _
                as usize
        },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(_GConverterInputStreamClass),
            "::",
            stringify!(_g_reserved3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GConverterInputStreamClass>()))._g_reserved4 as *const _
                as usize
        },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(_GConverterInputStreamClass),
            "::",
            stringify!(_g_reserved4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GConverterInputStreamClass>()))._g_reserved5 as *const _
                as usize
        },
        304usize,
        concat!(
            "Offset of field: ",
            stringify!(_GConverterInputStreamClass),
            "::",
            stringify!(_g_reserved5)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_g_converter_input_stream_get_type"]
    pub fn g_converter_input_stream_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_converter_input_stream_new"]
    pub fn g_converter_input_stream_new(
        base_stream: *mut GInputStream,
        converter: *mut GConverter,
    ) -> *mut GInputStream;
}
extern "C" {
    #[link_name = "\u{1}_g_converter_input_stream_get_converter"]
    pub fn g_converter_input_stream_get_converter(
        converter_stream: *mut GConverterInputStream,
    ) -> *mut GConverter;
}
/// GConverterOutputStream:
///
/// An implementation of #GFilterOutputStream that allows data
/// conversion.
pub type GConverterOutputStreamClass = _GConverterOutputStreamClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GConverterOutputStreamPrivate {
    _unused: [u8; 0],
}
pub type GConverterOutputStreamPrivate = _GConverterOutputStreamPrivate;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GConverterOutputStream {
    pub parent_instance: GFilterOutputStream,
    pub priv_: *mut GConverterOutputStreamPrivate,
}
#[test]
fn bindgen_test_layout__GConverterOutputStream() {
    assert_eq!(
        ::std::mem::size_of::<_GConverterOutputStream>(),
        48usize,
        concat!("Size of: ", stringify!(_GConverterOutputStream))
    );
    assert_eq!(
        ::std::mem::align_of::<_GConverterOutputStream>(),
        8usize,
        concat!("Alignment of ", stringify!(_GConverterOutputStream))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GConverterOutputStream>())).parent_instance as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GConverterOutputStream),
            "::",
            stringify!(parent_instance)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GConverterOutputStream>())).priv_ as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_GConverterOutputStream),
            "::",
            stringify!(priv_)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GConverterOutputStreamClass {
    pub parent_class: GFilterOutputStreamClass,
    pub _g_reserved1: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved2: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved3: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved4: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved5: ::std::option::Option<unsafe extern "C" fn()>,
}
#[test]
fn bindgen_test_layout__GConverterOutputStreamClass() {
    assert_eq!(
        ::std::mem::size_of::<_GConverterOutputStreamClass>(),
        360usize,
        concat!("Size of: ", stringify!(_GConverterOutputStreamClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_GConverterOutputStreamClass>(),
        8usize,
        concat!("Alignment of ", stringify!(_GConverterOutputStreamClass))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GConverterOutputStreamClass>())).parent_class as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GConverterOutputStreamClass),
            "::",
            stringify!(parent_class)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GConverterOutputStreamClass>()))._g_reserved1 as *const _
                as usize
        },
        320usize,
        concat!(
            "Offset of field: ",
            stringify!(_GConverterOutputStreamClass),
            "::",
            stringify!(_g_reserved1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GConverterOutputStreamClass>()))._g_reserved2 as *const _
                as usize
        },
        328usize,
        concat!(
            "Offset of field: ",
            stringify!(_GConverterOutputStreamClass),
            "::",
            stringify!(_g_reserved2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GConverterOutputStreamClass>()))._g_reserved3 as *const _
                as usize
        },
        336usize,
        concat!(
            "Offset of field: ",
            stringify!(_GConverterOutputStreamClass),
            "::",
            stringify!(_g_reserved3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GConverterOutputStreamClass>()))._g_reserved4 as *const _
                as usize
        },
        344usize,
        concat!(
            "Offset of field: ",
            stringify!(_GConverterOutputStreamClass),
            "::",
            stringify!(_g_reserved4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GConverterOutputStreamClass>()))._g_reserved5 as *const _
                as usize
        },
        352usize,
        concat!(
            "Offset of field: ",
            stringify!(_GConverterOutputStreamClass),
            "::",
            stringify!(_g_reserved5)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_g_converter_output_stream_get_type"]
    pub fn g_converter_output_stream_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_converter_output_stream_new"]
    pub fn g_converter_output_stream_new(
        base_stream: *mut GOutputStream,
        converter: *mut GConverter,
    ) -> *mut GOutputStream;
}
extern "C" {
    #[link_name = "\u{1}_g_converter_output_stream_get_converter"]
    pub fn g_converter_output_stream_get_converter(
        converter_stream: *mut GConverterOutputStream,
    ) -> *mut GConverter;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct accessx_descriptor {
    pub ad_name_offset: ::std::os::raw::c_uint,
    pub ad_flags: ::std::os::raw::c_int,
    pub ad_pad: [::std::os::raw::c_int; 2usize],
}
#[test]
fn bindgen_test_layout_accessx_descriptor() {
    assert_eq!(
        ::std::mem::size_of::<accessx_descriptor>(),
        16usize,
        concat!("Size of: ", stringify!(accessx_descriptor))
    );
    assert_eq!(
        ::std::mem::align_of::<accessx_descriptor>(),
        4usize,
        concat!("Alignment of ", stringify!(accessx_descriptor))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<accessx_descriptor>())).ad_name_offset as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(accessx_descriptor),
            "::",
            stringify!(ad_name_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<accessx_descriptor>())).ad_flags as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(accessx_descriptor),
            "::",
            stringify!(ad_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<accessx_descriptor>())).ad_pad as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(accessx_descriptor),
            "::",
            stringify!(ad_pad)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_getattrlistbulk"]
    pub fn getattrlistbulk(
        arg1: ::std::os::raw::c_int,
        arg2: *mut ::std::os::raw::c_void,
        arg3: *mut ::std::os::raw::c_void,
        arg4: usize,
        arg5: u64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_faccessat"]
    pub fn faccessat(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
        arg4: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_fchownat"]
    pub fn fchownat(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_char,
        arg3: uid_t,
        arg4: gid_t,
        arg5: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_linkat"]
    pub fn linkat(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
        arg4: *const ::std::os::raw::c_char,
        arg5: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_readlinkat"]
    pub fn readlinkat(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut ::std::os::raw::c_char,
        arg4: usize,
    ) -> isize;
}
extern "C" {
    #[link_name = "\u{1}_symlinkat"]
    pub fn symlinkat(
        arg1: *const ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
        arg3: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_unlinkat"]
    pub fn unlinkat(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_getattrlistat"]
    pub fn getattrlistat(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut ::std::os::raw::c_void,
        arg4: *mut ::std::os::raw::c_void,
        arg5: usize,
        arg6: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__exit"]
    pub fn _exit(arg1: ::std::os::raw::c_int);
}
extern "C" {
    #[link_name = "\u{1}_access"]
    pub fn access(
        arg1: *const ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_alarm"]
    pub fn alarm(arg1: ::std::os::raw::c_uint) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[link_name = "\u{1}_chdir"]
    pub fn chdir(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_chown"]
    pub fn chown(
        arg1: *const ::std::os::raw::c_char,
        arg2: uid_t,
        arg3: gid_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_close"]
    pub fn close(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_dup"]
    pub fn dup(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_dup2"]
    pub fn dup2(arg1: ::std::os::raw::c_int, arg2: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_execl"]
    pub fn execl(
        __path: *const ::std::os::raw::c_char,
        __arg0: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_execle"]
    pub fn execle(
        __path: *const ::std::os::raw::c_char,
        __arg0: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_execlp"]
    pub fn execlp(
        __file: *const ::std::os::raw::c_char,
        __arg0: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_execv"]
    pub fn execv(
        __path: *const ::std::os::raw::c_char,
        __argv: *const *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_execve"]
    pub fn execve(
        __file: *const ::std::os::raw::c_char,
        __argv: *const *const ::std::os::raw::c_char,
        __envp: *const *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_execvp"]
    pub fn execvp(
        __file: *const ::std::os::raw::c_char,
        __argv: *const *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_fork"]
    pub fn fork() -> pid_t;
}
extern "C" {
    #[link_name = "\u{1}_fpathconf"]
    pub fn fpathconf(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    #[link_name = "\u{1}_getcwd"]
    pub fn getcwd(arg1: *mut ::std::os::raw::c_char, arg2: usize) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_getegid"]
    pub fn getegid() -> gid_t;
}
extern "C" {
    #[link_name = "\u{1}_geteuid"]
    pub fn geteuid() -> uid_t;
}
extern "C" {
    #[link_name = "\u{1}_getgid"]
    pub fn getgid() -> gid_t;
}
extern "C" {
    #[link_name = "\u{1}_getgroups"]
    pub fn getgroups(arg1: ::std::os::raw::c_int, arg2: *mut gid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_getlogin"]
    pub fn getlogin() -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_getpgrp"]
    pub fn getpgrp() -> pid_t;
}
extern "C" {
    #[link_name = "\u{1}_getpid"]
    pub fn getpid() -> pid_t;
}
extern "C" {
    #[link_name = "\u{1}_getppid"]
    pub fn getppid() -> pid_t;
}
extern "C" {
    #[link_name = "\u{1}_getuid"]
    pub fn getuid() -> uid_t;
}
extern "C" {
    #[link_name = "\u{1}_isatty"]
    pub fn isatty(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_link"]
    pub fn link(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_lseek"]
    pub fn lseek(arg1: ::std::os::raw::c_int, arg2: off_t, arg3: ::std::os::raw::c_int) -> off_t;
}
extern "C" {
    #[link_name = "\u{1}_pathconf"]
    pub fn pathconf(
        arg1: *const ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    #[link_name = "\u{1}_pause"]
    pub fn pause() -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_pipe"]
    pub fn pipe(arg1: *mut ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_read"]
    pub fn read(
        arg1: ::std::os::raw::c_int,
        arg2: *mut ::std::os::raw::c_void,
        arg3: usize,
    ) -> isize;
}
extern "C" {
    #[link_name = "\u{1}_rmdir"]
    pub fn rmdir(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_setgid"]
    pub fn setgid(arg1: gid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_setpgid"]
    pub fn setpgid(arg1: pid_t, arg2: pid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_setsid"]
    pub fn setsid() -> pid_t;
}
extern "C" {
    #[link_name = "\u{1}_setuid"]
    pub fn setuid(arg1: uid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_sleep"]
    pub fn sleep(arg1: ::std::os::raw::c_uint) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[link_name = "\u{1}_sysconf"]
    pub fn sysconf(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_long;
}
extern "C" {
    #[link_name = "\u{1}_tcgetpgrp"]
    pub fn tcgetpgrp(arg1: ::std::os::raw::c_int) -> pid_t;
}
extern "C" {
    #[link_name = "\u{1}_tcsetpgrp"]
    pub fn tcsetpgrp(arg1: ::std::os::raw::c_int, arg2: pid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ttyname"]
    pub fn ttyname(arg1: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_ttyname_r"]
    pub fn ttyname_r(
        arg1: ::std::os::raw::c_int,
        arg2: *mut ::std::os::raw::c_char,
        arg3: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_unlink"]
    pub fn unlink(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_write"]
    pub fn write(
        __fd: ::std::os::raw::c_int,
        __buf: *const ::std::os::raw::c_void,
        __nbyte: usize,
    ) -> isize;
}
extern "C" {
    #[link_name = "\u{1}_confstr"]
    pub fn confstr(
        arg1: ::std::os::raw::c_int,
        arg2: *mut ::std::os::raw::c_char,
        arg3: usize,
    ) -> usize;
}
extern "C" {
    #[link_name = "\u{1}_getopt"]
    pub fn getopt(
        arg1: ::std::os::raw::c_int,
        arg2: *const *const ::std::os::raw::c_char,
        arg3: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_optarg"]
    pub static mut optarg: *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_optind"]
    pub static mut optind: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_opterr"]
    pub static mut opterr: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_optopt"]
    pub static mut optopt: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_brk"]
    pub fn brk(arg1: *const ::std::os::raw::c_void) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[link_name = "\u{1}_chroot"]
    pub fn chroot(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_crypt"]
    pub fn crypt(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_ctermid"]
    pub fn ctermid(arg1: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_encrypt"]
    pub fn encrypt(arg1: *mut ::std::os::raw::c_char, arg2: ::std::os::raw::c_int);
}
extern "C" {
    #[link_name = "\u{1}_fchdir"]
    pub fn fchdir(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_gethostid"]
    pub fn gethostid() -> ::std::os::raw::c_long;
}
extern "C" {
    #[link_name = "\u{1}_getpgid"]
    pub fn getpgid(arg1: pid_t) -> pid_t;
}
extern "C" {
    #[link_name = "\u{1}_getsid"]
    pub fn getsid(arg1: pid_t) -> pid_t;
}
extern "C" {
    #[link_name = "\u{1}_getdtablesize"]
    pub fn getdtablesize() -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_getpagesize"]
    pub fn getpagesize() -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_getpass"]
    pub fn getpass(arg1: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_getwd"]
    pub fn getwd(arg1: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_lchown"]
    pub fn lchown(
        arg1: *const ::std::os::raw::c_char,
        arg2: uid_t,
        arg3: gid_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_lockf"]
    pub fn lockf(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_int,
        arg3: off_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_nice"]
    pub fn nice(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_pread"]
    pub fn pread(
        __fd: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_void,
        __nbyte: usize,
        __offset: off_t,
    ) -> isize;
}
extern "C" {
    #[link_name = "\u{1}_pwrite"]
    pub fn pwrite(
        __fd: ::std::os::raw::c_int,
        __buf: *const ::std::os::raw::c_void,
        __nbyte: usize,
        __offset: off_t,
    ) -> isize;
}
extern "C" {
    #[link_name = "\u{1}_sbrk"]
    pub fn sbrk(arg1: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[link_name = "\u{1}_setpgrp"]
    pub fn setpgrp() -> pid_t;
}
extern "C" {
    #[link_name = "\u{1}_setregid"]
    pub fn setregid(arg1: gid_t, arg2: gid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_setreuid"]
    pub fn setreuid(arg1: uid_t, arg2: uid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_swab"]
    pub fn swab(
        arg1: *const ::std::os::raw::c_void,
        arg2: *mut ::std::os::raw::c_void,
        arg3: isize,
    );
}
extern "C" {
    #[link_name = "\u{1}_sync"]
    pub fn sync();
}
extern "C" {
    #[link_name = "\u{1}_truncate"]
    pub fn truncate(arg1: *const ::std::os::raw::c_char, arg2: off_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ualarm"]
    pub fn ualarm(arg1: useconds_t, arg2: useconds_t) -> useconds_t;
}
extern "C" {
    #[link_name = "\u{1}_usleep"]
    pub fn usleep(arg1: useconds_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_vfork"]
    pub fn vfork() -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_fsync"]
    pub fn fsync(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ftruncate"]
    pub fn ftruncate(arg1: ::std::os::raw::c_int, arg2: off_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_getlogin_r"]
    pub fn getlogin_r(arg1: *mut ::std::os::raw::c_char, arg2: usize) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_fchown"]
    pub fn fchown(arg1: ::std::os::raw::c_int, arg2: uid_t, arg3: gid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_gethostname"]
    pub fn gethostname(arg1: *mut ::std::os::raw::c_char, arg2: usize) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_readlink"]
    pub fn readlink(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut ::std::os::raw::c_char,
        arg3: usize,
    ) -> isize;
}
extern "C" {
    #[link_name = "\u{1}_setegid"]
    pub fn setegid(arg1: gid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_seteuid"]
    pub fn seteuid(arg1: uid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_symlink"]
    pub fn symlink(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_pselect"]
    pub fn pselect(
        arg1: ::std::os::raw::c_int,
        arg2: *mut fd_set,
        arg3: *mut fd_set,
        arg4: *mut fd_set,
        arg5: *const timespec,
        arg6: *const sigset_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_select"]
    pub fn select(
        arg1: ::std::os::raw::c_int,
        arg2: *mut fd_set,
        arg3: *mut fd_set,
        arg4: *mut fd_set,
        arg5: *mut timeval,
    ) -> ::std::os::raw::c_int;
}
pub type uuid_t = __darwin_uuid_t;
extern "C" {
    #[link_name = "\u{1}_accessx_np"]
    pub fn accessx_np(
        arg1: *const accessx_descriptor,
        arg2: usize,
        arg3: *mut ::std::os::raw::c_int,
        arg4: uid_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_acct"]
    pub fn acct(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_add_profil"]
    pub fn add_profil(
        arg1: *mut ::std::os::raw::c_char,
        arg2: usize,
        arg3: ::std::os::raw::c_ulong,
        arg4: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_endusershell"]
    pub fn endusershell();
}
extern "C" {
    #[link_name = "\u{1}_execvP"]
    pub fn execvP(
        __file: *const ::std::os::raw::c_char,
        __searchpath: *const ::std::os::raw::c_char,
        __argv: *const *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_fflagstostr"]
    pub fn fflagstostr(arg1: ::std::os::raw::c_ulong) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_getdomainname"]
    pub fn getdomainname(
        arg1: *mut ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_getgrouplist"]
    pub fn getgrouplist(
        arg1: *const ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
        arg3: *mut ::std::os::raw::c_int,
        arg4: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_gethostuuid"]
    pub fn gethostuuid(
        arg1: *mut ::std::os::raw::c_uchar,
        arg2: *const timespec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_getmode"]
    pub fn getmode(arg1: *const ::std::os::raw::c_void, arg2: mode_t) -> mode_t;
}
extern "C" {
    #[link_name = "\u{1}_getpeereid"]
    pub fn getpeereid(
        arg1: ::std::os::raw::c_int,
        arg2: *mut uid_t,
        arg3: *mut gid_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_getsgroups_np"]
    pub fn getsgroups_np(
        arg1: *mut ::std::os::raw::c_int,
        arg2: *mut ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_getusershell"]
    pub fn getusershell() -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_getwgroups_np"]
    pub fn getwgroups_np(
        arg1: *mut ::std::os::raw::c_int,
        arg2: *mut ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_initgroups"]
    pub fn initgroups(
        arg1: *const ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_issetugid"]
    pub fn issetugid() -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_mkdtemp"]
    pub fn mkdtemp(arg1: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_mknod"]
    pub fn mknod(
        arg1: *const ::std::os::raw::c_char,
        arg2: mode_t,
        arg3: dev_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_mkpath_np"]
    pub fn mkpath_np(path: *const ::std::os::raw::c_char, omode: mode_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_mkpathat_np"]
    pub fn mkpathat_np(
        dfd: ::std::os::raw::c_int,
        path: *const ::std::os::raw::c_char,
        omode: mode_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_mkstemps"]
    pub fn mkstemps(
        arg1: *mut ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_mkostemp"]
    pub fn mkostemp(
        path: *mut ::std::os::raw::c_char,
        oflags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_mkostemps"]
    pub fn mkostemps(
        path: *mut ::std::os::raw::c_char,
        slen: ::std::os::raw::c_int,
        oflags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_mkstemp_dprotected_np"]
    pub fn mkstemp_dprotected_np(
        path: *mut ::std::os::raw::c_char,
        dpclass: ::std::os::raw::c_int,
        dpflags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_nfssvc"]
    pub fn nfssvc(
        arg1: ::std::os::raw::c_int,
        arg2: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_profil"]
    pub fn profil(
        arg1: *mut ::std::os::raw::c_char,
        arg2: usize,
        arg3: ::std::os::raw::c_ulong,
        arg4: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_pthread_setugid_np"]
    pub fn pthread_setugid_np(arg1: uid_t, arg2: gid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_pthread_getugid_np"]
    pub fn pthread_getugid_np(arg1: *mut uid_t, arg2: *mut gid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_reboot"]
    pub fn reboot(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_revoke"]
    pub fn revoke(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_rcmd"]
    pub fn rcmd(
        arg1: *mut *mut ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
        arg3: *const ::std::os::raw::c_char,
        arg4: *const ::std::os::raw::c_char,
        arg5: *const ::std::os::raw::c_char,
        arg6: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_rcmd_af"]
    pub fn rcmd_af(
        arg1: *mut *mut ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
        arg3: *const ::std::os::raw::c_char,
        arg4: *const ::std::os::raw::c_char,
        arg5: *const ::std::os::raw::c_char,
        arg6: *mut ::std::os::raw::c_int,
        arg7: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_rresvport"]
    pub fn rresvport(arg1: *mut ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_rresvport_af"]
    pub fn rresvport_af(
        arg1: *mut ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_iruserok"]
    pub fn iruserok(
        arg1: ::std::os::raw::c_ulong,
        arg2: ::std::os::raw::c_int,
        arg3: *const ::std::os::raw::c_char,
        arg4: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_iruserok_sa"]
    pub fn iruserok_sa(
        arg1: *const ::std::os::raw::c_void,
        arg2: ::std::os::raw::c_int,
        arg3: ::std::os::raw::c_int,
        arg4: *const ::std::os::raw::c_char,
        arg5: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ruserok"]
    pub fn ruserok(
        arg1: *const ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
        arg3: *const ::std::os::raw::c_char,
        arg4: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_setdomainname"]
    pub fn setdomainname(
        arg1: *const ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_setgroups"]
    pub fn setgroups(arg1: ::std::os::raw::c_int, arg2: *const gid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_sethostid"]
    pub fn sethostid(arg1: ::std::os::raw::c_long);
}
extern "C" {
    #[link_name = "\u{1}_sethostname"]
    pub fn sethostname(
        arg1: *const ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_setlogin"]
    pub fn setlogin(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_setmode"]
    pub fn setmode(arg1: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[link_name = "\u{1}_setrgid"]
    pub fn setrgid(arg1: gid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_setruid"]
    pub fn setruid(arg1: uid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_setsgroups_np"]
    pub fn setsgroups_np(
        arg1: ::std::os::raw::c_int,
        arg2: *mut ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_setusershell"]
    pub fn setusershell();
}
extern "C" {
    #[link_name = "\u{1}_setwgroups_np"]
    pub fn setwgroups_np(
        arg1: ::std::os::raw::c_int,
        arg2: *mut ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_strtofflags"]
    pub fn strtofflags(
        arg1: *mut *mut ::std::os::raw::c_char,
        arg2: *mut ::std::os::raw::c_ulong,
        arg3: *mut ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_swapon"]
    pub fn swapon(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ttyslot"]
    pub fn ttyslot() -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_undelete"]
    pub fn undelete(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_unwhiteout"]
    pub fn unwhiteout(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_syscall"]
    pub fn syscall(arg1: ::std::os::raw::c_int, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_fgetattrlist"]
    pub fn fgetattrlist(
        arg1: ::std::os::raw::c_int,
        arg2: *mut ::std::os::raw::c_void,
        arg3: *mut ::std::os::raw::c_void,
        arg4: usize,
        arg5: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_fsetattrlist"]
    pub fn fsetattrlist(
        arg1: ::std::os::raw::c_int,
        arg2: *mut ::std::os::raw::c_void,
        arg3: *mut ::std::os::raw::c_void,
        arg4: usize,
        arg5: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_getattrlist"]
    pub fn getattrlist(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut ::std::os::raw::c_void,
        arg3: *mut ::std::os::raw::c_void,
        arg4: usize,
        arg5: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_setattrlist"]
    pub fn setattrlist(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut ::std::os::raw::c_void,
        arg3: *mut ::std::os::raw::c_void,
        arg4: usize,
        arg5: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_exchangedata"]
    pub fn exchangedata(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_getdirentriesattr"]
    pub fn getdirentriesattr(
        arg1: ::std::os::raw::c_int,
        arg2: *mut ::std::os::raw::c_void,
        arg3: *mut ::std::os::raw::c_void,
        arg4: usize,
        arg5: *mut ::std::os::raw::c_uint,
        arg6: *mut ::std::os::raw::c_uint,
        arg7: *mut ::std::os::raw::c_uint,
        arg8: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fssearchblock {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct searchstate {
    _unused: [u8; 0],
}
extern "C" {
    #[link_name = "\u{1}_searchfs"]
    pub fn searchfs(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut fssearchblock,
        arg3: *mut ::std::os::raw::c_ulong,
        arg4: ::std::os::raw::c_uint,
        arg5: ::std::os::raw::c_uint,
        arg6: *mut searchstate,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_fsctl"]
    pub fn fsctl(
        arg1: *const ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_ulong,
        arg3: *mut ::std::os::raw::c_void,
        arg4: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ffsctl"]
    pub fn ffsctl(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_ulong,
        arg3: *mut ::std::os::raw::c_void,
        arg4: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_fsync_volume_np"]
    pub fn fsync_volume_np(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_sync_volume_np"]
    pub fn sync_volume_np(
        arg1: *const ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_optreset"]
    pub static mut optreset: ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GCredentialsClass {
    _unused: [u8; 0],
}
pub type GCredentialsClass = _GCredentialsClass;
extern "C" {
    #[link_name = "\u{1}_g_credentials_get_type"]
    pub fn g_credentials_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_credentials_new"]
    pub fn g_credentials_new() -> *mut GCredentials;
}
extern "C" {
    #[link_name = "\u{1}_g_credentials_to_string"]
    pub fn g_credentials_to_string(credentials: *mut GCredentials) -> *mut gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_credentials_get_native"]
    pub fn g_credentials_get_native(
        credentials: *mut GCredentials,
        native_type: GCredentialsType,
    ) -> gpointer;
}
extern "C" {
    #[link_name = "\u{1}_g_credentials_set_native"]
    pub fn g_credentials_set_native(
        credentials: *mut GCredentials,
        native_type: GCredentialsType,
        native: gpointer,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_credentials_is_same_user"]
    pub fn g_credentials_is_same_user(
        credentials: *mut GCredentials,
        other_credentials: *mut GCredentials,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_credentials_get_unix_pid"]
    pub fn g_credentials_get_unix_pid(
        credentials: *mut GCredentials,
        error: *mut *mut GError,
    ) -> pid_t;
}
extern "C" {
    #[link_name = "\u{1}_g_credentials_get_unix_user"]
    pub fn g_credentials_get_unix_user(
        credentials: *mut GCredentials,
        error: *mut *mut GError,
    ) -> uid_t;
}
extern "C" {
    #[link_name = "\u{1}_g_credentials_set_unix_user"]
    pub fn g_credentials_set_unix_user(
        credentials: *mut GCredentials,
        uid: uid_t,
        error: *mut *mut GError,
    ) -> gboolean;
}
/// GDatagramBased:
///
/// Interface for socket-like objects with datagram semantics.
///
/// Since: 2.48
pub type GDatagramBasedInterface = _GDatagramBasedInterface;
/// GDatagramBasedInterface:
/// @g_iface: The parent interface.
/// @receive_messages: Virtual method for g_datagram_based_receive_messages().
/// @send_messages: Virtual method for g_datagram_based_send_messages().
/// @create_source: Virtual method for g_datagram_based_create_source().
/// @condition_check: Virtual method for g_datagram_based_condition_check().
/// @condition_wait: Virtual method for
/// g_datagram_based_condition_wait().
///
/// Provides an interface for socket-like objects which have datagram semantics,
/// following the Berkeley sockets API. The interface methods are thin wrappers
/// around the corresponding virtual methods, and no pre-processing of inputs is
/// implemented — so implementations of this API must handle all functionality
/// documented in the interface methods.
///
/// Since: 2.48
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GDatagramBasedInterface {
    pub g_iface: GTypeInterface,
    pub receive_messages: ::std::option::Option<
        unsafe extern "C" fn(
            datagram_based: *mut GDatagramBased,
            messages: *mut GInputMessage,
            num_messages: guint,
            flags: gint,
            timeout: gint64,
            cancellable: *mut GCancellable,
            error: *mut *mut GError,
        ) -> gint,
    >,
    pub send_messages: ::std::option::Option<
        unsafe extern "C" fn(
            datagram_based: *mut GDatagramBased,
            messages: *mut GOutputMessage,
            num_messages: guint,
            flags: gint,
            timeout: gint64,
            cancellable: *mut GCancellable,
            error: *mut *mut GError,
        ) -> gint,
    >,
    pub create_source: ::std::option::Option<
        unsafe extern "C" fn(
            datagram_based: *mut GDatagramBased,
            condition: GIOCondition,
            cancellable: *mut GCancellable,
        ) -> *mut GSource,
    >,
    pub condition_check: ::std::option::Option<
        unsafe extern "C" fn(datagram_based: *mut GDatagramBased, condition: GIOCondition)
            -> GIOCondition,
    >,
    pub condition_wait: ::std::option::Option<
        unsafe extern "C" fn(
            datagram_based: *mut GDatagramBased,
            condition: GIOCondition,
            timeout: gint64,
            cancellable: *mut GCancellable,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
}
#[test]
fn bindgen_test_layout__GDatagramBasedInterface() {
    assert_eq!(
        ::std::mem::size_of::<_GDatagramBasedInterface>(),
        56usize,
        concat!("Size of: ", stringify!(_GDatagramBasedInterface))
    );
    assert_eq!(
        ::std::mem::align_of::<_GDatagramBasedInterface>(),
        8usize,
        concat!("Alignment of ", stringify!(_GDatagramBasedInterface))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GDatagramBasedInterface>())).g_iface as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDatagramBasedInterface),
            "::",
            stringify!(g_iface)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GDatagramBasedInterface>())).receive_messages as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDatagramBasedInterface),
            "::",
            stringify!(receive_messages)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GDatagramBasedInterface>())).send_messages as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDatagramBasedInterface),
            "::",
            stringify!(send_messages)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GDatagramBasedInterface>())).create_source as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDatagramBasedInterface),
            "::",
            stringify!(create_source)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GDatagramBasedInterface>())).condition_check as *const _
                as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDatagramBasedInterface),
            "::",
            stringify!(condition_check)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GDatagramBasedInterface>())).condition_wait as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDatagramBasedInterface),
            "::",
            stringify!(condition_wait)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_g_datagram_based_get_type"]
    pub fn g_datagram_based_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_datagram_based_receive_messages"]
    pub fn g_datagram_based_receive_messages(
        datagram_based: *mut GDatagramBased,
        messages: *mut GInputMessage,
        num_messages: guint,
        flags: gint,
        timeout: gint64,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gint;
}
extern "C" {
    #[link_name = "\u{1}_g_datagram_based_send_messages"]
    pub fn g_datagram_based_send_messages(
        datagram_based: *mut GDatagramBased,
        messages: *mut GOutputMessage,
        num_messages: guint,
        flags: gint,
        timeout: gint64,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gint;
}
extern "C" {
    #[link_name = "\u{1}_g_datagram_based_create_source"]
    pub fn g_datagram_based_create_source(
        datagram_based: *mut GDatagramBased,
        condition: GIOCondition,
        cancellable: *mut GCancellable,
    ) -> *mut GSource;
}
extern "C" {
    #[link_name = "\u{1}_g_datagram_based_condition_check"]
    pub fn g_datagram_based_condition_check(
        datagram_based: *mut GDatagramBased,
        condition: GIOCondition,
    ) -> GIOCondition;
}
extern "C" {
    #[link_name = "\u{1}_g_datagram_based_condition_wait"]
    pub fn g_datagram_based_condition_wait(
        datagram_based: *mut GDatagramBased,
        condition: GIOCondition,
        timeout: gint64,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gboolean;
}
/// GDataInputStream:
///
/// An implementation of #GBufferedInputStream that allows for high-level
/// data manipulation of arbitrary data (including binary operations).
pub type GDataInputStreamClass = _GDataInputStreamClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GDataInputStreamPrivate {
    _unused: [u8; 0],
}
pub type GDataInputStreamPrivate = _GDataInputStreamPrivate;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GDataInputStream {
    pub parent_instance: GBufferedInputStream,
    pub priv_: *mut GDataInputStreamPrivate,
}
#[test]
fn bindgen_test_layout__GDataInputStream() {
    assert_eq!(
        ::std::mem::size_of::<_GDataInputStream>(),
        56usize,
        concat!("Size of: ", stringify!(_GDataInputStream))
    );
    assert_eq!(
        ::std::mem::align_of::<_GDataInputStream>(),
        8usize,
        concat!("Alignment of ", stringify!(_GDataInputStream))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GDataInputStream>())).parent_instance as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDataInputStream),
            "::",
            stringify!(parent_instance)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GDataInputStream>())).priv_ as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDataInputStream),
            "::",
            stringify!(priv_)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GDataInputStreamClass {
    pub parent_class: GBufferedInputStreamClass,
    pub _g_reserved1: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved2: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved3: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved4: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved5: ::std::option::Option<unsafe extern "C" fn()>,
}
#[test]
fn bindgen_test_layout__GDataInputStreamClass() {
    assert_eq!(
        ::std::mem::size_of::<_GDataInputStreamClass>(),
        376usize,
        concat!("Size of: ", stringify!(_GDataInputStreamClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_GDataInputStreamClass>(),
        8usize,
        concat!("Alignment of ", stringify!(_GDataInputStreamClass))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GDataInputStreamClass>())).parent_class as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDataInputStreamClass),
            "::",
            stringify!(parent_class)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GDataInputStreamClass>()))._g_reserved1 as *const _ as usize
        },
        336usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDataInputStreamClass),
            "::",
            stringify!(_g_reserved1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GDataInputStreamClass>()))._g_reserved2 as *const _ as usize
        },
        344usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDataInputStreamClass),
            "::",
            stringify!(_g_reserved2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GDataInputStreamClass>()))._g_reserved3 as *const _ as usize
        },
        352usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDataInputStreamClass),
            "::",
            stringify!(_g_reserved3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GDataInputStreamClass>()))._g_reserved4 as *const _ as usize
        },
        360usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDataInputStreamClass),
            "::",
            stringify!(_g_reserved4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GDataInputStreamClass>()))._g_reserved5 as *const _ as usize
        },
        368usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDataInputStreamClass),
            "::",
            stringify!(_g_reserved5)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_g_data_input_stream_get_type"]
    pub fn g_data_input_stream_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_data_input_stream_new"]
    pub fn g_data_input_stream_new(base_stream: *mut GInputStream) -> *mut GDataInputStream;
}
extern "C" {
    #[link_name = "\u{1}_g_data_input_stream_set_byte_order"]
    pub fn g_data_input_stream_set_byte_order(
        stream: *mut GDataInputStream,
        order: GDataStreamByteOrder,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_data_input_stream_get_byte_order"]
    pub fn g_data_input_stream_get_byte_order(
        stream: *mut GDataInputStream,
    ) -> GDataStreamByteOrder;
}
extern "C" {
    #[link_name = "\u{1}_g_data_input_stream_set_newline_type"]
    pub fn g_data_input_stream_set_newline_type(
        stream: *mut GDataInputStream,
        type_: GDataStreamNewlineType,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_data_input_stream_get_newline_type"]
    pub fn g_data_input_stream_get_newline_type(
        stream: *mut GDataInputStream,
    ) -> GDataStreamNewlineType;
}
extern "C" {
    #[link_name = "\u{1}_g_data_input_stream_read_byte"]
    pub fn g_data_input_stream_read_byte(
        stream: *mut GDataInputStream,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> guchar;
}
extern "C" {
    #[link_name = "\u{1}_g_data_input_stream_read_int16"]
    pub fn g_data_input_stream_read_int16(
        stream: *mut GDataInputStream,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gint16;
}
extern "C" {
    #[link_name = "\u{1}_g_data_input_stream_read_uint16"]
    pub fn g_data_input_stream_read_uint16(
        stream: *mut GDataInputStream,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> guint16;
}
extern "C" {
    #[link_name = "\u{1}_g_data_input_stream_read_int32"]
    pub fn g_data_input_stream_read_int32(
        stream: *mut GDataInputStream,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gint32;
}
extern "C" {
    #[link_name = "\u{1}_g_data_input_stream_read_uint32"]
    pub fn g_data_input_stream_read_uint32(
        stream: *mut GDataInputStream,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> guint32;
}
extern "C" {
    #[link_name = "\u{1}_g_data_input_stream_read_int64"]
    pub fn g_data_input_stream_read_int64(
        stream: *mut GDataInputStream,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gint64;
}
extern "C" {
    #[link_name = "\u{1}_g_data_input_stream_read_uint64"]
    pub fn g_data_input_stream_read_uint64(
        stream: *mut GDataInputStream,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> guint64;
}
extern "C" {
    #[link_name = "\u{1}_g_data_input_stream_read_line"]
    pub fn g_data_input_stream_read_line(
        stream: *mut GDataInputStream,
        length: *mut gsize,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_g_data_input_stream_read_line_utf8"]
    pub fn g_data_input_stream_read_line_utf8(
        stream: *mut GDataInputStream,
        length: *mut gsize,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_g_data_input_stream_read_line_async"]
    pub fn g_data_input_stream_read_line_async(
        stream: *mut GDataInputStream,
        io_priority: gint,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_data_input_stream_read_line_finish"]
    pub fn g_data_input_stream_read_line_finish(
        stream: *mut GDataInputStream,
        result: *mut GAsyncResult,
        length: *mut gsize,
        error: *mut *mut GError,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_g_data_input_stream_read_line_finish_utf8"]
    pub fn g_data_input_stream_read_line_finish_utf8(
        stream: *mut GDataInputStream,
        result: *mut GAsyncResult,
        length: *mut gsize,
        error: *mut *mut GError,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_g_data_input_stream_read_until"]
    pub fn g_data_input_stream_read_until(
        stream: *mut GDataInputStream,
        stop_chars: *const gchar,
        length: *mut gsize,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_g_data_input_stream_read_until_async"]
    pub fn g_data_input_stream_read_until_async(
        stream: *mut GDataInputStream,
        stop_chars: *const gchar,
        io_priority: gint,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_data_input_stream_read_until_finish"]
    pub fn g_data_input_stream_read_until_finish(
        stream: *mut GDataInputStream,
        result: *mut GAsyncResult,
        length: *mut gsize,
        error: *mut *mut GError,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_g_data_input_stream_read_upto"]
    pub fn g_data_input_stream_read_upto(
        stream: *mut GDataInputStream,
        stop_chars: *const gchar,
        stop_chars_len: gssize,
        length: *mut gsize,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_g_data_input_stream_read_upto_async"]
    pub fn g_data_input_stream_read_upto_async(
        stream: *mut GDataInputStream,
        stop_chars: *const gchar,
        stop_chars_len: gssize,
        io_priority: gint,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_data_input_stream_read_upto_finish"]
    pub fn g_data_input_stream_read_upto_finish(
        stream: *mut GDataInputStream,
        result: *mut GAsyncResult,
        length: *mut gsize,
        error: *mut *mut GError,
    ) -> *mut ::std::os::raw::c_char;
}
/// GDataOutputStream:
///
/// An implementation of #GBufferedOutputStream that allows for high-level
/// data manipulation of arbitrary data (including binary operations).
pub type GDataOutputStream = _GDataOutputStream;
pub type GDataOutputStreamClass = _GDataOutputStreamClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GDataOutputStreamPrivate {
    _unused: [u8; 0],
}
pub type GDataOutputStreamPrivate = _GDataOutputStreamPrivate;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GDataOutputStream {
    pub parent_instance: GFilterOutputStream,
    pub priv_: *mut GDataOutputStreamPrivate,
}
#[test]
fn bindgen_test_layout__GDataOutputStream() {
    assert_eq!(
        ::std::mem::size_of::<_GDataOutputStream>(),
        48usize,
        concat!("Size of: ", stringify!(_GDataOutputStream))
    );
    assert_eq!(
        ::std::mem::align_of::<_GDataOutputStream>(),
        8usize,
        concat!("Alignment of ", stringify!(_GDataOutputStream))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GDataOutputStream>())).parent_instance as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDataOutputStream),
            "::",
            stringify!(parent_instance)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GDataOutputStream>())).priv_ as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDataOutputStream),
            "::",
            stringify!(priv_)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GDataOutputStreamClass {
    pub parent_class: GFilterOutputStreamClass,
    pub _g_reserved1: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved2: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved3: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved4: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved5: ::std::option::Option<unsafe extern "C" fn()>,
}
#[test]
fn bindgen_test_layout__GDataOutputStreamClass() {
    assert_eq!(
        ::std::mem::size_of::<_GDataOutputStreamClass>(),
        360usize,
        concat!("Size of: ", stringify!(_GDataOutputStreamClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_GDataOutputStreamClass>(),
        8usize,
        concat!("Alignment of ", stringify!(_GDataOutputStreamClass))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GDataOutputStreamClass>())).parent_class as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDataOutputStreamClass),
            "::",
            stringify!(parent_class)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GDataOutputStreamClass>()))._g_reserved1 as *const _ as usize
        },
        320usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDataOutputStreamClass),
            "::",
            stringify!(_g_reserved1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GDataOutputStreamClass>()))._g_reserved2 as *const _ as usize
        },
        328usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDataOutputStreamClass),
            "::",
            stringify!(_g_reserved2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GDataOutputStreamClass>()))._g_reserved3 as *const _ as usize
        },
        336usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDataOutputStreamClass),
            "::",
            stringify!(_g_reserved3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GDataOutputStreamClass>()))._g_reserved4 as *const _ as usize
        },
        344usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDataOutputStreamClass),
            "::",
            stringify!(_g_reserved4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GDataOutputStreamClass>()))._g_reserved5 as *const _ as usize
        },
        352usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDataOutputStreamClass),
            "::",
            stringify!(_g_reserved5)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_g_data_output_stream_get_type"]
    pub fn g_data_output_stream_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_data_output_stream_new"]
    pub fn g_data_output_stream_new(base_stream: *mut GOutputStream) -> *mut GDataOutputStream;
}
extern "C" {
    #[link_name = "\u{1}_g_data_output_stream_set_byte_order"]
    pub fn g_data_output_stream_set_byte_order(
        stream: *mut GDataOutputStream,
        order: GDataStreamByteOrder,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_data_output_stream_get_byte_order"]
    pub fn g_data_output_stream_get_byte_order(
        stream: *mut GDataOutputStream,
    ) -> GDataStreamByteOrder;
}
extern "C" {
    #[link_name = "\u{1}_g_data_output_stream_put_byte"]
    pub fn g_data_output_stream_put_byte(
        stream: *mut GDataOutputStream,
        data: guchar,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_data_output_stream_put_int16"]
    pub fn g_data_output_stream_put_int16(
        stream: *mut GDataOutputStream,
        data: gint16,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_data_output_stream_put_uint16"]
    pub fn g_data_output_stream_put_uint16(
        stream: *mut GDataOutputStream,
        data: guint16,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_data_output_stream_put_int32"]
    pub fn g_data_output_stream_put_int32(
        stream: *mut GDataOutputStream,
        data: gint32,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_data_output_stream_put_uint32"]
    pub fn g_data_output_stream_put_uint32(
        stream: *mut GDataOutputStream,
        data: guint32,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_data_output_stream_put_int64"]
    pub fn g_data_output_stream_put_int64(
        stream: *mut GDataOutputStream,
        data: gint64,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_data_output_stream_put_uint64"]
    pub fn g_data_output_stream_put_uint64(
        stream: *mut GDataOutputStream,
        data: guint64,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_data_output_stream_put_string"]
    pub fn g_data_output_stream_put_string(
        stream: *mut GDataOutputStream,
        str: *const ::std::os::raw::c_char,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_dbus_address_escape_value"]
    pub fn g_dbus_address_escape_value(string: *const gchar) -> *mut gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_dbus_is_address"]
    pub fn g_dbus_is_address(string: *const gchar) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_dbus_is_supported_address"]
    pub fn g_dbus_is_supported_address(string: *const gchar, error: *mut *mut GError) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_dbus_address_get_stream"]
    pub fn g_dbus_address_get_stream(
        address: *const gchar,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_dbus_address_get_stream_finish"]
    pub fn g_dbus_address_get_stream_finish(
        res: *mut GAsyncResult,
        out_guid: *mut *mut gchar,
        error: *mut *mut GError,
    ) -> *mut GIOStream;
}
extern "C" {
    #[link_name = "\u{1}_g_dbus_address_get_stream_sync"]
    pub fn g_dbus_address_get_stream_sync(
        address: *const gchar,
        out_guid: *mut *mut gchar,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> *mut GIOStream;
}
extern "C" {
    #[link_name = "\u{1}_g_dbus_address_get_for_bus_sync"]
    pub fn g_dbus_address_get_for_bus_sync(
        bus_type: GBusType,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> *mut gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_dbus_auth_observer_get_type"]
    pub fn g_dbus_auth_observer_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_dbus_auth_observer_new"]
    pub fn g_dbus_auth_observer_new() -> *mut GDBusAuthObserver;
}
extern "C" {
    #[link_name = "\u{1}_g_dbus_auth_observer_authorize_authenticated_peer"]
    pub fn g_dbus_auth_observer_authorize_authenticated_peer(
        observer: *mut GDBusAuthObserver,
        stream: *mut GIOStream,
        credentials: *mut GCredentials,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_dbus_auth_observer_allow_mechanism"]
    pub fn g_dbus_auth_observer_allow_mechanism(
        observer: *mut GDBusAuthObserver,
        mechanism: *const gchar,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_dbus_connection_get_type"]
    pub fn g_dbus_connection_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_bus_get"]
    pub fn g_bus_get(
        bus_type: GBusType,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_bus_get_finish"]
    pub fn g_bus_get_finish(
        res: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> *mut GDBusConnection;
}
extern "C" {
    #[link_name = "\u{1}_g_bus_get_sync"]
    pub fn g_bus_get_sync(
        bus_type: GBusType,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> *mut GDBusConnection;
}
extern "C" {
    #[link_name = "\u{1}_g_dbus_connection_new"]
    pub fn g_dbus_connection_new(
        stream: *mut GIOStream,
        guid: *const gchar,
        flags: GDBusConnectionFlags,
        observer: *mut GDBusAuthObserver,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_dbus_connection_new_finish"]
    pub fn g_dbus_connection_new_finish(
        res: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> *mut GDBusConnection;
}
extern "C" {
    #[link_name = "\u{1}_g_dbus_connection_new_sync"]
    pub fn g_dbus_connection_new_sync(
        stream: *mut GIOStream,
        guid: *const gchar,
        flags: GDBusConnectionFlags,
        observer: *mut GDBusAuthObserver,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> *mut GDBusConnection;
}
extern "C" {
    #[link_name = "\u{1}_g_dbus_connection_new_for_address"]
    pub fn g_dbus_connection_new_for_address(
        address: *const gchar,
        flags: GDBusConnectionFlags,
        observer: *mut GDBusAuthObserver,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_dbus_connection_new_for_address_finish"]
    pub fn g_dbus_connection_new_for_address_finish(
        res: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> *mut GDBusConnection;
}
extern "C" {
    #[link_name = "\u{1}_g_dbus_connection_new_for_address_sync"]
    pub fn g_dbus_connection_new_for_address_sync(
        address: *const gchar,
        flags: GDBusConnectionFlags,
        observer: *mut GDBusAuthObserver,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> *mut GDBusConnection;
}
extern "C" {
    #[link_name = "\u{1}_g_dbus_connection_start_message_processing"]
    pub fn g_dbus_connection_start_message_processing(connection: *mut GDBusConnection);
}
extern "C" {
    #[link_name = "\u{1}_g_dbus_connection_is_closed"]
    pub fn g_dbus_connection_is_closed(connection: *mut GDBusConnection) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_dbus_connection_get_stream"]
    pub fn g_dbus_connection_get_stream(connection: *mut GDBusConnection) -> *mut GIOStream;
}
extern "C" {
    #[link_name = "\u{1}_g_dbus_connection_get_guid"]
    pub fn g_dbus_connection_get_guid(connection: *mut GDBusConnection) -> *const gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_dbus_connection_get_unique_name"]
    pub fn g_dbus_connection_get_unique_name(connection: *mut GDBusConnection) -> *const gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_dbus_connection_get_peer_credentials"]
    pub fn g_dbus_connection_get_peer_credentials(
        connection: *mut GDBusConnection,
    ) -> *mut GCredentials;
}
extern "C" {
    #[link_name = "\u{1}_g_dbus_connection_get_last_serial"]
    pub fn g_dbus_connection_get_last_serial(connection: *mut GDBusConnection) -> guint32;
}
extern "C" {
    #[link_name = "\u{1}_g_dbus_connection_get_exit_on_close"]
    pub fn g_dbus_connection_get_exit_on_close(connection: *mut GDBusConnection) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_dbus_connection_set_exit_on_close"]
    pub fn g_dbus_connection_set_exit_on_close(
        connection: *mut GDBusConnection,
        exit_on_close: gboolean,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_dbus_connection_get_capabilities"]
    pub fn g_dbus_connection_get_capabilities(
        connection: *mut GDBusConnection,
    ) -> GDBusCapabilityFlags;
}
extern "C" {
    #[link_name = "\u{1}_g_dbus_connection_close"]
    pub fn g_dbus_connection_close(
        connection: *mut GDBusConnection,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_dbus_connection_close_finish"]
    pub fn g_dbus_connection_close_finish(
        connection: *mut GDBusConnection,
        res: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_dbus_connection_close_sync"]
    pub fn g_dbus_connection_close_sync(
        connection: *mut GDBusConnection,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_dbus_connection_flush"]
    pub fn g_dbus_connection_flush(
        connection: *mut GDBusConnection,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_dbus_connection_flush_finish"]
    pub fn g_dbus_connection_flush_finish(
        connection: *mut GDBusConnection,
        res: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_dbus_connection_flush_sync"]
    pub fn g_dbus_connection_flush_sync(
        connection: *mut GDBusConnection,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_dbus_connection_send_message"]
    pub fn g_dbus_connection_send_message(
        connection: *mut GDBusConnection,
        message: *mut GDBusMessage,
        flags: GDBusSendMessageFlags,
        out_serial: *mut guint32,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_dbus_connection_send_message_with_reply"]
    pub fn g_dbus_connection_send_message_with_reply(
        connection: *mut GDBusConnection,
        message: *mut GDBusMessage,
        flags: GDBusSendMessageFlags,
        timeout_msec: gint,
        out_serial: *mut guint32,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_dbus_connection_send_message_with_reply_finish"]
    pub fn g_dbus_connection_send_message_with_reply_finish(
        connection: *mut GDBusConnection,
        res: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> *mut GDBusMessage;
}
extern "C" {
    #[link_name = "\u{1}_g_dbus_connection_send_message_with_reply_sync"]
    pub fn g_dbus_connection_send_message_with_reply_sync(
        connection: *mut GDBusConnection,
        message: *mut GDBusMessage,
        flags: GDBusSendMessageFlags,
        timeout_msec: gint,
        out_serial: *mut guint32,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> *mut GDBusMessage;
}
extern "C" {
    #[link_name = "\u{1}_g_dbus_connection_emit_signal"]
    pub fn g_dbus_connection_emit_signal(
        connection: *mut GDBusConnection,
        destination_bus_name: *const gchar,
        object_path: *const gchar,
        interface_name: *const gchar,
        signal_name: *const gchar,
        parameters: *mut GVariant,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_dbus_connection_call"]
    pub fn g_dbus_connection_call(
        connection: *mut GDBusConnection,
        bus_name: *const gchar,
        object_path: *const gchar,
        interface_name: *const gchar,
        method_name: *const gchar,
        parameters: *mut GVariant,
        reply_type: *const GVariantType,
        flags: GDBusCallFlags,
        timeout_msec: gint,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_dbus_connection_call_finish"]
    pub fn g_dbus_connection_call_finish(
        connection: *mut GDBusConnection,
        res: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> *mut GVariant;
}
extern "C" {
    #[link_name = "\u{1}_g_dbus_connection_call_sync"]
    pub fn g_dbus_connection_call_sync(
        connection: *mut GDBusConnection,
        bus_name: *const gchar,
        object_path: *const gchar,
        interface_name: *const gchar,
        method_name: *const gchar,
        parameters: *mut GVariant,
        reply_type: *const GVariantType,
        flags: GDBusCallFlags,
        timeout_msec: gint,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> *mut GVariant;
}
extern "C" {
    #[link_name = "\u{1}_g_dbus_connection_call_with_unix_fd_list"]
    pub fn g_dbus_connection_call_with_unix_fd_list(
        connection: *mut GDBusConnection,
        bus_name: *const gchar,
        object_path: *const gchar,
        interface_name: *const gchar,
        method_name: *const gchar,
        parameters: *mut GVariant,
        reply_type: *const GVariantType,
        flags: GDBusCallFlags,
        timeout_msec: gint,
        fd_list: *mut GUnixFDList,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_dbus_connection_call_with_unix_fd_list_finish"]
    pub fn g_dbus_connection_call_with_unix_fd_list_finish(
        connection: *mut GDBusConnection,
        out_fd_list: *mut *mut GUnixFDList,
        res: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> *mut GVariant;
}
extern "C" {
    #[link_name = "\u{1}_g_dbus_connection_call_with_unix_fd_list_sync"]
    pub fn g_dbus_connection_call_with_unix_fd_list_sync(
        connection: *mut GDBusConnection,
        bus_name: *const gchar,
        object_path: *const gchar,
        interface_name: *const gchar,
        method_name: *const gchar,
        parameters: *mut GVariant,
        reply_type: *const GVariantType,
        flags: GDBusCallFlags,
        timeout_msec: gint,
        fd_list: *mut GUnixFDList,
        out_fd_list: *mut *mut GUnixFDList,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> *mut GVariant;
}
/// GDBusInterfaceMethodCallFunc:
/// @connection: A #GDBusConnection.
/// @sender: The unique bus name of the remote caller.
/// @object_path: The object path that the method was invoked on.
/// @interface_name: The D-Bus interface name the method was invoked on.
/// @method_name: The name of the method that was invoked.
/// @parameters: A #GVariant tuple with parameters.
/// @invocation: (transfer full): A #GDBusMethodInvocation object that must be used to return a value or error.
/// @user_data: The @user_data #gpointer passed to g_dbus_connection_register_object().
///
/// The type of the @method_call function in #GDBusInterfaceVTable.
///
/// Since: 2.26
pub type GDBusInterfaceMethodCallFunc = ::std::option::Option<
    unsafe extern "C" fn(
        connection: *mut GDBusConnection,
        sender: *const gchar,
        object_path: *const gchar,
        interface_name: *const gchar,
        method_name: *const gchar,
        parameters: *mut GVariant,
        invocation: *mut GDBusMethodInvocation,
        user_data: gpointer,
    ),
>;
/// GDBusInterfaceGetPropertyFunc:
/// @connection: A #GDBusConnection.
/// @sender: The unique bus name of the remote caller.
/// @object_path: The object path that the method was invoked on.
/// @interface_name: The D-Bus interface name for the property.
/// @property_name: The name of the property to get the value of.
/// @error: Return location for error.
/// @user_data: The @user_data #gpointer passed to g_dbus_connection_register_object().
///
/// The type of the @get_property function in #GDBusInterfaceVTable.
///
/// Returns: A #GVariant with the value for @property_name or %NULL if
/// @error is set. If the returned #GVariant is floating, it is
/// consumed - otherwise its reference count is decreased by one.
///
/// Since: 2.26
pub type GDBusInterfaceGetPropertyFunc = ::std::option::Option<
    unsafe extern "C" fn(
        connection: *mut GDBusConnection,
        sender: *const gchar,
        object_path: *const gchar,
        interface_name: *const gchar,
        property_name: *const gchar,
        error: *mut *mut GError,
        user_data: gpointer,
    ) -> *mut GVariant,
>;
/// GDBusInterfaceSetPropertyFunc:
/// @connection: A #GDBusConnection.
/// @sender: The unique bus name of the remote caller.
/// @object_path: The object path that the method was invoked on.
/// @interface_name: The D-Bus interface name for the property.
/// @property_name: The name of the property to get the value of.
/// @value: The value to set the property to.
/// @error: Return location for error.
/// @user_data: The @user_data #gpointer passed to g_dbus_connection_register_object().
///
/// The type of the @set_property function in #GDBusInterfaceVTable.
///
/// Returns: %TRUE if the property was set to @value, %FALSE if @error is set.
///
/// Since: 2.26
pub type GDBusInterfaceSetPropertyFunc = ::std::option::Option<
    unsafe extern "C" fn(
        connection: *mut GDBusConnection,
        sender: *const gchar,
        object_path: *const gchar,
        interface_name: *const gchar,
        property_name: *const gchar,
        value: *mut GVariant,
        error: *mut *mut GError,
        user_data: gpointer,
    ) -> gboolean,
>;
/// GDBusInterfaceVTable:
/// @method_call: Function for handling incoming method calls.
/// @get_property: Function for getting a property.
/// @set_property: Function for setting a property.
///
/// Virtual table for handling properties and method calls for a D-Bus
/// interface.
///
/// Since 2.38, if you want to handle getting/setting D-Bus properties
/// asynchronously, give %NULL as your get_property() or set_property()
/// function. The D-Bus call will be directed to your @method_call function,
/// with the provided @interface_name set to "org.freedesktop.DBus.Properties".
///
/// Ownership of the #GDBusMethodInvocation object passed to the
/// method_call() function is transferred to your handler; you must
/// call one of the methods of #GDBusMethodInvocation to return a reply
/// (possibly empty), or an error. These functions also take ownership
/// of the passed-in invocation object, so unless the invocation
/// object has otherwise been referenced, it will be then be freed.
/// Calling one of these functions may be done within your
/// method_call() implementation but it also can be done at a later
/// point to handle the method asynchronously.
///
/// The usual checks on the validity of the calls is performed. For
/// `Get` calls, an error is automatically returned if the property does
/// not exist or the permissions do not allow access. The same checks are
/// performed for `Set` calls, and the provided value is also checked for
/// being the correct type.
///
/// For both `Get` and `Set` calls, the #GDBusMethodInvocation
/// passed to the @method_call handler can be queried with
/// g_dbus_method_invocation_get_property_info() to get a pointer
/// to the #GDBusPropertyInfo of the property.
///
/// If you have readable properties specified in your interface info,
/// you must ensure that you either provide a non-%NULL @get_property()
/// function or provide implementations of both the `Get` and `GetAll`
/// methods on org.freedesktop.DBus.Properties interface in your @method_call
/// function. Note that the required return type of the `Get` call is
/// `(v)`, not the type of the property. `GetAll` expects a return value
/// of type `a{sv}`.
///
/// If you have writable properties specified in your interface info,
/// you must ensure that you either provide a non-%NULL @set_property()
/// function or provide an implementation of the `Set` call. If implementing
/// the call, you must return the value of type %G_VARIANT_TYPE_UNIT.
///
/// Since: 2.26
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GDBusInterfaceVTable {
    pub method_call: GDBusInterfaceMethodCallFunc,
    pub get_property: GDBusInterfaceGetPropertyFunc,
    pub set_property: GDBusInterfaceSetPropertyFunc,
    pub padding: [gpointer; 8usize],
}
#[test]
fn bindgen_test_layout__GDBusInterfaceVTable() {
    assert_eq!(
        ::std::mem::size_of::<_GDBusInterfaceVTable>(),
        88usize,
        concat!("Size of: ", stringify!(_GDBusInterfaceVTable))
    );
    assert_eq!(
        ::std::mem::align_of::<_GDBusInterfaceVTable>(),
        8usize,
        concat!("Alignment of ", stringify!(_GDBusInterfaceVTable))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GDBusInterfaceVTable>())).method_call as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDBusInterfaceVTable),
            "::",
            stringify!(method_call)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GDBusInterfaceVTable>())).get_property as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDBusInterfaceVTable),
            "::",
            stringify!(get_property)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GDBusInterfaceVTable>())).set_property as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDBusInterfaceVTable),
            "::",
            stringify!(set_property)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GDBusInterfaceVTable>())).padding as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDBusInterfaceVTable),
            "::",
            stringify!(padding)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_g_dbus_connection_register_object"]
    pub fn g_dbus_connection_register_object(
        connection: *mut GDBusConnection,
        object_path: *const gchar,
        interface_info: *mut GDBusInterfaceInfo,
        vtable: *const GDBusInterfaceVTable,
        user_data: gpointer,
        user_data_free_func: GDestroyNotify,
        error: *mut *mut GError,
    ) -> guint;
}
extern "C" {
    #[link_name = "\u{1}_g_dbus_connection_register_object_with_closures"]
    pub fn g_dbus_connection_register_object_with_closures(
        connection: *mut GDBusConnection,
        object_path: *const gchar,
        interface_info: *mut GDBusInterfaceInfo,
        method_call_closure: *mut GClosure,
        get_property_closure: *mut GClosure,
        set_property_closure: *mut GClosure,
        error: *mut *mut GError,
    ) -> guint;
}
extern "C" {
    #[link_name = "\u{1}_g_dbus_connection_unregister_object"]
    pub fn g_dbus_connection_unregister_object(
        connection: *mut GDBusConnection,
        registration_id: guint,
    ) -> gboolean;
}
/// GDBusSubtreeEnumerateFunc:
/// @connection: A #GDBusConnection.
/// @sender: The unique bus name of the remote caller.
/// @object_path: The object path that was registered with g_dbus_connection_register_subtree().
/// @user_data: The @user_data #gpointer passed to g_dbus_connection_register_subtree().
///
/// The type of the @enumerate function in #GDBusSubtreeVTable.
///
/// This function is called when generating introspection data and also
/// when preparing to dispatch incoming messages in the event that the
/// %G_DBUS_SUBTREE_FLAGS_DISPATCH_TO_UNENUMERATED_NODES flag is not
/// specified (ie: to verify that the object path is valid).
///
/// Hierarchies are not supported; the items that you return should not
/// contain the '/' character.
///
/// The return value will be freed with g_strfreev().
///
/// Returns: A newly allocated array of strings for node names that are children of @object_path.
///
/// Since: 2.26
pub type GDBusSubtreeEnumerateFunc = ::std::option::Option<
    unsafe extern "C" fn(
        connection: *mut GDBusConnection,
        sender: *const gchar,
        object_path: *const gchar,
        user_data: gpointer,
    ) -> *mut *mut gchar,
>;
/// GDBusSubtreeIntrospectFunc:
/// @connection: A #GDBusConnection.
/// @sender: The unique bus name of the remote caller.
/// @object_path: The object path that was registered with g_dbus_connection_register_subtree().
/// @node: A node that is a child of @object_path (relative to @object_path) or %NULL for the root of the subtree.
/// @user_data: The @user_data #gpointer passed to g_dbus_connection_register_subtree().
///
/// The type of the @introspect function in #GDBusSubtreeVTable.
///
/// Subtrees are flat.  @node, if non-%NULL, is always exactly one
/// segment of the object path (ie: it never contains a slash).
///
/// This function should return %NULL to indicate that there is no object
/// at this node.
///
/// If this function returns non-%NULL, the return value is expected to
/// be a %NULL-terminated array of pointers to #GDBusInterfaceInfo
/// structures describing the interfaces implemented by @node.  This
/// array will have g_dbus_interface_info_unref() called on each item
/// before being freed with g_free().
///
/// The difference between returning %NULL and an array containing zero
/// items is that the standard DBus interfaces will returned to the
/// remote introspector in the empty array case, but not in the %NULL
/// case.
///
/// Returns: A %NULL-terminated array of pointers to #GDBusInterfaceInfo, or %NULL.
///
/// Since: 2.26
pub type GDBusSubtreeIntrospectFunc = ::std::option::Option<
    unsafe extern "C" fn(
        connection: *mut GDBusConnection,
        sender: *const gchar,
        object_path: *const gchar,
        node: *const gchar,
        user_data: gpointer,
    ) -> *mut *mut GDBusInterfaceInfo,
>;
/// GDBusSubtreeDispatchFunc:
/// @connection: A #GDBusConnection.
/// @sender: The unique bus name of the remote caller.
/// @object_path: The object path that was registered with g_dbus_connection_register_subtree().
/// @interface_name: The D-Bus interface name that the method call or property access is for.
/// @node: A node that is a child of @object_path (relative to @object_path) or %NULL for the root of the subtree.
/// @out_user_data: (nullable) (not optional): Return location for user data to pass to functions in the returned #GDBusInterfaceVTable (never %NULL).
/// @user_data: The @user_data #gpointer passed to g_dbus_connection_register_subtree().
///
/// The type of the @dispatch function in #GDBusSubtreeVTable.
///
/// Subtrees are flat.  @node, if non-%NULL, is always exactly one
/// segment of the object path (ie: it never contains a slash).
///
/// Returns: A #GDBusInterfaceVTable or %NULL if you don't want to handle the methods.
///
/// Since: 2.26
pub type GDBusSubtreeDispatchFunc = ::std::option::Option<
    unsafe extern "C" fn(
        connection: *mut GDBusConnection,
        sender: *const gchar,
        object_path: *const gchar,
        interface_name: *const gchar,
        node: *const gchar,
        out_user_data: *mut gpointer,
        user_data: gpointer,
    ) -> *const GDBusInterfaceVTable,
>;
/// GDBusSubtreeVTable:
/// @enumerate: Function for enumerating child nodes.
/// @introspect: Function for introspecting a child node.
/// @dispatch: Function for dispatching a remote call on a child node.
///
/// Virtual table for handling subtrees registered with g_dbus_connection_register_subtree().
///
/// Since: 2.26
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GDBusSubtreeVTable {
    pub enumerate: GDBusSubtreeEnumerateFunc,
    pub introspect: GDBusSubtreeIntrospectFunc,
    pub dispatch: GDBusSubtreeDispatchFunc,
    pub padding: [gpointer; 8usize],
}
#[test]
fn bindgen_test_layout__GDBusSubtreeVTable() {
    assert_eq!(
        ::std::mem::size_of::<_GDBusSubtreeVTable>(),
        88usize,
        concat!("Size of: ", stringify!(_GDBusSubtreeVTable))
    );
    assert_eq!(
        ::std::mem::align_of::<_GDBusSubtreeVTable>(),
        8usize,
        concat!("Alignment of ", stringify!(_GDBusSubtreeVTable))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GDBusSubtreeVTable>())).enumerate as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDBusSubtreeVTable),
            "::",
            stringify!(enumerate)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GDBusSubtreeVTable>())).introspect as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDBusSubtreeVTable),
            "::",
            stringify!(introspect)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GDBusSubtreeVTable>())).dispatch as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDBusSubtreeVTable),
            "::",
            stringify!(dispatch)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GDBusSubtreeVTable>())).padding as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDBusSubtreeVTable),
            "::",
            stringify!(padding)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_g_dbus_connection_register_subtree"]
    pub fn g_dbus_connection_register_subtree(
        connection: *mut GDBusConnection,
        object_path: *const gchar,
        vtable: *const GDBusSubtreeVTable,
        flags: GDBusSubtreeFlags,
        user_data: gpointer,
        user_data_free_func: GDestroyNotify,
        error: *mut *mut GError,
    ) -> guint;
}
extern "C" {
    #[link_name = "\u{1}_g_dbus_connection_unregister_subtree"]
    pub fn g_dbus_connection_unregister_subtree(
        connection: *mut GDBusConnection,
        registration_id: guint,
    ) -> gboolean;
}
/// GDBusSignalCallback:
/// @connection: A #GDBusConnection.
/// @sender_name: The unique bus name of the sender of the signal.
/// @object_path: The object path that the signal was emitted on.
/// @interface_name: The name of the interface.
/// @signal_name: The name of the signal.
/// @parameters: A #GVariant tuple with parameters for the signal.
/// @user_data: User data passed when subscribing to the signal.
///
/// Signature for callback function used in g_dbus_connection_signal_subscribe().
///
/// Since: 2.26
pub type GDBusSignalCallback = ::std::option::Option<
    unsafe extern "C" fn(
        connection: *mut GDBusConnection,
        sender_name: *const gchar,
        object_path: *const gchar,
        interface_name: *const gchar,
        signal_name: *const gchar,
        parameters: *mut GVariant,
        user_data: gpointer,
    ),
>;
extern "C" {
    #[link_name = "\u{1}_g_dbus_connection_signal_subscribe"]
    pub fn g_dbus_connection_signal_subscribe(
        connection: *mut GDBusConnection,
        sender: *const gchar,
        interface_name: *const gchar,
        member: *const gchar,
        object_path: *const gchar,
        arg0: *const gchar,
        flags: GDBusSignalFlags,
        callback: GDBusSignalCallback,
        user_data: gpointer,
        user_data_free_func: GDestroyNotify,
    ) -> guint;
}
extern "C" {
    #[link_name = "\u{1}_g_dbus_connection_signal_unsubscribe"]
    pub fn g_dbus_connection_signal_unsubscribe(
        connection: *mut GDBusConnection,
        subscription_id: guint,
    );
}
/// GDBusMessageFilterFunction:
/// @connection: (transfer none): A #GDBusConnection.
/// @message: (transfer full): A locked #GDBusMessage that the filter function takes ownership of.
/// @incoming: %TRUE if it is a message received from the other peer, %FALSE if it is
/// a message to be sent to the other peer.
/// @user_data: User data passed when adding the filter.
///
/// Signature for function used in g_dbus_connection_add_filter().
///
/// A filter function is passed a #GDBusMessage and expected to return
/// a #GDBusMessage too. Passive filter functions that don't modify the
/// message can simply return the @message object:
/// |[
/// static GDBusMessage *
/// passive_filter (GDBusConnection *connection
/// GDBusMessage    *message,
/// gboolean         incoming,
/// gpointer         user_data)
/// {
/// /<!-- -->* inspect @message *<!-- -->/
/// return message;
/// }
/// ]|
/// Filter functions that wants to drop a message can simply return %NULL:
/// |[
/// static GDBusMessage *
/// drop_filter (GDBusConnection *connection
/// GDBusMessage    *message,
/// gboolean         incoming,
/// gpointer         user_data)
/// {
/// if (should_drop_message)
/// {
/// g_object_unref (message);
/// message = NULL;
/// }
/// return message;
/// }
/// ]|
/// Finally, a filter function may modify a message by copying it:
/// |[
/// static GDBusMessage *
/// modifying_filter (GDBusConnection *connection
/// GDBusMessage    *message,
/// gboolean         incoming,
/// gpointer         user_data)
/// {
/// GDBusMessage *copy;
/// GError *error;
///
/// error = NULL;
/// copy = g_dbus_message_copy (message, &error);
/// /<!-- -->* handle @error being is set *<!-- -->/
/// g_object_unref (message);
///
/// /<!-- -->* modify @copy *<!-- -->/
///
/// return copy;
/// }
/// ]|
/// If the returned #GDBusMessage is different from @message and cannot
/// be sent on @connection (it could use features, such as file
/// descriptors, not compatible with @connection), then a warning is
/// logged to standard error. Applications can
/// check this ahead of time using g_dbus_message_to_blob() passing a
/// #GDBusCapabilityFlags value obtained from @connection.
///
/// Returns: (transfer full) (nullable): A #GDBusMessage that will be freed with
/// g_object_unref() or %NULL to drop the message. Passive filter
/// functions can simply return the passed @message object.
///
/// Since: 2.26
pub type GDBusMessageFilterFunction = ::std::option::Option<
    unsafe extern "C" fn(
        connection: *mut GDBusConnection,
        message: *mut GDBusMessage,
        incoming: gboolean,
        user_data: gpointer,
    ) -> *mut GDBusMessage,
>;
extern "C" {
    #[link_name = "\u{1}_g_dbus_connection_add_filter"]
    pub fn g_dbus_connection_add_filter(
        connection: *mut GDBusConnection,
        filter_function: GDBusMessageFilterFunction,
        user_data: gpointer,
        user_data_free_func: GDestroyNotify,
    ) -> guint;
}
extern "C" {
    #[link_name = "\u{1}_g_dbus_connection_remove_filter"]
    pub fn g_dbus_connection_remove_filter(connection: *mut GDBusConnection, filter_id: guint);
}
extern "C" {
    #[link_name = "\u{1}_g_dbus_error_quark"]
    pub fn g_dbus_error_quark() -> GQuark;
}
extern "C" {
    #[link_name = "\u{1}_g_dbus_error_is_remote_error"]
    pub fn g_dbus_error_is_remote_error(error: *const GError) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_dbus_error_get_remote_error"]
    pub fn g_dbus_error_get_remote_error(error: *const GError) -> *mut gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_dbus_error_strip_remote_error"]
    pub fn g_dbus_error_strip_remote_error(error: *mut GError) -> gboolean;
}
/// GDBusErrorEntry:
/// @error_code: An error code.
/// @dbus_error_name: The D-Bus error name to associate with @error_code.
///
/// Struct used in g_dbus_error_register_error_domain().
///
/// Since: 2.26
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GDBusErrorEntry {
    pub error_code: gint,
    pub dbus_error_name: *const gchar,
}
#[test]
fn bindgen_test_layout__GDBusErrorEntry() {
    assert_eq!(
        ::std::mem::size_of::<_GDBusErrorEntry>(),
        16usize,
        concat!("Size of: ", stringify!(_GDBusErrorEntry))
    );
    assert_eq!(
        ::std::mem::align_of::<_GDBusErrorEntry>(),
        8usize,
        concat!("Alignment of ", stringify!(_GDBusErrorEntry))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GDBusErrorEntry>())).error_code as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDBusErrorEntry),
            "::",
            stringify!(error_code)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GDBusErrorEntry>())).dbus_error_name as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDBusErrorEntry),
            "::",
            stringify!(dbus_error_name)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_g_dbus_error_register_error"]
    pub fn g_dbus_error_register_error(
        error_domain: GQuark,
        error_code: gint,
        dbus_error_name: *const gchar,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_dbus_error_unregister_error"]
    pub fn g_dbus_error_unregister_error(
        error_domain: GQuark,
        error_code: gint,
        dbus_error_name: *const gchar,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_dbus_error_register_error_domain"]
    pub fn g_dbus_error_register_error_domain(
        error_domain_quark_name: *const gchar,
        quark_volatile: *mut gsize,
        entries: *const GDBusErrorEntry,
        num_entries: guint,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_dbus_error_new_for_dbus_error"]
    pub fn g_dbus_error_new_for_dbus_error(
        dbus_error_name: *const gchar,
        dbus_error_message: *const gchar,
    ) -> *mut GError;
}
extern "C" {
    #[link_name = "\u{1}_g_dbus_error_set_dbus_error"]
    pub fn g_dbus_error_set_dbus_error(
        error: *mut *mut GError,
        dbus_error_name: *const gchar,
        dbus_error_message: *const gchar,
        format: *const gchar,
        ...
    );
}
extern "C" {
    #[link_name = "\u{1}_g_dbus_error_set_dbus_error_valist"]
    pub fn g_dbus_error_set_dbus_error_valist(
        error: *mut *mut GError,
        dbus_error_name: *const gchar,
        dbus_error_message: *const gchar,
        format: *const gchar,
        var_args: *mut __va_list_tag,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_dbus_error_encode_gerror"]
    pub fn g_dbus_error_encode_gerror(error: *const GError) -> *mut gchar;
}
/// GDBusAnnotationInfo:
/// @ref_count: The reference count or -1 if statically allocated.
/// @key: The name of the annotation, e.g. "org.freedesktop.DBus.Deprecated".
/// @value: The value of the annotation.
/// @annotations: (array zero-terminated=1): A pointer to a %NULL-terminated array of pointers to #GDBusAnnotationInfo structures or %NULL if there are no annotations.
///
/// Information about an annotation.
///
/// Since: 2.26
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GDBusAnnotationInfo {
    pub ref_count: gint,
    pub key: *mut gchar,
    pub value: *mut gchar,
    pub annotations: *mut *mut GDBusAnnotationInfo,
}
#[test]
fn bindgen_test_layout__GDBusAnnotationInfo() {
    assert_eq!(
        ::std::mem::size_of::<_GDBusAnnotationInfo>(),
        32usize,
        concat!("Size of: ", stringify!(_GDBusAnnotationInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<_GDBusAnnotationInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(_GDBusAnnotationInfo))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GDBusAnnotationInfo>())).ref_count as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDBusAnnotationInfo),
            "::",
            stringify!(ref_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GDBusAnnotationInfo>())).key as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDBusAnnotationInfo),
            "::",
            stringify!(key)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GDBusAnnotationInfo>())).value as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDBusAnnotationInfo),
            "::",
            stringify!(value)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GDBusAnnotationInfo>())).annotations as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDBusAnnotationInfo),
            "::",
            stringify!(annotations)
        )
    );
}
/// GDBusArgInfo:
/// @ref_count: The reference count or -1 if statically allocated.
/// @name: Name of the argument, e.g. @unix_user_id.
/// @signature: D-Bus signature of the argument (a single complete type).
/// @annotations: (array zero-terminated=1): A pointer to a %NULL-terminated array of pointers to #GDBusAnnotationInfo structures or %NULL if there are no annotations.
///
/// Information about an argument for a method or a signal.
///
/// Since: 2.26
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GDBusArgInfo {
    pub ref_count: gint,
    pub name: *mut gchar,
    pub signature: *mut gchar,
    pub annotations: *mut *mut GDBusAnnotationInfo,
}
#[test]
fn bindgen_test_layout__GDBusArgInfo() {
    assert_eq!(
        ::std::mem::size_of::<_GDBusArgInfo>(),
        32usize,
        concat!("Size of: ", stringify!(_GDBusArgInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<_GDBusArgInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(_GDBusArgInfo))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GDBusArgInfo>())).ref_count as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDBusArgInfo),
            "::",
            stringify!(ref_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GDBusArgInfo>())).name as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDBusArgInfo),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GDBusArgInfo>())).signature as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDBusArgInfo),
            "::",
            stringify!(signature)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GDBusArgInfo>())).annotations as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDBusArgInfo),
            "::",
            stringify!(annotations)
        )
    );
}
/// GDBusMethodInfo:
/// @ref_count: The reference count or -1 if statically allocated.
/// @name: The name of the D-Bus method, e.g. @RequestName.
/// @in_args: (array zero-terminated=1): A pointer to a %NULL-terminated array of pointers to #GDBusArgInfo structures or %NULL if there are no in arguments.
/// @out_args: (array zero-terminated=1): A pointer to a %NULL-terminated array of pointers to #GDBusArgInfo structures or %NULL if there are no out arguments.
/// @annotations: (array zero-terminated=1): A pointer to a %NULL-terminated array of pointers to #GDBusAnnotationInfo structures or %NULL if there are no annotations.
///
/// Information about a method on an D-Bus interface.
///
/// Since: 2.26
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GDBusMethodInfo {
    pub ref_count: gint,
    pub name: *mut gchar,
    pub in_args: *mut *mut GDBusArgInfo,
    pub out_args: *mut *mut GDBusArgInfo,
    pub annotations: *mut *mut GDBusAnnotationInfo,
}
#[test]
fn bindgen_test_layout__GDBusMethodInfo() {
    assert_eq!(
        ::std::mem::size_of::<_GDBusMethodInfo>(),
        40usize,
        concat!("Size of: ", stringify!(_GDBusMethodInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<_GDBusMethodInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(_GDBusMethodInfo))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GDBusMethodInfo>())).ref_count as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDBusMethodInfo),
            "::",
            stringify!(ref_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GDBusMethodInfo>())).name as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDBusMethodInfo),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GDBusMethodInfo>())).in_args as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDBusMethodInfo),
            "::",
            stringify!(in_args)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GDBusMethodInfo>())).out_args as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDBusMethodInfo),
            "::",
            stringify!(out_args)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GDBusMethodInfo>())).annotations as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDBusMethodInfo),
            "::",
            stringify!(annotations)
        )
    );
}
/// GDBusSignalInfo:
/// @ref_count: The reference count or -1 if statically allocated.
/// @name: The name of the D-Bus signal, e.g. "NameOwnerChanged".
/// @args: (array zero-terminated=1): A pointer to a %NULL-terminated array of pointers to #GDBusArgInfo structures or %NULL if there are no arguments.
/// @annotations: (array zero-terminated=1): A pointer to a %NULL-terminated array of pointers to #GDBusAnnotationInfo structures or %NULL if there are no annotations.
///
/// Information about a signal on a D-Bus interface.
///
/// Since: 2.26
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GDBusSignalInfo {
    pub ref_count: gint,
    pub name: *mut gchar,
    pub args: *mut *mut GDBusArgInfo,
    pub annotations: *mut *mut GDBusAnnotationInfo,
}
#[test]
fn bindgen_test_layout__GDBusSignalInfo() {
    assert_eq!(
        ::std::mem::size_of::<_GDBusSignalInfo>(),
        32usize,
        concat!("Size of: ", stringify!(_GDBusSignalInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<_GDBusSignalInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(_GDBusSignalInfo))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GDBusSignalInfo>())).ref_count as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDBusSignalInfo),
            "::",
            stringify!(ref_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GDBusSignalInfo>())).name as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDBusSignalInfo),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GDBusSignalInfo>())).args as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDBusSignalInfo),
            "::",
            stringify!(args)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GDBusSignalInfo>())).annotations as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDBusSignalInfo),
            "::",
            stringify!(annotations)
        )
    );
}
/// GDBusPropertyInfo:
/// @ref_count: The reference count or -1 if statically allocated.
/// @name: The name of the D-Bus property, e.g. "SupportedFilesystems".
/// @signature: The D-Bus signature of the property (a single complete type).
/// @flags: Access control flags for the property.
/// @annotations: (array zero-terminated=1): A pointer to a %NULL-terminated array of pointers to #GDBusAnnotationInfo structures or %NULL if there are no annotations.
///
/// Information about a D-Bus property on a D-Bus interface.
///
/// Since: 2.26
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GDBusPropertyInfo {
    pub ref_count: gint,
    pub name: *mut gchar,
    pub signature: *mut gchar,
    pub flags: GDBusPropertyInfoFlags,
    pub annotations: *mut *mut GDBusAnnotationInfo,
}
#[test]
fn bindgen_test_layout__GDBusPropertyInfo() {
    assert_eq!(
        ::std::mem::size_of::<_GDBusPropertyInfo>(),
        40usize,
        concat!("Size of: ", stringify!(_GDBusPropertyInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<_GDBusPropertyInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(_GDBusPropertyInfo))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GDBusPropertyInfo>())).ref_count as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDBusPropertyInfo),
            "::",
            stringify!(ref_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GDBusPropertyInfo>())).name as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDBusPropertyInfo),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GDBusPropertyInfo>())).signature as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDBusPropertyInfo),
            "::",
            stringify!(signature)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GDBusPropertyInfo>())).flags as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDBusPropertyInfo),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GDBusPropertyInfo>())).annotations as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDBusPropertyInfo),
            "::",
            stringify!(annotations)
        )
    );
}
/// GDBusInterfaceInfo:
/// @ref_count: The reference count or -1 if statically allocated.
/// @name: The name of the D-Bus interface, e.g. "org.freedesktop.DBus.Properties".
/// @methods: (array zero-terminated=1): A pointer to a %NULL-terminated array of pointers to #GDBusMethodInfo structures or %NULL if there are no methods.
/// @signals: (array zero-terminated=1): A pointer to a %NULL-terminated array of pointers to #GDBusSignalInfo structures or %NULL if there are no signals.
/// @properties: (array zero-terminated=1): A pointer to a %NULL-terminated array of pointers to #GDBusPropertyInfo structures or %NULL if there are no properties.
/// @annotations: (array zero-terminated=1): A pointer to a %NULL-terminated array of pointers to #GDBusAnnotationInfo structures or %NULL if there are no annotations.
///
/// Information about a D-Bus interface.
///
/// Since: 2.26
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GDBusInterfaceInfo {
    pub ref_count: gint,
    pub name: *mut gchar,
    pub methods: *mut *mut GDBusMethodInfo,
    pub signals: *mut *mut GDBusSignalInfo,
    pub properties: *mut *mut GDBusPropertyInfo,
    pub annotations: *mut *mut GDBusAnnotationInfo,
}
#[test]
fn bindgen_test_layout__GDBusInterfaceInfo() {
    assert_eq!(
        ::std::mem::size_of::<_GDBusInterfaceInfo>(),
        48usize,
        concat!("Size of: ", stringify!(_GDBusInterfaceInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<_GDBusInterfaceInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(_GDBusInterfaceInfo))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GDBusInterfaceInfo>())).ref_count as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDBusInterfaceInfo),
            "::",
            stringify!(ref_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GDBusInterfaceInfo>())).name as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDBusInterfaceInfo),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GDBusInterfaceInfo>())).methods as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDBusInterfaceInfo),
            "::",
            stringify!(methods)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GDBusInterfaceInfo>())).signals as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDBusInterfaceInfo),
            "::",
            stringify!(signals)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GDBusInterfaceInfo>())).properties as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDBusInterfaceInfo),
            "::",
            stringify!(properties)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GDBusInterfaceInfo>())).annotations as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDBusInterfaceInfo),
            "::",
            stringify!(annotations)
        )
    );
}
/// GDBusNodeInfo:
/// @ref_count: The reference count or -1 if statically allocated.
/// @path: The path of the node or %NULL if omitted. Note that this may be a relative path. See the D-Bus specification for more details.
/// @interfaces: (array zero-terminated=1): A pointer to a %NULL-terminated array of pointers to #GDBusInterfaceInfo structures or %NULL if there are no interfaces.
/// @nodes: (array zero-terminated=1): A pointer to a %NULL-terminated array of pointers to #GDBusNodeInfo structures or %NULL if there are no nodes.
/// @annotations: (array zero-terminated=1): A pointer to a %NULL-terminated array of pointers to #GDBusAnnotationInfo structures or %NULL if there are no annotations.
///
/// Information about nodes in a remote object hierarchy.
///
/// Since: 2.26
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GDBusNodeInfo {
    pub ref_count: gint,
    pub path: *mut gchar,
    pub interfaces: *mut *mut GDBusInterfaceInfo,
    pub nodes: *mut *mut GDBusNodeInfo,
    pub annotations: *mut *mut GDBusAnnotationInfo,
}
#[test]
fn bindgen_test_layout__GDBusNodeInfo() {
    assert_eq!(
        ::std::mem::size_of::<_GDBusNodeInfo>(),
        40usize,
        concat!("Size of: ", stringify!(_GDBusNodeInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<_GDBusNodeInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(_GDBusNodeInfo))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GDBusNodeInfo>())).ref_count as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDBusNodeInfo),
            "::",
            stringify!(ref_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GDBusNodeInfo>())).path as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDBusNodeInfo),
            "::",
            stringify!(path)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GDBusNodeInfo>())).interfaces as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDBusNodeInfo),
            "::",
            stringify!(interfaces)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GDBusNodeInfo>())).nodes as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDBusNodeInfo),
            "::",
            stringify!(nodes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GDBusNodeInfo>())).annotations as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDBusNodeInfo),
            "::",
            stringify!(annotations)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_g_dbus_annotation_info_lookup"]
    pub fn g_dbus_annotation_info_lookup(
        annotations: *mut *mut GDBusAnnotationInfo,
        name: *const gchar,
    ) -> *const gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_dbus_interface_info_lookup_method"]
    pub fn g_dbus_interface_info_lookup_method(
        info: *mut GDBusInterfaceInfo,
        name: *const gchar,
    ) -> *mut GDBusMethodInfo;
}
extern "C" {
    #[link_name = "\u{1}_g_dbus_interface_info_lookup_signal"]
    pub fn g_dbus_interface_info_lookup_signal(
        info: *mut GDBusInterfaceInfo,
        name: *const gchar,
    ) -> *mut GDBusSignalInfo;
}
extern "C" {
    #[link_name = "\u{1}_g_dbus_interface_info_lookup_property"]
    pub fn g_dbus_interface_info_lookup_property(
        info: *mut GDBusInterfaceInfo,
        name: *const gchar,
    ) -> *mut GDBusPropertyInfo;
}
extern "C" {
    #[link_name = "\u{1}_g_dbus_interface_info_cache_build"]
    pub fn g_dbus_interface_info_cache_build(info: *mut GDBusInterfaceInfo);
}
extern "C" {
    #[link_name = "\u{1}_g_dbus_interface_info_cache_release"]
    pub fn g_dbus_interface_info_cache_release(info: *mut GDBusInterfaceInfo);
}
extern "C" {
    #[link_name = "\u{1}_g_dbus_interface_info_generate_xml"]
    pub fn g_dbus_interface_info_generate_xml(
        info: *mut GDBusInterfaceInfo,
        indent: guint,
        string_builder: *mut GString,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_dbus_node_info_new_for_xml"]
    pub fn g_dbus_node_info_new_for_xml(
        xml_data: *const gchar,
        error: *mut *mut GError,
    ) -> *mut GDBusNodeInfo;
}
extern "C" {
    #[link_name = "\u{1}_g_dbus_node_info_lookup_interface"]
    pub fn g_dbus_node_info_lookup_interface(
        info: *mut GDBusNodeInfo,
        name: *const gchar,
    ) -> *mut GDBusInterfaceInfo;
}
extern "C" {
    #[link_name = "\u{1}_g_dbus_node_info_generate_xml"]
    pub fn g_dbus_node_info_generate_xml(
        info: *mut GDBusNodeInfo,
        indent: guint,
        string_builder: *mut GString,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_dbus_node_info_ref"]
    pub fn g_dbus_node_info_ref(info: *mut GDBusNodeInfo) -> *mut GDBusNodeInfo;
}
extern "C" {
    #[link_name = "\u{1}_g_dbus_interface_info_ref"]
    pub fn g_dbus_interface_info_ref(info: *mut GDBusInterfaceInfo) -> *mut GDBusInterfaceInfo;
}
extern "C" {
    #[link_name = "\u{1}_g_dbus_method_info_ref"]
    pub fn g_dbus_method_info_ref(info: *mut GDBusMethodInfo) -> *mut GDBusMethodInfo;
}
extern "C" {
    #[link_name = "\u{1}_g_dbus_signal_info_ref"]
    pub fn g_dbus_signal_info_ref(info: *mut GDBusSignalInfo) -> *mut GDBusSignalInfo;
}
extern "C" {
    #[link_name = "\u{1}_g_dbus_property_info_ref"]
    pub fn g_dbus_property_info_ref(info: *mut GDBusPropertyInfo) -> *mut GDBusPropertyInfo;
}
extern "C" {
    #[link_name = "\u{1}_g_dbus_arg_info_ref"]
    pub fn g_dbus_arg_info_ref(info: *mut GDBusArgInfo) -> *mut GDBusArgInfo;
}
extern "C" {
    #[link_name = "\u{1}_g_dbus_annotation_info_ref"]
    pub fn g_dbus_annotation_info_ref(info: *mut GDBusAnnotationInfo) -> *mut GDBusAnnotationInfo;
}
extern "C" {
    #[link_name = "\u{1}_g_dbus_node_info_unref"]
    pub fn g_dbus_node_info_unref(info: *mut GDBusNodeInfo);
}
extern "C" {
    #[link_name = "\u{1}_g_dbus_interface_info_unref"]
    pub fn g_dbus_interface_info_unref(info: *mut GDBusInterfaceInfo);
}
extern "C" {
    #[link_name = "\u{1}_g_dbus_method_info_unref"]
    pub fn g_dbus_method_info_unref(info: *mut GDBusMethodInfo);
}
extern "C" {
    #[link_name = "\u{1}_g_dbus_signal_info_unref"]
    pub fn g_dbus_signal_info_unref(info: *mut GDBusSignalInfo);
}
extern "C" {
    #[link_name = "\u{1}_g_dbus_property_info_unref"]
    pub fn g_dbus_property_info_unref(info: *mut GDBusPropertyInfo);
}
extern "C" {
    #[link_name = "\u{1}_g_dbus_arg_info_unref"]
    pub fn g_dbus_arg_info_unref(info: *mut GDBusArgInfo);
}
extern "C" {
    #[link_name = "\u{1}_g_dbus_annotation_info_unref"]
    pub fn g_dbus_annotation_info_unref(info: *mut GDBusAnnotationInfo);
}
extern "C" {
    #[link_name = "\u{1}_g_dbus_node_info_get_type"]
    pub fn g_dbus_node_info_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_dbus_interface_info_get_type"]
    pub fn g_dbus_interface_info_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_dbus_method_info_get_type"]
    pub fn g_dbus_method_info_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_dbus_signal_info_get_type"]
    pub fn g_dbus_signal_info_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_dbus_property_info_get_type"]
    pub fn g_dbus_property_info_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_dbus_arg_info_get_type"]
    pub fn g_dbus_arg_info_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_dbus_annotation_info_get_type"]
    pub fn g_dbus_annotation_info_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_dbus_message_get_type"]
    pub fn g_dbus_message_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_dbus_message_new"]
    pub fn g_dbus_message_new() -> *mut GDBusMessage;
}
extern "C" {
    #[link_name = "\u{1}_g_dbus_message_new_signal"]
    pub fn g_dbus_message_new_signal(
        path: *const gchar,
        interface_: *const gchar,
        signal: *const gchar,
    ) -> *mut GDBusMessage;
}
extern "C" {
    #[link_name = "\u{1}_g_dbus_message_new_method_call"]
    pub fn g_dbus_message_new_method_call(
        name: *const gchar,
        path: *const gchar,
        interface_: *const gchar,
        method: *const gchar,
    ) -> *mut GDBusMessage;
}
extern "C" {
    #[link_name = "\u{1}_g_dbus_message_new_method_reply"]
    pub fn g_dbus_message_new_method_reply(
        method_call_message: *mut GDBusMessage,
    ) -> *mut GDBusMessage;
}
extern "C" {
    #[link_name = "\u{1}_g_dbus_message_new_method_error"]
    pub fn g_dbus_message_new_method_error(
        method_call_message: *mut GDBusMessage,
        error_name: *const gchar,
        error_message_format: *const gchar,
        ...
    ) -> *mut GDBusMessage;
}
extern "C" {
    #[link_name = "\u{1}_g_dbus_message_new_method_error_valist"]
    pub fn g_dbus_message_new_method_error_valist(
        method_call_message: *mut GDBusMessage,
        error_name: *const gchar,
        error_message_format: *const gchar,
        var_args: *mut __va_list_tag,
    ) -> *mut GDBusMessage;
}
extern "C" {
    #[link_name = "\u{1}_g_dbus_message_new_method_error_literal"]
    pub fn g_dbus_message_new_method_error_literal(
        method_call_message: *mut GDBusMessage,
        error_name: *const gchar,
        error_message: *const gchar,
    ) -> *mut GDBusMessage;
}
extern "C" {
    #[link_name = "\u{1}_g_dbus_message_print"]
    pub fn g_dbus_message_print(message: *mut GDBusMessage, indent: guint) -> *mut gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_dbus_message_get_locked"]
    pub fn g_dbus_message_get_locked(message: *mut GDBusMessage) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_dbus_message_lock"]
    pub fn g_dbus_message_lock(message: *mut GDBusMessage);
}
extern "C" {
    #[link_name = "\u{1}_g_dbus_message_copy"]
    pub fn g_dbus_message_copy(
        message: *mut GDBusMessage,
        error: *mut *mut GError,
    ) -> *mut GDBusMessage;
}
extern "C" {
    #[link_name = "\u{1}_g_dbus_message_get_byte_order"]
    pub fn g_dbus_message_get_byte_order(message: *mut GDBusMessage) -> GDBusMessageByteOrder;
}
extern "C" {
    #[link_name = "\u{1}_g_dbus_message_set_byte_order"]
    pub fn g_dbus_message_set_byte_order(
        message: *mut GDBusMessage,
        byte_order: GDBusMessageByteOrder,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_dbus_message_get_message_type"]
    pub fn g_dbus_message_get_message_type(message: *mut GDBusMessage) -> GDBusMessageType;
}
extern "C" {
    #[link_name = "\u{1}_g_dbus_message_set_message_type"]
    pub fn g_dbus_message_set_message_type(message: *mut GDBusMessage, type_: GDBusMessageType);
}
extern "C" {
    #[link_name = "\u{1}_g_dbus_message_get_flags"]
    pub fn g_dbus_message_get_flags(message: *mut GDBusMessage) -> GDBusMessageFlags;
}
extern "C" {
    #[link_name = "\u{1}_g_dbus_message_set_flags"]
    pub fn g_dbus_message_set_flags(message: *mut GDBusMessage, flags: GDBusMessageFlags);
}
extern "C" {
    #[link_name = "\u{1}_g_dbus_message_get_serial"]
    pub fn g_dbus_message_get_serial(message: *mut GDBusMessage) -> guint32;
}
extern "C" {
    #[link_name = "\u{1}_g_dbus_message_set_serial"]
    pub fn g_dbus_message_set_serial(message: *mut GDBusMessage, serial: guint32);
}
extern "C" {
    #[link_name = "\u{1}_g_dbus_message_get_header"]
    pub fn g_dbus_message_get_header(
        message: *mut GDBusMessage,
        header_field: GDBusMessageHeaderField,
    ) -> *mut GVariant;
}
extern "C" {
    #[link_name = "\u{1}_g_dbus_message_set_header"]
    pub fn g_dbus_message_set_header(
        message: *mut GDBusMessage,
        header_field: GDBusMessageHeaderField,
        value: *mut GVariant,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_dbus_message_get_header_fields"]
    pub fn g_dbus_message_get_header_fields(message: *mut GDBusMessage) -> *mut guchar;
}
extern "C" {
    #[link_name = "\u{1}_g_dbus_message_get_body"]
    pub fn g_dbus_message_get_body(message: *mut GDBusMessage) -> *mut GVariant;
}
extern "C" {
    #[link_name = "\u{1}_g_dbus_message_set_body"]
    pub fn g_dbus_message_set_body(message: *mut GDBusMessage, body: *mut GVariant);
}
extern "C" {
    #[link_name = "\u{1}_g_dbus_message_get_unix_fd_list"]
    pub fn g_dbus_message_get_unix_fd_list(message: *mut GDBusMessage) -> *mut GUnixFDList;
}
extern "C" {
    #[link_name = "\u{1}_g_dbus_message_set_unix_fd_list"]
    pub fn g_dbus_message_set_unix_fd_list(message: *mut GDBusMessage, fd_list: *mut GUnixFDList);
}
extern "C" {
    #[link_name = "\u{1}_g_dbus_message_get_reply_serial"]
    pub fn g_dbus_message_get_reply_serial(message: *mut GDBusMessage) -> guint32;
}
extern "C" {
    #[link_name = "\u{1}_g_dbus_message_set_reply_serial"]
    pub fn g_dbus_message_set_reply_serial(message: *mut GDBusMessage, value: guint32);
}
extern "C" {
    #[link_name = "\u{1}_g_dbus_message_get_interface"]
    pub fn g_dbus_message_get_interface(message: *mut GDBusMessage) -> *const gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_dbus_message_set_interface"]
    pub fn g_dbus_message_set_interface(message: *mut GDBusMessage, value: *const gchar);
}
extern "C" {
    #[link_name = "\u{1}_g_dbus_message_get_member"]
    pub fn g_dbus_message_get_member(message: *mut GDBusMessage) -> *const gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_dbus_message_set_member"]
    pub fn g_dbus_message_set_member(message: *mut GDBusMessage, value: *const gchar);
}
extern "C" {
    #[link_name = "\u{1}_g_dbus_message_get_path"]
    pub fn g_dbus_message_get_path(message: *mut GDBusMessage) -> *const gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_dbus_message_set_path"]
    pub fn g_dbus_message_set_path(message: *mut GDBusMessage, value: *const gchar);
}
extern "C" {
    #[link_name = "\u{1}_g_dbus_message_get_sender"]
    pub fn g_dbus_message_get_sender(message: *mut GDBusMessage) -> *const gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_dbus_message_set_sender"]
    pub fn g_dbus_message_set_sender(message: *mut GDBusMessage, value: *const gchar);
}
extern "C" {
    #[link_name = "\u{1}_g_dbus_message_get_destination"]
    pub fn g_dbus_message_get_destination(message: *mut GDBusMessage) -> *const gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_dbus_message_set_destination"]
    pub fn g_dbus_message_set_destination(message: *mut GDBusMessage, value: *const gchar);
}
extern "C" {
    #[link_name = "\u{1}_g_dbus_message_get_error_name"]
    pub fn g_dbus_message_get_error_name(message: *mut GDBusMessage) -> *const gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_dbus_message_set_error_name"]
    pub fn g_dbus_message_set_error_name(message: *mut GDBusMessage, value: *const gchar);
}
extern "C" {
    #[link_name = "\u{1}_g_dbus_message_get_signature"]
    pub fn g_dbus_message_get_signature(message: *mut GDBusMessage) -> *const gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_dbus_message_set_signature"]
    pub fn g_dbus_message_set_signature(message: *mut GDBusMessage, value: *const gchar);
}
extern "C" {
    #[link_name = "\u{1}_g_dbus_message_get_num_unix_fds"]
    pub fn g_dbus_message_get_num_unix_fds(message: *mut GDBusMessage) -> guint32;
}
extern "C" {
    #[link_name = "\u{1}_g_dbus_message_set_num_unix_fds"]
    pub fn g_dbus_message_set_num_unix_fds(message: *mut GDBusMessage, value: guint32);
}
extern "C" {
    #[link_name = "\u{1}_g_dbus_message_get_arg0"]
    pub fn g_dbus_message_get_arg0(message: *mut GDBusMessage) -> *const gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_dbus_message_new_from_blob"]
    pub fn g_dbus_message_new_from_blob(
        blob: *mut guchar,
        blob_len: gsize,
        capabilities: GDBusCapabilityFlags,
        error: *mut *mut GError,
    ) -> *mut GDBusMessage;
}
extern "C" {
    #[link_name = "\u{1}_g_dbus_message_bytes_needed"]
    pub fn g_dbus_message_bytes_needed(
        blob: *mut guchar,
        blob_len: gsize,
        error: *mut *mut GError,
    ) -> gssize;
}
extern "C" {
    #[link_name = "\u{1}_g_dbus_message_to_blob"]
    pub fn g_dbus_message_to_blob(
        message: *mut GDBusMessage,
        out_size: *mut gsize,
        capabilities: GDBusCapabilityFlags,
        error: *mut *mut GError,
    ) -> *mut guchar;
}
extern "C" {
    #[link_name = "\u{1}_g_dbus_message_to_gerror"]
    pub fn g_dbus_message_to_gerror(
        message: *mut GDBusMessage,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_dbus_method_invocation_get_type"]
    pub fn g_dbus_method_invocation_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_dbus_method_invocation_get_sender"]
    pub fn g_dbus_method_invocation_get_sender(
        invocation: *mut GDBusMethodInvocation,
    ) -> *const gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_dbus_method_invocation_get_object_path"]
    pub fn g_dbus_method_invocation_get_object_path(
        invocation: *mut GDBusMethodInvocation,
    ) -> *const gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_dbus_method_invocation_get_interface_name"]
    pub fn g_dbus_method_invocation_get_interface_name(
        invocation: *mut GDBusMethodInvocation,
    ) -> *const gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_dbus_method_invocation_get_method_name"]
    pub fn g_dbus_method_invocation_get_method_name(
        invocation: *mut GDBusMethodInvocation,
    ) -> *const gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_dbus_method_invocation_get_method_info"]
    pub fn g_dbus_method_invocation_get_method_info(
        invocation: *mut GDBusMethodInvocation,
    ) -> *const GDBusMethodInfo;
}
extern "C" {
    #[link_name = "\u{1}_g_dbus_method_invocation_get_property_info"]
    pub fn g_dbus_method_invocation_get_property_info(
        invocation: *mut GDBusMethodInvocation,
    ) -> *const GDBusPropertyInfo;
}
extern "C" {
    #[link_name = "\u{1}_g_dbus_method_invocation_get_connection"]
    pub fn g_dbus_method_invocation_get_connection(
        invocation: *mut GDBusMethodInvocation,
    ) -> *mut GDBusConnection;
}
extern "C" {
    #[link_name = "\u{1}_g_dbus_method_invocation_get_message"]
    pub fn g_dbus_method_invocation_get_message(
        invocation: *mut GDBusMethodInvocation,
    ) -> *mut GDBusMessage;
}
extern "C" {
    #[link_name = "\u{1}_g_dbus_method_invocation_get_parameters"]
    pub fn g_dbus_method_invocation_get_parameters(
        invocation: *mut GDBusMethodInvocation,
    ) -> *mut GVariant;
}
extern "C" {
    #[link_name = "\u{1}_g_dbus_method_invocation_get_user_data"]
    pub fn g_dbus_method_invocation_get_user_data(
        invocation: *mut GDBusMethodInvocation,
    ) -> gpointer;
}
extern "C" {
    #[link_name = "\u{1}_g_dbus_method_invocation_return_value"]
    pub fn g_dbus_method_invocation_return_value(
        invocation: *mut GDBusMethodInvocation,
        parameters: *mut GVariant,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_dbus_method_invocation_return_value_with_unix_fd_list"]
    pub fn g_dbus_method_invocation_return_value_with_unix_fd_list(
        invocation: *mut GDBusMethodInvocation,
        parameters: *mut GVariant,
        fd_list: *mut GUnixFDList,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_dbus_method_invocation_return_error"]
    pub fn g_dbus_method_invocation_return_error(
        invocation: *mut GDBusMethodInvocation,
        domain: GQuark,
        code: gint,
        format: *const gchar,
        ...
    );
}
extern "C" {
    #[link_name = "\u{1}_g_dbus_method_invocation_return_error_valist"]
    pub fn g_dbus_method_invocation_return_error_valist(
        invocation: *mut GDBusMethodInvocation,
        domain: GQuark,
        code: gint,
        format: *const gchar,
        var_args: *mut __va_list_tag,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_dbus_method_invocation_return_error_literal"]
    pub fn g_dbus_method_invocation_return_error_literal(
        invocation: *mut GDBusMethodInvocation,
        domain: GQuark,
        code: gint,
        message: *const gchar,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_dbus_method_invocation_return_gerror"]
    pub fn g_dbus_method_invocation_return_gerror(
        invocation: *mut GDBusMethodInvocation,
        error: *const GError,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_dbus_method_invocation_take_error"]
    pub fn g_dbus_method_invocation_take_error(
        invocation: *mut GDBusMethodInvocation,
        error: *mut GError,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_dbus_method_invocation_return_dbus_error"]
    pub fn g_dbus_method_invocation_return_dbus_error(
        invocation: *mut GDBusMethodInvocation,
        error_name: *const gchar,
        error_message: *const gchar,
    );
}
/// GBusAcquiredCallback:
/// @connection: The #GDBusConnection to a message bus.
/// @name: The name that is requested to be owned.
/// @user_data: User data passed to g_bus_own_name().
///
/// Invoked when a connection to a message bus has been obtained.
///
/// Since: 2.26
pub type GBusAcquiredCallback = ::std::option::Option<
    unsafe extern "C" fn(connection: *mut GDBusConnection, name: *const gchar, user_data: gpointer),
>;
/// GBusNameAcquiredCallback:
/// @connection: The #GDBusConnection on which to acquired the name.
/// @name: The name being owned.
/// @user_data: User data passed to g_bus_own_name() or g_bus_own_name_on_connection().
///
/// Invoked when the name is acquired.
///
/// Since: 2.26
pub type GBusNameAcquiredCallback = ::std::option::Option<
    unsafe extern "C" fn(connection: *mut GDBusConnection, name: *const gchar, user_data: gpointer),
>;
/// GBusNameLostCallback:
/// @connection: The #GDBusConnection on which to acquire the name or %NULL if
/// the connection was disconnected.
/// @name: The name being owned.
/// @user_data: User data passed to g_bus_own_name() or g_bus_own_name_on_connection().
///
/// Invoked when the name is lost or @connection has been closed.
///
/// Since: 2.26
pub type GBusNameLostCallback = ::std::option::Option<
    unsafe extern "C" fn(connection: *mut GDBusConnection, name: *const gchar, user_data: gpointer),
>;
extern "C" {
    #[link_name = "\u{1}_g_bus_own_name"]
    pub fn g_bus_own_name(
        bus_type: GBusType,
        name: *const gchar,
        flags: GBusNameOwnerFlags,
        bus_acquired_handler: GBusAcquiredCallback,
        name_acquired_handler: GBusNameAcquiredCallback,
        name_lost_handler: GBusNameLostCallback,
        user_data: gpointer,
        user_data_free_func: GDestroyNotify,
    ) -> guint;
}
extern "C" {
    #[link_name = "\u{1}_g_bus_own_name_on_connection"]
    pub fn g_bus_own_name_on_connection(
        connection: *mut GDBusConnection,
        name: *const gchar,
        flags: GBusNameOwnerFlags,
        name_acquired_handler: GBusNameAcquiredCallback,
        name_lost_handler: GBusNameLostCallback,
        user_data: gpointer,
        user_data_free_func: GDestroyNotify,
    ) -> guint;
}
extern "C" {
    #[link_name = "\u{1}_g_bus_own_name_with_closures"]
    pub fn g_bus_own_name_with_closures(
        bus_type: GBusType,
        name: *const gchar,
        flags: GBusNameOwnerFlags,
        bus_acquired_closure: *mut GClosure,
        name_acquired_closure: *mut GClosure,
        name_lost_closure: *mut GClosure,
    ) -> guint;
}
extern "C" {
    #[link_name = "\u{1}_g_bus_own_name_on_connection_with_closures"]
    pub fn g_bus_own_name_on_connection_with_closures(
        connection: *mut GDBusConnection,
        name: *const gchar,
        flags: GBusNameOwnerFlags,
        name_acquired_closure: *mut GClosure,
        name_lost_closure: *mut GClosure,
    ) -> guint;
}
extern "C" {
    #[link_name = "\u{1}_g_bus_unown_name"]
    pub fn g_bus_unown_name(owner_id: guint);
}
/// GBusNameAppearedCallback:
/// @connection: The #GDBusConnection the name is being watched on.
/// @name: The name being watched.
/// @name_owner: Unique name of the owner of the name being watched.
/// @user_data: User data passed to g_bus_watch_name().
///
/// Invoked when the name being watched is known to have to have a owner.
///
/// Since: 2.26
pub type GBusNameAppearedCallback = ::std::option::Option<
    unsafe extern "C" fn(
        connection: *mut GDBusConnection,
        name: *const gchar,
        name_owner: *const gchar,
        user_data: gpointer,
    ),
>;
/// GBusNameVanishedCallback:
/// @connection: The #GDBusConnection the name is being watched on, or
/// %NULL.
/// @name: The name being watched.
/// @user_data: User data passed to g_bus_watch_name().
///
/// Invoked when the name being watched is known not to have to have a owner.
///
/// This is also invoked when the #GDBusConection on which the watch was
/// established has been closed.  In that case, @connection will be
/// %NULL.
///
/// Since: 2.26
pub type GBusNameVanishedCallback = ::std::option::Option<
    unsafe extern "C" fn(connection: *mut GDBusConnection, name: *const gchar, user_data: gpointer),
>;
extern "C" {
    #[link_name = "\u{1}_g_bus_watch_name"]
    pub fn g_bus_watch_name(
        bus_type: GBusType,
        name: *const gchar,
        flags: GBusNameWatcherFlags,
        name_appeared_handler: GBusNameAppearedCallback,
        name_vanished_handler: GBusNameVanishedCallback,
        user_data: gpointer,
        user_data_free_func: GDestroyNotify,
    ) -> guint;
}
extern "C" {
    #[link_name = "\u{1}_g_bus_watch_name_on_connection"]
    pub fn g_bus_watch_name_on_connection(
        connection: *mut GDBusConnection,
        name: *const gchar,
        flags: GBusNameWatcherFlags,
        name_appeared_handler: GBusNameAppearedCallback,
        name_vanished_handler: GBusNameVanishedCallback,
        user_data: gpointer,
        user_data_free_func: GDestroyNotify,
    ) -> guint;
}
extern "C" {
    #[link_name = "\u{1}_g_bus_watch_name_with_closures"]
    pub fn g_bus_watch_name_with_closures(
        bus_type: GBusType,
        name: *const gchar,
        flags: GBusNameWatcherFlags,
        name_appeared_closure: *mut GClosure,
        name_vanished_closure: *mut GClosure,
    ) -> guint;
}
extern "C" {
    #[link_name = "\u{1}_g_bus_watch_name_on_connection_with_closures"]
    pub fn g_bus_watch_name_on_connection_with_closures(
        connection: *mut GDBusConnection,
        name: *const gchar,
        flags: GBusNameWatcherFlags,
        name_appeared_closure: *mut GClosure,
        name_vanished_closure: *mut GClosure,
    ) -> guint;
}
extern "C" {
    #[link_name = "\u{1}_g_bus_unwatch_name"]
    pub fn g_bus_unwatch_name(watcher_id: guint);
}
pub type GDBusProxyClass = _GDBusProxyClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GDBusProxyPrivate {
    _unused: [u8; 0],
}
pub type GDBusProxyPrivate = _GDBusProxyPrivate;
/// GDBusProxy:
///
/// The #GDBusProxy structure contains only private data and
/// should only be accessed using the provided API.
///
/// Since: 2.26
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GDBusProxy {
    pub parent_instance: GObject,
    pub priv_: *mut GDBusProxyPrivate,
}
#[test]
fn bindgen_test_layout__GDBusProxy() {
    assert_eq!(
        ::std::mem::size_of::<_GDBusProxy>(),
        32usize,
        concat!("Size of: ", stringify!(_GDBusProxy))
    );
    assert_eq!(
        ::std::mem::align_of::<_GDBusProxy>(),
        8usize,
        concat!("Alignment of ", stringify!(_GDBusProxy))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GDBusProxy>())).parent_instance as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDBusProxy),
            "::",
            stringify!(parent_instance)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GDBusProxy>())).priv_ as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDBusProxy),
            "::",
            stringify!(priv_)
        )
    );
}
/// GDBusProxyClass:
/// @g_properties_changed: Signal class handler for the #GDBusProxy::g-properties-changed signal.
/// @g_signal: Signal class handler for the #GDBusProxy::g-signal signal.
///
/// Class structure for #GDBusProxy.
///
/// Since: 2.26
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GDBusProxyClass {
    pub parent_class: GObjectClass,
    pub g_properties_changed: ::std::option::Option<
        unsafe extern "C" fn(
            proxy: *mut GDBusProxy,
            changed_properties: *mut GVariant,
            invalidated_properties: *const *const gchar,
        ),
    >,
    pub g_signal: ::std::option::Option<
        unsafe extern "C" fn(
            proxy: *mut GDBusProxy,
            sender_name: *const gchar,
            signal_name: *const gchar,
            parameters: *mut GVariant,
        ),
    >,
    pub padding: [gpointer; 32usize],
}
#[test]
fn bindgen_test_layout__GDBusProxyClass() {
    assert_eq!(
        ::std::mem::size_of::<_GDBusProxyClass>(),
        408usize,
        concat!("Size of: ", stringify!(_GDBusProxyClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_GDBusProxyClass>(),
        8usize,
        concat!("Alignment of ", stringify!(_GDBusProxyClass))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GDBusProxyClass>())).parent_class as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDBusProxyClass),
            "::",
            stringify!(parent_class)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GDBusProxyClass>())).g_properties_changed as *const _ as usize
        },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDBusProxyClass),
            "::",
            stringify!(g_properties_changed)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GDBusProxyClass>())).g_signal as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDBusProxyClass),
            "::",
            stringify!(g_signal)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GDBusProxyClass>())).padding as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDBusProxyClass),
            "::",
            stringify!(padding)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_g_dbus_proxy_get_type"]
    pub fn g_dbus_proxy_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_dbus_proxy_new"]
    pub fn g_dbus_proxy_new(
        connection: *mut GDBusConnection,
        flags: GDBusProxyFlags,
        info: *mut GDBusInterfaceInfo,
        name: *const gchar,
        object_path: *const gchar,
        interface_name: *const gchar,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_dbus_proxy_new_finish"]
    pub fn g_dbus_proxy_new_finish(
        res: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> *mut GDBusProxy;
}
extern "C" {
    #[link_name = "\u{1}_g_dbus_proxy_new_sync"]
    pub fn g_dbus_proxy_new_sync(
        connection: *mut GDBusConnection,
        flags: GDBusProxyFlags,
        info: *mut GDBusInterfaceInfo,
        name: *const gchar,
        object_path: *const gchar,
        interface_name: *const gchar,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> *mut GDBusProxy;
}
extern "C" {
    #[link_name = "\u{1}_g_dbus_proxy_new_for_bus"]
    pub fn g_dbus_proxy_new_for_bus(
        bus_type: GBusType,
        flags: GDBusProxyFlags,
        info: *mut GDBusInterfaceInfo,
        name: *const gchar,
        object_path: *const gchar,
        interface_name: *const gchar,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_dbus_proxy_new_for_bus_finish"]
    pub fn g_dbus_proxy_new_for_bus_finish(
        res: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> *mut GDBusProxy;
}
extern "C" {
    #[link_name = "\u{1}_g_dbus_proxy_new_for_bus_sync"]
    pub fn g_dbus_proxy_new_for_bus_sync(
        bus_type: GBusType,
        flags: GDBusProxyFlags,
        info: *mut GDBusInterfaceInfo,
        name: *const gchar,
        object_path: *const gchar,
        interface_name: *const gchar,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> *mut GDBusProxy;
}
extern "C" {
    #[link_name = "\u{1}_g_dbus_proxy_get_connection"]
    pub fn g_dbus_proxy_get_connection(proxy: *mut GDBusProxy) -> *mut GDBusConnection;
}
extern "C" {
    #[link_name = "\u{1}_g_dbus_proxy_get_flags"]
    pub fn g_dbus_proxy_get_flags(proxy: *mut GDBusProxy) -> GDBusProxyFlags;
}
extern "C" {
    #[link_name = "\u{1}_g_dbus_proxy_get_name"]
    pub fn g_dbus_proxy_get_name(proxy: *mut GDBusProxy) -> *const gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_dbus_proxy_get_name_owner"]
    pub fn g_dbus_proxy_get_name_owner(proxy: *mut GDBusProxy) -> *mut gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_dbus_proxy_get_object_path"]
    pub fn g_dbus_proxy_get_object_path(proxy: *mut GDBusProxy) -> *const gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_dbus_proxy_get_interface_name"]
    pub fn g_dbus_proxy_get_interface_name(proxy: *mut GDBusProxy) -> *const gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_dbus_proxy_get_default_timeout"]
    pub fn g_dbus_proxy_get_default_timeout(proxy: *mut GDBusProxy) -> gint;
}
extern "C" {
    #[link_name = "\u{1}_g_dbus_proxy_set_default_timeout"]
    pub fn g_dbus_proxy_set_default_timeout(proxy: *mut GDBusProxy, timeout_msec: gint);
}
extern "C" {
    #[link_name = "\u{1}_g_dbus_proxy_get_interface_info"]
    pub fn g_dbus_proxy_get_interface_info(proxy: *mut GDBusProxy) -> *mut GDBusInterfaceInfo;
}
extern "C" {
    #[link_name = "\u{1}_g_dbus_proxy_set_interface_info"]
    pub fn g_dbus_proxy_set_interface_info(proxy: *mut GDBusProxy, info: *mut GDBusInterfaceInfo);
}
extern "C" {
    #[link_name = "\u{1}_g_dbus_proxy_get_cached_property"]
    pub fn g_dbus_proxy_get_cached_property(
        proxy: *mut GDBusProxy,
        property_name: *const gchar,
    ) -> *mut GVariant;
}
extern "C" {
    #[link_name = "\u{1}_g_dbus_proxy_set_cached_property"]
    pub fn g_dbus_proxy_set_cached_property(
        proxy: *mut GDBusProxy,
        property_name: *const gchar,
        value: *mut GVariant,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_dbus_proxy_get_cached_property_names"]
    pub fn g_dbus_proxy_get_cached_property_names(proxy: *mut GDBusProxy) -> *mut *mut gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_dbus_proxy_call"]
    pub fn g_dbus_proxy_call(
        proxy: *mut GDBusProxy,
        method_name: *const gchar,
        parameters: *mut GVariant,
        flags: GDBusCallFlags,
        timeout_msec: gint,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_dbus_proxy_call_finish"]
    pub fn g_dbus_proxy_call_finish(
        proxy: *mut GDBusProxy,
        res: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> *mut GVariant;
}
extern "C" {
    #[link_name = "\u{1}_g_dbus_proxy_call_sync"]
    pub fn g_dbus_proxy_call_sync(
        proxy: *mut GDBusProxy,
        method_name: *const gchar,
        parameters: *mut GVariant,
        flags: GDBusCallFlags,
        timeout_msec: gint,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> *mut GVariant;
}
extern "C" {
    #[link_name = "\u{1}_g_dbus_proxy_call_with_unix_fd_list"]
    pub fn g_dbus_proxy_call_with_unix_fd_list(
        proxy: *mut GDBusProxy,
        method_name: *const gchar,
        parameters: *mut GVariant,
        flags: GDBusCallFlags,
        timeout_msec: gint,
        fd_list: *mut GUnixFDList,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_dbus_proxy_call_with_unix_fd_list_finish"]
    pub fn g_dbus_proxy_call_with_unix_fd_list_finish(
        proxy: *mut GDBusProxy,
        out_fd_list: *mut *mut GUnixFDList,
        res: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> *mut GVariant;
}
extern "C" {
    #[link_name = "\u{1}_g_dbus_proxy_call_with_unix_fd_list_sync"]
    pub fn g_dbus_proxy_call_with_unix_fd_list_sync(
        proxy: *mut GDBusProxy,
        method_name: *const gchar,
        parameters: *mut GVariant,
        flags: GDBusCallFlags,
        timeout_msec: gint,
        fd_list: *mut GUnixFDList,
        out_fd_list: *mut *mut GUnixFDList,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> *mut GVariant;
}
extern "C" {
    #[link_name = "\u{1}_g_dbus_server_get_type"]
    pub fn g_dbus_server_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_dbus_server_new_sync"]
    pub fn g_dbus_server_new_sync(
        address: *const gchar,
        flags: GDBusServerFlags,
        guid: *const gchar,
        observer: *mut GDBusAuthObserver,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> *mut GDBusServer;
}
extern "C" {
    #[link_name = "\u{1}_g_dbus_server_get_client_address"]
    pub fn g_dbus_server_get_client_address(server: *mut GDBusServer) -> *const gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_dbus_server_get_guid"]
    pub fn g_dbus_server_get_guid(server: *mut GDBusServer) -> *const gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_dbus_server_get_flags"]
    pub fn g_dbus_server_get_flags(server: *mut GDBusServer) -> GDBusServerFlags;
}
extern "C" {
    #[link_name = "\u{1}_g_dbus_server_start"]
    pub fn g_dbus_server_start(server: *mut GDBusServer);
}
extern "C" {
    #[link_name = "\u{1}_g_dbus_server_stop"]
    pub fn g_dbus_server_stop(server: *mut GDBusServer);
}
extern "C" {
    #[link_name = "\u{1}_g_dbus_server_is_active"]
    pub fn g_dbus_server_is_active(server: *mut GDBusServer) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_dbus_is_guid"]
    pub fn g_dbus_is_guid(string: *const gchar) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_dbus_generate_guid"]
    pub fn g_dbus_generate_guid() -> *mut gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_dbus_is_name"]
    pub fn g_dbus_is_name(string: *const gchar) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_dbus_is_unique_name"]
    pub fn g_dbus_is_unique_name(string: *const gchar) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_dbus_is_member_name"]
    pub fn g_dbus_is_member_name(string: *const gchar) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_dbus_is_interface_name"]
    pub fn g_dbus_is_interface_name(string: *const gchar) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_dbus_gvariant_to_gvalue"]
    pub fn g_dbus_gvariant_to_gvalue(value: *mut GVariant, out_gvalue: *mut GValue);
}
extern "C" {
    #[link_name = "\u{1}_g_dbus_gvalue_to_gvariant"]
    pub fn g_dbus_gvalue_to_gvariant(
        gvalue: *const GValue,
        type_: *const GVariantType,
    ) -> *mut GVariant;
}
/// GDriveIface:
/// @g_iface: The parent interface.
/// @changed: Signal emitted when the drive is changed.
/// @disconnected: The removed signal that is emitted when the #GDrive have been disconnected. If the recipient is holding references to the object they should release them so the object can be finalized.
/// @eject_button: Signal emitted when the physical eject button (if any) of a drive have been pressed.
/// @get_name: Returns the name for the given #GDrive.
/// @get_icon: Returns a #GIcon for the given #GDrive.
/// @has_volumes: Returns %TRUE if the #GDrive has mountable volumes.
/// @get_volumes: Returns a list #GList of #GVolume for the #GDrive.
/// @is_removable: Returns %TRUE if the #GDrive and/or its media is considered removable by the user. Since 2.50.
/// @is_media_removable: Returns %TRUE if the #GDrive supports removal and insertion of media.
/// @has_media: Returns %TRUE if the #GDrive has media inserted.
/// @is_media_check_automatic: Returns %TRUE if the #GDrive is capabable of automatically detecting media changes.
/// @can_poll_for_media: Returns %TRUE if the #GDrive is capable of manually polling for media change.
/// @can_eject: Returns %TRUE if the #GDrive can eject media.
/// @eject: Ejects a #GDrive.
/// @eject_finish: Finishes an eject operation.
/// @poll_for_media: Poll for media insertion/removal on a #GDrive.
/// @poll_for_media_finish: Finishes a media poll operation.
/// @get_identifier: Returns the identifier of the given kind, or %NULL if
/// the #GDrive doesn't have one.
/// @enumerate_identifiers: Returns an array strings listing the kinds
/// of identifiers which the #GDrive has.
/// @get_start_stop_type: Gets a #GDriveStartStopType with details about starting/stopping the drive. Since 2.22.
/// @can_stop: Returns %TRUE if a #GDrive can be stopped. Since 2.22.
/// @stop: Stops a #GDrive. Since 2.22.
/// @stop_finish: Finishes a stop operation. Since 2.22.
/// @can_start: Returns %TRUE if a #GDrive can be started. Since 2.22.
/// @can_start_degraded: Returns %TRUE if a #GDrive can be started degraded. Since 2.22.
/// @start: Starts a #GDrive. Since 2.22.
/// @start_finish: Finishes a start operation. Since 2.22.
/// @stop_button: Signal emitted when the physical stop button (if any) of a drive have been pressed. Since 2.22.
/// @eject_with_operation: Starts ejecting a #GDrive using a #GMountOperation. Since 2.22.
/// @eject_with_operation_finish: Finishes an eject operation using a #GMountOperation. Since 2.22.
/// @get_sort_key: Gets a key used for sorting #GDrive instances or %NULL if no such key exists. Since 2.32.
/// @get_symbolic_icon: Returns a symbolic #GIcon for the given #GDrive. Since 2.34.
///
/// Interface for creating #GDrive implementations.
pub type GDriveIface = _GDriveIface;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GDriveIface {
    pub g_iface: GTypeInterface,
    pub changed: ::std::option::Option<unsafe extern "C" fn(drive: *mut GDrive)>,
    pub disconnected: ::std::option::Option<unsafe extern "C" fn(drive: *mut GDrive)>,
    pub eject_button: ::std::option::Option<unsafe extern "C" fn(drive: *mut GDrive)>,
    pub get_name: ::std::option::Option<
        unsafe extern "C" fn(drive: *mut GDrive) -> *mut ::std::os::raw::c_char,
    >,
    pub get_icon: ::std::option::Option<unsafe extern "C" fn(drive: *mut GDrive) -> *mut GIcon>,
    pub has_volumes: ::std::option::Option<unsafe extern "C" fn(drive: *mut GDrive) -> gboolean>,
    pub get_volumes: ::std::option::Option<unsafe extern "C" fn(drive: *mut GDrive) -> *mut GList>,
    pub is_media_removable:
        ::std::option::Option<unsafe extern "C" fn(drive: *mut GDrive) -> gboolean>,
    pub has_media: ::std::option::Option<unsafe extern "C" fn(drive: *mut GDrive) -> gboolean>,
    pub is_media_check_automatic:
        ::std::option::Option<unsafe extern "C" fn(drive: *mut GDrive) -> gboolean>,
    pub can_eject: ::std::option::Option<unsafe extern "C" fn(drive: *mut GDrive) -> gboolean>,
    pub can_poll_for_media:
        ::std::option::Option<unsafe extern "C" fn(drive: *mut GDrive) -> gboolean>,
    pub eject: ::std::option::Option<
        unsafe extern "C" fn(
            drive: *mut GDrive,
            flags: GMountUnmountFlags,
            cancellable: *mut GCancellable,
            callback: GAsyncReadyCallback,
            user_data: gpointer,
        ),
    >,
    pub eject_finish: ::std::option::Option<
        unsafe extern "C" fn(
            drive: *mut GDrive,
            result: *mut GAsyncResult,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
    pub poll_for_media: ::std::option::Option<
        unsafe extern "C" fn(
            drive: *mut GDrive,
            cancellable: *mut GCancellable,
            callback: GAsyncReadyCallback,
            user_data: gpointer,
        ),
    >,
    pub poll_for_media_finish: ::std::option::Option<
        unsafe extern "C" fn(
            drive: *mut GDrive,
            result: *mut GAsyncResult,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
    pub get_identifier: ::std::option::Option<
        unsafe extern "C" fn(drive: *mut GDrive, kind: *const ::std::os::raw::c_char)
            -> *mut ::std::os::raw::c_char,
    >,
    pub enumerate_identifiers: ::std::option::Option<
        unsafe extern "C" fn(drive: *mut GDrive) -> *mut *mut ::std::os::raw::c_char,
    >,
    pub get_start_stop_type:
        ::std::option::Option<unsafe extern "C" fn(drive: *mut GDrive) -> GDriveStartStopType>,
    pub can_start: ::std::option::Option<unsafe extern "C" fn(drive: *mut GDrive) -> gboolean>,
    pub can_start_degraded:
        ::std::option::Option<unsafe extern "C" fn(drive: *mut GDrive) -> gboolean>,
    pub start: ::std::option::Option<
        unsafe extern "C" fn(
            drive: *mut GDrive,
            flags: GDriveStartFlags,
            mount_operation: *mut GMountOperation,
            cancellable: *mut GCancellable,
            callback: GAsyncReadyCallback,
            user_data: gpointer,
        ),
    >,
    pub start_finish: ::std::option::Option<
        unsafe extern "C" fn(
            drive: *mut GDrive,
            result: *mut GAsyncResult,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
    pub can_stop: ::std::option::Option<unsafe extern "C" fn(drive: *mut GDrive) -> gboolean>,
    pub stop: ::std::option::Option<
        unsafe extern "C" fn(
            drive: *mut GDrive,
            flags: GMountUnmountFlags,
            mount_operation: *mut GMountOperation,
            cancellable: *mut GCancellable,
            callback: GAsyncReadyCallback,
            user_data: gpointer,
        ),
    >,
    pub stop_finish: ::std::option::Option<
        unsafe extern "C" fn(
            drive: *mut GDrive,
            result: *mut GAsyncResult,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
    pub stop_button: ::std::option::Option<unsafe extern "C" fn(drive: *mut GDrive)>,
    pub eject_with_operation: ::std::option::Option<
        unsafe extern "C" fn(
            drive: *mut GDrive,
            flags: GMountUnmountFlags,
            mount_operation: *mut GMountOperation,
            cancellable: *mut GCancellable,
            callback: GAsyncReadyCallback,
            user_data: gpointer,
        ),
    >,
    pub eject_with_operation_finish: ::std::option::Option<
        unsafe extern "C" fn(
            drive: *mut GDrive,
            result: *mut GAsyncResult,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
    pub get_sort_key:
        ::std::option::Option<unsafe extern "C" fn(drive: *mut GDrive) -> *const gchar>,
    pub get_symbolic_icon:
        ::std::option::Option<unsafe extern "C" fn(drive: *mut GDrive) -> *mut GIcon>,
    pub is_removable: ::std::option::Option<unsafe extern "C" fn(drive: *mut GDrive) -> gboolean>,
}
#[test]
fn bindgen_test_layout__GDriveIface() {
    assert_eq!(
        ::std::mem::size_of::<_GDriveIface>(),
        272usize,
        concat!("Size of: ", stringify!(_GDriveIface))
    );
    assert_eq!(
        ::std::mem::align_of::<_GDriveIface>(),
        8usize,
        concat!("Alignment of ", stringify!(_GDriveIface))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GDriveIface>())).g_iface as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDriveIface),
            "::",
            stringify!(g_iface)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GDriveIface>())).changed as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDriveIface),
            "::",
            stringify!(changed)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GDriveIface>())).disconnected as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDriveIface),
            "::",
            stringify!(disconnected)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GDriveIface>())).eject_button as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDriveIface),
            "::",
            stringify!(eject_button)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GDriveIface>())).get_name as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDriveIface),
            "::",
            stringify!(get_name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GDriveIface>())).get_icon as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDriveIface),
            "::",
            stringify!(get_icon)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GDriveIface>())).has_volumes as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDriveIface),
            "::",
            stringify!(has_volumes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GDriveIface>())).get_volumes as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDriveIface),
            "::",
            stringify!(get_volumes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GDriveIface>())).is_media_removable as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDriveIface),
            "::",
            stringify!(is_media_removable)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GDriveIface>())).has_media as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDriveIface),
            "::",
            stringify!(has_media)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GDriveIface>())).is_media_check_automatic as *const _ as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDriveIface),
            "::",
            stringify!(is_media_check_automatic)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GDriveIface>())).can_eject as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDriveIface),
            "::",
            stringify!(can_eject)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GDriveIface>())).can_poll_for_media as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDriveIface),
            "::",
            stringify!(can_poll_for_media)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GDriveIface>())).eject as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDriveIface),
            "::",
            stringify!(eject)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GDriveIface>())).eject_finish as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDriveIface),
            "::",
            stringify!(eject_finish)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GDriveIface>())).poll_for_media as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDriveIface),
            "::",
            stringify!(poll_for_media)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GDriveIface>())).poll_for_media_finish as *const _ as usize
        },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDriveIface),
            "::",
            stringify!(poll_for_media_finish)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GDriveIface>())).get_identifier as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDriveIface),
            "::",
            stringify!(get_identifier)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GDriveIface>())).enumerate_identifiers as *const _ as usize
        },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDriveIface),
            "::",
            stringify!(enumerate_identifiers)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GDriveIface>())).get_start_stop_type as *const _ as usize
        },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDriveIface),
            "::",
            stringify!(get_start_stop_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GDriveIface>())).can_start as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDriveIface),
            "::",
            stringify!(can_start)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GDriveIface>())).can_start_degraded as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDriveIface),
            "::",
            stringify!(can_start_degraded)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GDriveIface>())).start as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDriveIface),
            "::",
            stringify!(start)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GDriveIface>())).start_finish as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDriveIface),
            "::",
            stringify!(start_finish)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GDriveIface>())).can_stop as *const _ as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDriveIface),
            "::",
            stringify!(can_stop)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GDriveIface>())).stop as *const _ as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDriveIface),
            "::",
            stringify!(stop)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GDriveIface>())).stop_finish as *const _ as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDriveIface),
            "::",
            stringify!(stop_finish)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GDriveIface>())).stop_button as *const _ as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDriveIface),
            "::",
            stringify!(stop_button)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GDriveIface>())).eject_with_operation as *const _ as usize
        },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDriveIface),
            "::",
            stringify!(eject_with_operation)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GDriveIface>())).eject_with_operation_finish as *const _
                as usize
        },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDriveIface),
            "::",
            stringify!(eject_with_operation_finish)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GDriveIface>())).get_sort_key as *const _ as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDriveIface),
            "::",
            stringify!(get_sort_key)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GDriveIface>())).get_symbolic_icon as *const _ as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDriveIface),
            "::",
            stringify!(get_symbolic_icon)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GDriveIface>())).is_removable as *const _ as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDriveIface),
            "::",
            stringify!(is_removable)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_g_drive_get_type"]
    pub fn g_drive_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_drive_get_name"]
    pub fn g_drive_get_name(drive: *mut GDrive) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_g_drive_get_icon"]
    pub fn g_drive_get_icon(drive: *mut GDrive) -> *mut GIcon;
}
extern "C" {
    #[link_name = "\u{1}_g_drive_get_symbolic_icon"]
    pub fn g_drive_get_symbolic_icon(drive: *mut GDrive) -> *mut GIcon;
}
extern "C" {
    #[link_name = "\u{1}_g_drive_has_volumes"]
    pub fn g_drive_has_volumes(drive: *mut GDrive) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_drive_get_volumes"]
    pub fn g_drive_get_volumes(drive: *mut GDrive) -> *mut GList;
}
extern "C" {
    #[link_name = "\u{1}_g_drive_is_removable"]
    pub fn g_drive_is_removable(drive: *mut GDrive) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_drive_is_media_removable"]
    pub fn g_drive_is_media_removable(drive: *mut GDrive) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_drive_has_media"]
    pub fn g_drive_has_media(drive: *mut GDrive) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_drive_is_media_check_automatic"]
    pub fn g_drive_is_media_check_automatic(drive: *mut GDrive) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_drive_can_poll_for_media"]
    pub fn g_drive_can_poll_for_media(drive: *mut GDrive) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_drive_can_eject"]
    pub fn g_drive_can_eject(drive: *mut GDrive) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_drive_eject"]
    pub fn g_drive_eject(
        drive: *mut GDrive,
        flags: GMountUnmountFlags,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_drive_eject_finish"]
    pub fn g_drive_eject_finish(
        drive: *mut GDrive,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_drive_poll_for_media"]
    pub fn g_drive_poll_for_media(
        drive: *mut GDrive,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_drive_poll_for_media_finish"]
    pub fn g_drive_poll_for_media_finish(
        drive: *mut GDrive,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_drive_get_identifier"]
    pub fn g_drive_get_identifier(
        drive: *mut GDrive,
        kind: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_g_drive_enumerate_identifiers"]
    pub fn g_drive_enumerate_identifiers(drive: *mut GDrive) -> *mut *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_g_drive_get_start_stop_type"]
    pub fn g_drive_get_start_stop_type(drive: *mut GDrive) -> GDriveStartStopType;
}
extern "C" {
    #[link_name = "\u{1}_g_drive_can_start"]
    pub fn g_drive_can_start(drive: *mut GDrive) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_drive_can_start_degraded"]
    pub fn g_drive_can_start_degraded(drive: *mut GDrive) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_drive_start"]
    pub fn g_drive_start(
        drive: *mut GDrive,
        flags: GDriveStartFlags,
        mount_operation: *mut GMountOperation,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_drive_start_finish"]
    pub fn g_drive_start_finish(
        drive: *mut GDrive,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_drive_can_stop"]
    pub fn g_drive_can_stop(drive: *mut GDrive) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_drive_stop"]
    pub fn g_drive_stop(
        drive: *mut GDrive,
        flags: GMountUnmountFlags,
        mount_operation: *mut GMountOperation,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_drive_stop_finish"]
    pub fn g_drive_stop_finish(
        drive: *mut GDrive,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_drive_eject_with_operation"]
    pub fn g_drive_eject_with_operation(
        drive: *mut GDrive,
        flags: GMountUnmountFlags,
        mount_operation: *mut GMountOperation,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_drive_eject_with_operation_finish"]
    pub fn g_drive_eject_with_operation_finish(
        drive: *mut GDrive,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_drive_get_sort_key"]
    pub fn g_drive_get_sort_key(drive: *mut GDrive) -> *const gchar;
}
pub type GDtlsConnectionInterface = _GDtlsConnectionInterface;
/// GDtlsConnectionInterface:
/// @g_iface: The parent interface.
/// @accept_certificate: Check whether to accept a certificate.
/// @handshake: Perform a handshake operation.
/// @handshake_async: Start an asynchronous handshake operation.
/// @handshake_finish: Finish an asynchronous handshake operation.
/// @shutdown: Shut down one or both directions of the connection.
/// @shutdown_async: Start an asynchronous shutdown operation.
/// @shutdown_finish: Finish an asynchronous shutdown operation.
///
/// Virtual method table for a #GDtlsConnection implementation.
///
/// Since: 2.48
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GDtlsConnectionInterface {
    pub g_iface: GTypeInterface,
    pub accept_certificate: ::std::option::Option<
        unsafe extern "C" fn(
            connection: *mut GDtlsConnection,
            peer_cert: *mut GTlsCertificate,
            errors: GTlsCertificateFlags,
        ) -> gboolean,
    >,
    pub handshake: ::std::option::Option<
        unsafe extern "C" fn(
            conn: *mut GDtlsConnection,
            cancellable: *mut GCancellable,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
    pub handshake_async: ::std::option::Option<
        unsafe extern "C" fn(
            conn: *mut GDtlsConnection,
            io_priority: ::std::os::raw::c_int,
            cancellable: *mut GCancellable,
            callback: GAsyncReadyCallback,
            user_data: gpointer,
        ),
    >,
    pub handshake_finish: ::std::option::Option<
        unsafe extern "C" fn(
            conn: *mut GDtlsConnection,
            result: *mut GAsyncResult,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
    pub shutdown: ::std::option::Option<
        unsafe extern "C" fn(
            conn: *mut GDtlsConnection,
            shutdown_read: gboolean,
            shutdown_write: gboolean,
            cancellable: *mut GCancellable,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
    pub shutdown_async: ::std::option::Option<
        unsafe extern "C" fn(
            conn: *mut GDtlsConnection,
            shutdown_read: gboolean,
            shutdown_write: gboolean,
            io_priority: ::std::os::raw::c_int,
            cancellable: *mut GCancellable,
            callback: GAsyncReadyCallback,
            user_data: gpointer,
        ),
    >,
    pub shutdown_finish: ::std::option::Option<
        unsafe extern "C" fn(
            conn: *mut GDtlsConnection,
            result: *mut GAsyncResult,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
}
#[test]
fn bindgen_test_layout__GDtlsConnectionInterface() {
    assert_eq!(
        ::std::mem::size_of::<_GDtlsConnectionInterface>(),
        72usize,
        concat!("Size of: ", stringify!(_GDtlsConnectionInterface))
    );
    assert_eq!(
        ::std::mem::align_of::<_GDtlsConnectionInterface>(),
        8usize,
        concat!("Alignment of ", stringify!(_GDtlsConnectionInterface))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GDtlsConnectionInterface>())).g_iface as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDtlsConnectionInterface),
            "::",
            stringify!(g_iface)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GDtlsConnectionInterface>())).accept_certificate as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDtlsConnectionInterface),
            "::",
            stringify!(accept_certificate)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GDtlsConnectionInterface>())).handshake as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDtlsConnectionInterface),
            "::",
            stringify!(handshake)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GDtlsConnectionInterface>())).handshake_async as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDtlsConnectionInterface),
            "::",
            stringify!(handshake_async)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GDtlsConnectionInterface>())).handshake_finish as *const _
                as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDtlsConnectionInterface),
            "::",
            stringify!(handshake_finish)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GDtlsConnectionInterface>())).shutdown as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDtlsConnectionInterface),
            "::",
            stringify!(shutdown)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GDtlsConnectionInterface>())).shutdown_async as *const _
                as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDtlsConnectionInterface),
            "::",
            stringify!(shutdown_async)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GDtlsConnectionInterface>())).shutdown_finish as *const _
                as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDtlsConnectionInterface),
            "::",
            stringify!(shutdown_finish)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_g_dtls_connection_get_type"]
    pub fn g_dtls_connection_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_dtls_connection_set_database"]
    pub fn g_dtls_connection_set_database(conn: *mut GDtlsConnection, database: *mut GTlsDatabase);
}
extern "C" {
    #[link_name = "\u{1}_g_dtls_connection_get_database"]
    pub fn g_dtls_connection_get_database(conn: *mut GDtlsConnection) -> *mut GTlsDatabase;
}
extern "C" {
    #[link_name = "\u{1}_g_dtls_connection_set_certificate"]
    pub fn g_dtls_connection_set_certificate(
        conn: *mut GDtlsConnection,
        certificate: *mut GTlsCertificate,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_dtls_connection_get_certificate"]
    pub fn g_dtls_connection_get_certificate(conn: *mut GDtlsConnection) -> *mut GTlsCertificate;
}
extern "C" {
    #[link_name = "\u{1}_g_dtls_connection_set_interaction"]
    pub fn g_dtls_connection_set_interaction(
        conn: *mut GDtlsConnection,
        interaction: *mut GTlsInteraction,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_dtls_connection_get_interaction"]
    pub fn g_dtls_connection_get_interaction(conn: *mut GDtlsConnection) -> *mut GTlsInteraction;
}
extern "C" {
    #[link_name = "\u{1}_g_dtls_connection_get_peer_certificate"]
    pub fn g_dtls_connection_get_peer_certificate(
        conn: *mut GDtlsConnection,
    ) -> *mut GTlsCertificate;
}
extern "C" {
    #[link_name = "\u{1}_g_dtls_connection_get_peer_certificate_errors"]
    pub fn g_dtls_connection_get_peer_certificate_errors(
        conn: *mut GDtlsConnection,
    ) -> GTlsCertificateFlags;
}
extern "C" {
    #[link_name = "\u{1}_g_dtls_connection_set_require_close_notify"]
    pub fn g_dtls_connection_set_require_close_notify(
        conn: *mut GDtlsConnection,
        require_close_notify: gboolean,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_dtls_connection_get_require_close_notify"]
    pub fn g_dtls_connection_get_require_close_notify(conn: *mut GDtlsConnection) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_dtls_connection_set_rehandshake_mode"]
    pub fn g_dtls_connection_set_rehandshake_mode(
        conn: *mut GDtlsConnection,
        mode: GTlsRehandshakeMode,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_dtls_connection_get_rehandshake_mode"]
    pub fn g_dtls_connection_get_rehandshake_mode(
        conn: *mut GDtlsConnection,
    ) -> GTlsRehandshakeMode;
}
extern "C" {
    #[link_name = "\u{1}_g_dtls_connection_handshake"]
    pub fn g_dtls_connection_handshake(
        conn: *mut GDtlsConnection,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_dtls_connection_handshake_async"]
    pub fn g_dtls_connection_handshake_async(
        conn: *mut GDtlsConnection,
        io_priority: ::std::os::raw::c_int,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_dtls_connection_handshake_finish"]
    pub fn g_dtls_connection_handshake_finish(
        conn: *mut GDtlsConnection,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_dtls_connection_shutdown"]
    pub fn g_dtls_connection_shutdown(
        conn: *mut GDtlsConnection,
        shutdown_read: gboolean,
        shutdown_write: gboolean,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_dtls_connection_shutdown_async"]
    pub fn g_dtls_connection_shutdown_async(
        conn: *mut GDtlsConnection,
        shutdown_read: gboolean,
        shutdown_write: gboolean,
        io_priority: ::std::os::raw::c_int,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_dtls_connection_shutdown_finish"]
    pub fn g_dtls_connection_shutdown_finish(
        conn: *mut GDtlsConnection,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_dtls_connection_close"]
    pub fn g_dtls_connection_close(
        conn: *mut GDtlsConnection,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_dtls_connection_close_async"]
    pub fn g_dtls_connection_close_async(
        conn: *mut GDtlsConnection,
        io_priority: ::std::os::raw::c_int,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_dtls_connection_close_finish"]
    pub fn g_dtls_connection_close_finish(
        conn: *mut GDtlsConnection,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_dtls_connection_emit_accept_certificate"]
    pub fn g_dtls_connection_emit_accept_certificate(
        conn: *mut GDtlsConnection,
        peer_cert: *mut GTlsCertificate,
        errors: GTlsCertificateFlags,
    ) -> gboolean;
}
pub type GDtlsClientConnectionInterface = _GDtlsClientConnectionInterface;
/// GDtlsClientConnectionInterface:
/// @g_iface: The parent interface.
///
/// vtable for a #GDtlsClientConnection implementation.
///
/// Since: 2.48
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GDtlsClientConnectionInterface {
    pub g_iface: GTypeInterface,
}
#[test]
fn bindgen_test_layout__GDtlsClientConnectionInterface() {
    assert_eq!(
        ::std::mem::size_of::<_GDtlsClientConnectionInterface>(),
        16usize,
        concat!("Size of: ", stringify!(_GDtlsClientConnectionInterface))
    );
    assert_eq!(
        ::std::mem::align_of::<_GDtlsClientConnectionInterface>(),
        8usize,
        concat!("Alignment of ", stringify!(_GDtlsClientConnectionInterface))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GDtlsClientConnectionInterface>())).g_iface as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDtlsClientConnectionInterface),
            "::",
            stringify!(g_iface)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_g_dtls_client_connection_get_type"]
    pub fn g_dtls_client_connection_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_dtls_client_connection_new"]
    pub fn g_dtls_client_connection_new(
        base_socket: *mut GDatagramBased,
        server_identity: *mut GSocketConnectable,
        error: *mut *mut GError,
    ) -> *mut GDatagramBased;
}
extern "C" {
    #[link_name = "\u{1}_g_dtls_client_connection_get_validation_flags"]
    pub fn g_dtls_client_connection_get_validation_flags(
        conn: *mut GDtlsClientConnection,
    ) -> GTlsCertificateFlags;
}
extern "C" {
    #[link_name = "\u{1}_g_dtls_client_connection_set_validation_flags"]
    pub fn g_dtls_client_connection_set_validation_flags(
        conn: *mut GDtlsClientConnection,
        flags: GTlsCertificateFlags,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_dtls_client_connection_get_server_identity"]
    pub fn g_dtls_client_connection_get_server_identity(
        conn: *mut GDtlsClientConnection,
    ) -> *mut GSocketConnectable;
}
extern "C" {
    #[link_name = "\u{1}_g_dtls_client_connection_set_server_identity"]
    pub fn g_dtls_client_connection_set_server_identity(
        conn: *mut GDtlsClientConnection,
        identity: *mut GSocketConnectable,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_dtls_client_connection_get_accepted_cas"]
    pub fn g_dtls_client_connection_get_accepted_cas(
        conn: *mut GDtlsClientConnection,
    ) -> *mut GList;
}
/// GDtlsServerConnection:
///
/// DTLS server-side connection. This is the server-side implementation
/// of a #GDtlsConnection.
///
/// Since: 2.48
pub type GDtlsServerConnectionInterface = _GDtlsServerConnectionInterface;
/// GDtlsServerConnectionInterface:
/// @g_iface: The parent interface.
///
/// vtable for a #GDtlsServerConnection implementation.
///
/// Since: 2.48
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GDtlsServerConnectionInterface {
    pub g_iface: GTypeInterface,
}
#[test]
fn bindgen_test_layout__GDtlsServerConnectionInterface() {
    assert_eq!(
        ::std::mem::size_of::<_GDtlsServerConnectionInterface>(),
        16usize,
        concat!("Size of: ", stringify!(_GDtlsServerConnectionInterface))
    );
    assert_eq!(
        ::std::mem::align_of::<_GDtlsServerConnectionInterface>(),
        8usize,
        concat!("Alignment of ", stringify!(_GDtlsServerConnectionInterface))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GDtlsServerConnectionInterface>())).g_iface as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDtlsServerConnectionInterface),
            "::",
            stringify!(g_iface)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_g_dtls_server_connection_get_type"]
    pub fn g_dtls_server_connection_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_dtls_server_connection_new"]
    pub fn g_dtls_server_connection_new(
        base_socket: *mut GDatagramBased,
        certificate: *mut GTlsCertificate,
        error: *mut *mut GError,
    ) -> *mut GDatagramBased;
}
/// GIcon:
///
/// An abstract type that specifies an icon.
pub type GIconIface = _GIconIface;
/// GIconIface:
/// @g_iface: The parent interface.
/// @hash: A hash for a given #GIcon.
/// @equal: Checks if two #GIcons are equal.
/// @to_tokens: Serializes a #GIcon into tokens. The tokens must not
/// contain any whitespace. Don't implement if the #GIcon can't be
/// serialized (Since 2.20).
/// @from_tokens: Constructs a #GIcon from tokens. Set the #GError if
/// the tokens are malformed. Don't implement if the #GIcon can't be
/// serialized (Since 2.20).
/// @serialize: Serializes a #GIcon into a #GVariant. Since: 2.38
///
/// GIconIface is used to implement GIcon types for various
/// different systems. See #GThemedIcon and #GLoadableIcon for
/// examples of how to implement this interface.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GIconIface {
    pub g_iface: GTypeInterface,
    pub hash: ::std::option::Option<unsafe extern "C" fn(icon: *mut GIcon) -> guint>,
    pub equal: ::std::option::Option<
        unsafe extern "C" fn(icon1: *mut GIcon, icon2: *mut GIcon) -> gboolean,
    >,
    pub to_tokens: ::std::option::Option<
        unsafe extern "C" fn(icon: *mut GIcon, tokens: *mut GPtrArray, out_version: *mut gint)
            -> gboolean,
    >,
    pub from_tokens: ::std::option::Option<
        unsafe extern "C" fn(
            tokens: *mut *mut gchar,
            num_tokens: gint,
            version: gint,
            error: *mut *mut GError,
        ) -> *mut GIcon,
    >,
    pub serialize: ::std::option::Option<unsafe extern "C" fn(icon: *mut GIcon) -> *mut GVariant>,
}
#[test]
fn bindgen_test_layout__GIconIface() {
    assert_eq!(
        ::std::mem::size_of::<_GIconIface>(),
        56usize,
        concat!("Size of: ", stringify!(_GIconIface))
    );
    assert_eq!(
        ::std::mem::align_of::<_GIconIface>(),
        8usize,
        concat!("Alignment of ", stringify!(_GIconIface))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GIconIface>())).g_iface as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GIconIface),
            "::",
            stringify!(g_iface)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GIconIface>())).hash as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GIconIface),
            "::",
            stringify!(hash)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GIconIface>())).equal as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GIconIface),
            "::",
            stringify!(equal)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GIconIface>())).to_tokens as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_GIconIface),
            "::",
            stringify!(to_tokens)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GIconIface>())).from_tokens as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_GIconIface),
            "::",
            stringify!(from_tokens)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GIconIface>())).serialize as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_GIconIface),
            "::",
            stringify!(serialize)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_g_icon_get_type"]
    pub fn g_icon_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_icon_hash"]
    pub fn g_icon_hash(icon: gconstpointer) -> guint;
}
extern "C" {
    #[link_name = "\u{1}_g_icon_equal"]
    pub fn g_icon_equal(icon1: *mut GIcon, icon2: *mut GIcon) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_icon_to_string"]
    pub fn g_icon_to_string(icon: *mut GIcon) -> *mut gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_icon_new_for_string"]
    pub fn g_icon_new_for_string(str: *const gchar, error: *mut *mut GError) -> *mut GIcon;
}
extern "C" {
    #[link_name = "\u{1}_g_icon_serialize"]
    pub fn g_icon_serialize(icon: *mut GIcon) -> *mut GVariant;
}
extern "C" {
    #[link_name = "\u{1}_g_icon_deserialize"]
    pub fn g_icon_deserialize(value: *mut GVariant) -> *mut GIcon;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GEmblem {
    _unused: [u8; 0],
}
/// GEmblem:
///
/// An object for Emblems
pub type GEmblem = _GEmblem;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GEmblemClass {
    _unused: [u8; 0],
}
pub type GEmblemClass = _GEmblemClass;
extern "C" {
    #[link_name = "\u{1}_g_emblem_get_type"]
    pub fn g_emblem_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_emblem_new"]
    pub fn g_emblem_new(icon: *mut GIcon) -> *mut GEmblem;
}
extern "C" {
    #[link_name = "\u{1}_g_emblem_new_with_origin"]
    pub fn g_emblem_new_with_origin(icon: *mut GIcon, origin: GEmblemOrigin) -> *mut GEmblem;
}
extern "C" {
    #[link_name = "\u{1}_g_emblem_get_icon"]
    pub fn g_emblem_get_icon(emblem: *mut GEmblem) -> *mut GIcon;
}
extern "C" {
    #[link_name = "\u{1}_g_emblem_get_origin"]
    pub fn g_emblem_get_origin(emblem: *mut GEmblem) -> GEmblemOrigin;
}
/// GEmblemedIcon:
///
/// An implementation of #GIcon for icons with emblems.
pub type GEmblemedIcon = _GEmblemedIcon;
pub type GEmblemedIconClass = _GEmblemedIconClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GEmblemedIconPrivate {
    _unused: [u8; 0],
}
pub type GEmblemedIconPrivate = _GEmblemedIconPrivate;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GEmblemedIcon {
    pub parent_instance: GObject,
    pub priv_: *mut GEmblemedIconPrivate,
}
#[test]
fn bindgen_test_layout__GEmblemedIcon() {
    assert_eq!(
        ::std::mem::size_of::<_GEmblemedIcon>(),
        32usize,
        concat!("Size of: ", stringify!(_GEmblemedIcon))
    );
    assert_eq!(
        ::std::mem::align_of::<_GEmblemedIcon>(),
        8usize,
        concat!("Alignment of ", stringify!(_GEmblemedIcon))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GEmblemedIcon>())).parent_instance as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GEmblemedIcon),
            "::",
            stringify!(parent_instance)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GEmblemedIcon>())).priv_ as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GEmblemedIcon),
            "::",
            stringify!(priv_)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GEmblemedIconClass {
    pub parent_class: GObjectClass,
}
#[test]
fn bindgen_test_layout__GEmblemedIconClass() {
    assert_eq!(
        ::std::mem::size_of::<_GEmblemedIconClass>(),
        136usize,
        concat!("Size of: ", stringify!(_GEmblemedIconClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_GEmblemedIconClass>(),
        8usize,
        concat!("Alignment of ", stringify!(_GEmblemedIconClass))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GEmblemedIconClass>())).parent_class as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GEmblemedIconClass),
            "::",
            stringify!(parent_class)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_g_emblemed_icon_get_type"]
    pub fn g_emblemed_icon_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_emblemed_icon_new"]
    pub fn g_emblemed_icon_new(icon: *mut GIcon, emblem: *mut GEmblem) -> *mut GIcon;
}
extern "C" {
    #[link_name = "\u{1}_g_emblemed_icon_get_icon"]
    pub fn g_emblemed_icon_get_icon(emblemed: *mut GEmblemedIcon) -> *mut GIcon;
}
extern "C" {
    #[link_name = "\u{1}_g_emblemed_icon_get_emblems"]
    pub fn g_emblemed_icon_get_emblems(emblemed: *mut GEmblemedIcon) -> *mut GList;
}
extern "C" {
    #[link_name = "\u{1}_g_emblemed_icon_add_emblem"]
    pub fn g_emblemed_icon_add_emblem(emblemed: *mut GEmblemedIcon, emblem: *mut GEmblem);
}
extern "C" {
    #[link_name = "\u{1}_g_emblemed_icon_clear_emblems"]
    pub fn g_emblemed_icon_clear_emblems(emblemed: *mut GEmblemedIcon);
}
/// GFileAttributeInfo:
/// @name: the name of the attribute.
/// @type: the #GFileAttributeType type of the attribute.
/// @flags: a set of #GFileAttributeInfoFlags.
///
/// Information about a specific attribute.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GFileAttributeInfo {
    pub name: *mut ::std::os::raw::c_char,
    pub type_: GFileAttributeType,
    pub flags: GFileAttributeInfoFlags,
}
#[test]
fn bindgen_test_layout__GFileAttributeInfo() {
    assert_eq!(
        ::std::mem::size_of::<_GFileAttributeInfo>(),
        16usize,
        concat!("Size of: ", stringify!(_GFileAttributeInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<_GFileAttributeInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(_GFileAttributeInfo))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GFileAttributeInfo>())).name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileAttributeInfo),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GFileAttributeInfo>())).type_ as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileAttributeInfo),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GFileAttributeInfo>())).flags as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileAttributeInfo),
            "::",
            stringify!(flags)
        )
    );
}
/// GFileAttributeInfoList:
/// @infos: an array of #GFileAttributeInfos.
/// @n_infos: the number of values in the array.
///
/// Acts as a lightweight registry for possible valid file attributes.
/// The registry stores Key-Value pair formats as #GFileAttributeInfos.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GFileAttributeInfoList {
    pub infos: *mut GFileAttributeInfo,
    pub n_infos: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout__GFileAttributeInfoList() {
    assert_eq!(
        ::std::mem::size_of::<_GFileAttributeInfoList>(),
        16usize,
        concat!("Size of: ", stringify!(_GFileAttributeInfoList))
    );
    assert_eq!(
        ::std::mem::align_of::<_GFileAttributeInfoList>(),
        8usize,
        concat!("Alignment of ", stringify!(_GFileAttributeInfoList))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GFileAttributeInfoList>())).infos as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileAttributeInfoList),
            "::",
            stringify!(infos)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GFileAttributeInfoList>())).n_infos as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileAttributeInfoList),
            "::",
            stringify!(n_infos)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_g_file_attribute_info_list_get_type"]
    pub fn g_file_attribute_info_list_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_file_attribute_info_list_new"]
    pub fn g_file_attribute_info_list_new() -> *mut GFileAttributeInfoList;
}
extern "C" {
    #[link_name = "\u{1}_g_file_attribute_info_list_ref"]
    pub fn g_file_attribute_info_list_ref(
        list: *mut GFileAttributeInfoList,
    ) -> *mut GFileAttributeInfoList;
}
extern "C" {
    #[link_name = "\u{1}_g_file_attribute_info_list_unref"]
    pub fn g_file_attribute_info_list_unref(list: *mut GFileAttributeInfoList);
}
extern "C" {
    #[link_name = "\u{1}_g_file_attribute_info_list_dup"]
    pub fn g_file_attribute_info_list_dup(
        list: *mut GFileAttributeInfoList,
    ) -> *mut GFileAttributeInfoList;
}
extern "C" {
    #[link_name = "\u{1}_g_file_attribute_info_list_lookup"]
    pub fn g_file_attribute_info_list_lookup(
        list: *mut GFileAttributeInfoList,
        name: *const ::std::os::raw::c_char,
    ) -> *const GFileAttributeInfo;
}
extern "C" {
    #[link_name = "\u{1}_g_file_attribute_info_list_add"]
    pub fn g_file_attribute_info_list_add(
        list: *mut GFileAttributeInfoList,
        name: *const ::std::os::raw::c_char,
        type_: GFileAttributeType,
        flags: GFileAttributeInfoFlags,
    );
}
/// GFileEnumerator:
///
/// A per matched file iterator.
pub type GFileEnumeratorClass = _GFileEnumeratorClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GFileEnumeratorPrivate {
    _unused: [u8; 0],
}
pub type GFileEnumeratorPrivate = _GFileEnumeratorPrivate;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GFileEnumerator {
    pub parent_instance: GObject,
    pub priv_: *mut GFileEnumeratorPrivate,
}
#[test]
fn bindgen_test_layout__GFileEnumerator() {
    assert_eq!(
        ::std::mem::size_of::<_GFileEnumerator>(),
        32usize,
        concat!("Size of: ", stringify!(_GFileEnumerator))
    );
    assert_eq!(
        ::std::mem::align_of::<_GFileEnumerator>(),
        8usize,
        concat!("Alignment of ", stringify!(_GFileEnumerator))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GFileEnumerator>())).parent_instance as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileEnumerator),
            "::",
            stringify!(parent_instance)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GFileEnumerator>())).priv_ as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileEnumerator),
            "::",
            stringify!(priv_)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GFileEnumeratorClass {
    pub parent_class: GObjectClass,
    pub next_file: ::std::option::Option<
        unsafe extern "C" fn(
            enumerator: *mut GFileEnumerator,
            cancellable: *mut GCancellable,
            error: *mut *mut GError,
        ) -> *mut GFileInfo,
    >,
    pub close_fn: ::std::option::Option<
        unsafe extern "C" fn(
            enumerator: *mut GFileEnumerator,
            cancellable: *mut GCancellable,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
    pub next_files_async: ::std::option::Option<
        unsafe extern "C" fn(
            enumerator: *mut GFileEnumerator,
            num_files: ::std::os::raw::c_int,
            io_priority: ::std::os::raw::c_int,
            cancellable: *mut GCancellable,
            callback: GAsyncReadyCallback,
            user_data: gpointer,
        ),
    >,
    pub next_files_finish: ::std::option::Option<
        unsafe extern "C" fn(
            enumerator: *mut GFileEnumerator,
            result: *mut GAsyncResult,
            error: *mut *mut GError,
        ) -> *mut GList,
    >,
    pub close_async: ::std::option::Option<
        unsafe extern "C" fn(
            enumerator: *mut GFileEnumerator,
            io_priority: ::std::os::raw::c_int,
            cancellable: *mut GCancellable,
            callback: GAsyncReadyCallback,
            user_data: gpointer,
        ),
    >,
    pub close_finish: ::std::option::Option<
        unsafe extern "C" fn(
            enumerator: *mut GFileEnumerator,
            result: *mut GAsyncResult,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
    pub _g_reserved1: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved2: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved3: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved4: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved5: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved6: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved7: ::std::option::Option<unsafe extern "C" fn()>,
}
#[test]
fn bindgen_test_layout__GFileEnumeratorClass() {
    assert_eq!(
        ::std::mem::size_of::<_GFileEnumeratorClass>(),
        240usize,
        concat!("Size of: ", stringify!(_GFileEnumeratorClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_GFileEnumeratorClass>(),
        8usize,
        concat!("Alignment of ", stringify!(_GFileEnumeratorClass))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GFileEnumeratorClass>())).parent_class as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileEnumeratorClass),
            "::",
            stringify!(parent_class)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GFileEnumeratorClass>())).next_file as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileEnumeratorClass),
            "::",
            stringify!(next_file)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GFileEnumeratorClass>())).close_fn as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileEnumeratorClass),
            "::",
            stringify!(close_fn)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GFileEnumeratorClass>())).next_files_async as *const _ as usize
        },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileEnumeratorClass),
            "::",
            stringify!(next_files_async)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GFileEnumeratorClass>())).next_files_finish as *const _ as usize
        },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileEnumeratorClass),
            "::",
            stringify!(next_files_finish)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GFileEnumeratorClass>())).close_async as *const _ as usize
        },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileEnumeratorClass),
            "::",
            stringify!(close_async)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GFileEnumeratorClass>())).close_finish as *const _ as usize
        },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileEnumeratorClass),
            "::",
            stringify!(close_finish)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GFileEnumeratorClass>()))._g_reserved1 as *const _ as usize
        },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileEnumeratorClass),
            "::",
            stringify!(_g_reserved1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GFileEnumeratorClass>()))._g_reserved2 as *const _ as usize
        },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileEnumeratorClass),
            "::",
            stringify!(_g_reserved2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GFileEnumeratorClass>()))._g_reserved3 as *const _ as usize
        },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileEnumeratorClass),
            "::",
            stringify!(_g_reserved3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GFileEnumeratorClass>()))._g_reserved4 as *const _ as usize
        },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileEnumeratorClass),
            "::",
            stringify!(_g_reserved4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GFileEnumeratorClass>()))._g_reserved5 as *const _ as usize
        },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileEnumeratorClass),
            "::",
            stringify!(_g_reserved5)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GFileEnumeratorClass>()))._g_reserved6 as *const _ as usize
        },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileEnumeratorClass),
            "::",
            stringify!(_g_reserved6)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GFileEnumeratorClass>()))._g_reserved7 as *const _ as usize
        },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileEnumeratorClass),
            "::",
            stringify!(_g_reserved7)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_g_file_enumerator_get_type"]
    pub fn g_file_enumerator_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_file_enumerator_next_file"]
    pub fn g_file_enumerator_next_file(
        enumerator: *mut GFileEnumerator,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> *mut GFileInfo;
}
extern "C" {
    #[link_name = "\u{1}_g_file_enumerator_close"]
    pub fn g_file_enumerator_close(
        enumerator: *mut GFileEnumerator,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_file_enumerator_next_files_async"]
    pub fn g_file_enumerator_next_files_async(
        enumerator: *mut GFileEnumerator,
        num_files: ::std::os::raw::c_int,
        io_priority: ::std::os::raw::c_int,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_file_enumerator_next_files_finish"]
    pub fn g_file_enumerator_next_files_finish(
        enumerator: *mut GFileEnumerator,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> *mut GList;
}
extern "C" {
    #[link_name = "\u{1}_g_file_enumerator_close_async"]
    pub fn g_file_enumerator_close_async(
        enumerator: *mut GFileEnumerator,
        io_priority: ::std::os::raw::c_int,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_file_enumerator_close_finish"]
    pub fn g_file_enumerator_close_finish(
        enumerator: *mut GFileEnumerator,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_file_enumerator_is_closed"]
    pub fn g_file_enumerator_is_closed(enumerator: *mut GFileEnumerator) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_file_enumerator_has_pending"]
    pub fn g_file_enumerator_has_pending(enumerator: *mut GFileEnumerator) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_file_enumerator_set_pending"]
    pub fn g_file_enumerator_set_pending(enumerator: *mut GFileEnumerator, pending: gboolean);
}
extern "C" {
    #[link_name = "\u{1}_g_file_enumerator_get_container"]
    pub fn g_file_enumerator_get_container(enumerator: *mut GFileEnumerator) -> *mut GFile;
}
extern "C" {
    #[link_name = "\u{1}_g_file_enumerator_get_child"]
    pub fn g_file_enumerator_get_child(
        enumerator: *mut GFileEnumerator,
        info: *mut GFileInfo,
    ) -> *mut GFile;
}
extern "C" {
    #[link_name = "\u{1}_g_file_enumerator_iterate"]
    pub fn g_file_enumerator_iterate(
        direnum: *mut GFileEnumerator,
        out_info: *mut *mut GFileInfo,
        out_child: *mut *mut GFile,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gboolean;
}
pub type GFileIface = _GFileIface;
/// GFileIface:
/// @g_iface: The parent interface.
/// @dup: Duplicates a #GFile.
/// @hash: Creates a hash of a #GFile.
/// @equal: Checks equality of two given #GFiles.
/// @is_native: Checks to see if a file is native to the system.
/// @has_uri_scheme: Checks to see if a #GFile has a given URI scheme.
/// @get_uri_scheme: Gets the URI scheme for a #GFile.
/// @get_basename: Gets the basename for a given #GFile.
/// @get_path: Gets the current path within a #GFile.
/// @get_uri: Gets a URI for the path within a #GFile.
/// @get_parse_name: Gets the parsed name for the #GFile.
/// @get_parent: Gets the parent directory for the #GFile.
/// @prefix_matches: Checks whether a #GFile contains a specified file.
/// @get_relative_path: Gets the path for a #GFile relative to a given path.
/// @resolve_relative_path: Resolves a relative path for a #GFile to an absolute path.
/// @get_child_for_display_name: Gets the child #GFile for a given display name.
/// @enumerate_children: Gets a #GFileEnumerator with the children of a #GFile.
/// @enumerate_children_async: Asynchronously gets a #GFileEnumerator with the children of a #GFile.
/// @enumerate_children_finish: Finishes asynchronously enumerating the children.
/// @query_info: Gets the #GFileInfo for a #GFile.
/// @query_info_async: Asynchronously gets the #GFileInfo for a #GFile.
/// @query_info_finish: Finishes an asynchronous query info operation.
/// @query_filesystem_info: Gets a #GFileInfo for the file system #GFile is on.
/// @query_filesystem_info_async: Asynchronously gets a #GFileInfo for the file system #GFile is on.
/// @query_filesystem_info_finish: Finishes asynchronously getting the file system info.
/// @find_enclosing_mount: Gets a #GMount for the #GFile.
/// @find_enclosing_mount_async: Asynchronously gets the #GMount for a #GFile.
/// @find_enclosing_mount_finish: Finishes asynchronously getting the volume.
/// @set_display_name: Sets the display name for a #GFile.
/// @set_display_name_async: Asynchronously sets a #GFile's display name.
/// @set_display_name_finish: Finishes asynchronously setting a #GFile's display name.
/// @query_settable_attributes: Returns a list of #GFileAttributes that can be set.
/// @_query_settable_attributes_async: Asynchronously gets a list of #GFileAttributes that can be set.
/// @_query_settable_attributes_finish: Finishes asynchronously querying settable attributes.
/// @query_writable_namespaces: Returns a list of #GFileAttribute namespaces that are writable.
/// @_query_writable_namespaces_async: Asynchronously gets a list of #GFileAttribute namespaces that are writable.
/// @_query_writable_namespaces_finish: Finishes asynchronously querying the writable namespaces.
/// @set_attribute: Sets a #GFileAttribute.
/// @set_attributes_from_info: Sets a #GFileAttribute with information from a #GFileInfo.
/// @set_attributes_async: Asynchronously sets a file's attributes.
/// @set_attributes_finish: Finishes setting a file's attributes asynchronously.
/// @read_fn: Reads a file asynchronously.
/// @read_async: Asynchronously reads a file.
/// @read_finish: Finishes asynchronously reading a file.
/// @append_to: Writes to the end of a file.
/// @append_to_async: Asynchronously writes to the end of a file.
/// @append_to_finish: Finishes an asynchronous file append operation.
/// @create: Creates a new file.
/// @create_async: Asynchronously creates a file.
/// @create_finish: Finishes asynchronously creating a file.
/// @replace: Replaces the contents of a file.
/// @replace_async: Asynchronously replaces the contents of a file.
/// @replace_finish: Finishes asynchronously replacing a file.
/// @delete_file: Deletes a file.
/// @delete_file_async: Asynchronously deletes a file.
/// @delete_file_finish: Finishes an asynchronous delete.
/// @trash: Sends a #GFile to the Trash location.
/// @trash_async: Asynchronously sends a #GFile to the Trash location.
/// @trash_finish: Finishes an asynchronous file trashing operation.
/// @make_directory: Makes a directory.
/// @make_directory_async: Asynchronously makes a directory.
/// @make_directory_finish: Finishes making a directory asynchronously.
/// @make_symbolic_link: Makes a symbolic link.
/// @_make_symbolic_link_async: Asynchronously makes a symbolic link
/// @_make_symbolic_link_finish: Finishes making a symbolic link asynchronously.
/// @copy: Copies a file.
/// @copy_async: Asynchronously copies a file.
/// @copy_finish: Finishes an asynchronous copy operation.
/// @move: Moves a file.
/// @_move_async: Asynchronously moves a file.
/// @_move_finish: Finishes an asynchronous move operation.
/// @mount_mountable: Mounts a mountable object.
/// @mount_mountable_finish: Finishes a mounting operation.
/// @unmount_mountable: Unmounts a mountable object.
/// @unmount_mountable_finish: Finishes an unmount operation.
/// @eject_mountable: Ejects a mountable.
/// @eject_mountable_finish: Finishes an eject operation.
/// @mount_enclosing_volume: Mounts a specified location.
/// @mount_enclosing_volume_finish: Finishes mounting a specified location.
/// @monitor_dir: Creates a #GFileMonitor for the location.
/// @monitor_file: Creates a #GFileMonitor for the location.
/// @open_readwrite: Open file read/write. Since 2.22.
/// @open_readwrite_async: Asynchronously opens file read/write. Since 2.22.
/// @open_readwrite_finish: Finishes an asynchronous open read/write. Since 2.22.
/// @create_readwrite: Creates file read/write. Since 2.22.
/// @create_readwrite_async: Asynchronously creates file read/write. Since 2.22.
/// @create_readwrite_finish: Finishes an asynchronous creates read/write. Since 2.22.
/// @replace_readwrite: Replaces file read/write. Since 2.22.
/// @replace_readwrite_async: Asynchronously replaces file read/write. Since 2.22.
/// @replace_readwrite_finish: Finishes an asynchronous replace read/write. Since 2.22.
/// @start_mountable: Starts a mountable object. Since 2.22.
/// @start_mountable_finish: Finishes an start operation. Since 2.22.
/// @stop_mountable: Stops a mountable. Since 2.22.
/// @stop_mountable_finish: Finishes an stop operation. Since 2.22.
/// @supports_thread_contexts: a boolean that indicates whether the #GFile implementation supports thread-default contexts. Since 2.22.
/// @unmount_mountable_with_operation: Unmounts a mountable object using a #GMountOperation. Since 2.22.
/// @unmount_mountable_with_operation_finish: Finishes an unmount operation using a #GMountOperation. Since 2.22.
/// @eject_mountable_with_operation: Ejects a mountable object using a #GMountOperation. Since 2.22.
/// @eject_mountable_with_operation_finish: Finishes an eject operation using a #GMountOperation. Since 2.22.
/// @poll_mountable: Polls a mountable object for media changes. Since 2.22.
/// @poll_mountable_finish: Finishes an poll operation for media changes. Since 2.22.
/// @measure_disk_usage: Recursively measures the disk usage of @file. Since 2.38
/// @measure_disk_usage_async: Asynchronously recursively measures the disk usage of @file. Since 2.38
/// @measure_disk_usage_finish: Finishes an asynchronous recursive measurement of the disk usage of @file. Since 2.38
///
/// An interface for writing VFS file handles.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GFileIface {
    pub g_iface: GTypeInterface,
    pub dup: ::std::option::Option<unsafe extern "C" fn(file: *mut GFile) -> *mut GFile>,
    pub hash: ::std::option::Option<unsafe extern "C" fn(file: *mut GFile) -> guint>,
    pub equal: ::std::option::Option<
        unsafe extern "C" fn(file1: *mut GFile, file2: *mut GFile) -> gboolean,
    >,
    pub is_native: ::std::option::Option<unsafe extern "C" fn(file: *mut GFile) -> gboolean>,
    pub has_uri_scheme: ::std::option::Option<
        unsafe extern "C" fn(file: *mut GFile, uri_scheme: *const ::std::os::raw::c_char)
            -> gboolean,
    >,
    pub get_uri_scheme: ::std::option::Option<
        unsafe extern "C" fn(file: *mut GFile) -> *mut ::std::os::raw::c_char,
    >,
    pub get_basename: ::std::option::Option<
        unsafe extern "C" fn(file: *mut GFile) -> *mut ::std::os::raw::c_char,
    >,
    pub get_path: ::std::option::Option<
        unsafe extern "C" fn(file: *mut GFile) -> *mut ::std::os::raw::c_char,
    >,
    pub get_uri: ::std::option::Option<
        unsafe extern "C" fn(file: *mut GFile) -> *mut ::std::os::raw::c_char,
    >,
    pub get_parse_name: ::std::option::Option<
        unsafe extern "C" fn(file: *mut GFile) -> *mut ::std::os::raw::c_char,
    >,
    pub get_parent: ::std::option::Option<unsafe extern "C" fn(file: *mut GFile) -> *mut GFile>,
    pub prefix_matches: ::std::option::Option<
        unsafe extern "C" fn(prefix: *mut GFile, file: *mut GFile) -> gboolean,
    >,
    pub get_relative_path: ::std::option::Option<
        unsafe extern "C" fn(parent: *mut GFile, descendant: *mut GFile)
            -> *mut ::std::os::raw::c_char,
    >,
    pub resolve_relative_path: ::std::option::Option<
        unsafe extern "C" fn(file: *mut GFile, relative_path: *const ::std::os::raw::c_char)
            -> *mut GFile,
    >,
    pub get_child_for_display_name: ::std::option::Option<
        unsafe extern "C" fn(
            file: *mut GFile,
            display_name: *const ::std::os::raw::c_char,
            error: *mut *mut GError,
        ) -> *mut GFile,
    >,
    pub enumerate_children: ::std::option::Option<
        unsafe extern "C" fn(
            file: *mut GFile,
            attributes: *const ::std::os::raw::c_char,
            flags: GFileQueryInfoFlags,
            cancellable: *mut GCancellable,
            error: *mut *mut GError,
        ) -> *mut GFileEnumerator,
    >,
    pub enumerate_children_async: ::std::option::Option<
        unsafe extern "C" fn(
            file: *mut GFile,
            attributes: *const ::std::os::raw::c_char,
            flags: GFileQueryInfoFlags,
            io_priority: ::std::os::raw::c_int,
            cancellable: *mut GCancellable,
            callback: GAsyncReadyCallback,
            user_data: gpointer,
        ),
    >,
    pub enumerate_children_finish: ::std::option::Option<
        unsafe extern "C" fn(file: *mut GFile, res: *mut GAsyncResult, error: *mut *mut GError)
            -> *mut GFileEnumerator,
    >,
    pub query_info: ::std::option::Option<
        unsafe extern "C" fn(
            file: *mut GFile,
            attributes: *const ::std::os::raw::c_char,
            flags: GFileQueryInfoFlags,
            cancellable: *mut GCancellable,
            error: *mut *mut GError,
        ) -> *mut GFileInfo,
    >,
    pub query_info_async: ::std::option::Option<
        unsafe extern "C" fn(
            file: *mut GFile,
            attributes: *const ::std::os::raw::c_char,
            flags: GFileQueryInfoFlags,
            io_priority: ::std::os::raw::c_int,
            cancellable: *mut GCancellable,
            callback: GAsyncReadyCallback,
            user_data: gpointer,
        ),
    >,
    pub query_info_finish: ::std::option::Option<
        unsafe extern "C" fn(file: *mut GFile, res: *mut GAsyncResult, error: *mut *mut GError)
            -> *mut GFileInfo,
    >,
    pub query_filesystem_info: ::std::option::Option<
        unsafe extern "C" fn(
            file: *mut GFile,
            attributes: *const ::std::os::raw::c_char,
            cancellable: *mut GCancellable,
            error: *mut *mut GError,
        ) -> *mut GFileInfo,
    >,
    pub query_filesystem_info_async: ::std::option::Option<
        unsafe extern "C" fn(
            file: *mut GFile,
            attributes: *const ::std::os::raw::c_char,
            io_priority: ::std::os::raw::c_int,
            cancellable: *mut GCancellable,
            callback: GAsyncReadyCallback,
            user_data: gpointer,
        ),
    >,
    pub query_filesystem_info_finish: ::std::option::Option<
        unsafe extern "C" fn(file: *mut GFile, res: *mut GAsyncResult, error: *mut *mut GError)
            -> *mut GFileInfo,
    >,
    pub find_enclosing_mount: ::std::option::Option<
        unsafe extern "C" fn(
            file: *mut GFile,
            cancellable: *mut GCancellable,
            error: *mut *mut GError,
        ) -> *mut GMount,
    >,
    pub find_enclosing_mount_async: ::std::option::Option<
        unsafe extern "C" fn(
            file: *mut GFile,
            io_priority: ::std::os::raw::c_int,
            cancellable: *mut GCancellable,
            callback: GAsyncReadyCallback,
            user_data: gpointer,
        ),
    >,
    pub find_enclosing_mount_finish: ::std::option::Option<
        unsafe extern "C" fn(file: *mut GFile, res: *mut GAsyncResult, error: *mut *mut GError)
            -> *mut GMount,
    >,
    pub set_display_name: ::std::option::Option<
        unsafe extern "C" fn(
            file: *mut GFile,
            display_name: *const ::std::os::raw::c_char,
            cancellable: *mut GCancellable,
            error: *mut *mut GError,
        ) -> *mut GFile,
    >,
    pub set_display_name_async: ::std::option::Option<
        unsafe extern "C" fn(
            file: *mut GFile,
            display_name: *const ::std::os::raw::c_char,
            io_priority: ::std::os::raw::c_int,
            cancellable: *mut GCancellable,
            callback: GAsyncReadyCallback,
            user_data: gpointer,
        ),
    >,
    pub set_display_name_finish: ::std::option::Option<
        unsafe extern "C" fn(file: *mut GFile, res: *mut GAsyncResult, error: *mut *mut GError)
            -> *mut GFile,
    >,
    pub query_settable_attributes: ::std::option::Option<
        unsafe extern "C" fn(
            file: *mut GFile,
            cancellable: *mut GCancellable,
            error: *mut *mut GError,
        ) -> *mut GFileAttributeInfoList,
    >,
    pub _query_settable_attributes_async: ::std::option::Option<unsafe extern "C" fn()>,
    pub _query_settable_attributes_finish: ::std::option::Option<unsafe extern "C" fn()>,
    pub query_writable_namespaces: ::std::option::Option<
        unsafe extern "C" fn(
            file: *mut GFile,
            cancellable: *mut GCancellable,
            error: *mut *mut GError,
        ) -> *mut GFileAttributeInfoList,
    >,
    pub _query_writable_namespaces_async: ::std::option::Option<unsafe extern "C" fn()>,
    pub _query_writable_namespaces_finish: ::std::option::Option<unsafe extern "C" fn()>,
    pub set_attribute: ::std::option::Option<
        unsafe extern "C" fn(
            file: *mut GFile,
            attribute: *const ::std::os::raw::c_char,
            type_: GFileAttributeType,
            value_p: gpointer,
            flags: GFileQueryInfoFlags,
            cancellable: *mut GCancellable,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
    pub set_attributes_from_info: ::std::option::Option<
        unsafe extern "C" fn(
            file: *mut GFile,
            info: *mut GFileInfo,
            flags: GFileQueryInfoFlags,
            cancellable: *mut GCancellable,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
    pub set_attributes_async: ::std::option::Option<
        unsafe extern "C" fn(
            file: *mut GFile,
            info: *mut GFileInfo,
            flags: GFileQueryInfoFlags,
            io_priority: ::std::os::raw::c_int,
            cancellable: *mut GCancellable,
            callback: GAsyncReadyCallback,
            user_data: gpointer,
        ),
    >,
    pub set_attributes_finish: ::std::option::Option<
        unsafe extern "C" fn(
            file: *mut GFile,
            result: *mut GAsyncResult,
            info: *mut *mut GFileInfo,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
    pub read_fn: ::std::option::Option<
        unsafe extern "C" fn(
            file: *mut GFile,
            cancellable: *mut GCancellable,
            error: *mut *mut GError,
        ) -> *mut GFileInputStream,
    >,
    pub read_async: ::std::option::Option<
        unsafe extern "C" fn(
            file: *mut GFile,
            io_priority: ::std::os::raw::c_int,
            cancellable: *mut GCancellable,
            callback: GAsyncReadyCallback,
            user_data: gpointer,
        ),
    >,
    pub read_finish: ::std::option::Option<
        unsafe extern "C" fn(file: *mut GFile, res: *mut GAsyncResult, error: *mut *mut GError)
            -> *mut GFileInputStream,
    >,
    pub append_to: ::std::option::Option<
        unsafe extern "C" fn(
            file: *mut GFile,
            flags: GFileCreateFlags,
            cancellable: *mut GCancellable,
            error: *mut *mut GError,
        ) -> *mut GFileOutputStream,
    >,
    pub append_to_async: ::std::option::Option<
        unsafe extern "C" fn(
            file: *mut GFile,
            flags: GFileCreateFlags,
            io_priority: ::std::os::raw::c_int,
            cancellable: *mut GCancellable,
            callback: GAsyncReadyCallback,
            user_data: gpointer,
        ),
    >,
    pub append_to_finish: ::std::option::Option<
        unsafe extern "C" fn(file: *mut GFile, res: *mut GAsyncResult, error: *mut *mut GError)
            -> *mut GFileOutputStream,
    >,
    pub create: ::std::option::Option<
        unsafe extern "C" fn(
            file: *mut GFile,
            flags: GFileCreateFlags,
            cancellable: *mut GCancellable,
            error: *mut *mut GError,
        ) -> *mut GFileOutputStream,
    >,
    pub create_async: ::std::option::Option<
        unsafe extern "C" fn(
            file: *mut GFile,
            flags: GFileCreateFlags,
            io_priority: ::std::os::raw::c_int,
            cancellable: *mut GCancellable,
            callback: GAsyncReadyCallback,
            user_data: gpointer,
        ),
    >,
    pub create_finish: ::std::option::Option<
        unsafe extern "C" fn(file: *mut GFile, res: *mut GAsyncResult, error: *mut *mut GError)
            -> *mut GFileOutputStream,
    >,
    pub replace: ::std::option::Option<
        unsafe extern "C" fn(
            file: *mut GFile,
            etag: *const ::std::os::raw::c_char,
            make_backup: gboolean,
            flags: GFileCreateFlags,
            cancellable: *mut GCancellable,
            error: *mut *mut GError,
        ) -> *mut GFileOutputStream,
    >,
    pub replace_async: ::std::option::Option<
        unsafe extern "C" fn(
            file: *mut GFile,
            etag: *const ::std::os::raw::c_char,
            make_backup: gboolean,
            flags: GFileCreateFlags,
            io_priority: ::std::os::raw::c_int,
            cancellable: *mut GCancellable,
            callback: GAsyncReadyCallback,
            user_data: gpointer,
        ),
    >,
    pub replace_finish: ::std::option::Option<
        unsafe extern "C" fn(file: *mut GFile, res: *mut GAsyncResult, error: *mut *mut GError)
            -> *mut GFileOutputStream,
    >,
    pub delete_file: ::std::option::Option<
        unsafe extern "C" fn(
            file: *mut GFile,
            cancellable: *mut GCancellable,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
    pub delete_file_async: ::std::option::Option<
        unsafe extern "C" fn(
            file: *mut GFile,
            io_priority: ::std::os::raw::c_int,
            cancellable: *mut GCancellable,
            callback: GAsyncReadyCallback,
            user_data: gpointer,
        ),
    >,
    pub delete_file_finish: ::std::option::Option<
        unsafe extern "C" fn(file: *mut GFile, result: *mut GAsyncResult, error: *mut *mut GError)
            -> gboolean,
    >,
    pub trash: ::std::option::Option<
        unsafe extern "C" fn(
            file: *mut GFile,
            cancellable: *mut GCancellable,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
    pub trash_async: ::std::option::Option<
        unsafe extern "C" fn(
            file: *mut GFile,
            io_priority: ::std::os::raw::c_int,
            cancellable: *mut GCancellable,
            callback: GAsyncReadyCallback,
            user_data: gpointer,
        ),
    >,
    pub trash_finish: ::std::option::Option<
        unsafe extern "C" fn(file: *mut GFile, result: *mut GAsyncResult, error: *mut *mut GError)
            -> gboolean,
    >,
    pub make_directory: ::std::option::Option<
        unsafe extern "C" fn(
            file: *mut GFile,
            cancellable: *mut GCancellable,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
    pub make_directory_async: ::std::option::Option<
        unsafe extern "C" fn(
            file: *mut GFile,
            io_priority: ::std::os::raw::c_int,
            cancellable: *mut GCancellable,
            callback: GAsyncReadyCallback,
            user_data: gpointer,
        ),
    >,
    pub make_directory_finish: ::std::option::Option<
        unsafe extern "C" fn(file: *mut GFile, result: *mut GAsyncResult, error: *mut *mut GError)
            -> gboolean,
    >,
    pub make_symbolic_link: ::std::option::Option<
        unsafe extern "C" fn(
            file: *mut GFile,
            symlink_value: *const ::std::os::raw::c_char,
            cancellable: *mut GCancellable,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
    pub _make_symbolic_link_async: ::std::option::Option<unsafe extern "C" fn()>,
    pub _make_symbolic_link_finish: ::std::option::Option<unsafe extern "C" fn()>,
    pub copy: ::std::option::Option<
        unsafe extern "C" fn(
            source: *mut GFile,
            destination: *mut GFile,
            flags: GFileCopyFlags,
            cancellable: *mut GCancellable,
            progress_callback: GFileProgressCallback,
            progress_callback_data: gpointer,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
    pub copy_async: ::std::option::Option<
        unsafe extern "C" fn(
            source: *mut GFile,
            destination: *mut GFile,
            flags: GFileCopyFlags,
            io_priority: ::std::os::raw::c_int,
            cancellable: *mut GCancellable,
            progress_callback: GFileProgressCallback,
            progress_callback_data: gpointer,
            callback: GAsyncReadyCallback,
            user_data: gpointer,
        ),
    >,
    pub copy_finish: ::std::option::Option<
        unsafe extern "C" fn(file: *mut GFile, res: *mut GAsyncResult, error: *mut *mut GError)
            -> gboolean,
    >,
    pub move_: ::std::option::Option<
        unsafe extern "C" fn(
            source: *mut GFile,
            destination: *mut GFile,
            flags: GFileCopyFlags,
            cancellable: *mut GCancellable,
            progress_callback: GFileProgressCallback,
            progress_callback_data: gpointer,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
    pub _move_async: ::std::option::Option<unsafe extern "C" fn()>,
    pub _move_finish: ::std::option::Option<unsafe extern "C" fn()>,
    pub mount_mountable: ::std::option::Option<
        unsafe extern "C" fn(
            file: *mut GFile,
            flags: GMountMountFlags,
            mount_operation: *mut GMountOperation,
            cancellable: *mut GCancellable,
            callback: GAsyncReadyCallback,
            user_data: gpointer,
        ),
    >,
    pub mount_mountable_finish: ::std::option::Option<
        unsafe extern "C" fn(file: *mut GFile, result: *mut GAsyncResult, error: *mut *mut GError)
            -> *mut GFile,
    >,
    pub unmount_mountable: ::std::option::Option<
        unsafe extern "C" fn(
            file: *mut GFile,
            flags: GMountUnmountFlags,
            cancellable: *mut GCancellable,
            callback: GAsyncReadyCallback,
            user_data: gpointer,
        ),
    >,
    pub unmount_mountable_finish: ::std::option::Option<
        unsafe extern "C" fn(file: *mut GFile, result: *mut GAsyncResult, error: *mut *mut GError)
            -> gboolean,
    >,
    pub eject_mountable: ::std::option::Option<
        unsafe extern "C" fn(
            file: *mut GFile,
            flags: GMountUnmountFlags,
            cancellable: *mut GCancellable,
            callback: GAsyncReadyCallback,
            user_data: gpointer,
        ),
    >,
    pub eject_mountable_finish: ::std::option::Option<
        unsafe extern "C" fn(file: *mut GFile, result: *mut GAsyncResult, error: *mut *mut GError)
            -> gboolean,
    >,
    pub mount_enclosing_volume: ::std::option::Option<
        unsafe extern "C" fn(
            location: *mut GFile,
            flags: GMountMountFlags,
            mount_operation: *mut GMountOperation,
            cancellable: *mut GCancellable,
            callback: GAsyncReadyCallback,
            user_data: gpointer,
        ),
    >,
    pub mount_enclosing_volume_finish: ::std::option::Option<
        unsafe extern "C" fn(
            location: *mut GFile,
            result: *mut GAsyncResult,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
    pub monitor_dir: ::std::option::Option<
        unsafe extern "C" fn(
            file: *mut GFile,
            flags: GFileMonitorFlags,
            cancellable: *mut GCancellable,
            error: *mut *mut GError,
        ) -> *mut GFileMonitor,
    >,
    pub monitor_file: ::std::option::Option<
        unsafe extern "C" fn(
            file: *mut GFile,
            flags: GFileMonitorFlags,
            cancellable: *mut GCancellable,
            error: *mut *mut GError,
        ) -> *mut GFileMonitor,
    >,
    pub open_readwrite: ::std::option::Option<
        unsafe extern "C" fn(
            file: *mut GFile,
            cancellable: *mut GCancellable,
            error: *mut *mut GError,
        ) -> *mut GFileIOStream,
    >,
    pub open_readwrite_async: ::std::option::Option<
        unsafe extern "C" fn(
            file: *mut GFile,
            io_priority: ::std::os::raw::c_int,
            cancellable: *mut GCancellable,
            callback: GAsyncReadyCallback,
            user_data: gpointer,
        ),
    >,
    pub open_readwrite_finish: ::std::option::Option<
        unsafe extern "C" fn(file: *mut GFile, res: *mut GAsyncResult, error: *mut *mut GError)
            -> *mut GFileIOStream,
    >,
    pub create_readwrite: ::std::option::Option<
        unsafe extern "C" fn(
            file: *mut GFile,
            flags: GFileCreateFlags,
            cancellable: *mut GCancellable,
            error: *mut *mut GError,
        ) -> *mut GFileIOStream,
    >,
    pub create_readwrite_async: ::std::option::Option<
        unsafe extern "C" fn(
            file: *mut GFile,
            flags: GFileCreateFlags,
            io_priority: ::std::os::raw::c_int,
            cancellable: *mut GCancellable,
            callback: GAsyncReadyCallback,
            user_data: gpointer,
        ),
    >,
    pub create_readwrite_finish: ::std::option::Option<
        unsafe extern "C" fn(file: *mut GFile, res: *mut GAsyncResult, error: *mut *mut GError)
            -> *mut GFileIOStream,
    >,
    pub replace_readwrite: ::std::option::Option<
        unsafe extern "C" fn(
            file: *mut GFile,
            etag: *const ::std::os::raw::c_char,
            make_backup: gboolean,
            flags: GFileCreateFlags,
            cancellable: *mut GCancellable,
            error: *mut *mut GError,
        ) -> *mut GFileIOStream,
    >,
    pub replace_readwrite_async: ::std::option::Option<
        unsafe extern "C" fn(
            file: *mut GFile,
            etag: *const ::std::os::raw::c_char,
            make_backup: gboolean,
            flags: GFileCreateFlags,
            io_priority: ::std::os::raw::c_int,
            cancellable: *mut GCancellable,
            callback: GAsyncReadyCallback,
            user_data: gpointer,
        ),
    >,
    pub replace_readwrite_finish: ::std::option::Option<
        unsafe extern "C" fn(file: *mut GFile, res: *mut GAsyncResult, error: *mut *mut GError)
            -> *mut GFileIOStream,
    >,
    pub start_mountable: ::std::option::Option<
        unsafe extern "C" fn(
            file: *mut GFile,
            flags: GDriveStartFlags,
            start_operation: *mut GMountOperation,
            cancellable: *mut GCancellable,
            callback: GAsyncReadyCallback,
            user_data: gpointer,
        ),
    >,
    pub start_mountable_finish: ::std::option::Option<
        unsafe extern "C" fn(file: *mut GFile, result: *mut GAsyncResult, error: *mut *mut GError)
            -> gboolean,
    >,
    pub stop_mountable: ::std::option::Option<
        unsafe extern "C" fn(
            file: *mut GFile,
            flags: GMountUnmountFlags,
            mount_operation: *mut GMountOperation,
            cancellable: *mut GCancellable,
            callback: GAsyncReadyCallback,
            user_data: gpointer,
        ),
    >,
    pub stop_mountable_finish: ::std::option::Option<
        unsafe extern "C" fn(file: *mut GFile, result: *mut GAsyncResult, error: *mut *mut GError)
            -> gboolean,
    >,
    pub supports_thread_contexts: gboolean,
    pub unmount_mountable_with_operation: ::std::option::Option<
        unsafe extern "C" fn(
            file: *mut GFile,
            flags: GMountUnmountFlags,
            mount_operation: *mut GMountOperation,
            cancellable: *mut GCancellable,
            callback: GAsyncReadyCallback,
            user_data: gpointer,
        ),
    >,
    pub unmount_mountable_with_operation_finish: ::std::option::Option<
        unsafe extern "C" fn(file: *mut GFile, result: *mut GAsyncResult, error: *mut *mut GError)
            -> gboolean,
    >,
    pub eject_mountable_with_operation: ::std::option::Option<
        unsafe extern "C" fn(
            file: *mut GFile,
            flags: GMountUnmountFlags,
            mount_operation: *mut GMountOperation,
            cancellable: *mut GCancellable,
            callback: GAsyncReadyCallback,
            user_data: gpointer,
        ),
    >,
    pub eject_mountable_with_operation_finish: ::std::option::Option<
        unsafe extern "C" fn(file: *mut GFile, result: *mut GAsyncResult, error: *mut *mut GError)
            -> gboolean,
    >,
    pub poll_mountable: ::std::option::Option<
        unsafe extern "C" fn(
            file: *mut GFile,
            cancellable: *mut GCancellable,
            callback: GAsyncReadyCallback,
            user_data: gpointer,
        ),
    >,
    pub poll_mountable_finish: ::std::option::Option<
        unsafe extern "C" fn(file: *mut GFile, result: *mut GAsyncResult, error: *mut *mut GError)
            -> gboolean,
    >,
    pub measure_disk_usage: ::std::option::Option<
        unsafe extern "C" fn(
            file: *mut GFile,
            flags: GFileMeasureFlags,
            cancellable: *mut GCancellable,
            progress_callback: GFileMeasureProgressCallback,
            progress_data: gpointer,
            disk_usage: *mut guint64,
            num_dirs: *mut guint64,
            num_files: *mut guint64,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
    pub measure_disk_usage_async: ::std::option::Option<
        unsafe extern "C" fn(
            file: *mut GFile,
            flags: GFileMeasureFlags,
            io_priority: gint,
            cancellable: *mut GCancellable,
            progress_callback: GFileMeasureProgressCallback,
            progress_data: gpointer,
            callback: GAsyncReadyCallback,
            user_data: gpointer,
        ),
    >,
    pub measure_disk_usage_finish: ::std::option::Option<
        unsafe extern "C" fn(
            file: *mut GFile,
            result: *mut GAsyncResult,
            disk_usage: *mut guint64,
            num_dirs: *mut guint64,
            num_files: *mut guint64,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
}
#[test]
fn bindgen_test_layout__GFileIface() {
    assert_eq!(
        ::std::mem::size_of::<_GFileIface>(),
        840usize,
        concat!("Size of: ", stringify!(_GFileIface))
    );
    assert_eq!(
        ::std::mem::align_of::<_GFileIface>(),
        8usize,
        concat!("Alignment of ", stringify!(_GFileIface))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GFileIface>())).g_iface as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIface),
            "::",
            stringify!(g_iface)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GFileIface>())).dup as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIface),
            "::",
            stringify!(dup)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GFileIface>())).hash as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIface),
            "::",
            stringify!(hash)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GFileIface>())).equal as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIface),
            "::",
            stringify!(equal)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GFileIface>())).is_native as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIface),
            "::",
            stringify!(is_native)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GFileIface>())).has_uri_scheme as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIface),
            "::",
            stringify!(has_uri_scheme)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GFileIface>())).get_uri_scheme as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIface),
            "::",
            stringify!(get_uri_scheme)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GFileIface>())).get_basename as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIface),
            "::",
            stringify!(get_basename)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GFileIface>())).get_path as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIface),
            "::",
            stringify!(get_path)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GFileIface>())).get_uri as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIface),
            "::",
            stringify!(get_uri)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GFileIface>())).get_parse_name as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIface),
            "::",
            stringify!(get_parse_name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GFileIface>())).get_parent as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIface),
            "::",
            stringify!(get_parent)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GFileIface>())).prefix_matches as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIface),
            "::",
            stringify!(prefix_matches)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GFileIface>())).get_relative_path as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIface),
            "::",
            stringify!(get_relative_path)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GFileIface>())).resolve_relative_path as *const _ as usize
        },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIface),
            "::",
            stringify!(resolve_relative_path)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GFileIface>())).get_child_for_display_name as *const _ as usize
        },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIface),
            "::",
            stringify!(get_child_for_display_name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GFileIface>())).enumerate_children as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIface),
            "::",
            stringify!(enumerate_children)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GFileIface>())).enumerate_children_async as *const _ as usize
        },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIface),
            "::",
            stringify!(enumerate_children_async)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GFileIface>())).enumerate_children_finish as *const _ as usize
        },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIface),
            "::",
            stringify!(enumerate_children_finish)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GFileIface>())).query_info as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIface),
            "::",
            stringify!(query_info)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GFileIface>())).query_info_async as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIface),
            "::",
            stringify!(query_info_async)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GFileIface>())).query_info_finish as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIface),
            "::",
            stringify!(query_info_finish)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GFileIface>())).query_filesystem_info as *const _ as usize
        },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIface),
            "::",
            stringify!(query_filesystem_info)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GFileIface>())).query_filesystem_info_async as *const _ as usize
        },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIface),
            "::",
            stringify!(query_filesystem_info_async)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GFileIface>())).query_filesystem_info_finish as *const _
                as usize
        },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIface),
            "::",
            stringify!(query_filesystem_info_finish)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GFileIface>())).find_enclosing_mount as *const _ as usize
        },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIface),
            "::",
            stringify!(find_enclosing_mount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GFileIface>())).find_enclosing_mount_async as *const _ as usize
        },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIface),
            "::",
            stringify!(find_enclosing_mount_async)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GFileIface>())).find_enclosing_mount_finish as *const _ as usize
        },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIface),
            "::",
            stringify!(find_enclosing_mount_finish)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GFileIface>())).set_display_name as *const _ as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIface),
            "::",
            stringify!(set_display_name)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GFileIface>())).set_display_name_async as *const _ as usize
        },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIface),
            "::",
            stringify!(set_display_name_async)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GFileIface>())).set_display_name_finish as *const _ as usize
        },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIface),
            "::",
            stringify!(set_display_name_finish)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GFileIface>())).query_settable_attributes as *const _ as usize
        },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIface),
            "::",
            stringify!(query_settable_attributes)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GFileIface>()))._query_settable_attributes_async as *const _
                as usize
        },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIface),
            "::",
            stringify!(_query_settable_attributes_async)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GFileIface>()))._query_settable_attributes_finish as *const _
                as usize
        },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIface),
            "::",
            stringify!(_query_settable_attributes_finish)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GFileIface>())).query_writable_namespaces as *const _ as usize
        },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIface),
            "::",
            stringify!(query_writable_namespaces)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GFileIface>()))._query_writable_namespaces_async as *const _
                as usize
        },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIface),
            "::",
            stringify!(_query_writable_namespaces_async)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GFileIface>()))._query_writable_namespaces_finish as *const _
                as usize
        },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIface),
            "::",
            stringify!(_query_writable_namespaces_finish)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GFileIface>())).set_attribute as *const _ as usize },
        304usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIface),
            "::",
            stringify!(set_attribute)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GFileIface>())).set_attributes_from_info as *const _ as usize
        },
        312usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIface),
            "::",
            stringify!(set_attributes_from_info)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GFileIface>())).set_attributes_async as *const _ as usize
        },
        320usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIface),
            "::",
            stringify!(set_attributes_async)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GFileIface>())).set_attributes_finish as *const _ as usize
        },
        328usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIface),
            "::",
            stringify!(set_attributes_finish)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GFileIface>())).read_fn as *const _ as usize },
        336usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIface),
            "::",
            stringify!(read_fn)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GFileIface>())).read_async as *const _ as usize },
        344usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIface),
            "::",
            stringify!(read_async)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GFileIface>())).read_finish as *const _ as usize },
        352usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIface),
            "::",
            stringify!(read_finish)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GFileIface>())).append_to as *const _ as usize },
        360usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIface),
            "::",
            stringify!(append_to)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GFileIface>())).append_to_async as *const _ as usize },
        368usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIface),
            "::",
            stringify!(append_to_async)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GFileIface>())).append_to_finish as *const _ as usize },
        376usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIface),
            "::",
            stringify!(append_to_finish)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GFileIface>())).create as *const _ as usize },
        384usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIface),
            "::",
            stringify!(create)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GFileIface>())).create_async as *const _ as usize },
        392usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIface),
            "::",
            stringify!(create_async)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GFileIface>())).create_finish as *const _ as usize },
        400usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIface),
            "::",
            stringify!(create_finish)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GFileIface>())).replace as *const _ as usize },
        408usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIface),
            "::",
            stringify!(replace)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GFileIface>())).replace_async as *const _ as usize },
        416usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIface),
            "::",
            stringify!(replace_async)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GFileIface>())).replace_finish as *const _ as usize },
        424usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIface),
            "::",
            stringify!(replace_finish)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GFileIface>())).delete_file as *const _ as usize },
        432usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIface),
            "::",
            stringify!(delete_file)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GFileIface>())).delete_file_async as *const _ as usize },
        440usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIface),
            "::",
            stringify!(delete_file_async)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GFileIface>())).delete_file_finish as *const _ as usize },
        448usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIface),
            "::",
            stringify!(delete_file_finish)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GFileIface>())).trash as *const _ as usize },
        456usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIface),
            "::",
            stringify!(trash)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GFileIface>())).trash_async as *const _ as usize },
        464usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIface),
            "::",
            stringify!(trash_async)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GFileIface>())).trash_finish as *const _ as usize },
        472usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIface),
            "::",
            stringify!(trash_finish)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GFileIface>())).make_directory as *const _ as usize },
        480usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIface),
            "::",
            stringify!(make_directory)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GFileIface>())).make_directory_async as *const _ as usize
        },
        488usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIface),
            "::",
            stringify!(make_directory_async)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GFileIface>())).make_directory_finish as *const _ as usize
        },
        496usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIface),
            "::",
            stringify!(make_directory_finish)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GFileIface>())).make_symbolic_link as *const _ as usize },
        504usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIface),
            "::",
            stringify!(make_symbolic_link)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GFileIface>()))._make_symbolic_link_async as *const _ as usize
        },
        512usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIface),
            "::",
            stringify!(_make_symbolic_link_async)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GFileIface>()))._make_symbolic_link_finish as *const _ as usize
        },
        520usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIface),
            "::",
            stringify!(_make_symbolic_link_finish)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GFileIface>())).copy as *const _ as usize },
        528usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIface),
            "::",
            stringify!(copy)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GFileIface>())).copy_async as *const _ as usize },
        536usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIface),
            "::",
            stringify!(copy_async)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GFileIface>())).copy_finish as *const _ as usize },
        544usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIface),
            "::",
            stringify!(copy_finish)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GFileIface>())).move_ as *const _ as usize },
        552usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIface),
            "::",
            stringify!(move_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GFileIface>()))._move_async as *const _ as usize },
        560usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIface),
            "::",
            stringify!(_move_async)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GFileIface>()))._move_finish as *const _ as usize },
        568usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIface),
            "::",
            stringify!(_move_finish)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GFileIface>())).mount_mountable as *const _ as usize },
        576usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIface),
            "::",
            stringify!(mount_mountable)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GFileIface>())).mount_mountable_finish as *const _ as usize
        },
        584usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIface),
            "::",
            stringify!(mount_mountable_finish)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GFileIface>())).unmount_mountable as *const _ as usize },
        592usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIface),
            "::",
            stringify!(unmount_mountable)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GFileIface>())).unmount_mountable_finish as *const _ as usize
        },
        600usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIface),
            "::",
            stringify!(unmount_mountable_finish)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GFileIface>())).eject_mountable as *const _ as usize },
        608usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIface),
            "::",
            stringify!(eject_mountable)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GFileIface>())).eject_mountable_finish as *const _ as usize
        },
        616usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIface),
            "::",
            stringify!(eject_mountable_finish)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GFileIface>())).mount_enclosing_volume as *const _ as usize
        },
        624usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIface),
            "::",
            stringify!(mount_enclosing_volume)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GFileIface>())).mount_enclosing_volume_finish as *const _
                as usize
        },
        632usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIface),
            "::",
            stringify!(mount_enclosing_volume_finish)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GFileIface>())).monitor_dir as *const _ as usize },
        640usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIface),
            "::",
            stringify!(monitor_dir)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GFileIface>())).monitor_file as *const _ as usize },
        648usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIface),
            "::",
            stringify!(monitor_file)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GFileIface>())).open_readwrite as *const _ as usize },
        656usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIface),
            "::",
            stringify!(open_readwrite)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GFileIface>())).open_readwrite_async as *const _ as usize
        },
        664usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIface),
            "::",
            stringify!(open_readwrite_async)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GFileIface>())).open_readwrite_finish as *const _ as usize
        },
        672usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIface),
            "::",
            stringify!(open_readwrite_finish)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GFileIface>())).create_readwrite as *const _ as usize },
        680usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIface),
            "::",
            stringify!(create_readwrite)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GFileIface>())).create_readwrite_async as *const _ as usize
        },
        688usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIface),
            "::",
            stringify!(create_readwrite_async)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GFileIface>())).create_readwrite_finish as *const _ as usize
        },
        696usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIface),
            "::",
            stringify!(create_readwrite_finish)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GFileIface>())).replace_readwrite as *const _ as usize },
        704usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIface),
            "::",
            stringify!(replace_readwrite)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GFileIface>())).replace_readwrite_async as *const _ as usize
        },
        712usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIface),
            "::",
            stringify!(replace_readwrite_async)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GFileIface>())).replace_readwrite_finish as *const _ as usize
        },
        720usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIface),
            "::",
            stringify!(replace_readwrite_finish)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GFileIface>())).start_mountable as *const _ as usize },
        728usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIface),
            "::",
            stringify!(start_mountable)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GFileIface>())).start_mountable_finish as *const _ as usize
        },
        736usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIface),
            "::",
            stringify!(start_mountable_finish)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GFileIface>())).stop_mountable as *const _ as usize },
        744usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIface),
            "::",
            stringify!(stop_mountable)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GFileIface>())).stop_mountable_finish as *const _ as usize
        },
        752usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIface),
            "::",
            stringify!(stop_mountable_finish)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GFileIface>())).supports_thread_contexts as *const _ as usize
        },
        760usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIface),
            "::",
            stringify!(supports_thread_contexts)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GFileIface>())).unmount_mountable_with_operation as *const _
                as usize
        },
        768usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIface),
            "::",
            stringify!(unmount_mountable_with_operation)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GFileIface>())).unmount_mountable_with_operation_finish
                as *const _ as usize
        },
        776usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIface),
            "::",
            stringify!(unmount_mountable_with_operation_finish)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GFileIface>())).eject_mountable_with_operation as *const _
                as usize
        },
        784usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIface),
            "::",
            stringify!(eject_mountable_with_operation)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GFileIface>())).eject_mountable_with_operation_finish
                as *const _ as usize
        },
        792usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIface),
            "::",
            stringify!(eject_mountable_with_operation_finish)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GFileIface>())).poll_mountable as *const _ as usize },
        800usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIface),
            "::",
            stringify!(poll_mountable)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GFileIface>())).poll_mountable_finish as *const _ as usize
        },
        808usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIface),
            "::",
            stringify!(poll_mountable_finish)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GFileIface>())).measure_disk_usage as *const _ as usize },
        816usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIface),
            "::",
            stringify!(measure_disk_usage)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GFileIface>())).measure_disk_usage_async as *const _ as usize
        },
        824usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIface),
            "::",
            stringify!(measure_disk_usage_async)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GFileIface>())).measure_disk_usage_finish as *const _ as usize
        },
        832usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIface),
            "::",
            stringify!(measure_disk_usage_finish)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_g_file_get_type"]
    pub fn g_file_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_file_new_for_path"]
    pub fn g_file_new_for_path(path: *const ::std::os::raw::c_char) -> *mut GFile;
}
extern "C" {
    #[link_name = "\u{1}_g_file_new_for_uri"]
    pub fn g_file_new_for_uri(uri: *const ::std::os::raw::c_char) -> *mut GFile;
}
extern "C" {
    #[link_name = "\u{1}_g_file_new_for_commandline_arg"]
    pub fn g_file_new_for_commandline_arg(arg: *const ::std::os::raw::c_char) -> *mut GFile;
}
extern "C" {
    #[link_name = "\u{1}_g_file_new_for_commandline_arg_and_cwd"]
    pub fn g_file_new_for_commandline_arg_and_cwd(
        arg: *const gchar,
        cwd: *const gchar,
    ) -> *mut GFile;
}
extern "C" {
    #[link_name = "\u{1}_g_file_new_tmp"]
    pub fn g_file_new_tmp(
        tmpl: *const ::std::os::raw::c_char,
        iostream: *mut *mut GFileIOStream,
        error: *mut *mut GError,
    ) -> *mut GFile;
}
extern "C" {
    #[link_name = "\u{1}_g_file_parse_name"]
    pub fn g_file_parse_name(parse_name: *const ::std::os::raw::c_char) -> *mut GFile;
}
extern "C" {
    #[link_name = "\u{1}_g_file_dup"]
    pub fn g_file_dup(file: *mut GFile) -> *mut GFile;
}
extern "C" {
    #[link_name = "\u{1}_g_file_hash"]
    pub fn g_file_hash(file: gconstpointer) -> guint;
}
extern "C" {
    #[link_name = "\u{1}_g_file_equal"]
    pub fn g_file_equal(file1: *mut GFile, file2: *mut GFile) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_file_get_basename"]
    pub fn g_file_get_basename(file: *mut GFile) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_g_file_get_path"]
    pub fn g_file_get_path(file: *mut GFile) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_g_file_get_uri"]
    pub fn g_file_get_uri(file: *mut GFile) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_g_file_get_parse_name"]
    pub fn g_file_get_parse_name(file: *mut GFile) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_g_file_get_parent"]
    pub fn g_file_get_parent(file: *mut GFile) -> *mut GFile;
}
extern "C" {
    #[link_name = "\u{1}_g_file_has_parent"]
    pub fn g_file_has_parent(file: *mut GFile, parent: *mut GFile) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_file_get_child"]
    pub fn g_file_get_child(file: *mut GFile, name: *const ::std::os::raw::c_char) -> *mut GFile;
}
extern "C" {
    #[link_name = "\u{1}_g_file_get_child_for_display_name"]
    pub fn g_file_get_child_for_display_name(
        file: *mut GFile,
        display_name: *const ::std::os::raw::c_char,
        error: *mut *mut GError,
    ) -> *mut GFile;
}
extern "C" {
    #[link_name = "\u{1}_g_file_has_prefix"]
    pub fn g_file_has_prefix(file: *mut GFile, prefix: *mut GFile) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_file_get_relative_path"]
    pub fn g_file_get_relative_path(
        parent: *mut GFile,
        descendant: *mut GFile,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_g_file_resolve_relative_path"]
    pub fn g_file_resolve_relative_path(
        file: *mut GFile,
        relative_path: *const ::std::os::raw::c_char,
    ) -> *mut GFile;
}
extern "C" {
    #[link_name = "\u{1}_g_file_is_native"]
    pub fn g_file_is_native(file: *mut GFile) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_file_has_uri_scheme"]
    pub fn g_file_has_uri_scheme(
        file: *mut GFile,
        uri_scheme: *const ::std::os::raw::c_char,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_file_get_uri_scheme"]
    pub fn g_file_get_uri_scheme(file: *mut GFile) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_g_file_read"]
    pub fn g_file_read(
        file: *mut GFile,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> *mut GFileInputStream;
}
extern "C" {
    #[link_name = "\u{1}_g_file_read_async"]
    pub fn g_file_read_async(
        file: *mut GFile,
        io_priority: ::std::os::raw::c_int,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_file_read_finish"]
    pub fn g_file_read_finish(
        file: *mut GFile,
        res: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> *mut GFileInputStream;
}
extern "C" {
    #[link_name = "\u{1}_g_file_append_to"]
    pub fn g_file_append_to(
        file: *mut GFile,
        flags: GFileCreateFlags,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> *mut GFileOutputStream;
}
extern "C" {
    #[link_name = "\u{1}_g_file_create"]
    pub fn g_file_create(
        file: *mut GFile,
        flags: GFileCreateFlags,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> *mut GFileOutputStream;
}
extern "C" {
    #[link_name = "\u{1}_g_file_replace"]
    pub fn g_file_replace(
        file: *mut GFile,
        etag: *const ::std::os::raw::c_char,
        make_backup: gboolean,
        flags: GFileCreateFlags,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> *mut GFileOutputStream;
}
extern "C" {
    #[link_name = "\u{1}_g_file_append_to_async"]
    pub fn g_file_append_to_async(
        file: *mut GFile,
        flags: GFileCreateFlags,
        io_priority: ::std::os::raw::c_int,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_file_append_to_finish"]
    pub fn g_file_append_to_finish(
        file: *mut GFile,
        res: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> *mut GFileOutputStream;
}
extern "C" {
    #[link_name = "\u{1}_g_file_create_async"]
    pub fn g_file_create_async(
        file: *mut GFile,
        flags: GFileCreateFlags,
        io_priority: ::std::os::raw::c_int,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_file_create_finish"]
    pub fn g_file_create_finish(
        file: *mut GFile,
        res: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> *mut GFileOutputStream;
}
extern "C" {
    #[link_name = "\u{1}_g_file_replace_async"]
    pub fn g_file_replace_async(
        file: *mut GFile,
        etag: *const ::std::os::raw::c_char,
        make_backup: gboolean,
        flags: GFileCreateFlags,
        io_priority: ::std::os::raw::c_int,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_file_replace_finish"]
    pub fn g_file_replace_finish(
        file: *mut GFile,
        res: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> *mut GFileOutputStream;
}
extern "C" {
    #[link_name = "\u{1}_g_file_open_readwrite"]
    pub fn g_file_open_readwrite(
        file: *mut GFile,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> *mut GFileIOStream;
}
extern "C" {
    #[link_name = "\u{1}_g_file_open_readwrite_async"]
    pub fn g_file_open_readwrite_async(
        file: *mut GFile,
        io_priority: ::std::os::raw::c_int,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_file_open_readwrite_finish"]
    pub fn g_file_open_readwrite_finish(
        file: *mut GFile,
        res: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> *mut GFileIOStream;
}
extern "C" {
    #[link_name = "\u{1}_g_file_create_readwrite"]
    pub fn g_file_create_readwrite(
        file: *mut GFile,
        flags: GFileCreateFlags,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> *mut GFileIOStream;
}
extern "C" {
    #[link_name = "\u{1}_g_file_create_readwrite_async"]
    pub fn g_file_create_readwrite_async(
        file: *mut GFile,
        flags: GFileCreateFlags,
        io_priority: ::std::os::raw::c_int,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_file_create_readwrite_finish"]
    pub fn g_file_create_readwrite_finish(
        file: *mut GFile,
        res: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> *mut GFileIOStream;
}
extern "C" {
    #[link_name = "\u{1}_g_file_replace_readwrite"]
    pub fn g_file_replace_readwrite(
        file: *mut GFile,
        etag: *const ::std::os::raw::c_char,
        make_backup: gboolean,
        flags: GFileCreateFlags,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> *mut GFileIOStream;
}
extern "C" {
    #[link_name = "\u{1}_g_file_replace_readwrite_async"]
    pub fn g_file_replace_readwrite_async(
        file: *mut GFile,
        etag: *const ::std::os::raw::c_char,
        make_backup: gboolean,
        flags: GFileCreateFlags,
        io_priority: ::std::os::raw::c_int,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_file_replace_readwrite_finish"]
    pub fn g_file_replace_readwrite_finish(
        file: *mut GFile,
        res: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> *mut GFileIOStream;
}
extern "C" {
    #[link_name = "\u{1}_g_file_query_exists"]
    pub fn g_file_query_exists(file: *mut GFile, cancellable: *mut GCancellable) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_file_query_file_type"]
    pub fn g_file_query_file_type(
        file: *mut GFile,
        flags: GFileQueryInfoFlags,
        cancellable: *mut GCancellable,
    ) -> GFileType;
}
extern "C" {
    #[link_name = "\u{1}_g_file_query_info"]
    pub fn g_file_query_info(
        file: *mut GFile,
        attributes: *const ::std::os::raw::c_char,
        flags: GFileQueryInfoFlags,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> *mut GFileInfo;
}
extern "C" {
    #[link_name = "\u{1}_g_file_query_info_async"]
    pub fn g_file_query_info_async(
        file: *mut GFile,
        attributes: *const ::std::os::raw::c_char,
        flags: GFileQueryInfoFlags,
        io_priority: ::std::os::raw::c_int,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_file_query_info_finish"]
    pub fn g_file_query_info_finish(
        file: *mut GFile,
        res: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> *mut GFileInfo;
}
extern "C" {
    #[link_name = "\u{1}_g_file_query_filesystem_info"]
    pub fn g_file_query_filesystem_info(
        file: *mut GFile,
        attributes: *const ::std::os::raw::c_char,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> *mut GFileInfo;
}
extern "C" {
    #[link_name = "\u{1}_g_file_query_filesystem_info_async"]
    pub fn g_file_query_filesystem_info_async(
        file: *mut GFile,
        attributes: *const ::std::os::raw::c_char,
        io_priority: ::std::os::raw::c_int,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_file_query_filesystem_info_finish"]
    pub fn g_file_query_filesystem_info_finish(
        file: *mut GFile,
        res: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> *mut GFileInfo;
}
extern "C" {
    #[link_name = "\u{1}_g_file_find_enclosing_mount"]
    pub fn g_file_find_enclosing_mount(
        file: *mut GFile,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> *mut GMount;
}
extern "C" {
    #[link_name = "\u{1}_g_file_find_enclosing_mount_async"]
    pub fn g_file_find_enclosing_mount_async(
        file: *mut GFile,
        io_priority: ::std::os::raw::c_int,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_file_find_enclosing_mount_finish"]
    pub fn g_file_find_enclosing_mount_finish(
        file: *mut GFile,
        res: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> *mut GMount;
}
extern "C" {
    #[link_name = "\u{1}_g_file_enumerate_children"]
    pub fn g_file_enumerate_children(
        file: *mut GFile,
        attributes: *const ::std::os::raw::c_char,
        flags: GFileQueryInfoFlags,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> *mut GFileEnumerator;
}
extern "C" {
    #[link_name = "\u{1}_g_file_enumerate_children_async"]
    pub fn g_file_enumerate_children_async(
        file: *mut GFile,
        attributes: *const ::std::os::raw::c_char,
        flags: GFileQueryInfoFlags,
        io_priority: ::std::os::raw::c_int,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_file_enumerate_children_finish"]
    pub fn g_file_enumerate_children_finish(
        file: *mut GFile,
        res: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> *mut GFileEnumerator;
}
extern "C" {
    #[link_name = "\u{1}_g_file_set_display_name"]
    pub fn g_file_set_display_name(
        file: *mut GFile,
        display_name: *const ::std::os::raw::c_char,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> *mut GFile;
}
extern "C" {
    #[link_name = "\u{1}_g_file_set_display_name_async"]
    pub fn g_file_set_display_name_async(
        file: *mut GFile,
        display_name: *const ::std::os::raw::c_char,
        io_priority: ::std::os::raw::c_int,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_file_set_display_name_finish"]
    pub fn g_file_set_display_name_finish(
        file: *mut GFile,
        res: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> *mut GFile;
}
extern "C" {
    #[link_name = "\u{1}_g_file_delete"]
    pub fn g_file_delete(
        file: *mut GFile,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_file_delete_async"]
    pub fn g_file_delete_async(
        file: *mut GFile,
        io_priority: ::std::os::raw::c_int,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_file_delete_finish"]
    pub fn g_file_delete_finish(
        file: *mut GFile,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_file_trash"]
    pub fn g_file_trash(
        file: *mut GFile,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_file_trash_async"]
    pub fn g_file_trash_async(
        file: *mut GFile,
        io_priority: ::std::os::raw::c_int,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_file_trash_finish"]
    pub fn g_file_trash_finish(
        file: *mut GFile,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_file_copy"]
    pub fn g_file_copy(
        source: *mut GFile,
        destination: *mut GFile,
        flags: GFileCopyFlags,
        cancellable: *mut GCancellable,
        progress_callback: GFileProgressCallback,
        progress_callback_data: gpointer,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_file_copy_async"]
    pub fn g_file_copy_async(
        source: *mut GFile,
        destination: *mut GFile,
        flags: GFileCopyFlags,
        io_priority: ::std::os::raw::c_int,
        cancellable: *mut GCancellable,
        progress_callback: GFileProgressCallback,
        progress_callback_data: gpointer,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_file_copy_finish"]
    pub fn g_file_copy_finish(
        file: *mut GFile,
        res: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_file_move"]
    pub fn g_file_move(
        source: *mut GFile,
        destination: *mut GFile,
        flags: GFileCopyFlags,
        cancellable: *mut GCancellable,
        progress_callback: GFileProgressCallback,
        progress_callback_data: gpointer,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_file_make_directory"]
    pub fn g_file_make_directory(
        file: *mut GFile,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_file_make_directory_async"]
    pub fn g_file_make_directory_async(
        file: *mut GFile,
        io_priority: ::std::os::raw::c_int,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_file_make_directory_finish"]
    pub fn g_file_make_directory_finish(
        file: *mut GFile,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_file_make_directory_with_parents"]
    pub fn g_file_make_directory_with_parents(
        file: *mut GFile,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_file_make_symbolic_link"]
    pub fn g_file_make_symbolic_link(
        file: *mut GFile,
        symlink_value: *const ::std::os::raw::c_char,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_file_query_settable_attributes"]
    pub fn g_file_query_settable_attributes(
        file: *mut GFile,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> *mut GFileAttributeInfoList;
}
extern "C" {
    #[link_name = "\u{1}_g_file_query_writable_namespaces"]
    pub fn g_file_query_writable_namespaces(
        file: *mut GFile,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> *mut GFileAttributeInfoList;
}
extern "C" {
    #[link_name = "\u{1}_g_file_set_attribute"]
    pub fn g_file_set_attribute(
        file: *mut GFile,
        attribute: *const ::std::os::raw::c_char,
        type_: GFileAttributeType,
        value_p: gpointer,
        flags: GFileQueryInfoFlags,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_file_set_attributes_from_info"]
    pub fn g_file_set_attributes_from_info(
        file: *mut GFile,
        info: *mut GFileInfo,
        flags: GFileQueryInfoFlags,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_file_set_attributes_async"]
    pub fn g_file_set_attributes_async(
        file: *mut GFile,
        info: *mut GFileInfo,
        flags: GFileQueryInfoFlags,
        io_priority: ::std::os::raw::c_int,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_file_set_attributes_finish"]
    pub fn g_file_set_attributes_finish(
        file: *mut GFile,
        result: *mut GAsyncResult,
        info: *mut *mut GFileInfo,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_file_set_attribute_string"]
    pub fn g_file_set_attribute_string(
        file: *mut GFile,
        attribute: *const ::std::os::raw::c_char,
        value: *const ::std::os::raw::c_char,
        flags: GFileQueryInfoFlags,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_file_set_attribute_byte_string"]
    pub fn g_file_set_attribute_byte_string(
        file: *mut GFile,
        attribute: *const ::std::os::raw::c_char,
        value: *const ::std::os::raw::c_char,
        flags: GFileQueryInfoFlags,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_file_set_attribute_uint32"]
    pub fn g_file_set_attribute_uint32(
        file: *mut GFile,
        attribute: *const ::std::os::raw::c_char,
        value: guint32,
        flags: GFileQueryInfoFlags,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_file_set_attribute_int32"]
    pub fn g_file_set_attribute_int32(
        file: *mut GFile,
        attribute: *const ::std::os::raw::c_char,
        value: gint32,
        flags: GFileQueryInfoFlags,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_file_set_attribute_uint64"]
    pub fn g_file_set_attribute_uint64(
        file: *mut GFile,
        attribute: *const ::std::os::raw::c_char,
        value: guint64,
        flags: GFileQueryInfoFlags,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_file_set_attribute_int64"]
    pub fn g_file_set_attribute_int64(
        file: *mut GFile,
        attribute: *const ::std::os::raw::c_char,
        value: gint64,
        flags: GFileQueryInfoFlags,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_file_mount_enclosing_volume"]
    pub fn g_file_mount_enclosing_volume(
        location: *mut GFile,
        flags: GMountMountFlags,
        mount_operation: *mut GMountOperation,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_file_mount_enclosing_volume_finish"]
    pub fn g_file_mount_enclosing_volume_finish(
        location: *mut GFile,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_file_mount_mountable"]
    pub fn g_file_mount_mountable(
        file: *mut GFile,
        flags: GMountMountFlags,
        mount_operation: *mut GMountOperation,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_file_mount_mountable_finish"]
    pub fn g_file_mount_mountable_finish(
        file: *mut GFile,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> *mut GFile;
}
extern "C" {
    #[link_name = "\u{1}_g_file_unmount_mountable"]
    pub fn g_file_unmount_mountable(
        file: *mut GFile,
        flags: GMountUnmountFlags,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_file_unmount_mountable_finish"]
    pub fn g_file_unmount_mountable_finish(
        file: *mut GFile,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_file_unmount_mountable_with_operation"]
    pub fn g_file_unmount_mountable_with_operation(
        file: *mut GFile,
        flags: GMountUnmountFlags,
        mount_operation: *mut GMountOperation,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_file_unmount_mountable_with_operation_finish"]
    pub fn g_file_unmount_mountable_with_operation_finish(
        file: *mut GFile,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_file_eject_mountable"]
    pub fn g_file_eject_mountable(
        file: *mut GFile,
        flags: GMountUnmountFlags,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_file_eject_mountable_finish"]
    pub fn g_file_eject_mountable_finish(
        file: *mut GFile,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_file_eject_mountable_with_operation"]
    pub fn g_file_eject_mountable_with_operation(
        file: *mut GFile,
        flags: GMountUnmountFlags,
        mount_operation: *mut GMountOperation,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_file_eject_mountable_with_operation_finish"]
    pub fn g_file_eject_mountable_with_operation_finish(
        file: *mut GFile,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_file_copy_attributes"]
    pub fn g_file_copy_attributes(
        source: *mut GFile,
        destination: *mut GFile,
        flags: GFileCopyFlags,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_file_monitor_directory"]
    pub fn g_file_monitor_directory(
        file: *mut GFile,
        flags: GFileMonitorFlags,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> *mut GFileMonitor;
}
extern "C" {
    #[link_name = "\u{1}_g_file_monitor_file"]
    pub fn g_file_monitor_file(
        file: *mut GFile,
        flags: GFileMonitorFlags,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> *mut GFileMonitor;
}
extern "C" {
    #[link_name = "\u{1}_g_file_monitor"]
    pub fn g_file_monitor(
        file: *mut GFile,
        flags: GFileMonitorFlags,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> *mut GFileMonitor;
}
extern "C" {
    #[link_name = "\u{1}_g_file_measure_disk_usage"]
    pub fn g_file_measure_disk_usage(
        file: *mut GFile,
        flags: GFileMeasureFlags,
        cancellable: *mut GCancellable,
        progress_callback: GFileMeasureProgressCallback,
        progress_data: gpointer,
        disk_usage: *mut guint64,
        num_dirs: *mut guint64,
        num_files: *mut guint64,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_file_measure_disk_usage_async"]
    pub fn g_file_measure_disk_usage_async(
        file: *mut GFile,
        flags: GFileMeasureFlags,
        io_priority: gint,
        cancellable: *mut GCancellable,
        progress_callback: GFileMeasureProgressCallback,
        progress_data: gpointer,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_file_measure_disk_usage_finish"]
    pub fn g_file_measure_disk_usage_finish(
        file: *mut GFile,
        result: *mut GAsyncResult,
        disk_usage: *mut guint64,
        num_dirs: *mut guint64,
        num_files: *mut guint64,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_file_start_mountable"]
    pub fn g_file_start_mountable(
        file: *mut GFile,
        flags: GDriveStartFlags,
        start_operation: *mut GMountOperation,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_file_start_mountable_finish"]
    pub fn g_file_start_mountable_finish(
        file: *mut GFile,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_file_stop_mountable"]
    pub fn g_file_stop_mountable(
        file: *mut GFile,
        flags: GMountUnmountFlags,
        mount_operation: *mut GMountOperation,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_file_stop_mountable_finish"]
    pub fn g_file_stop_mountable_finish(
        file: *mut GFile,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_file_poll_mountable"]
    pub fn g_file_poll_mountable(
        file: *mut GFile,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_file_poll_mountable_finish"]
    pub fn g_file_poll_mountable_finish(
        file: *mut GFile,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_file_query_default_handler"]
    pub fn g_file_query_default_handler(
        file: *mut GFile,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> *mut GAppInfo;
}
extern "C" {
    #[link_name = "\u{1}_g_file_load_contents"]
    pub fn g_file_load_contents(
        file: *mut GFile,
        cancellable: *mut GCancellable,
        contents: *mut *mut ::std::os::raw::c_char,
        length: *mut gsize,
        etag_out: *mut *mut ::std::os::raw::c_char,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_file_load_contents_async"]
    pub fn g_file_load_contents_async(
        file: *mut GFile,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_file_load_contents_finish"]
    pub fn g_file_load_contents_finish(
        file: *mut GFile,
        res: *mut GAsyncResult,
        contents: *mut *mut ::std::os::raw::c_char,
        length: *mut gsize,
        etag_out: *mut *mut ::std::os::raw::c_char,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_file_load_partial_contents_async"]
    pub fn g_file_load_partial_contents_async(
        file: *mut GFile,
        cancellable: *mut GCancellable,
        read_more_callback: GFileReadMoreCallback,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_file_load_partial_contents_finish"]
    pub fn g_file_load_partial_contents_finish(
        file: *mut GFile,
        res: *mut GAsyncResult,
        contents: *mut *mut ::std::os::raw::c_char,
        length: *mut gsize,
        etag_out: *mut *mut ::std::os::raw::c_char,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_file_replace_contents"]
    pub fn g_file_replace_contents(
        file: *mut GFile,
        contents: *const ::std::os::raw::c_char,
        length: gsize,
        etag: *const ::std::os::raw::c_char,
        make_backup: gboolean,
        flags: GFileCreateFlags,
        new_etag: *mut *mut ::std::os::raw::c_char,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_file_replace_contents_async"]
    pub fn g_file_replace_contents_async(
        file: *mut GFile,
        contents: *const ::std::os::raw::c_char,
        length: gsize,
        etag: *const ::std::os::raw::c_char,
        make_backup: gboolean,
        flags: GFileCreateFlags,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_file_replace_contents_bytes_async"]
    pub fn g_file_replace_contents_bytes_async(
        file: *mut GFile,
        contents: *mut GBytes,
        etag: *const ::std::os::raw::c_char,
        make_backup: gboolean,
        flags: GFileCreateFlags,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_file_replace_contents_finish"]
    pub fn g_file_replace_contents_finish(
        file: *mut GFile,
        res: *mut GAsyncResult,
        new_etag: *mut *mut ::std::os::raw::c_char,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_file_supports_thread_contexts"]
    pub fn g_file_supports_thread_contexts(file: *mut GFile) -> gboolean;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GFileIconClass {
    _unused: [u8; 0],
}
/// GFileIcon:
///
/// Gets an icon for a #GFile. Implements #GLoadableIcon.
pub type GFileIconClass = _GFileIconClass;
extern "C" {
    #[link_name = "\u{1}_g_file_icon_get_type"]
    pub fn g_file_icon_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_file_icon_new"]
    pub fn g_file_icon_new(file: *mut GFile) -> *mut GIcon;
}
extern "C" {
    #[link_name = "\u{1}_g_file_icon_get_file"]
    pub fn g_file_icon_get_file(icon: *mut GFileIcon) -> *mut GFile;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GFileInfoClass {
    _unused: [u8; 0],
}
/// GFileInfo:
///
/// Stores information about a file system object referenced by a #GFile.
pub type GFileInfoClass = _GFileInfoClass;
extern "C" {
    #[link_name = "\u{1}_g_file_info_get_type"]
    pub fn g_file_info_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_file_info_new"]
    pub fn g_file_info_new() -> *mut GFileInfo;
}
extern "C" {
    #[link_name = "\u{1}_g_file_info_dup"]
    pub fn g_file_info_dup(other: *mut GFileInfo) -> *mut GFileInfo;
}
extern "C" {
    #[link_name = "\u{1}_g_file_info_copy_into"]
    pub fn g_file_info_copy_into(src_info: *mut GFileInfo, dest_info: *mut GFileInfo);
}
extern "C" {
    #[link_name = "\u{1}_g_file_info_has_attribute"]
    pub fn g_file_info_has_attribute(
        info: *mut GFileInfo,
        attribute: *const ::std::os::raw::c_char,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_file_info_has_namespace"]
    pub fn g_file_info_has_namespace(
        info: *mut GFileInfo,
        name_space: *const ::std::os::raw::c_char,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_file_info_list_attributes"]
    pub fn g_file_info_list_attributes(
        info: *mut GFileInfo,
        name_space: *const ::std::os::raw::c_char,
    ) -> *mut *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_g_file_info_get_attribute_data"]
    pub fn g_file_info_get_attribute_data(
        info: *mut GFileInfo,
        attribute: *const ::std::os::raw::c_char,
        type_: *mut GFileAttributeType,
        value_pp: *mut gpointer,
        status: *mut GFileAttributeStatus,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_file_info_get_attribute_type"]
    pub fn g_file_info_get_attribute_type(
        info: *mut GFileInfo,
        attribute: *const ::std::os::raw::c_char,
    ) -> GFileAttributeType;
}
extern "C" {
    #[link_name = "\u{1}_g_file_info_remove_attribute"]
    pub fn g_file_info_remove_attribute(
        info: *mut GFileInfo,
        attribute: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_file_info_get_attribute_status"]
    pub fn g_file_info_get_attribute_status(
        info: *mut GFileInfo,
        attribute: *const ::std::os::raw::c_char,
    ) -> GFileAttributeStatus;
}
extern "C" {
    #[link_name = "\u{1}_g_file_info_set_attribute_status"]
    pub fn g_file_info_set_attribute_status(
        info: *mut GFileInfo,
        attribute: *const ::std::os::raw::c_char,
        status: GFileAttributeStatus,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_file_info_get_attribute_as_string"]
    pub fn g_file_info_get_attribute_as_string(
        info: *mut GFileInfo,
        attribute: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_g_file_info_get_attribute_string"]
    pub fn g_file_info_get_attribute_string(
        info: *mut GFileInfo,
        attribute: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_g_file_info_get_attribute_byte_string"]
    pub fn g_file_info_get_attribute_byte_string(
        info: *mut GFileInfo,
        attribute: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_g_file_info_get_attribute_boolean"]
    pub fn g_file_info_get_attribute_boolean(
        info: *mut GFileInfo,
        attribute: *const ::std::os::raw::c_char,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_file_info_get_attribute_uint32"]
    pub fn g_file_info_get_attribute_uint32(
        info: *mut GFileInfo,
        attribute: *const ::std::os::raw::c_char,
    ) -> guint32;
}
extern "C" {
    #[link_name = "\u{1}_g_file_info_get_attribute_int32"]
    pub fn g_file_info_get_attribute_int32(
        info: *mut GFileInfo,
        attribute: *const ::std::os::raw::c_char,
    ) -> gint32;
}
extern "C" {
    #[link_name = "\u{1}_g_file_info_get_attribute_uint64"]
    pub fn g_file_info_get_attribute_uint64(
        info: *mut GFileInfo,
        attribute: *const ::std::os::raw::c_char,
    ) -> guint64;
}
extern "C" {
    #[link_name = "\u{1}_g_file_info_get_attribute_int64"]
    pub fn g_file_info_get_attribute_int64(
        info: *mut GFileInfo,
        attribute: *const ::std::os::raw::c_char,
    ) -> gint64;
}
extern "C" {
    #[link_name = "\u{1}_g_file_info_get_attribute_object"]
    pub fn g_file_info_get_attribute_object(
        info: *mut GFileInfo,
        attribute: *const ::std::os::raw::c_char,
    ) -> *mut GObject;
}
extern "C" {
    #[link_name = "\u{1}_g_file_info_get_attribute_stringv"]
    pub fn g_file_info_get_attribute_stringv(
        info: *mut GFileInfo,
        attribute: *const ::std::os::raw::c_char,
    ) -> *mut *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_g_file_info_set_attribute"]
    pub fn g_file_info_set_attribute(
        info: *mut GFileInfo,
        attribute: *const ::std::os::raw::c_char,
        type_: GFileAttributeType,
        value_p: gpointer,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_file_info_set_attribute_string"]
    pub fn g_file_info_set_attribute_string(
        info: *mut GFileInfo,
        attribute: *const ::std::os::raw::c_char,
        attr_value: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_file_info_set_attribute_byte_string"]
    pub fn g_file_info_set_attribute_byte_string(
        info: *mut GFileInfo,
        attribute: *const ::std::os::raw::c_char,
        attr_value: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_file_info_set_attribute_boolean"]
    pub fn g_file_info_set_attribute_boolean(
        info: *mut GFileInfo,
        attribute: *const ::std::os::raw::c_char,
        attr_value: gboolean,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_file_info_set_attribute_uint32"]
    pub fn g_file_info_set_attribute_uint32(
        info: *mut GFileInfo,
        attribute: *const ::std::os::raw::c_char,
        attr_value: guint32,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_file_info_set_attribute_int32"]
    pub fn g_file_info_set_attribute_int32(
        info: *mut GFileInfo,
        attribute: *const ::std::os::raw::c_char,
        attr_value: gint32,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_file_info_set_attribute_uint64"]
    pub fn g_file_info_set_attribute_uint64(
        info: *mut GFileInfo,
        attribute: *const ::std::os::raw::c_char,
        attr_value: guint64,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_file_info_set_attribute_int64"]
    pub fn g_file_info_set_attribute_int64(
        info: *mut GFileInfo,
        attribute: *const ::std::os::raw::c_char,
        attr_value: gint64,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_file_info_set_attribute_object"]
    pub fn g_file_info_set_attribute_object(
        info: *mut GFileInfo,
        attribute: *const ::std::os::raw::c_char,
        attr_value: *mut GObject,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_file_info_set_attribute_stringv"]
    pub fn g_file_info_set_attribute_stringv(
        info: *mut GFileInfo,
        attribute: *const ::std::os::raw::c_char,
        attr_value: *mut *mut ::std::os::raw::c_char,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_file_info_clear_status"]
    pub fn g_file_info_clear_status(info: *mut GFileInfo);
}
extern "C" {
    #[link_name = "\u{1}_g_file_info_get_deletion_date"]
    pub fn g_file_info_get_deletion_date(info: *mut GFileInfo) -> *mut GDateTime;
}
extern "C" {
    #[link_name = "\u{1}_g_file_info_get_file_type"]
    pub fn g_file_info_get_file_type(info: *mut GFileInfo) -> GFileType;
}
extern "C" {
    #[link_name = "\u{1}_g_file_info_get_is_hidden"]
    pub fn g_file_info_get_is_hidden(info: *mut GFileInfo) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_file_info_get_is_backup"]
    pub fn g_file_info_get_is_backup(info: *mut GFileInfo) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_file_info_get_is_symlink"]
    pub fn g_file_info_get_is_symlink(info: *mut GFileInfo) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_file_info_get_name"]
    pub fn g_file_info_get_name(info: *mut GFileInfo) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_g_file_info_get_display_name"]
    pub fn g_file_info_get_display_name(info: *mut GFileInfo) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_g_file_info_get_edit_name"]
    pub fn g_file_info_get_edit_name(info: *mut GFileInfo) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_g_file_info_get_icon"]
    pub fn g_file_info_get_icon(info: *mut GFileInfo) -> *mut GIcon;
}
extern "C" {
    #[link_name = "\u{1}_g_file_info_get_symbolic_icon"]
    pub fn g_file_info_get_symbolic_icon(info: *mut GFileInfo) -> *mut GIcon;
}
extern "C" {
    #[link_name = "\u{1}_g_file_info_get_content_type"]
    pub fn g_file_info_get_content_type(info: *mut GFileInfo) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_g_file_info_get_size"]
    pub fn g_file_info_get_size(info: *mut GFileInfo) -> goffset;
}
extern "C" {
    #[link_name = "\u{1}_g_file_info_get_modification_time"]
    pub fn g_file_info_get_modification_time(info: *mut GFileInfo, result: *mut GTimeVal);
}
extern "C" {
    #[link_name = "\u{1}_g_file_info_get_symlink_target"]
    pub fn g_file_info_get_symlink_target(info: *mut GFileInfo) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_g_file_info_get_etag"]
    pub fn g_file_info_get_etag(info: *mut GFileInfo) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_g_file_info_get_sort_order"]
    pub fn g_file_info_get_sort_order(info: *mut GFileInfo) -> gint32;
}
extern "C" {
    #[link_name = "\u{1}_g_file_info_set_attribute_mask"]
    pub fn g_file_info_set_attribute_mask(info: *mut GFileInfo, mask: *mut GFileAttributeMatcher);
}
extern "C" {
    #[link_name = "\u{1}_g_file_info_unset_attribute_mask"]
    pub fn g_file_info_unset_attribute_mask(info: *mut GFileInfo);
}
extern "C" {
    #[link_name = "\u{1}_g_file_info_set_file_type"]
    pub fn g_file_info_set_file_type(info: *mut GFileInfo, type_: GFileType);
}
extern "C" {
    #[link_name = "\u{1}_g_file_info_set_is_hidden"]
    pub fn g_file_info_set_is_hidden(info: *mut GFileInfo, is_hidden: gboolean);
}
extern "C" {
    #[link_name = "\u{1}_g_file_info_set_is_symlink"]
    pub fn g_file_info_set_is_symlink(info: *mut GFileInfo, is_symlink: gboolean);
}
extern "C" {
    #[link_name = "\u{1}_g_file_info_set_name"]
    pub fn g_file_info_set_name(info: *mut GFileInfo, name: *const ::std::os::raw::c_char);
}
extern "C" {
    #[link_name = "\u{1}_g_file_info_set_display_name"]
    pub fn g_file_info_set_display_name(
        info: *mut GFileInfo,
        display_name: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_file_info_set_edit_name"]
    pub fn g_file_info_set_edit_name(
        info: *mut GFileInfo,
        edit_name: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_file_info_set_icon"]
    pub fn g_file_info_set_icon(info: *mut GFileInfo, icon: *mut GIcon);
}
extern "C" {
    #[link_name = "\u{1}_g_file_info_set_symbolic_icon"]
    pub fn g_file_info_set_symbolic_icon(info: *mut GFileInfo, icon: *mut GIcon);
}
extern "C" {
    #[link_name = "\u{1}_g_file_info_set_content_type"]
    pub fn g_file_info_set_content_type(
        info: *mut GFileInfo,
        content_type: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_file_info_set_size"]
    pub fn g_file_info_set_size(info: *mut GFileInfo, size: goffset);
}
extern "C" {
    #[link_name = "\u{1}_g_file_info_set_modification_time"]
    pub fn g_file_info_set_modification_time(info: *mut GFileInfo, mtime: *mut GTimeVal);
}
extern "C" {
    #[link_name = "\u{1}_g_file_info_set_symlink_target"]
    pub fn g_file_info_set_symlink_target(
        info: *mut GFileInfo,
        symlink_target: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_file_info_set_sort_order"]
    pub fn g_file_info_set_sort_order(info: *mut GFileInfo, sort_order: gint32);
}
extern "C" {
    #[link_name = "\u{1}_g_file_attribute_matcher_get_type"]
    pub fn g_file_attribute_matcher_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_file_attribute_matcher_new"]
    pub fn g_file_attribute_matcher_new(
        attributes: *const ::std::os::raw::c_char,
    ) -> *mut GFileAttributeMatcher;
}
extern "C" {
    #[link_name = "\u{1}_g_file_attribute_matcher_ref"]
    pub fn g_file_attribute_matcher_ref(
        matcher: *mut GFileAttributeMatcher,
    ) -> *mut GFileAttributeMatcher;
}
extern "C" {
    #[link_name = "\u{1}_g_file_attribute_matcher_unref"]
    pub fn g_file_attribute_matcher_unref(matcher: *mut GFileAttributeMatcher);
}
extern "C" {
    #[link_name = "\u{1}_g_file_attribute_matcher_subtract"]
    pub fn g_file_attribute_matcher_subtract(
        matcher: *mut GFileAttributeMatcher,
        subtract: *mut GFileAttributeMatcher,
    ) -> *mut GFileAttributeMatcher;
}
extern "C" {
    #[link_name = "\u{1}_g_file_attribute_matcher_matches"]
    pub fn g_file_attribute_matcher_matches(
        matcher: *mut GFileAttributeMatcher,
        attribute: *const ::std::os::raw::c_char,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_file_attribute_matcher_matches_only"]
    pub fn g_file_attribute_matcher_matches_only(
        matcher: *mut GFileAttributeMatcher,
        attribute: *const ::std::os::raw::c_char,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_file_attribute_matcher_enumerate_namespace"]
    pub fn g_file_attribute_matcher_enumerate_namespace(
        matcher: *mut GFileAttributeMatcher,
        ns: *const ::std::os::raw::c_char,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_file_attribute_matcher_enumerate_next"]
    pub fn g_file_attribute_matcher_enumerate_next(
        matcher: *mut GFileAttributeMatcher,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_g_file_attribute_matcher_to_string"]
    pub fn g_file_attribute_matcher_to_string(
        matcher: *mut GFileAttributeMatcher,
    ) -> *mut ::std::os::raw::c_char;
}
/// GFileInputStream:
///
/// A subclass of GInputStream for opened files. This adds
/// a few file-specific operations and seeking.
///
/// #GFileInputStream implements #GSeekable.
pub type GFileInputStreamClass = _GFileInputStreamClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GFileInputStreamPrivate {
    _unused: [u8; 0],
}
pub type GFileInputStreamPrivate = _GFileInputStreamPrivate;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GFileInputStream {
    pub parent_instance: GInputStream,
    pub priv_: *mut GFileInputStreamPrivate,
}
#[test]
fn bindgen_test_layout__GFileInputStream() {
    assert_eq!(
        ::std::mem::size_of::<_GFileInputStream>(),
        40usize,
        concat!("Size of: ", stringify!(_GFileInputStream))
    );
    assert_eq!(
        ::std::mem::align_of::<_GFileInputStream>(),
        8usize,
        concat!("Alignment of ", stringify!(_GFileInputStream))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GFileInputStream>())).parent_instance as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileInputStream),
            "::",
            stringify!(parent_instance)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GFileInputStream>())).priv_ as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileInputStream),
            "::",
            stringify!(priv_)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GFileInputStreamClass {
    pub parent_class: GInputStreamClass,
    pub tell: ::std::option::Option<unsafe extern "C" fn(stream: *mut GFileInputStream) -> goffset>,
    pub can_seek:
        ::std::option::Option<unsafe extern "C" fn(stream: *mut GFileInputStream) -> gboolean>,
    pub seek: ::std::option::Option<
        unsafe extern "C" fn(
            stream: *mut GFileInputStream,
            offset: goffset,
            type_: GSeekType,
            cancellable: *mut GCancellable,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
    pub query_info: ::std::option::Option<
        unsafe extern "C" fn(
            stream: *mut GFileInputStream,
            attributes: *const ::std::os::raw::c_char,
            cancellable: *mut GCancellable,
            error: *mut *mut GError,
        ) -> *mut GFileInfo,
    >,
    pub query_info_async: ::std::option::Option<
        unsafe extern "C" fn(
            stream: *mut GFileInputStream,
            attributes: *const ::std::os::raw::c_char,
            io_priority: ::std::os::raw::c_int,
            cancellable: *mut GCancellable,
            callback: GAsyncReadyCallback,
            user_data: gpointer,
        ),
    >,
    pub query_info_finish: ::std::option::Option<
        unsafe extern "C" fn(
            stream: *mut GFileInputStream,
            result: *mut GAsyncResult,
            error: *mut *mut GError,
        ) -> *mut GFileInfo,
    >,
    pub _g_reserved1: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved2: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved3: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved4: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved5: ::std::option::Option<unsafe extern "C" fn()>,
}
#[test]
fn bindgen_test_layout__GFileInputStreamClass() {
    assert_eq!(
        ::std::mem::size_of::<_GFileInputStreamClass>(),
        336usize,
        concat!("Size of: ", stringify!(_GFileInputStreamClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_GFileInputStreamClass>(),
        8usize,
        concat!("Alignment of ", stringify!(_GFileInputStreamClass))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GFileInputStreamClass>())).parent_class as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileInputStreamClass),
            "::",
            stringify!(parent_class)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GFileInputStreamClass>())).tell as *const _ as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileInputStreamClass),
            "::",
            stringify!(tell)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GFileInputStreamClass>())).can_seek as *const _ as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileInputStreamClass),
            "::",
            stringify!(can_seek)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GFileInputStreamClass>())).seek as *const _ as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileInputStreamClass),
            "::",
            stringify!(seek)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GFileInputStreamClass>())).query_info as *const _ as usize
        },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileInputStreamClass),
            "::",
            stringify!(query_info)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GFileInputStreamClass>())).query_info_async as *const _ as usize
        },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileInputStreamClass),
            "::",
            stringify!(query_info_async)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GFileInputStreamClass>())).query_info_finish as *const _
                as usize
        },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileInputStreamClass),
            "::",
            stringify!(query_info_finish)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GFileInputStreamClass>()))._g_reserved1 as *const _ as usize
        },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileInputStreamClass),
            "::",
            stringify!(_g_reserved1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GFileInputStreamClass>()))._g_reserved2 as *const _ as usize
        },
        304usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileInputStreamClass),
            "::",
            stringify!(_g_reserved2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GFileInputStreamClass>()))._g_reserved3 as *const _ as usize
        },
        312usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileInputStreamClass),
            "::",
            stringify!(_g_reserved3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GFileInputStreamClass>()))._g_reserved4 as *const _ as usize
        },
        320usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileInputStreamClass),
            "::",
            stringify!(_g_reserved4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GFileInputStreamClass>()))._g_reserved5 as *const _ as usize
        },
        328usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileInputStreamClass),
            "::",
            stringify!(_g_reserved5)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_g_file_input_stream_get_type"]
    pub fn g_file_input_stream_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_file_input_stream_query_info"]
    pub fn g_file_input_stream_query_info(
        stream: *mut GFileInputStream,
        attributes: *const ::std::os::raw::c_char,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> *mut GFileInfo;
}
extern "C" {
    #[link_name = "\u{1}_g_file_input_stream_query_info_async"]
    pub fn g_file_input_stream_query_info_async(
        stream: *mut GFileInputStream,
        attributes: *const ::std::os::raw::c_char,
        io_priority: ::std::os::raw::c_int,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_file_input_stream_query_info_finish"]
    pub fn g_file_input_stream_query_info_finish(
        stream: *mut GFileInputStream,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> *mut GFileInfo;
}
extern "C" {
    #[link_name = "\u{1}_g_io_error_quark"]
    pub fn g_io_error_quark() -> GQuark;
}
extern "C" {
    #[link_name = "\u{1}_g_io_error_from_errno"]
    pub fn g_io_error_from_errno(err_no: gint) -> GIOErrorEnum;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GIOStreamPrivate {
    _unused: [u8; 0],
}
pub type GIOStreamPrivate = _GIOStreamPrivate;
pub type GIOStreamClass = _GIOStreamClass;
/// GIOStream:
///
/// Base class for read-write streams.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GIOStream {
    pub parent_instance: GObject,
    pub priv_: *mut GIOStreamPrivate,
}
#[test]
fn bindgen_test_layout__GIOStream() {
    assert_eq!(
        ::std::mem::size_of::<_GIOStream>(),
        32usize,
        concat!("Size of: ", stringify!(_GIOStream))
    );
    assert_eq!(
        ::std::mem::align_of::<_GIOStream>(),
        8usize,
        concat!("Alignment of ", stringify!(_GIOStream))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GIOStream>())).parent_instance as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GIOStream),
            "::",
            stringify!(parent_instance)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GIOStream>())).priv_ as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GIOStream),
            "::",
            stringify!(priv_)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GIOStreamClass {
    pub parent_class: GObjectClass,
    pub get_input_stream:
        ::std::option::Option<unsafe extern "C" fn(stream: *mut GIOStream) -> *mut GInputStream>,
    pub get_output_stream:
        ::std::option::Option<unsafe extern "C" fn(stream: *mut GIOStream) -> *mut GOutputStream>,
    pub close_fn: ::std::option::Option<
        unsafe extern "C" fn(
            stream: *mut GIOStream,
            cancellable: *mut GCancellable,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
    pub close_async: ::std::option::Option<
        unsafe extern "C" fn(
            stream: *mut GIOStream,
            io_priority: ::std::os::raw::c_int,
            cancellable: *mut GCancellable,
            callback: GAsyncReadyCallback,
            user_data: gpointer,
        ),
    >,
    pub close_finish: ::std::option::Option<
        unsafe extern "C" fn(
            stream: *mut GIOStream,
            result: *mut GAsyncResult,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
    pub _g_reserved1: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved2: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved3: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved4: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved5: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved6: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved7: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved8: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved9: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved10: ::std::option::Option<unsafe extern "C" fn()>,
}
#[test]
fn bindgen_test_layout__GIOStreamClass() {
    assert_eq!(
        ::std::mem::size_of::<_GIOStreamClass>(),
        256usize,
        concat!("Size of: ", stringify!(_GIOStreamClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_GIOStreamClass>(),
        8usize,
        concat!("Alignment of ", stringify!(_GIOStreamClass))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GIOStreamClass>())).parent_class as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GIOStreamClass),
            "::",
            stringify!(parent_class)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GIOStreamClass>())).get_input_stream as *const _ as usize
        },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_GIOStreamClass),
            "::",
            stringify!(get_input_stream)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GIOStreamClass>())).get_output_stream as *const _ as usize
        },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_GIOStreamClass),
            "::",
            stringify!(get_output_stream)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GIOStreamClass>())).close_fn as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(_GIOStreamClass),
            "::",
            stringify!(close_fn)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GIOStreamClass>())).close_async as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_GIOStreamClass),
            "::",
            stringify!(close_async)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GIOStreamClass>())).close_finish as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(_GIOStreamClass),
            "::",
            stringify!(close_finish)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GIOStreamClass>()))._g_reserved1 as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(_GIOStreamClass),
            "::",
            stringify!(_g_reserved1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GIOStreamClass>()))._g_reserved2 as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(_GIOStreamClass),
            "::",
            stringify!(_g_reserved2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GIOStreamClass>()))._g_reserved3 as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(_GIOStreamClass),
            "::",
            stringify!(_g_reserved3)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GIOStreamClass>()))._g_reserved4 as *const _ as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(_GIOStreamClass),
            "::",
            stringify!(_g_reserved4)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GIOStreamClass>()))._g_reserved5 as *const _ as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(_GIOStreamClass),
            "::",
            stringify!(_g_reserved5)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GIOStreamClass>()))._g_reserved6 as *const _ as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(_GIOStreamClass),
            "::",
            stringify!(_g_reserved6)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GIOStreamClass>()))._g_reserved7 as *const _ as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(_GIOStreamClass),
            "::",
            stringify!(_g_reserved7)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GIOStreamClass>()))._g_reserved8 as *const _ as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(_GIOStreamClass),
            "::",
            stringify!(_g_reserved8)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GIOStreamClass>()))._g_reserved9 as *const _ as usize },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(_GIOStreamClass),
            "::",
            stringify!(_g_reserved9)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GIOStreamClass>()))._g_reserved10 as *const _ as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(_GIOStreamClass),
            "::",
            stringify!(_g_reserved10)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_g_io_stream_get_type"]
    pub fn g_io_stream_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_io_stream_get_input_stream"]
    pub fn g_io_stream_get_input_stream(stream: *mut GIOStream) -> *mut GInputStream;
}
extern "C" {
    #[link_name = "\u{1}_g_io_stream_get_output_stream"]
    pub fn g_io_stream_get_output_stream(stream: *mut GIOStream) -> *mut GOutputStream;
}
extern "C" {
    #[link_name = "\u{1}_g_io_stream_splice_async"]
    pub fn g_io_stream_splice_async(
        stream1: *mut GIOStream,
        stream2: *mut GIOStream,
        flags: GIOStreamSpliceFlags,
        io_priority: ::std::os::raw::c_int,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_io_stream_splice_finish"]
    pub fn g_io_stream_splice_finish(
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_io_stream_close"]
    pub fn g_io_stream_close(
        stream: *mut GIOStream,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_io_stream_close_async"]
    pub fn g_io_stream_close_async(
        stream: *mut GIOStream,
        io_priority: ::std::os::raw::c_int,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_io_stream_close_finish"]
    pub fn g_io_stream_close_finish(
        stream: *mut GIOStream,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_io_stream_is_closed"]
    pub fn g_io_stream_is_closed(stream: *mut GIOStream) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_io_stream_has_pending"]
    pub fn g_io_stream_has_pending(stream: *mut GIOStream) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_io_stream_set_pending"]
    pub fn g_io_stream_set_pending(stream: *mut GIOStream, error: *mut *mut GError) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_io_stream_clear_pending"]
    pub fn g_io_stream_clear_pending(stream: *mut GIOStream);
}
/// GFileIOStream:
///
/// A subclass of GIOStream for opened files. This adds
/// a few file-specific operations and seeking and truncating.
///
/// #GFileIOStream implements GSeekable.
pub type GFileIOStreamClass = _GFileIOStreamClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GFileIOStreamPrivate {
    _unused: [u8; 0],
}
pub type GFileIOStreamPrivate = _GFileIOStreamPrivate;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GFileIOStream {
    pub parent_instance: GIOStream,
    pub priv_: *mut GFileIOStreamPrivate,
}
#[test]
fn bindgen_test_layout__GFileIOStream() {
    assert_eq!(
        ::std::mem::size_of::<_GFileIOStream>(),
        40usize,
        concat!("Size of: ", stringify!(_GFileIOStream))
    );
    assert_eq!(
        ::std::mem::align_of::<_GFileIOStream>(),
        8usize,
        concat!("Alignment of ", stringify!(_GFileIOStream))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GFileIOStream>())).parent_instance as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIOStream),
            "::",
            stringify!(parent_instance)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GFileIOStream>())).priv_ as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIOStream),
            "::",
            stringify!(priv_)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GFileIOStreamClass {
    pub parent_class: GIOStreamClass,
    pub tell: ::std::option::Option<unsafe extern "C" fn(stream: *mut GFileIOStream) -> goffset>,
    pub can_seek:
        ::std::option::Option<unsafe extern "C" fn(stream: *mut GFileIOStream) -> gboolean>,
    pub seek: ::std::option::Option<
        unsafe extern "C" fn(
            stream: *mut GFileIOStream,
            offset: goffset,
            type_: GSeekType,
            cancellable: *mut GCancellable,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
    pub can_truncate:
        ::std::option::Option<unsafe extern "C" fn(stream: *mut GFileIOStream) -> gboolean>,
    pub truncate_fn: ::std::option::Option<
        unsafe extern "C" fn(
            stream: *mut GFileIOStream,
            size: goffset,
            cancellable: *mut GCancellable,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
    pub query_info: ::std::option::Option<
        unsafe extern "C" fn(
            stream: *mut GFileIOStream,
            attributes: *const ::std::os::raw::c_char,
            cancellable: *mut GCancellable,
            error: *mut *mut GError,
        ) -> *mut GFileInfo,
    >,
    pub query_info_async: ::std::option::Option<
        unsafe extern "C" fn(
            stream: *mut GFileIOStream,
            attributes: *const ::std::os::raw::c_char,
            io_priority: ::std::os::raw::c_int,
            cancellable: *mut GCancellable,
            callback: GAsyncReadyCallback,
            user_data: gpointer,
        ),
    >,
    pub query_info_finish: ::std::option::Option<
        unsafe extern "C" fn(
            stream: *mut GFileIOStream,
            result: *mut GAsyncResult,
            error: *mut *mut GError,
        ) -> *mut GFileInfo,
    >,
    pub get_etag: ::std::option::Option<
        unsafe extern "C" fn(stream: *mut GFileIOStream) -> *mut ::std::os::raw::c_char,
    >,
    pub _g_reserved1: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved2: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved3: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved4: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved5: ::std::option::Option<unsafe extern "C" fn()>,
}
#[test]
fn bindgen_test_layout__GFileIOStreamClass() {
    assert_eq!(
        ::std::mem::size_of::<_GFileIOStreamClass>(),
        368usize,
        concat!("Size of: ", stringify!(_GFileIOStreamClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_GFileIOStreamClass>(),
        8usize,
        concat!("Alignment of ", stringify!(_GFileIOStreamClass))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GFileIOStreamClass>())).parent_class as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIOStreamClass),
            "::",
            stringify!(parent_class)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GFileIOStreamClass>())).tell as *const _ as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIOStreamClass),
            "::",
            stringify!(tell)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GFileIOStreamClass>())).can_seek as *const _ as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIOStreamClass),
            "::",
            stringify!(can_seek)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GFileIOStreamClass>())).seek as *const _ as usize },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIOStreamClass),
            "::",
            stringify!(seek)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GFileIOStreamClass>())).can_truncate as *const _ as usize
        },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIOStreamClass),
            "::",
            stringify!(can_truncate)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GFileIOStreamClass>())).truncate_fn as *const _ as usize },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIOStreamClass),
            "::",
            stringify!(truncate_fn)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GFileIOStreamClass>())).query_info as *const _ as usize },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIOStreamClass),
            "::",
            stringify!(query_info)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GFileIOStreamClass>())).query_info_async as *const _ as usize
        },
        304usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIOStreamClass),
            "::",
            stringify!(query_info_async)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GFileIOStreamClass>())).query_info_finish as *const _ as usize
        },
        312usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIOStreamClass),
            "::",
            stringify!(query_info_finish)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GFileIOStreamClass>())).get_etag as *const _ as usize },
        320usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIOStreamClass),
            "::",
            stringify!(get_etag)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GFileIOStreamClass>()))._g_reserved1 as *const _ as usize
        },
        328usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIOStreamClass),
            "::",
            stringify!(_g_reserved1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GFileIOStreamClass>()))._g_reserved2 as *const _ as usize
        },
        336usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIOStreamClass),
            "::",
            stringify!(_g_reserved2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GFileIOStreamClass>()))._g_reserved3 as *const _ as usize
        },
        344usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIOStreamClass),
            "::",
            stringify!(_g_reserved3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GFileIOStreamClass>()))._g_reserved4 as *const _ as usize
        },
        352usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIOStreamClass),
            "::",
            stringify!(_g_reserved4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GFileIOStreamClass>()))._g_reserved5 as *const _ as usize
        },
        360usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileIOStreamClass),
            "::",
            stringify!(_g_reserved5)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_g_file_io_stream_get_type"]
    pub fn g_file_io_stream_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_file_io_stream_query_info"]
    pub fn g_file_io_stream_query_info(
        stream: *mut GFileIOStream,
        attributes: *const ::std::os::raw::c_char,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> *mut GFileInfo;
}
extern "C" {
    #[link_name = "\u{1}_g_file_io_stream_query_info_async"]
    pub fn g_file_io_stream_query_info_async(
        stream: *mut GFileIOStream,
        attributes: *const ::std::os::raw::c_char,
        io_priority: ::std::os::raw::c_int,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_file_io_stream_query_info_finish"]
    pub fn g_file_io_stream_query_info_finish(
        stream: *mut GFileIOStream,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> *mut GFileInfo;
}
extern "C" {
    #[link_name = "\u{1}_g_file_io_stream_get_etag"]
    pub fn g_file_io_stream_get_etag(stream: *mut GFileIOStream) -> *mut ::std::os::raw::c_char;
}
pub type GFileMonitorClass = _GFileMonitorClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GFileMonitorPrivate {
    _unused: [u8; 0],
}
pub type GFileMonitorPrivate = _GFileMonitorPrivate;
/// GFileMonitor:
///
/// Watches for changes to a file.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GFileMonitor {
    pub parent_instance: GObject,
    pub priv_: *mut GFileMonitorPrivate,
}
#[test]
fn bindgen_test_layout__GFileMonitor() {
    assert_eq!(
        ::std::mem::size_of::<_GFileMonitor>(),
        32usize,
        concat!("Size of: ", stringify!(_GFileMonitor))
    );
    assert_eq!(
        ::std::mem::align_of::<_GFileMonitor>(),
        8usize,
        concat!("Alignment of ", stringify!(_GFileMonitor))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GFileMonitor>())).parent_instance as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileMonitor),
            "::",
            stringify!(parent_instance)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GFileMonitor>())).priv_ as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileMonitor),
            "::",
            stringify!(priv_)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GFileMonitorClass {
    pub parent_class: GObjectClass,
    pub changed: ::std::option::Option<
        unsafe extern "C" fn(
            monitor: *mut GFileMonitor,
            file: *mut GFile,
            other_file: *mut GFile,
            event_type: GFileMonitorEvent,
        ),
    >,
    pub cancel: ::std::option::Option<unsafe extern "C" fn(monitor: *mut GFileMonitor) -> gboolean>,
    pub _g_reserved1: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved2: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved3: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved4: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved5: ::std::option::Option<unsafe extern "C" fn()>,
}
#[test]
fn bindgen_test_layout__GFileMonitorClass() {
    assert_eq!(
        ::std::mem::size_of::<_GFileMonitorClass>(),
        192usize,
        concat!("Size of: ", stringify!(_GFileMonitorClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_GFileMonitorClass>(),
        8usize,
        concat!("Alignment of ", stringify!(_GFileMonitorClass))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GFileMonitorClass>())).parent_class as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileMonitorClass),
            "::",
            stringify!(parent_class)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GFileMonitorClass>())).changed as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileMonitorClass),
            "::",
            stringify!(changed)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GFileMonitorClass>())).cancel as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileMonitorClass),
            "::",
            stringify!(cancel)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GFileMonitorClass>()))._g_reserved1 as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileMonitorClass),
            "::",
            stringify!(_g_reserved1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GFileMonitorClass>()))._g_reserved2 as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileMonitorClass),
            "::",
            stringify!(_g_reserved2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GFileMonitorClass>()))._g_reserved3 as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileMonitorClass),
            "::",
            stringify!(_g_reserved3)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GFileMonitorClass>()))._g_reserved4 as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileMonitorClass),
            "::",
            stringify!(_g_reserved4)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GFileMonitorClass>()))._g_reserved5 as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileMonitorClass),
            "::",
            stringify!(_g_reserved5)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_g_file_monitor_get_type"]
    pub fn g_file_monitor_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_file_monitor_cancel"]
    pub fn g_file_monitor_cancel(monitor: *mut GFileMonitor) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_file_monitor_is_cancelled"]
    pub fn g_file_monitor_is_cancelled(monitor: *mut GFileMonitor) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_file_monitor_set_rate_limit"]
    pub fn g_file_monitor_set_rate_limit(monitor: *mut GFileMonitor, limit_msecs: gint);
}
extern "C" {
    #[link_name = "\u{1}_g_file_monitor_emit_event"]
    pub fn g_file_monitor_emit_event(
        monitor: *mut GFileMonitor,
        child: *mut GFile,
        other_file: *mut GFile,
        event_type: GFileMonitorEvent,
    );
}
/// GFilenameCompleter:
///
/// Completes filenames based on files that exist within the file system.
pub type GFilenameCompleterClass = _GFilenameCompleterClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GFilenameCompleterClass {
    pub parent_class: GObjectClass,
    pub got_completion_data:
        ::std::option::Option<unsafe extern "C" fn(filename_completer: *mut GFilenameCompleter)>,
    pub _g_reserved1: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved2: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved3: ::std::option::Option<unsafe extern "C" fn()>,
}
#[test]
fn bindgen_test_layout__GFilenameCompleterClass() {
    assert_eq!(
        ::std::mem::size_of::<_GFilenameCompleterClass>(),
        168usize,
        concat!("Size of: ", stringify!(_GFilenameCompleterClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_GFilenameCompleterClass>(),
        8usize,
        concat!("Alignment of ", stringify!(_GFilenameCompleterClass))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GFilenameCompleterClass>())).parent_class as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFilenameCompleterClass),
            "::",
            stringify!(parent_class)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GFilenameCompleterClass>())).got_completion_data as *const _
                as usize
        },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFilenameCompleterClass),
            "::",
            stringify!(got_completion_data)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GFilenameCompleterClass>()))._g_reserved1 as *const _ as usize
        },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFilenameCompleterClass),
            "::",
            stringify!(_g_reserved1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GFilenameCompleterClass>()))._g_reserved2 as *const _ as usize
        },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFilenameCompleterClass),
            "::",
            stringify!(_g_reserved2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GFilenameCompleterClass>()))._g_reserved3 as *const _ as usize
        },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFilenameCompleterClass),
            "::",
            stringify!(_g_reserved3)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_g_filename_completer_get_type"]
    pub fn g_filename_completer_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_filename_completer_new"]
    pub fn g_filename_completer_new() -> *mut GFilenameCompleter;
}
extern "C" {
    #[link_name = "\u{1}_g_filename_completer_get_completion_suffix"]
    pub fn g_filename_completer_get_completion_suffix(
        completer: *mut GFilenameCompleter,
        initial_text: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_g_filename_completer_get_completions"]
    pub fn g_filename_completer_get_completions(
        completer: *mut GFilenameCompleter,
        initial_text: *const ::std::os::raw::c_char,
    ) -> *mut *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_g_filename_completer_set_dirs_only"]
    pub fn g_filename_completer_set_dirs_only(
        completer: *mut GFilenameCompleter,
        dirs_only: gboolean,
    );
}
/// GFileOutputStream:
///
/// A subclass of GOutputStream for opened files. This adds
/// a few file-specific operations and seeking and truncating.
///
/// #GFileOutputStream implements GSeekable.
pub type GFileOutputStreamClass = _GFileOutputStreamClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GFileOutputStreamPrivate {
    _unused: [u8; 0],
}
pub type GFileOutputStreamPrivate = _GFileOutputStreamPrivate;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GFileOutputStream {
    pub parent_instance: GOutputStream,
    pub priv_: *mut GFileOutputStreamPrivate,
}
#[test]
fn bindgen_test_layout__GFileOutputStream() {
    assert_eq!(
        ::std::mem::size_of::<_GFileOutputStream>(),
        40usize,
        concat!("Size of: ", stringify!(_GFileOutputStream))
    );
    assert_eq!(
        ::std::mem::align_of::<_GFileOutputStream>(),
        8usize,
        concat!("Alignment of ", stringify!(_GFileOutputStream))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GFileOutputStream>())).parent_instance as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileOutputStream),
            "::",
            stringify!(parent_instance)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GFileOutputStream>())).priv_ as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileOutputStream),
            "::",
            stringify!(priv_)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GFileOutputStreamClass {
    pub parent_class: GOutputStreamClass,
    pub tell:
        ::std::option::Option<unsafe extern "C" fn(stream: *mut GFileOutputStream) -> goffset>,
    pub can_seek:
        ::std::option::Option<unsafe extern "C" fn(stream: *mut GFileOutputStream) -> gboolean>,
    pub seek: ::std::option::Option<
        unsafe extern "C" fn(
            stream: *mut GFileOutputStream,
            offset: goffset,
            type_: GSeekType,
            cancellable: *mut GCancellable,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
    pub can_truncate:
        ::std::option::Option<unsafe extern "C" fn(stream: *mut GFileOutputStream) -> gboolean>,
    pub truncate_fn: ::std::option::Option<
        unsafe extern "C" fn(
            stream: *mut GFileOutputStream,
            size: goffset,
            cancellable: *mut GCancellable,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
    pub query_info: ::std::option::Option<
        unsafe extern "C" fn(
            stream: *mut GFileOutputStream,
            attributes: *const ::std::os::raw::c_char,
            cancellable: *mut GCancellable,
            error: *mut *mut GError,
        ) -> *mut GFileInfo,
    >,
    pub query_info_async: ::std::option::Option<
        unsafe extern "C" fn(
            stream: *mut GFileOutputStream,
            attributes: *const ::std::os::raw::c_char,
            io_priority: ::std::os::raw::c_int,
            cancellable: *mut GCancellable,
            callback: GAsyncReadyCallback,
            user_data: gpointer,
        ),
    >,
    pub query_info_finish: ::std::option::Option<
        unsafe extern "C" fn(
            stream: *mut GFileOutputStream,
            result: *mut GAsyncResult,
            error: *mut *mut GError,
        ) -> *mut GFileInfo,
    >,
    pub get_etag: ::std::option::Option<
        unsafe extern "C" fn(stream: *mut GFileOutputStream) -> *mut ::std::os::raw::c_char,
    >,
    pub _g_reserved1: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved2: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved3: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved4: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved5: ::std::option::Option<unsafe extern "C" fn()>,
}
#[test]
fn bindgen_test_layout__GFileOutputStreamClass() {
    assert_eq!(
        ::std::mem::size_of::<_GFileOutputStreamClass>(),
        408usize,
        concat!("Size of: ", stringify!(_GFileOutputStreamClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_GFileOutputStreamClass>(),
        8usize,
        concat!("Alignment of ", stringify!(_GFileOutputStreamClass))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GFileOutputStreamClass>())).parent_class as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileOutputStreamClass),
            "::",
            stringify!(parent_class)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GFileOutputStreamClass>())).tell as *const _ as usize },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileOutputStreamClass),
            "::",
            stringify!(tell)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GFileOutputStreamClass>())).can_seek as *const _ as usize
        },
        304usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileOutputStreamClass),
            "::",
            stringify!(can_seek)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GFileOutputStreamClass>())).seek as *const _ as usize },
        312usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileOutputStreamClass),
            "::",
            stringify!(seek)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GFileOutputStreamClass>())).can_truncate as *const _ as usize
        },
        320usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileOutputStreamClass),
            "::",
            stringify!(can_truncate)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GFileOutputStreamClass>())).truncate_fn as *const _ as usize
        },
        328usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileOutputStreamClass),
            "::",
            stringify!(truncate_fn)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GFileOutputStreamClass>())).query_info as *const _ as usize
        },
        336usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileOutputStreamClass),
            "::",
            stringify!(query_info)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GFileOutputStreamClass>())).query_info_async as *const _
                as usize
        },
        344usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileOutputStreamClass),
            "::",
            stringify!(query_info_async)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GFileOutputStreamClass>())).query_info_finish as *const _
                as usize
        },
        352usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileOutputStreamClass),
            "::",
            stringify!(query_info_finish)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GFileOutputStreamClass>())).get_etag as *const _ as usize
        },
        360usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileOutputStreamClass),
            "::",
            stringify!(get_etag)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GFileOutputStreamClass>()))._g_reserved1 as *const _ as usize
        },
        368usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileOutputStreamClass),
            "::",
            stringify!(_g_reserved1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GFileOutputStreamClass>()))._g_reserved2 as *const _ as usize
        },
        376usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileOutputStreamClass),
            "::",
            stringify!(_g_reserved2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GFileOutputStreamClass>()))._g_reserved3 as *const _ as usize
        },
        384usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileOutputStreamClass),
            "::",
            stringify!(_g_reserved3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GFileOutputStreamClass>()))._g_reserved4 as *const _ as usize
        },
        392usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileOutputStreamClass),
            "::",
            stringify!(_g_reserved4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GFileOutputStreamClass>()))._g_reserved5 as *const _ as usize
        },
        400usize,
        concat!(
            "Offset of field: ",
            stringify!(_GFileOutputStreamClass),
            "::",
            stringify!(_g_reserved5)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_g_file_output_stream_get_type"]
    pub fn g_file_output_stream_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_file_output_stream_query_info"]
    pub fn g_file_output_stream_query_info(
        stream: *mut GFileOutputStream,
        attributes: *const ::std::os::raw::c_char,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> *mut GFileInfo;
}
extern "C" {
    #[link_name = "\u{1}_g_file_output_stream_query_info_async"]
    pub fn g_file_output_stream_query_info_async(
        stream: *mut GFileOutputStream,
        attributes: *const ::std::os::raw::c_char,
        io_priority: ::std::os::raw::c_int,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_file_output_stream_query_info_finish"]
    pub fn g_file_output_stream_query_info_finish(
        stream: *mut GFileOutputStream,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> *mut GFileInfo;
}
extern "C" {
    #[link_name = "\u{1}_g_file_output_stream_get_etag"]
    pub fn g_file_output_stream_get_etag(
        stream: *mut GFileOutputStream,
    ) -> *mut ::std::os::raw::c_char;
}
pub type GInetAddressClass = _GInetAddressClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GInetAddressPrivate {
    _unused: [u8; 0],
}
pub type GInetAddressPrivate = _GInetAddressPrivate;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GInetAddress {
    pub parent_instance: GObject,
    pub priv_: *mut GInetAddressPrivate,
}
#[test]
fn bindgen_test_layout__GInetAddress() {
    assert_eq!(
        ::std::mem::size_of::<_GInetAddress>(),
        32usize,
        concat!("Size of: ", stringify!(_GInetAddress))
    );
    assert_eq!(
        ::std::mem::align_of::<_GInetAddress>(),
        8usize,
        concat!("Alignment of ", stringify!(_GInetAddress))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GInetAddress>())).parent_instance as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GInetAddress),
            "::",
            stringify!(parent_instance)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GInetAddress>())).priv_ as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GInetAddress),
            "::",
            stringify!(priv_)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GInetAddressClass {
    pub parent_class: GObjectClass,
    pub to_string:
        ::std::option::Option<unsafe extern "C" fn(address: *mut GInetAddress) -> *mut gchar>,
    pub to_bytes:
        ::std::option::Option<unsafe extern "C" fn(address: *mut GInetAddress) -> *const guint8>,
}
#[test]
fn bindgen_test_layout__GInetAddressClass() {
    assert_eq!(
        ::std::mem::size_of::<_GInetAddressClass>(),
        152usize,
        concat!("Size of: ", stringify!(_GInetAddressClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_GInetAddressClass>(),
        8usize,
        concat!("Alignment of ", stringify!(_GInetAddressClass))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GInetAddressClass>())).parent_class as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GInetAddressClass),
            "::",
            stringify!(parent_class)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GInetAddressClass>())).to_string as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_GInetAddressClass),
            "::",
            stringify!(to_string)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GInetAddressClass>())).to_bytes as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_GInetAddressClass),
            "::",
            stringify!(to_bytes)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_g_inet_address_get_type"]
    pub fn g_inet_address_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_inet_address_new_from_string"]
    pub fn g_inet_address_new_from_string(string: *const gchar) -> *mut GInetAddress;
}
extern "C" {
    #[link_name = "\u{1}_g_inet_address_new_from_bytes"]
    pub fn g_inet_address_new_from_bytes(
        bytes: *const guint8,
        family: GSocketFamily,
    ) -> *mut GInetAddress;
}
extern "C" {
    #[link_name = "\u{1}_g_inet_address_new_loopback"]
    pub fn g_inet_address_new_loopback(family: GSocketFamily) -> *mut GInetAddress;
}
extern "C" {
    #[link_name = "\u{1}_g_inet_address_new_any"]
    pub fn g_inet_address_new_any(family: GSocketFamily) -> *mut GInetAddress;
}
extern "C" {
    #[link_name = "\u{1}_g_inet_address_equal"]
    pub fn g_inet_address_equal(
        address: *mut GInetAddress,
        other_address: *mut GInetAddress,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_inet_address_to_string"]
    pub fn g_inet_address_to_string(address: *mut GInetAddress) -> *mut gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_inet_address_to_bytes"]
    pub fn g_inet_address_to_bytes(address: *mut GInetAddress) -> *const guint8;
}
extern "C" {
    #[link_name = "\u{1}_g_inet_address_get_native_size"]
    pub fn g_inet_address_get_native_size(address: *mut GInetAddress) -> gsize;
}
extern "C" {
    #[link_name = "\u{1}_g_inet_address_get_family"]
    pub fn g_inet_address_get_family(address: *mut GInetAddress) -> GSocketFamily;
}
extern "C" {
    #[link_name = "\u{1}_g_inet_address_get_is_any"]
    pub fn g_inet_address_get_is_any(address: *mut GInetAddress) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_inet_address_get_is_loopback"]
    pub fn g_inet_address_get_is_loopback(address: *mut GInetAddress) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_inet_address_get_is_link_local"]
    pub fn g_inet_address_get_is_link_local(address: *mut GInetAddress) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_inet_address_get_is_site_local"]
    pub fn g_inet_address_get_is_site_local(address: *mut GInetAddress) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_inet_address_get_is_multicast"]
    pub fn g_inet_address_get_is_multicast(address: *mut GInetAddress) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_inet_address_get_is_mc_global"]
    pub fn g_inet_address_get_is_mc_global(address: *mut GInetAddress) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_inet_address_get_is_mc_link_local"]
    pub fn g_inet_address_get_is_mc_link_local(address: *mut GInetAddress) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_inet_address_get_is_mc_node_local"]
    pub fn g_inet_address_get_is_mc_node_local(address: *mut GInetAddress) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_inet_address_get_is_mc_org_local"]
    pub fn g_inet_address_get_is_mc_org_local(address: *mut GInetAddress) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_inet_address_get_is_mc_site_local"]
    pub fn g_inet_address_get_is_mc_site_local(address: *mut GInetAddress) -> gboolean;
}
pub type GInetAddressMaskClass = _GInetAddressMaskClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GInetAddressMaskPrivate {
    _unused: [u8; 0],
}
pub type GInetAddressMaskPrivate = _GInetAddressMaskPrivate;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GInetAddressMask {
    pub parent_instance: GObject,
    pub priv_: *mut GInetAddressMaskPrivate,
}
#[test]
fn bindgen_test_layout__GInetAddressMask() {
    assert_eq!(
        ::std::mem::size_of::<_GInetAddressMask>(),
        32usize,
        concat!("Size of: ", stringify!(_GInetAddressMask))
    );
    assert_eq!(
        ::std::mem::align_of::<_GInetAddressMask>(),
        8usize,
        concat!("Alignment of ", stringify!(_GInetAddressMask))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GInetAddressMask>())).parent_instance as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GInetAddressMask),
            "::",
            stringify!(parent_instance)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GInetAddressMask>())).priv_ as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GInetAddressMask),
            "::",
            stringify!(priv_)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GInetAddressMaskClass {
    pub parent_class: GObjectClass,
}
#[test]
fn bindgen_test_layout__GInetAddressMaskClass() {
    assert_eq!(
        ::std::mem::size_of::<_GInetAddressMaskClass>(),
        136usize,
        concat!("Size of: ", stringify!(_GInetAddressMaskClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_GInetAddressMaskClass>(),
        8usize,
        concat!("Alignment of ", stringify!(_GInetAddressMaskClass))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GInetAddressMaskClass>())).parent_class as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GInetAddressMaskClass),
            "::",
            stringify!(parent_class)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_g_inet_address_mask_get_type"]
    pub fn g_inet_address_mask_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_inet_address_mask_new"]
    pub fn g_inet_address_mask_new(
        addr: *mut GInetAddress,
        length: guint,
        error: *mut *mut GError,
    ) -> *mut GInetAddressMask;
}
extern "C" {
    #[link_name = "\u{1}_g_inet_address_mask_new_from_string"]
    pub fn g_inet_address_mask_new_from_string(
        mask_string: *const gchar,
        error: *mut *mut GError,
    ) -> *mut GInetAddressMask;
}
extern "C" {
    #[link_name = "\u{1}_g_inet_address_mask_to_string"]
    pub fn g_inet_address_mask_to_string(mask: *mut GInetAddressMask) -> *mut gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_inet_address_mask_get_family"]
    pub fn g_inet_address_mask_get_family(mask: *mut GInetAddressMask) -> GSocketFamily;
}
extern "C" {
    #[link_name = "\u{1}_g_inet_address_mask_get_address"]
    pub fn g_inet_address_mask_get_address(mask: *mut GInetAddressMask) -> *mut GInetAddress;
}
extern "C" {
    #[link_name = "\u{1}_g_inet_address_mask_get_length"]
    pub fn g_inet_address_mask_get_length(mask: *mut GInetAddressMask) -> guint;
}
extern "C" {
    #[link_name = "\u{1}_g_inet_address_mask_matches"]
    pub fn g_inet_address_mask_matches(
        mask: *mut GInetAddressMask,
        address: *mut GInetAddress,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_inet_address_mask_equal"]
    pub fn g_inet_address_mask_equal(
        mask: *mut GInetAddressMask,
        mask2: *mut GInetAddressMask,
    ) -> gboolean;
}
pub type GSocketAddressClass = _GSocketAddressClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GSocketAddress {
    pub parent_instance: GObject,
}
#[test]
fn bindgen_test_layout__GSocketAddress() {
    assert_eq!(
        ::std::mem::size_of::<_GSocketAddress>(),
        24usize,
        concat!("Size of: ", stringify!(_GSocketAddress))
    );
    assert_eq!(
        ::std::mem::align_of::<_GSocketAddress>(),
        8usize,
        concat!("Alignment of ", stringify!(_GSocketAddress))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GSocketAddress>())).parent_instance as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSocketAddress),
            "::",
            stringify!(parent_instance)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GSocketAddressClass {
    pub parent_class: GObjectClass,
    pub get_family:
        ::std::option::Option<unsafe extern "C" fn(address: *mut GSocketAddress) -> GSocketFamily>,
    pub get_native_size:
        ::std::option::Option<unsafe extern "C" fn(address: *mut GSocketAddress) -> gssize>,
    pub to_native: ::std::option::Option<
        unsafe extern "C" fn(
            address: *mut GSocketAddress,
            dest: gpointer,
            destlen: gsize,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
}
#[test]
fn bindgen_test_layout__GSocketAddressClass() {
    assert_eq!(
        ::std::mem::size_of::<_GSocketAddressClass>(),
        160usize,
        concat!("Size of: ", stringify!(_GSocketAddressClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_GSocketAddressClass>(),
        8usize,
        concat!("Alignment of ", stringify!(_GSocketAddressClass))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GSocketAddressClass>())).parent_class as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSocketAddressClass),
            "::",
            stringify!(parent_class)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GSocketAddressClass>())).get_family as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSocketAddressClass),
            "::",
            stringify!(get_family)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GSocketAddressClass>())).get_native_size as *const _ as usize
        },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSocketAddressClass),
            "::",
            stringify!(get_native_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GSocketAddressClass>())).to_native as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSocketAddressClass),
            "::",
            stringify!(to_native)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_g_socket_address_get_type"]
    pub fn g_socket_address_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_socket_address_get_family"]
    pub fn g_socket_address_get_family(address: *mut GSocketAddress) -> GSocketFamily;
}
extern "C" {
    #[link_name = "\u{1}_g_socket_address_new_from_native"]
    pub fn g_socket_address_new_from_native(native: gpointer, len: gsize) -> *mut GSocketAddress;
}
extern "C" {
    #[link_name = "\u{1}_g_socket_address_to_native"]
    pub fn g_socket_address_to_native(
        address: *mut GSocketAddress,
        dest: gpointer,
        destlen: gsize,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_socket_address_get_native_size"]
    pub fn g_socket_address_get_native_size(address: *mut GSocketAddress) -> gssize;
}
pub type GInetSocketAddressClass = _GInetSocketAddressClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GInetSocketAddressPrivate {
    _unused: [u8; 0],
}
pub type GInetSocketAddressPrivate = _GInetSocketAddressPrivate;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GInetSocketAddress {
    pub parent_instance: GSocketAddress,
    pub priv_: *mut GInetSocketAddressPrivate,
}
#[test]
fn bindgen_test_layout__GInetSocketAddress() {
    assert_eq!(
        ::std::mem::size_of::<_GInetSocketAddress>(),
        32usize,
        concat!("Size of: ", stringify!(_GInetSocketAddress))
    );
    assert_eq!(
        ::std::mem::align_of::<_GInetSocketAddress>(),
        8usize,
        concat!("Alignment of ", stringify!(_GInetSocketAddress))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GInetSocketAddress>())).parent_instance as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GInetSocketAddress),
            "::",
            stringify!(parent_instance)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GInetSocketAddress>())).priv_ as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GInetSocketAddress),
            "::",
            stringify!(priv_)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GInetSocketAddressClass {
    pub parent_class: GSocketAddressClass,
}
#[test]
fn bindgen_test_layout__GInetSocketAddressClass() {
    assert_eq!(
        ::std::mem::size_of::<_GInetSocketAddressClass>(),
        160usize,
        concat!("Size of: ", stringify!(_GInetSocketAddressClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_GInetSocketAddressClass>(),
        8usize,
        concat!("Alignment of ", stringify!(_GInetSocketAddressClass))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GInetSocketAddressClass>())).parent_class as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GInetSocketAddressClass),
            "::",
            stringify!(parent_class)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_g_inet_socket_address_get_type"]
    pub fn g_inet_socket_address_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_inet_socket_address_new"]
    pub fn g_inet_socket_address_new(
        address: *mut GInetAddress,
        port: guint16,
    ) -> *mut GSocketAddress;
}
extern "C" {
    #[link_name = "\u{1}_g_inet_socket_address_new_from_string"]
    pub fn g_inet_socket_address_new_from_string(
        address: *const ::std::os::raw::c_char,
        port: guint,
    ) -> *mut GSocketAddress;
}
extern "C" {
    #[link_name = "\u{1}_g_inet_socket_address_get_address"]
    pub fn g_inet_socket_address_get_address(address: *mut GInetSocketAddress)
        -> *mut GInetAddress;
}
extern "C" {
    #[link_name = "\u{1}_g_inet_socket_address_get_port"]
    pub fn g_inet_socket_address_get_port(address: *mut GInetSocketAddress) -> guint16;
}
extern "C" {
    #[link_name = "\u{1}_g_inet_socket_address_get_flowinfo"]
    pub fn g_inet_socket_address_get_flowinfo(address: *mut GInetSocketAddress) -> guint32;
}
extern "C" {
    #[link_name = "\u{1}_g_inet_socket_address_get_scope_id"]
    pub fn g_inet_socket_address_get_scope_id(address: *mut GInetSocketAddress) -> guint32;
}
extern "C" {
    #[link_name = "\u{1}_g_app_info_create_flags_get_type"]
    pub fn g_app_info_create_flags_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_converter_flags_get_type"]
    pub fn g_converter_flags_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_converter_result_get_type"]
    pub fn g_converter_result_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_data_stream_byte_order_get_type"]
    pub fn g_data_stream_byte_order_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_data_stream_newline_type_get_type"]
    pub fn g_data_stream_newline_type_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_file_attribute_type_get_type"]
    pub fn g_file_attribute_type_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_file_attribute_info_flags_get_type"]
    pub fn g_file_attribute_info_flags_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_file_attribute_status_get_type"]
    pub fn g_file_attribute_status_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_file_query_info_flags_get_type"]
    pub fn g_file_query_info_flags_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_file_create_flags_get_type"]
    pub fn g_file_create_flags_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_file_measure_flags_get_type"]
    pub fn g_file_measure_flags_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_mount_mount_flags_get_type"]
    pub fn g_mount_mount_flags_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_mount_unmount_flags_get_type"]
    pub fn g_mount_unmount_flags_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_drive_start_flags_get_type"]
    pub fn g_drive_start_flags_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_drive_start_stop_type_get_type"]
    pub fn g_drive_start_stop_type_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_file_copy_flags_get_type"]
    pub fn g_file_copy_flags_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_file_monitor_flags_get_type"]
    pub fn g_file_monitor_flags_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_file_type_get_type"]
    pub fn g_file_type_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_filesystem_preview_type_get_type"]
    pub fn g_filesystem_preview_type_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_file_monitor_event_get_type"]
    pub fn g_file_monitor_event_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_io_error_enum_get_type"]
    pub fn g_io_error_enum_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_ask_password_flags_get_type"]
    pub fn g_ask_password_flags_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_password_save_get_type"]
    pub fn g_password_save_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_mount_operation_result_get_type"]
    pub fn g_mount_operation_result_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_output_stream_splice_flags_get_type"]
    pub fn g_output_stream_splice_flags_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_io_stream_splice_flags_get_type"]
    pub fn g_io_stream_splice_flags_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_emblem_origin_get_type"]
    pub fn g_emblem_origin_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_resolver_error_get_type"]
    pub fn g_resolver_error_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_resolver_record_type_get_type"]
    pub fn g_resolver_record_type_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_resource_error_get_type"]
    pub fn g_resource_error_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_resource_flags_get_type"]
    pub fn g_resource_flags_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_resource_lookup_flags_get_type"]
    pub fn g_resource_lookup_flags_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_socket_family_get_type"]
    pub fn g_socket_family_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_socket_type_get_type"]
    pub fn g_socket_type_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_socket_msg_flags_get_type"]
    pub fn g_socket_msg_flags_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_socket_protocol_get_type"]
    pub fn g_socket_protocol_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_zlib_compressor_format_get_type"]
    pub fn g_zlib_compressor_format_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_unix_socket_address_type_get_type"]
    pub fn g_unix_socket_address_type_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_bus_type_get_type"]
    pub fn g_bus_type_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_bus_name_owner_flags_get_type"]
    pub fn g_bus_name_owner_flags_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_bus_name_watcher_flags_get_type"]
    pub fn g_bus_name_watcher_flags_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_dbus_proxy_flags_get_type"]
    pub fn g_dbus_proxy_flags_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_dbus_error_get_type"]
    pub fn g_dbus_error_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_dbus_connection_flags_get_type"]
    pub fn g_dbus_connection_flags_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_dbus_capability_flags_get_type"]
    pub fn g_dbus_capability_flags_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_dbus_call_flags_get_type"]
    pub fn g_dbus_call_flags_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_dbus_message_type_get_type"]
    pub fn g_dbus_message_type_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_dbus_message_flags_get_type"]
    pub fn g_dbus_message_flags_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_dbus_message_header_field_get_type"]
    pub fn g_dbus_message_header_field_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_dbus_property_info_flags_get_type"]
    pub fn g_dbus_property_info_flags_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_dbus_subtree_flags_get_type"]
    pub fn g_dbus_subtree_flags_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_dbus_server_flags_get_type"]
    pub fn g_dbus_server_flags_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_dbus_signal_flags_get_type"]
    pub fn g_dbus_signal_flags_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_dbus_send_message_flags_get_type"]
    pub fn g_dbus_send_message_flags_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_credentials_type_get_type"]
    pub fn g_credentials_type_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_dbus_message_byte_order_get_type"]
    pub fn g_dbus_message_byte_order_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_application_flags_get_type"]
    pub fn g_application_flags_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_tls_error_get_type"]
    pub fn g_tls_error_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_tls_certificate_flags_get_type"]
    pub fn g_tls_certificate_flags_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_tls_authentication_mode_get_type"]
    pub fn g_tls_authentication_mode_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_tls_rehandshake_mode_get_type"]
    pub fn g_tls_rehandshake_mode_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_tls_password_flags_get_type"]
    pub fn g_tls_password_flags_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_tls_interaction_result_get_type"]
    pub fn g_tls_interaction_result_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_dbus_interface_skeleton_flags_get_type"]
    pub fn g_dbus_interface_skeleton_flags_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_dbus_object_manager_client_flags_get_type"]
    pub fn g_dbus_object_manager_client_flags_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_tls_database_verify_flags_get_type"]
    pub fn g_tls_database_verify_flags_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_tls_database_lookup_flags_get_type"]
    pub fn g_tls_database_lookup_flags_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_tls_certificate_request_flags_get_type"]
    pub fn g_tls_certificate_request_flags_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_io_module_scope_flags_get_type"]
    pub fn g_io_module_scope_flags_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_socket_client_event_get_type"]
    pub fn g_socket_client_event_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_socket_listener_event_get_type"]
    pub fn g_socket_listener_event_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_test_dbus_flags_get_type"]
    pub fn g_test_dbus_flags_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_subprocess_flags_get_type"]
    pub fn g_subprocess_flags_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_notification_priority_get_type"]
    pub fn g_notification_priority_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_network_connectivity_get_type"]
    pub fn g_network_connectivity_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_settings_bind_flags_get_type"]
    pub fn g_settings_bind_flags_get_type() -> GType;
}
pub const GModuleFlags_G_MODULE_BIND_LAZY: GModuleFlags = 1;
pub const GModuleFlags_G_MODULE_BIND_LOCAL: GModuleFlags = 2;
pub const GModuleFlags_G_MODULE_BIND_MASK: GModuleFlags = 3;
/// GModuleFlags:
/// @G_MODULE_BIND_LAZY: specifies that symbols are only resolved when
/// needed. The default action is to bind all symbols when the module
/// is loaded.
/// @G_MODULE_BIND_LOCAL: specifies that symbols in the module should
/// not be added to the global name space. The default action on most
/// platforms is to place symbols in the module in the global name space,
/// which may cause conflicts with existing symbols.
/// @G_MODULE_BIND_MASK: mask for all flags.
///
/// Flags passed to g_module_open().
/// Note that these flags are not supported on all platforms.
pub type GModuleFlags = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GModule {
    _unused: [u8; 0],
}
pub type GModule = _GModule;
pub type GModuleCheckInit =
    ::std::option::Option<unsafe extern "C" fn(module: *mut GModule) -> *const gchar>;
pub type GModuleUnload = ::std::option::Option<unsafe extern "C" fn(module: *mut GModule)>;
extern "C" {
    #[link_name = "\u{1}_g_module_supported"]
    pub fn g_module_supported() -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_module_open"]
    pub fn g_module_open(file_name: *const gchar, flags: GModuleFlags) -> *mut GModule;
}
extern "C" {
    #[link_name = "\u{1}_g_module_close"]
    pub fn g_module_close(module: *mut GModule) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_module_make_resident"]
    pub fn g_module_make_resident(module: *mut GModule);
}
extern "C" {
    #[link_name = "\u{1}_g_module_error"]
    pub fn g_module_error() -> *const gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_module_symbol"]
    pub fn g_module_symbol(
        module: *mut GModule,
        symbol_name: *const gchar,
        symbol: *mut gpointer,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_module_name"]
    pub fn g_module_name(module: *mut GModule) -> *const gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_module_build_path"]
    pub fn g_module_build_path(directory: *const gchar, module_name: *const gchar) -> *mut gchar;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GIOModuleScope {
    _unused: [u8; 0],
}
pub type GIOModuleScope = _GIOModuleScope;
extern "C" {
    #[link_name = "\u{1}_g_io_module_scope_new"]
    pub fn g_io_module_scope_new(flags: GIOModuleScopeFlags) -> *mut GIOModuleScope;
}
extern "C" {
    #[link_name = "\u{1}_g_io_module_scope_free"]
    pub fn g_io_module_scope_free(scope: *mut GIOModuleScope);
}
extern "C" {
    #[link_name = "\u{1}_g_io_module_scope_block"]
    pub fn g_io_module_scope_block(scope: *mut GIOModuleScope, basename: *const gchar);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GIOModuleClass {
    _unused: [u8; 0],
}
/// GIOModule:
///
/// Opaque module base class for extending GIO.
pub type GIOModuleClass = _GIOModuleClass;
extern "C" {
    #[link_name = "\u{1}_g_io_module_get_type"]
    pub fn g_io_module_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_io_module_new"]
    pub fn g_io_module_new(filename: *const gchar) -> *mut GIOModule;
}
extern "C" {
    #[link_name = "\u{1}_g_io_modules_scan_all_in_directory"]
    pub fn g_io_modules_scan_all_in_directory(dirname: *const ::std::os::raw::c_char);
}
extern "C" {
    #[link_name = "\u{1}_g_io_modules_load_all_in_directory"]
    pub fn g_io_modules_load_all_in_directory(dirname: *const gchar) -> *mut GList;
}
extern "C" {
    #[link_name = "\u{1}_g_io_modules_scan_all_in_directory_with_scope"]
    pub fn g_io_modules_scan_all_in_directory_with_scope(
        dirname: *const gchar,
        scope: *mut GIOModuleScope,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_io_modules_load_all_in_directory_with_scope"]
    pub fn g_io_modules_load_all_in_directory_with_scope(
        dirname: *const gchar,
        scope: *mut GIOModuleScope,
    ) -> *mut GList;
}
extern "C" {
    #[link_name = "\u{1}_g_io_extension_point_register"]
    pub fn g_io_extension_point_register(
        name: *const ::std::os::raw::c_char,
    ) -> *mut GIOExtensionPoint;
}
extern "C" {
    #[link_name = "\u{1}_g_io_extension_point_lookup"]
    pub fn g_io_extension_point_lookup(
        name: *const ::std::os::raw::c_char,
    ) -> *mut GIOExtensionPoint;
}
extern "C" {
    #[link_name = "\u{1}_g_io_extension_point_set_required_type"]
    pub fn g_io_extension_point_set_required_type(
        extension_point: *mut GIOExtensionPoint,
        type_: GType,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_io_extension_point_get_required_type"]
    pub fn g_io_extension_point_get_required_type(extension_point: *mut GIOExtensionPoint)
        -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_io_extension_point_get_extensions"]
    pub fn g_io_extension_point_get_extensions(
        extension_point: *mut GIOExtensionPoint,
    ) -> *mut GList;
}
extern "C" {
    #[link_name = "\u{1}_g_io_extension_point_get_extension_by_name"]
    pub fn g_io_extension_point_get_extension_by_name(
        extension_point: *mut GIOExtensionPoint,
        name: *const ::std::os::raw::c_char,
    ) -> *mut GIOExtension;
}
extern "C" {
    #[link_name = "\u{1}_g_io_extension_point_implement"]
    pub fn g_io_extension_point_implement(
        extension_point_name: *const ::std::os::raw::c_char,
        type_: GType,
        extension_name: *const ::std::os::raw::c_char,
        priority: gint,
    ) -> *mut GIOExtension;
}
extern "C" {
    #[link_name = "\u{1}_g_io_extension_get_type"]
    pub fn g_io_extension_get_type(extension: *mut GIOExtension) -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_io_extension_get_name"]
    pub fn g_io_extension_get_name(extension: *mut GIOExtension) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_g_io_extension_get_priority"]
    pub fn g_io_extension_get_priority(extension: *mut GIOExtension) -> gint;
}
extern "C" {
    #[link_name = "\u{1}_g_io_extension_ref_class"]
    pub fn g_io_extension_ref_class(extension: *mut GIOExtension) -> *mut GTypeClass;
}
extern "C" {
    /// g_io_module_load:
    /// @module: a #GIOModule.
    ///
    /// Required API for GIO modules to implement.
    ///
    /// This function is run after the module has been loaded into GIO,
    /// to initialize the module. Typically, this function will call
    /// g_io_extension_point_implement().
    #[link_name = "\u{1}_g_io_module_load"]
    pub fn g_io_module_load(module: *mut GIOModule);
}
extern "C" {
    /// g_io_module_unload:
    /// @module: a #GIOModule.
    ///
    /// Required API for GIO modules to implement.
    ///
    /// This function is run when the module is being unloaded from GIO,
    /// to finalize the module.
    #[link_name = "\u{1}_g_io_module_unload"]
    pub fn g_io_module_unload(module: *mut GIOModule);
}
extern "C" {
    /// g_io_module_query:
    ///
    /// Optional API for GIO modules to implement.
    ///
    /// Should return a list of all the extension points that may be
    /// implemented in this module.
    ///
    /// This method will not be called in normal use, however it may be
    /// called when probing existing modules and recording which extension
    /// points that this model is used for. This means we won't have to
    /// load and initialize this module unless its needed.
    ///
    /// If this function is not implemented by the module the module will
    /// always be loaded, initialized and then unloaded on application
    /// startup so that it can register its extension points during init.
    ///
    /// Note that a module need not actually implement all the extension
    /// points that g_io_module_query() returns, since the exact list of
    /// extension may depend on runtime issues. However all extension
    /// points actually implemented must be returned by g_io_module_query()
    /// (if defined).
    ///
    /// When installing a module that implements g_io_module_query() you must
    /// run gio-querymodules in order to build the cache files required for
    /// lazy loading.
    ///
    /// Returns: (transfer full): A %NULL-terminated array of strings,
    /// listing the supported extension points of the module. The array
    /// must be suitable for freeing with g_strfreev().
    ///
    /// Since: 2.24
    #[link_name = "\u{1}_g_io_module_query"]
    pub fn g_io_module_query() -> *mut *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_g_io_scheduler_push_job"]
    pub fn g_io_scheduler_push_job(
        job_func: GIOSchedulerJobFunc,
        user_data: gpointer,
        notify: GDestroyNotify,
        io_priority: gint,
        cancellable: *mut GCancellable,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_io_scheduler_cancel_all_jobs"]
    pub fn g_io_scheduler_cancel_all_jobs();
}
extern "C" {
    #[link_name = "\u{1}_g_io_scheduler_job_send_to_mainloop"]
    pub fn g_io_scheduler_job_send_to_mainloop(
        job: *mut GIOSchedulerJob,
        func: GSourceFunc,
        user_data: gpointer,
        notify: GDestroyNotify,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_io_scheduler_job_send_to_mainloop_async"]
    pub fn g_io_scheduler_job_send_to_mainloop_async(
        job: *mut GIOSchedulerJob,
        func: GSourceFunc,
        user_data: gpointer,
        notify: GDestroyNotify,
    );
}
/// GLoadableIcon:
///
/// Generic type for all kinds of icons that can be loaded
/// as a stream.
pub type GLoadableIconIface = _GLoadableIconIface;
/// GLoadableIconIface:
/// @g_iface: The parent interface.
/// @load: Loads an icon.
/// @load_async: Loads an icon asynchronously.
/// @load_finish: Finishes an asynchronous icon load.
///
/// Interface for icons that can be loaded as a stream.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GLoadableIconIface {
    pub g_iface: GTypeInterface,
    pub load: ::std::option::Option<
        unsafe extern "C" fn(
            icon: *mut GLoadableIcon,
            size: ::std::os::raw::c_int,
            type_: *mut *mut ::std::os::raw::c_char,
            cancellable: *mut GCancellable,
            error: *mut *mut GError,
        ) -> *mut GInputStream,
    >,
    pub load_async: ::std::option::Option<
        unsafe extern "C" fn(
            icon: *mut GLoadableIcon,
            size: ::std::os::raw::c_int,
            cancellable: *mut GCancellable,
            callback: GAsyncReadyCallback,
            user_data: gpointer,
        ),
    >,
    pub load_finish: ::std::option::Option<
        unsafe extern "C" fn(
            icon: *mut GLoadableIcon,
            res: *mut GAsyncResult,
            type_: *mut *mut ::std::os::raw::c_char,
            error: *mut *mut GError,
        ) -> *mut GInputStream,
    >,
}
#[test]
fn bindgen_test_layout__GLoadableIconIface() {
    assert_eq!(
        ::std::mem::size_of::<_GLoadableIconIface>(),
        40usize,
        concat!("Size of: ", stringify!(_GLoadableIconIface))
    );
    assert_eq!(
        ::std::mem::align_of::<_GLoadableIconIface>(),
        8usize,
        concat!("Alignment of ", stringify!(_GLoadableIconIface))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GLoadableIconIface>())).g_iface as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GLoadableIconIface),
            "::",
            stringify!(g_iface)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GLoadableIconIface>())).load as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GLoadableIconIface),
            "::",
            stringify!(load)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GLoadableIconIface>())).load_async as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GLoadableIconIface),
            "::",
            stringify!(load_async)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GLoadableIconIface>())).load_finish as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_GLoadableIconIface),
            "::",
            stringify!(load_finish)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_g_loadable_icon_get_type"]
    pub fn g_loadable_icon_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_loadable_icon_load"]
    pub fn g_loadable_icon_load(
        icon: *mut GLoadableIcon,
        size: ::std::os::raw::c_int,
        type_: *mut *mut ::std::os::raw::c_char,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> *mut GInputStream;
}
extern "C" {
    #[link_name = "\u{1}_g_loadable_icon_load_async"]
    pub fn g_loadable_icon_load_async(
        icon: *mut GLoadableIcon,
        size: ::std::os::raw::c_int,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_loadable_icon_load_finish"]
    pub fn g_loadable_icon_load_finish(
        icon: *mut GLoadableIcon,
        res: *mut GAsyncResult,
        type_: *mut *mut ::std::os::raw::c_char,
        error: *mut *mut GError,
    ) -> *mut GInputStream;
}
/// GMemoryInputStream:
///
/// Implements #GInputStream for arbitrary memory chunks.
pub type GMemoryInputStreamClass = _GMemoryInputStreamClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GMemoryInputStreamPrivate {
    _unused: [u8; 0],
}
pub type GMemoryInputStreamPrivate = _GMemoryInputStreamPrivate;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GMemoryInputStream {
    pub parent_instance: GInputStream,
    pub priv_: *mut GMemoryInputStreamPrivate,
}
#[test]
fn bindgen_test_layout__GMemoryInputStream() {
    assert_eq!(
        ::std::mem::size_of::<_GMemoryInputStream>(),
        40usize,
        concat!("Size of: ", stringify!(_GMemoryInputStream))
    );
    assert_eq!(
        ::std::mem::align_of::<_GMemoryInputStream>(),
        8usize,
        concat!("Alignment of ", stringify!(_GMemoryInputStream))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GMemoryInputStream>())).parent_instance as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMemoryInputStream),
            "::",
            stringify!(parent_instance)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GMemoryInputStream>())).priv_ as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMemoryInputStream),
            "::",
            stringify!(priv_)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GMemoryInputStreamClass {
    pub parent_class: GInputStreamClass,
    pub _g_reserved1: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved2: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved3: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved4: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved5: ::std::option::Option<unsafe extern "C" fn()>,
}
#[test]
fn bindgen_test_layout__GMemoryInputStreamClass() {
    assert_eq!(
        ::std::mem::size_of::<_GMemoryInputStreamClass>(),
        288usize,
        concat!("Size of: ", stringify!(_GMemoryInputStreamClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_GMemoryInputStreamClass>(),
        8usize,
        concat!("Alignment of ", stringify!(_GMemoryInputStreamClass))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GMemoryInputStreamClass>())).parent_class as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMemoryInputStreamClass),
            "::",
            stringify!(parent_class)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GMemoryInputStreamClass>()))._g_reserved1 as *const _ as usize
        },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMemoryInputStreamClass),
            "::",
            stringify!(_g_reserved1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GMemoryInputStreamClass>()))._g_reserved2 as *const _ as usize
        },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMemoryInputStreamClass),
            "::",
            stringify!(_g_reserved2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GMemoryInputStreamClass>()))._g_reserved3 as *const _ as usize
        },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMemoryInputStreamClass),
            "::",
            stringify!(_g_reserved3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GMemoryInputStreamClass>()))._g_reserved4 as *const _ as usize
        },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMemoryInputStreamClass),
            "::",
            stringify!(_g_reserved4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GMemoryInputStreamClass>()))._g_reserved5 as *const _ as usize
        },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMemoryInputStreamClass),
            "::",
            stringify!(_g_reserved5)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_g_memory_input_stream_get_type"]
    pub fn g_memory_input_stream_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_memory_input_stream_new"]
    pub fn g_memory_input_stream_new() -> *mut GInputStream;
}
extern "C" {
    #[link_name = "\u{1}_g_memory_input_stream_new_from_data"]
    pub fn g_memory_input_stream_new_from_data(
        data: *const ::std::os::raw::c_void,
        len: gssize,
        destroy: GDestroyNotify,
    ) -> *mut GInputStream;
}
extern "C" {
    #[link_name = "\u{1}_g_memory_input_stream_new_from_bytes"]
    pub fn g_memory_input_stream_new_from_bytes(bytes: *mut GBytes) -> *mut GInputStream;
}
extern "C" {
    #[link_name = "\u{1}_g_memory_input_stream_add_data"]
    pub fn g_memory_input_stream_add_data(
        stream: *mut GMemoryInputStream,
        data: *const ::std::os::raw::c_void,
        len: gssize,
        destroy: GDestroyNotify,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_memory_input_stream_add_bytes"]
    pub fn g_memory_input_stream_add_bytes(stream: *mut GMemoryInputStream, bytes: *mut GBytes);
}
/// GMemoryOutputStream:
///
/// Implements #GOutputStream for arbitrary memory chunks.
pub type GMemoryOutputStreamClass = _GMemoryOutputStreamClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GMemoryOutputStreamPrivate {
    _unused: [u8; 0],
}
pub type GMemoryOutputStreamPrivate = _GMemoryOutputStreamPrivate;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GMemoryOutputStream {
    pub parent_instance: GOutputStream,
    pub priv_: *mut GMemoryOutputStreamPrivate,
}
#[test]
fn bindgen_test_layout__GMemoryOutputStream() {
    assert_eq!(
        ::std::mem::size_of::<_GMemoryOutputStream>(),
        40usize,
        concat!("Size of: ", stringify!(_GMemoryOutputStream))
    );
    assert_eq!(
        ::std::mem::align_of::<_GMemoryOutputStream>(),
        8usize,
        concat!("Alignment of ", stringify!(_GMemoryOutputStream))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GMemoryOutputStream>())).parent_instance as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMemoryOutputStream),
            "::",
            stringify!(parent_instance)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GMemoryOutputStream>())).priv_ as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMemoryOutputStream),
            "::",
            stringify!(priv_)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GMemoryOutputStreamClass {
    pub parent_class: GOutputStreamClass,
    pub _g_reserved1: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved2: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved3: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved4: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved5: ::std::option::Option<unsafe extern "C" fn()>,
}
#[test]
fn bindgen_test_layout__GMemoryOutputStreamClass() {
    assert_eq!(
        ::std::mem::size_of::<_GMemoryOutputStreamClass>(),
        336usize,
        concat!("Size of: ", stringify!(_GMemoryOutputStreamClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_GMemoryOutputStreamClass>(),
        8usize,
        concat!("Alignment of ", stringify!(_GMemoryOutputStreamClass))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GMemoryOutputStreamClass>())).parent_class as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMemoryOutputStreamClass),
            "::",
            stringify!(parent_class)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GMemoryOutputStreamClass>()))._g_reserved1 as *const _ as usize
        },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMemoryOutputStreamClass),
            "::",
            stringify!(_g_reserved1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GMemoryOutputStreamClass>()))._g_reserved2 as *const _ as usize
        },
        304usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMemoryOutputStreamClass),
            "::",
            stringify!(_g_reserved2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GMemoryOutputStreamClass>()))._g_reserved3 as *const _ as usize
        },
        312usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMemoryOutputStreamClass),
            "::",
            stringify!(_g_reserved3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GMemoryOutputStreamClass>()))._g_reserved4 as *const _ as usize
        },
        320usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMemoryOutputStreamClass),
            "::",
            stringify!(_g_reserved4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GMemoryOutputStreamClass>()))._g_reserved5 as *const _ as usize
        },
        328usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMemoryOutputStreamClass),
            "::",
            stringify!(_g_reserved5)
        )
    );
}
/// GReallocFunc:
/// @data: memory block to reallocate
/// @size: size to reallocate @data to
///
/// Changes the size of the memory block pointed to by @data to
/// @size bytes.
///
/// The function should have the same semantics as realloc().
///
/// Returns: a pointer to the reallocated memory
pub type GReallocFunc =
    ::std::option::Option<unsafe extern "C" fn(data: gpointer, size: gsize) -> gpointer>;
extern "C" {
    #[link_name = "\u{1}_g_memory_output_stream_get_type"]
    pub fn g_memory_output_stream_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_memory_output_stream_new"]
    pub fn g_memory_output_stream_new(
        data: gpointer,
        size: gsize,
        realloc_function: GReallocFunc,
        destroy_function: GDestroyNotify,
    ) -> *mut GOutputStream;
}
extern "C" {
    #[link_name = "\u{1}_g_memory_output_stream_new_resizable"]
    pub fn g_memory_output_stream_new_resizable() -> *mut GOutputStream;
}
extern "C" {
    #[link_name = "\u{1}_g_memory_output_stream_get_data"]
    pub fn g_memory_output_stream_get_data(ostream: *mut GMemoryOutputStream) -> gpointer;
}
extern "C" {
    #[link_name = "\u{1}_g_memory_output_stream_get_size"]
    pub fn g_memory_output_stream_get_size(ostream: *mut GMemoryOutputStream) -> gsize;
}
extern "C" {
    #[link_name = "\u{1}_g_memory_output_stream_get_data_size"]
    pub fn g_memory_output_stream_get_data_size(ostream: *mut GMemoryOutputStream) -> gsize;
}
extern "C" {
    #[link_name = "\u{1}_g_memory_output_stream_steal_data"]
    pub fn g_memory_output_stream_steal_data(ostream: *mut GMemoryOutputStream) -> gpointer;
}
extern "C" {
    #[link_name = "\u{1}_g_memory_output_stream_steal_as_bytes"]
    pub fn g_memory_output_stream_steal_as_bytes(ostream: *mut GMemoryOutputStream) -> *mut GBytes;
}
pub type GMountIface = _GMountIface;
/// GMountIface:
/// @g_iface: The parent interface.
/// @changed: Changed signal that is emitted when the mount's state has changed.
/// @unmounted: The unmounted signal that is emitted when the #GMount have been unmounted. If the recipient is holding references to the object they should release them so the object can be finalized.
/// @pre_unmount: The ::pre-unmount signal that is emitted when the #GMount will soon be emitted. If the recipient is somehow holding the mount open by keeping an open file on it it should close the file.
/// @get_root: Gets a #GFile to the root directory of the #GMount.
/// @get_name: Gets a string containing the name of the #GMount.
/// @get_icon: Gets a #GIcon for the #GMount.
/// @get_uuid: Gets the UUID for the #GMount. The reference is typically based on the file system UUID for the mount in question and should be considered an opaque string. Returns %NULL if there is no UUID available.
/// @get_volume: Gets a #GVolume the mount is located on. Returns %NULL if the #GMount is not associated with a #GVolume.
/// @get_drive: Gets a #GDrive the volume of the mount is located on. Returns %NULL if the #GMount is not associated with a #GDrive or a #GVolume. This is convenience method for getting the #GVolume and using that to get the #GDrive.
/// @can_unmount: Checks if a #GMount can be unmounted.
/// @can_eject: Checks if a #GMount can be ejected.
/// @unmount: Starts unmounting a #GMount.
/// @unmount_finish: Finishes an unmounting operation.
/// @eject: Starts ejecting a #GMount.
/// @eject_finish: Finishes an eject operation.
/// @remount: Starts remounting a #GMount.
/// @remount_finish: Finishes a remounting operation.
/// @guess_content_type: Starts guessing the type of the content of a #GMount.
/// See g_mount_guess_content_type() for more information on content
/// type guessing. This operation was added in 2.18.
/// @guess_content_type_finish: Finishes a content type guessing operation. Added in 2.18.
/// @guess_content_type_sync: Synchronous variant of @guess_content_type. Added in 2.18
/// @unmount_with_operation: Starts unmounting a #GMount using a #GMountOperation. Since 2.22.
/// @unmount_with_operation_finish: Finishes an unmounting operation using a #GMountOperation. Since 2.22.
/// @eject_with_operation: Starts ejecting a #GMount using a #GMountOperation. Since 2.22.
/// @eject_with_operation_finish: Finishes an eject operation using a #GMountOperation. Since 2.22.
/// @get_default_location: Gets a #GFile indication a start location that can be use as the entry point for this mount. Since 2.24.
/// @get_sort_key: Gets a key used for sorting #GMount instance or %NULL if no such key exists. Since 2.32.
/// @get_symbolic_icon: Gets a symbolic #GIcon for the #GMount. Since 2.34.
///
/// Interface for implementing operations for mounts.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GMountIface {
    pub g_iface: GTypeInterface,
    pub changed: ::std::option::Option<unsafe extern "C" fn(mount: *mut GMount)>,
    pub unmounted: ::std::option::Option<unsafe extern "C" fn(mount: *mut GMount)>,
    pub get_root: ::std::option::Option<unsafe extern "C" fn(mount: *mut GMount) -> *mut GFile>,
    pub get_name: ::std::option::Option<
        unsafe extern "C" fn(mount: *mut GMount) -> *mut ::std::os::raw::c_char,
    >,
    pub get_icon: ::std::option::Option<unsafe extern "C" fn(mount: *mut GMount) -> *mut GIcon>,
    pub get_uuid: ::std::option::Option<
        unsafe extern "C" fn(mount: *mut GMount) -> *mut ::std::os::raw::c_char,
    >,
    pub get_volume: ::std::option::Option<unsafe extern "C" fn(mount: *mut GMount) -> *mut GVolume>,
    pub get_drive: ::std::option::Option<unsafe extern "C" fn(mount: *mut GMount) -> *mut GDrive>,
    pub can_unmount: ::std::option::Option<unsafe extern "C" fn(mount: *mut GMount) -> gboolean>,
    pub can_eject: ::std::option::Option<unsafe extern "C" fn(mount: *mut GMount) -> gboolean>,
    pub unmount: ::std::option::Option<
        unsafe extern "C" fn(
            mount: *mut GMount,
            flags: GMountUnmountFlags,
            cancellable: *mut GCancellable,
            callback: GAsyncReadyCallback,
            user_data: gpointer,
        ),
    >,
    pub unmount_finish: ::std::option::Option<
        unsafe extern "C" fn(
            mount: *mut GMount,
            result: *mut GAsyncResult,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
    pub eject: ::std::option::Option<
        unsafe extern "C" fn(
            mount: *mut GMount,
            flags: GMountUnmountFlags,
            cancellable: *mut GCancellable,
            callback: GAsyncReadyCallback,
            user_data: gpointer,
        ),
    >,
    pub eject_finish: ::std::option::Option<
        unsafe extern "C" fn(
            mount: *mut GMount,
            result: *mut GAsyncResult,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
    pub remount: ::std::option::Option<
        unsafe extern "C" fn(
            mount: *mut GMount,
            flags: GMountMountFlags,
            mount_operation: *mut GMountOperation,
            cancellable: *mut GCancellable,
            callback: GAsyncReadyCallback,
            user_data: gpointer,
        ),
    >,
    pub remount_finish: ::std::option::Option<
        unsafe extern "C" fn(
            mount: *mut GMount,
            result: *mut GAsyncResult,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
    pub guess_content_type: ::std::option::Option<
        unsafe extern "C" fn(
            mount: *mut GMount,
            force_rescan: gboolean,
            cancellable: *mut GCancellable,
            callback: GAsyncReadyCallback,
            user_data: gpointer,
        ),
    >,
    pub guess_content_type_finish: ::std::option::Option<
        unsafe extern "C" fn(
            mount: *mut GMount,
            result: *mut GAsyncResult,
            error: *mut *mut GError,
        ) -> *mut *mut gchar,
    >,
    pub guess_content_type_sync: ::std::option::Option<
        unsafe extern "C" fn(
            mount: *mut GMount,
            force_rescan: gboolean,
            cancellable: *mut GCancellable,
            error: *mut *mut GError,
        ) -> *mut *mut gchar,
    >,
    pub pre_unmount: ::std::option::Option<unsafe extern "C" fn(mount: *mut GMount)>,
    pub unmount_with_operation: ::std::option::Option<
        unsafe extern "C" fn(
            mount: *mut GMount,
            flags: GMountUnmountFlags,
            mount_operation: *mut GMountOperation,
            cancellable: *mut GCancellable,
            callback: GAsyncReadyCallback,
            user_data: gpointer,
        ),
    >,
    pub unmount_with_operation_finish: ::std::option::Option<
        unsafe extern "C" fn(
            mount: *mut GMount,
            result: *mut GAsyncResult,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
    pub eject_with_operation: ::std::option::Option<
        unsafe extern "C" fn(
            mount: *mut GMount,
            flags: GMountUnmountFlags,
            mount_operation: *mut GMountOperation,
            cancellable: *mut GCancellable,
            callback: GAsyncReadyCallback,
            user_data: gpointer,
        ),
    >,
    pub eject_with_operation_finish: ::std::option::Option<
        unsafe extern "C" fn(
            mount: *mut GMount,
            result: *mut GAsyncResult,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
    pub get_default_location:
        ::std::option::Option<unsafe extern "C" fn(mount: *mut GMount) -> *mut GFile>,
    pub get_sort_key:
        ::std::option::Option<unsafe extern "C" fn(mount: *mut GMount) -> *const gchar>,
    pub get_symbolic_icon:
        ::std::option::Option<unsafe extern "C" fn(mount: *mut GMount) -> *mut GIcon>,
}
#[test]
fn bindgen_test_layout__GMountIface() {
    assert_eq!(
        ::std::mem::size_of::<_GMountIface>(),
        232usize,
        concat!("Size of: ", stringify!(_GMountIface))
    );
    assert_eq!(
        ::std::mem::align_of::<_GMountIface>(),
        8usize,
        concat!("Alignment of ", stringify!(_GMountIface))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GMountIface>())).g_iface as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMountIface),
            "::",
            stringify!(g_iface)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GMountIface>())).changed as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMountIface),
            "::",
            stringify!(changed)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GMountIface>())).unmounted as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMountIface),
            "::",
            stringify!(unmounted)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GMountIface>())).get_root as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMountIface),
            "::",
            stringify!(get_root)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GMountIface>())).get_name as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMountIface),
            "::",
            stringify!(get_name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GMountIface>())).get_icon as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMountIface),
            "::",
            stringify!(get_icon)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GMountIface>())).get_uuid as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMountIface),
            "::",
            stringify!(get_uuid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GMountIface>())).get_volume as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMountIface),
            "::",
            stringify!(get_volume)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GMountIface>())).get_drive as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMountIface),
            "::",
            stringify!(get_drive)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GMountIface>())).can_unmount as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMountIface),
            "::",
            stringify!(can_unmount)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GMountIface>())).can_eject as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMountIface),
            "::",
            stringify!(can_eject)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GMountIface>())).unmount as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMountIface),
            "::",
            stringify!(unmount)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GMountIface>())).unmount_finish as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMountIface),
            "::",
            stringify!(unmount_finish)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GMountIface>())).eject as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMountIface),
            "::",
            stringify!(eject)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GMountIface>())).eject_finish as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMountIface),
            "::",
            stringify!(eject_finish)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GMountIface>())).remount as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMountIface),
            "::",
            stringify!(remount)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GMountIface>())).remount_finish as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMountIface),
            "::",
            stringify!(remount_finish)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GMountIface>())).guess_content_type as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMountIface),
            "::",
            stringify!(guess_content_type)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GMountIface>())).guess_content_type_finish as *const _ as usize
        },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMountIface),
            "::",
            stringify!(guess_content_type_finish)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GMountIface>())).guess_content_type_sync as *const _ as usize
        },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMountIface),
            "::",
            stringify!(guess_content_type_sync)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GMountIface>())).pre_unmount as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMountIface),
            "::",
            stringify!(pre_unmount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GMountIface>())).unmount_with_operation as *const _ as usize
        },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMountIface),
            "::",
            stringify!(unmount_with_operation)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GMountIface>())).unmount_with_operation_finish as *const _
                as usize
        },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMountIface),
            "::",
            stringify!(unmount_with_operation_finish)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GMountIface>())).eject_with_operation as *const _ as usize
        },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMountIface),
            "::",
            stringify!(eject_with_operation)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GMountIface>())).eject_with_operation_finish as *const _
                as usize
        },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMountIface),
            "::",
            stringify!(eject_with_operation_finish)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GMountIface>())).get_default_location as *const _ as usize
        },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMountIface),
            "::",
            stringify!(get_default_location)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GMountIface>())).get_sort_key as *const _ as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMountIface),
            "::",
            stringify!(get_sort_key)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GMountIface>())).get_symbolic_icon as *const _ as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMountIface),
            "::",
            stringify!(get_symbolic_icon)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_g_mount_get_type"]
    pub fn g_mount_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_mount_get_root"]
    pub fn g_mount_get_root(mount: *mut GMount) -> *mut GFile;
}
extern "C" {
    #[link_name = "\u{1}_g_mount_get_default_location"]
    pub fn g_mount_get_default_location(mount: *mut GMount) -> *mut GFile;
}
extern "C" {
    #[link_name = "\u{1}_g_mount_get_name"]
    pub fn g_mount_get_name(mount: *mut GMount) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_g_mount_get_icon"]
    pub fn g_mount_get_icon(mount: *mut GMount) -> *mut GIcon;
}
extern "C" {
    #[link_name = "\u{1}_g_mount_get_symbolic_icon"]
    pub fn g_mount_get_symbolic_icon(mount: *mut GMount) -> *mut GIcon;
}
extern "C" {
    #[link_name = "\u{1}_g_mount_get_uuid"]
    pub fn g_mount_get_uuid(mount: *mut GMount) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_g_mount_get_volume"]
    pub fn g_mount_get_volume(mount: *mut GMount) -> *mut GVolume;
}
extern "C" {
    #[link_name = "\u{1}_g_mount_get_drive"]
    pub fn g_mount_get_drive(mount: *mut GMount) -> *mut GDrive;
}
extern "C" {
    #[link_name = "\u{1}_g_mount_can_unmount"]
    pub fn g_mount_can_unmount(mount: *mut GMount) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_mount_can_eject"]
    pub fn g_mount_can_eject(mount: *mut GMount) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_mount_unmount"]
    pub fn g_mount_unmount(
        mount: *mut GMount,
        flags: GMountUnmountFlags,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_mount_unmount_finish"]
    pub fn g_mount_unmount_finish(
        mount: *mut GMount,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_mount_eject"]
    pub fn g_mount_eject(
        mount: *mut GMount,
        flags: GMountUnmountFlags,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_mount_eject_finish"]
    pub fn g_mount_eject_finish(
        mount: *mut GMount,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_mount_remount"]
    pub fn g_mount_remount(
        mount: *mut GMount,
        flags: GMountMountFlags,
        mount_operation: *mut GMountOperation,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_mount_remount_finish"]
    pub fn g_mount_remount_finish(
        mount: *mut GMount,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_mount_guess_content_type"]
    pub fn g_mount_guess_content_type(
        mount: *mut GMount,
        force_rescan: gboolean,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_mount_guess_content_type_finish"]
    pub fn g_mount_guess_content_type_finish(
        mount: *mut GMount,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> *mut *mut gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_mount_guess_content_type_sync"]
    pub fn g_mount_guess_content_type_sync(
        mount: *mut GMount,
        force_rescan: gboolean,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> *mut *mut gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_mount_is_shadowed"]
    pub fn g_mount_is_shadowed(mount: *mut GMount) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_mount_shadow"]
    pub fn g_mount_shadow(mount: *mut GMount);
}
extern "C" {
    #[link_name = "\u{1}_g_mount_unshadow"]
    pub fn g_mount_unshadow(mount: *mut GMount);
}
extern "C" {
    #[link_name = "\u{1}_g_mount_unmount_with_operation"]
    pub fn g_mount_unmount_with_operation(
        mount: *mut GMount,
        flags: GMountUnmountFlags,
        mount_operation: *mut GMountOperation,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_mount_unmount_with_operation_finish"]
    pub fn g_mount_unmount_with_operation_finish(
        mount: *mut GMount,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_mount_eject_with_operation"]
    pub fn g_mount_eject_with_operation(
        mount: *mut GMount,
        flags: GMountUnmountFlags,
        mount_operation: *mut GMountOperation,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_mount_eject_with_operation_finish"]
    pub fn g_mount_eject_with_operation_finish(
        mount: *mut GMount,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_mount_get_sort_key"]
    pub fn g_mount_get_sort_key(mount: *mut GMount) -> *const gchar;
}
/// GMountOperation:
///
/// Class for providing authentication methods for mounting operations,
/// such as mounting a file locally, or authenticating with a server.
pub type GMountOperationClass = _GMountOperationClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GMountOperationPrivate {
    _unused: [u8; 0],
}
pub type GMountOperationPrivate = _GMountOperationPrivate;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GMountOperation {
    pub parent_instance: GObject,
    pub priv_: *mut GMountOperationPrivate,
}
#[test]
fn bindgen_test_layout__GMountOperation() {
    assert_eq!(
        ::std::mem::size_of::<_GMountOperation>(),
        32usize,
        concat!("Size of: ", stringify!(_GMountOperation))
    );
    assert_eq!(
        ::std::mem::align_of::<_GMountOperation>(),
        8usize,
        concat!("Alignment of ", stringify!(_GMountOperation))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GMountOperation>())).parent_instance as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMountOperation),
            "::",
            stringify!(parent_instance)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GMountOperation>())).priv_ as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMountOperation),
            "::",
            stringify!(priv_)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GMountOperationClass {
    pub parent_class: GObjectClass,
    pub ask_password: ::std::option::Option<
        unsafe extern "C" fn(
            op: *mut GMountOperation,
            message: *const ::std::os::raw::c_char,
            default_user: *const ::std::os::raw::c_char,
            default_domain: *const ::std::os::raw::c_char,
            flags: GAskPasswordFlags,
        ),
    >,
    pub ask_question: ::std::option::Option<
        unsafe extern "C" fn(
            op: *mut GMountOperation,
            message: *const ::std::os::raw::c_char,
            choices: *mut *const ::std::os::raw::c_char,
        ),
    >,
    pub reply: ::std::option::Option<
        unsafe extern "C" fn(op: *mut GMountOperation, result: GMountOperationResult),
    >,
    pub aborted: ::std::option::Option<unsafe extern "C" fn(op: *mut GMountOperation)>,
    pub show_processes: ::std::option::Option<
        unsafe extern "C" fn(
            op: *mut GMountOperation,
            message: *const gchar,
            processes: *mut GArray,
            choices: *mut *const gchar,
        ),
    >,
    pub show_unmount_progress: ::std::option::Option<
        unsafe extern "C" fn(
            op: *mut GMountOperation,
            message: *const gchar,
            time_left: gint64,
            bytes_left: gint64,
        ),
    >,
    pub _g_reserved1: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved2: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved3: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved4: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved5: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved6: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved7: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved8: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved9: ::std::option::Option<unsafe extern "C" fn()>,
}
#[test]
fn bindgen_test_layout__GMountOperationClass() {
    assert_eq!(
        ::std::mem::size_of::<_GMountOperationClass>(),
        256usize,
        concat!("Size of: ", stringify!(_GMountOperationClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_GMountOperationClass>(),
        8usize,
        concat!("Alignment of ", stringify!(_GMountOperationClass))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GMountOperationClass>())).parent_class as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMountOperationClass),
            "::",
            stringify!(parent_class)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GMountOperationClass>())).ask_password as *const _ as usize
        },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMountOperationClass),
            "::",
            stringify!(ask_password)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GMountOperationClass>())).ask_question as *const _ as usize
        },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMountOperationClass),
            "::",
            stringify!(ask_question)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GMountOperationClass>())).reply as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMountOperationClass),
            "::",
            stringify!(reply)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GMountOperationClass>())).aborted as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMountOperationClass),
            "::",
            stringify!(aborted)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GMountOperationClass>())).show_processes as *const _ as usize
        },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMountOperationClass),
            "::",
            stringify!(show_processes)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GMountOperationClass>())).show_unmount_progress as *const _
                as usize
        },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMountOperationClass),
            "::",
            stringify!(show_unmount_progress)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GMountOperationClass>()))._g_reserved1 as *const _ as usize
        },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMountOperationClass),
            "::",
            stringify!(_g_reserved1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GMountOperationClass>()))._g_reserved2 as *const _ as usize
        },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMountOperationClass),
            "::",
            stringify!(_g_reserved2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GMountOperationClass>()))._g_reserved3 as *const _ as usize
        },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMountOperationClass),
            "::",
            stringify!(_g_reserved3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GMountOperationClass>()))._g_reserved4 as *const _ as usize
        },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMountOperationClass),
            "::",
            stringify!(_g_reserved4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GMountOperationClass>()))._g_reserved5 as *const _ as usize
        },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMountOperationClass),
            "::",
            stringify!(_g_reserved5)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GMountOperationClass>()))._g_reserved6 as *const _ as usize
        },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMountOperationClass),
            "::",
            stringify!(_g_reserved6)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GMountOperationClass>()))._g_reserved7 as *const _ as usize
        },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMountOperationClass),
            "::",
            stringify!(_g_reserved7)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GMountOperationClass>()))._g_reserved8 as *const _ as usize
        },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMountOperationClass),
            "::",
            stringify!(_g_reserved8)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GMountOperationClass>()))._g_reserved9 as *const _ as usize
        },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMountOperationClass),
            "::",
            stringify!(_g_reserved9)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_g_mount_operation_get_type"]
    pub fn g_mount_operation_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_mount_operation_new"]
    pub fn g_mount_operation_new() -> *mut GMountOperation;
}
extern "C" {
    #[link_name = "\u{1}_g_mount_operation_get_username"]
    pub fn g_mount_operation_get_username(
        op: *mut GMountOperation,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_g_mount_operation_set_username"]
    pub fn g_mount_operation_set_username(
        op: *mut GMountOperation,
        username: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_mount_operation_get_password"]
    pub fn g_mount_operation_get_password(
        op: *mut GMountOperation,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_g_mount_operation_set_password"]
    pub fn g_mount_operation_set_password(
        op: *mut GMountOperation,
        password: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_mount_operation_get_anonymous"]
    pub fn g_mount_operation_get_anonymous(op: *mut GMountOperation) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_mount_operation_set_anonymous"]
    pub fn g_mount_operation_set_anonymous(op: *mut GMountOperation, anonymous: gboolean);
}
extern "C" {
    #[link_name = "\u{1}_g_mount_operation_get_domain"]
    pub fn g_mount_operation_get_domain(op: *mut GMountOperation) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_g_mount_operation_set_domain"]
    pub fn g_mount_operation_set_domain(
        op: *mut GMountOperation,
        domain: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_mount_operation_get_password_save"]
    pub fn g_mount_operation_get_password_save(op: *mut GMountOperation) -> GPasswordSave;
}
extern "C" {
    #[link_name = "\u{1}_g_mount_operation_set_password_save"]
    pub fn g_mount_operation_set_password_save(op: *mut GMountOperation, save: GPasswordSave);
}
extern "C" {
    #[link_name = "\u{1}_g_mount_operation_get_choice"]
    pub fn g_mount_operation_get_choice(op: *mut GMountOperation) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_g_mount_operation_set_choice"]
    pub fn g_mount_operation_set_choice(op: *mut GMountOperation, choice: ::std::os::raw::c_int);
}
extern "C" {
    #[link_name = "\u{1}_g_mount_operation_reply"]
    pub fn g_mount_operation_reply(op: *mut GMountOperation, result: GMountOperationResult);
}
/// GVolumeMonitor:
///
/// A Volume Monitor that watches for volume events.
pub type GVolumeMonitorClass = _GVolumeMonitorClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GVolumeMonitor {
    pub parent_instance: GObject,
    pub priv_: gpointer,
}
#[test]
fn bindgen_test_layout__GVolumeMonitor() {
    assert_eq!(
        ::std::mem::size_of::<_GVolumeMonitor>(),
        32usize,
        concat!("Size of: ", stringify!(_GVolumeMonitor))
    );
    assert_eq!(
        ::std::mem::align_of::<_GVolumeMonitor>(),
        8usize,
        concat!("Alignment of ", stringify!(_GVolumeMonitor))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GVolumeMonitor>())).parent_instance as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GVolumeMonitor),
            "::",
            stringify!(parent_instance)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GVolumeMonitor>())).priv_ as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GVolumeMonitor),
            "::",
            stringify!(priv_)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GVolumeMonitorClass {
    pub parent_class: GObjectClass,
    pub volume_added: ::std::option::Option<
        unsafe extern "C" fn(volume_monitor: *mut GVolumeMonitor, volume: *mut GVolume),
    >,
    pub volume_removed: ::std::option::Option<
        unsafe extern "C" fn(volume_monitor: *mut GVolumeMonitor, volume: *mut GVolume),
    >,
    pub volume_changed: ::std::option::Option<
        unsafe extern "C" fn(volume_monitor: *mut GVolumeMonitor, volume: *mut GVolume),
    >,
    pub mount_added: ::std::option::Option<
        unsafe extern "C" fn(volume_monitor: *mut GVolumeMonitor, mount: *mut GMount),
    >,
    pub mount_removed: ::std::option::Option<
        unsafe extern "C" fn(volume_monitor: *mut GVolumeMonitor, mount: *mut GMount),
    >,
    pub mount_pre_unmount: ::std::option::Option<
        unsafe extern "C" fn(volume_monitor: *mut GVolumeMonitor, mount: *mut GMount),
    >,
    pub mount_changed: ::std::option::Option<
        unsafe extern "C" fn(volume_monitor: *mut GVolumeMonitor, mount: *mut GMount),
    >,
    pub drive_connected: ::std::option::Option<
        unsafe extern "C" fn(volume_monitor: *mut GVolumeMonitor, drive: *mut GDrive),
    >,
    pub drive_disconnected: ::std::option::Option<
        unsafe extern "C" fn(volume_monitor: *mut GVolumeMonitor, drive: *mut GDrive),
    >,
    pub drive_changed: ::std::option::Option<
        unsafe extern "C" fn(volume_monitor: *mut GVolumeMonitor, drive: *mut GDrive),
    >,
    pub is_supported: ::std::option::Option<unsafe extern "C" fn() -> gboolean>,
    pub get_connected_drives: ::std::option::Option<
        unsafe extern "C" fn(volume_monitor: *mut GVolumeMonitor) -> *mut GList,
    >,
    pub get_volumes: ::std::option::Option<
        unsafe extern "C" fn(volume_monitor: *mut GVolumeMonitor) -> *mut GList,
    >,
    pub get_mounts: ::std::option::Option<
        unsafe extern "C" fn(volume_monitor: *mut GVolumeMonitor) -> *mut GList,
    >,
    pub get_volume_for_uuid: ::std::option::Option<
        unsafe extern "C" fn(
            volume_monitor: *mut GVolumeMonitor,
            uuid: *const ::std::os::raw::c_char,
        ) -> *mut GVolume,
    >,
    pub get_mount_for_uuid: ::std::option::Option<
        unsafe extern "C" fn(
            volume_monitor: *mut GVolumeMonitor,
            uuid: *const ::std::os::raw::c_char,
        ) -> *mut GMount,
    >,
    pub adopt_orphan_mount: ::std::option::Option<
        unsafe extern "C" fn(mount: *mut GMount, volume_monitor: *mut GVolumeMonitor)
            -> *mut GVolume,
    >,
    pub drive_eject_button: ::std::option::Option<
        unsafe extern "C" fn(volume_monitor: *mut GVolumeMonitor, drive: *mut GDrive),
    >,
    pub drive_stop_button: ::std::option::Option<
        unsafe extern "C" fn(volume_monitor: *mut GVolumeMonitor, drive: *mut GDrive),
    >,
    pub _g_reserved1: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved2: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved3: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved4: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved5: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved6: ::std::option::Option<unsafe extern "C" fn()>,
}
#[test]
fn bindgen_test_layout__GVolumeMonitorClass() {
    assert_eq!(
        ::std::mem::size_of::<_GVolumeMonitorClass>(),
        336usize,
        concat!("Size of: ", stringify!(_GVolumeMonitorClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_GVolumeMonitorClass>(),
        8usize,
        concat!("Alignment of ", stringify!(_GVolumeMonitorClass))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GVolumeMonitorClass>())).parent_class as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GVolumeMonitorClass),
            "::",
            stringify!(parent_class)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GVolumeMonitorClass>())).volume_added as *const _ as usize
        },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_GVolumeMonitorClass),
            "::",
            stringify!(volume_added)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GVolumeMonitorClass>())).volume_removed as *const _ as usize
        },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_GVolumeMonitorClass),
            "::",
            stringify!(volume_removed)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GVolumeMonitorClass>())).volume_changed as *const _ as usize
        },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(_GVolumeMonitorClass),
            "::",
            stringify!(volume_changed)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GVolumeMonitorClass>())).mount_added as *const _ as usize
        },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_GVolumeMonitorClass),
            "::",
            stringify!(mount_added)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GVolumeMonitorClass>())).mount_removed as *const _ as usize
        },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(_GVolumeMonitorClass),
            "::",
            stringify!(mount_removed)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GVolumeMonitorClass>())).mount_pre_unmount as *const _ as usize
        },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(_GVolumeMonitorClass),
            "::",
            stringify!(mount_pre_unmount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GVolumeMonitorClass>())).mount_changed as *const _ as usize
        },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(_GVolumeMonitorClass),
            "::",
            stringify!(mount_changed)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GVolumeMonitorClass>())).drive_connected as *const _ as usize
        },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(_GVolumeMonitorClass),
            "::",
            stringify!(drive_connected)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GVolumeMonitorClass>())).drive_disconnected as *const _ as usize
        },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(_GVolumeMonitorClass),
            "::",
            stringify!(drive_disconnected)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GVolumeMonitorClass>())).drive_changed as *const _ as usize
        },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(_GVolumeMonitorClass),
            "::",
            stringify!(drive_changed)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GVolumeMonitorClass>())).is_supported as *const _ as usize
        },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(_GVolumeMonitorClass),
            "::",
            stringify!(is_supported)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GVolumeMonitorClass>())).get_connected_drives as *const _
                as usize
        },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(_GVolumeMonitorClass),
            "::",
            stringify!(get_connected_drives)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GVolumeMonitorClass>())).get_volumes as *const _ as usize
        },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(_GVolumeMonitorClass),
            "::",
            stringify!(get_volumes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GVolumeMonitorClass>())).get_mounts as *const _ as usize },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(_GVolumeMonitorClass),
            "::",
            stringify!(get_mounts)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GVolumeMonitorClass>())).get_volume_for_uuid as *const _
                as usize
        },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(_GVolumeMonitorClass),
            "::",
            stringify!(get_volume_for_uuid)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GVolumeMonitorClass>())).get_mount_for_uuid as *const _ as usize
        },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(_GVolumeMonitorClass),
            "::",
            stringify!(get_mount_for_uuid)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GVolumeMonitorClass>())).adopt_orphan_mount as *const _ as usize
        },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(_GVolumeMonitorClass),
            "::",
            stringify!(adopt_orphan_mount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GVolumeMonitorClass>())).drive_eject_button as *const _ as usize
        },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(_GVolumeMonitorClass),
            "::",
            stringify!(drive_eject_button)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GVolumeMonitorClass>())).drive_stop_button as *const _ as usize
        },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(_GVolumeMonitorClass),
            "::",
            stringify!(drive_stop_button)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GVolumeMonitorClass>()))._g_reserved1 as *const _ as usize
        },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(_GVolumeMonitorClass),
            "::",
            stringify!(_g_reserved1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GVolumeMonitorClass>()))._g_reserved2 as *const _ as usize
        },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(_GVolumeMonitorClass),
            "::",
            stringify!(_g_reserved2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GVolumeMonitorClass>()))._g_reserved3 as *const _ as usize
        },
        304usize,
        concat!(
            "Offset of field: ",
            stringify!(_GVolumeMonitorClass),
            "::",
            stringify!(_g_reserved3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GVolumeMonitorClass>()))._g_reserved4 as *const _ as usize
        },
        312usize,
        concat!(
            "Offset of field: ",
            stringify!(_GVolumeMonitorClass),
            "::",
            stringify!(_g_reserved4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GVolumeMonitorClass>()))._g_reserved5 as *const _ as usize
        },
        320usize,
        concat!(
            "Offset of field: ",
            stringify!(_GVolumeMonitorClass),
            "::",
            stringify!(_g_reserved5)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GVolumeMonitorClass>()))._g_reserved6 as *const _ as usize
        },
        328usize,
        concat!(
            "Offset of field: ",
            stringify!(_GVolumeMonitorClass),
            "::",
            stringify!(_g_reserved6)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_g_volume_monitor_get_type"]
    pub fn g_volume_monitor_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_volume_monitor_get"]
    pub fn g_volume_monitor_get() -> *mut GVolumeMonitor;
}
extern "C" {
    #[link_name = "\u{1}_g_volume_monitor_get_connected_drives"]
    pub fn g_volume_monitor_get_connected_drives(volume_monitor: *mut GVolumeMonitor)
        -> *mut GList;
}
extern "C" {
    #[link_name = "\u{1}_g_volume_monitor_get_volumes"]
    pub fn g_volume_monitor_get_volumes(volume_monitor: *mut GVolumeMonitor) -> *mut GList;
}
extern "C" {
    #[link_name = "\u{1}_g_volume_monitor_get_mounts"]
    pub fn g_volume_monitor_get_mounts(volume_monitor: *mut GVolumeMonitor) -> *mut GList;
}
extern "C" {
    #[link_name = "\u{1}_g_volume_monitor_get_volume_for_uuid"]
    pub fn g_volume_monitor_get_volume_for_uuid(
        volume_monitor: *mut GVolumeMonitor,
        uuid: *const ::std::os::raw::c_char,
    ) -> *mut GVolume;
}
extern "C" {
    #[link_name = "\u{1}_g_volume_monitor_get_mount_for_uuid"]
    pub fn g_volume_monitor_get_mount_for_uuid(
        volume_monitor: *mut GVolumeMonitor,
        uuid: *const ::std::os::raw::c_char,
    ) -> *mut GMount;
}
extern "C" {
    #[link_name = "\u{1}_g_volume_monitor_adopt_orphan_mount"]
    pub fn g_volume_monitor_adopt_orphan_mount(mount: *mut GMount) -> *mut GVolume;
}
pub type GNativeVolumeMonitor = _GNativeVolumeMonitor;
pub type GNativeVolumeMonitorClass = _GNativeVolumeMonitorClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GNativeVolumeMonitor {
    pub parent_instance: GVolumeMonitor,
}
#[test]
fn bindgen_test_layout__GNativeVolumeMonitor() {
    assert_eq!(
        ::std::mem::size_of::<_GNativeVolumeMonitor>(),
        32usize,
        concat!("Size of: ", stringify!(_GNativeVolumeMonitor))
    );
    assert_eq!(
        ::std::mem::align_of::<_GNativeVolumeMonitor>(),
        8usize,
        concat!("Alignment of ", stringify!(_GNativeVolumeMonitor))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GNativeVolumeMonitor>())).parent_instance as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GNativeVolumeMonitor),
            "::",
            stringify!(parent_instance)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GNativeVolumeMonitorClass {
    pub parent_class: GVolumeMonitorClass,
    pub get_mount_for_mount_path: ::std::option::Option<
        unsafe extern "C" fn(
            mount_path: *const ::std::os::raw::c_char,
            cancellable: *mut GCancellable,
        ) -> *mut GMount,
    >,
}
#[test]
fn bindgen_test_layout__GNativeVolumeMonitorClass() {
    assert_eq!(
        ::std::mem::size_of::<_GNativeVolumeMonitorClass>(),
        344usize,
        concat!("Size of: ", stringify!(_GNativeVolumeMonitorClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_GNativeVolumeMonitorClass>(),
        8usize,
        concat!("Alignment of ", stringify!(_GNativeVolumeMonitorClass))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GNativeVolumeMonitorClass>())).parent_class as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GNativeVolumeMonitorClass),
            "::",
            stringify!(parent_class)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GNativeVolumeMonitorClass>())).get_mount_for_mount_path
                as *const _ as usize
        },
        336usize,
        concat!(
            "Offset of field: ",
            stringify!(_GNativeVolumeMonitorClass),
            "::",
            stringify!(get_mount_for_mount_path)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_g_native_volume_monitor_get_type"]
    pub fn g_native_volume_monitor_get_type() -> GType;
}
pub type GNetworkAddressClass = _GNetworkAddressClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GNetworkAddressPrivate {
    _unused: [u8; 0],
}
pub type GNetworkAddressPrivate = _GNetworkAddressPrivate;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GNetworkAddress {
    pub parent_instance: GObject,
    pub priv_: *mut GNetworkAddressPrivate,
}
#[test]
fn bindgen_test_layout__GNetworkAddress() {
    assert_eq!(
        ::std::mem::size_of::<_GNetworkAddress>(),
        32usize,
        concat!("Size of: ", stringify!(_GNetworkAddress))
    );
    assert_eq!(
        ::std::mem::align_of::<_GNetworkAddress>(),
        8usize,
        concat!("Alignment of ", stringify!(_GNetworkAddress))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GNetworkAddress>())).parent_instance as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GNetworkAddress),
            "::",
            stringify!(parent_instance)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GNetworkAddress>())).priv_ as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GNetworkAddress),
            "::",
            stringify!(priv_)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GNetworkAddressClass {
    pub parent_class: GObjectClass,
}
#[test]
fn bindgen_test_layout__GNetworkAddressClass() {
    assert_eq!(
        ::std::mem::size_of::<_GNetworkAddressClass>(),
        136usize,
        concat!("Size of: ", stringify!(_GNetworkAddressClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_GNetworkAddressClass>(),
        8usize,
        concat!("Alignment of ", stringify!(_GNetworkAddressClass))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GNetworkAddressClass>())).parent_class as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GNetworkAddressClass),
            "::",
            stringify!(parent_class)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_g_network_address_get_type"]
    pub fn g_network_address_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_network_address_new"]
    pub fn g_network_address_new(hostname: *const gchar, port: guint16) -> *mut GSocketConnectable;
}
extern "C" {
    #[link_name = "\u{1}_g_network_address_new_loopback"]
    pub fn g_network_address_new_loopback(port: guint16) -> *mut GSocketConnectable;
}
extern "C" {
    #[link_name = "\u{1}_g_network_address_parse"]
    pub fn g_network_address_parse(
        host_and_port: *const gchar,
        default_port: guint16,
        error: *mut *mut GError,
    ) -> *mut GSocketConnectable;
}
extern "C" {
    #[link_name = "\u{1}_g_network_address_parse_uri"]
    pub fn g_network_address_parse_uri(
        uri: *const gchar,
        default_port: guint16,
        error: *mut *mut GError,
    ) -> *mut GSocketConnectable;
}
extern "C" {
    #[link_name = "\u{1}_g_network_address_get_hostname"]
    pub fn g_network_address_get_hostname(addr: *mut GNetworkAddress) -> *const gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_network_address_get_port"]
    pub fn g_network_address_get_port(addr: *mut GNetworkAddress) -> guint16;
}
extern "C" {
    #[link_name = "\u{1}_g_network_address_get_scheme"]
    pub fn g_network_address_get_scheme(addr: *mut GNetworkAddress) -> *const gchar;
}
pub type GNetworkMonitorInterface = _GNetworkMonitorInterface;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GNetworkMonitorInterface {
    pub g_iface: GTypeInterface,
    pub network_changed: ::std::option::Option<
        unsafe extern "C" fn(monitor: *mut GNetworkMonitor, available: gboolean),
    >,
    pub can_reach: ::std::option::Option<
        unsafe extern "C" fn(
            monitor: *mut GNetworkMonitor,
            connectable: *mut GSocketConnectable,
            cancellable: *mut GCancellable,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
    pub can_reach_async: ::std::option::Option<
        unsafe extern "C" fn(
            monitor: *mut GNetworkMonitor,
            connectable: *mut GSocketConnectable,
            cancellable: *mut GCancellable,
            callback: GAsyncReadyCallback,
            user_data: gpointer,
        ),
    >,
    pub can_reach_finish: ::std::option::Option<
        unsafe extern "C" fn(
            monitor: *mut GNetworkMonitor,
            result: *mut GAsyncResult,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
}
#[test]
fn bindgen_test_layout__GNetworkMonitorInterface() {
    assert_eq!(
        ::std::mem::size_of::<_GNetworkMonitorInterface>(),
        48usize,
        concat!("Size of: ", stringify!(_GNetworkMonitorInterface))
    );
    assert_eq!(
        ::std::mem::align_of::<_GNetworkMonitorInterface>(),
        8usize,
        concat!("Alignment of ", stringify!(_GNetworkMonitorInterface))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GNetworkMonitorInterface>())).g_iface as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GNetworkMonitorInterface),
            "::",
            stringify!(g_iface)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GNetworkMonitorInterface>())).network_changed as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GNetworkMonitorInterface),
            "::",
            stringify!(network_changed)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GNetworkMonitorInterface>())).can_reach as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GNetworkMonitorInterface),
            "::",
            stringify!(can_reach)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GNetworkMonitorInterface>())).can_reach_async as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_GNetworkMonitorInterface),
            "::",
            stringify!(can_reach_async)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GNetworkMonitorInterface>())).can_reach_finish as *const _
                as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_GNetworkMonitorInterface),
            "::",
            stringify!(can_reach_finish)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_g_network_monitor_get_type"]
    pub fn g_network_monitor_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_network_monitor_get_default"]
    pub fn g_network_monitor_get_default() -> *mut GNetworkMonitor;
}
extern "C" {
    #[link_name = "\u{1}_g_network_monitor_get_network_available"]
    pub fn g_network_monitor_get_network_available(monitor: *mut GNetworkMonitor) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_network_monitor_get_network_metered"]
    pub fn g_network_monitor_get_network_metered(monitor: *mut GNetworkMonitor) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_network_monitor_get_connectivity"]
    pub fn g_network_monitor_get_connectivity(
        monitor: *mut GNetworkMonitor,
    ) -> GNetworkConnectivity;
}
extern "C" {
    #[link_name = "\u{1}_g_network_monitor_can_reach"]
    pub fn g_network_monitor_can_reach(
        monitor: *mut GNetworkMonitor,
        connectable: *mut GSocketConnectable,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_network_monitor_can_reach_async"]
    pub fn g_network_monitor_can_reach_async(
        monitor: *mut GNetworkMonitor,
        connectable: *mut GSocketConnectable,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_network_monitor_can_reach_finish"]
    pub fn g_network_monitor_can_reach_finish(
        monitor: *mut GNetworkMonitor,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> gboolean;
}
pub type GNetworkServiceClass = _GNetworkServiceClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GNetworkServicePrivate {
    _unused: [u8; 0],
}
pub type GNetworkServicePrivate = _GNetworkServicePrivate;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GNetworkService {
    pub parent_instance: GObject,
    pub priv_: *mut GNetworkServicePrivate,
}
#[test]
fn bindgen_test_layout__GNetworkService() {
    assert_eq!(
        ::std::mem::size_of::<_GNetworkService>(),
        32usize,
        concat!("Size of: ", stringify!(_GNetworkService))
    );
    assert_eq!(
        ::std::mem::align_of::<_GNetworkService>(),
        8usize,
        concat!("Alignment of ", stringify!(_GNetworkService))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GNetworkService>())).parent_instance as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GNetworkService),
            "::",
            stringify!(parent_instance)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GNetworkService>())).priv_ as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GNetworkService),
            "::",
            stringify!(priv_)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GNetworkServiceClass {
    pub parent_class: GObjectClass,
}
#[test]
fn bindgen_test_layout__GNetworkServiceClass() {
    assert_eq!(
        ::std::mem::size_of::<_GNetworkServiceClass>(),
        136usize,
        concat!("Size of: ", stringify!(_GNetworkServiceClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_GNetworkServiceClass>(),
        8usize,
        concat!("Alignment of ", stringify!(_GNetworkServiceClass))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GNetworkServiceClass>())).parent_class as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GNetworkServiceClass),
            "::",
            stringify!(parent_class)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_g_network_service_get_type"]
    pub fn g_network_service_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_network_service_new"]
    pub fn g_network_service_new(
        service: *const gchar,
        protocol: *const gchar,
        domain: *const gchar,
    ) -> *mut GSocketConnectable;
}
extern "C" {
    #[link_name = "\u{1}_g_network_service_get_service"]
    pub fn g_network_service_get_service(srv: *mut GNetworkService) -> *const gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_network_service_get_protocol"]
    pub fn g_network_service_get_protocol(srv: *mut GNetworkService) -> *const gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_network_service_get_domain"]
    pub fn g_network_service_get_domain(srv: *mut GNetworkService) -> *const gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_network_service_get_scheme"]
    pub fn g_network_service_get_scheme(srv: *mut GNetworkService) -> *const gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_network_service_set_scheme"]
    pub fn g_network_service_set_scheme(srv: *mut GNetworkService, scheme: *const gchar);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GPermissionPrivate {
    _unused: [u8; 0],
}
pub type GPermissionPrivate = _GPermissionPrivate;
pub type GPermissionClass = _GPermissionClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GPermission {
    pub parent_instance: GObject,
    pub priv_: *mut GPermissionPrivate,
}
#[test]
fn bindgen_test_layout__GPermission() {
    assert_eq!(
        ::std::mem::size_of::<_GPermission>(),
        32usize,
        concat!("Size of: ", stringify!(_GPermission))
    );
    assert_eq!(
        ::std::mem::align_of::<_GPermission>(),
        8usize,
        concat!("Alignment of ", stringify!(_GPermission))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GPermission>())).parent_instance as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GPermission),
            "::",
            stringify!(parent_instance)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GPermission>())).priv_ as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GPermission),
            "::",
            stringify!(priv_)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GPermissionClass {
    pub parent_class: GObjectClass,
    pub acquire: ::std::option::Option<
        unsafe extern "C" fn(
            permission: *mut GPermission,
            cancellable: *mut GCancellable,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
    pub acquire_async: ::std::option::Option<
        unsafe extern "C" fn(
            permission: *mut GPermission,
            cancellable: *mut GCancellable,
            callback: GAsyncReadyCallback,
            user_data: gpointer,
        ),
    >,
    pub acquire_finish: ::std::option::Option<
        unsafe extern "C" fn(
            permission: *mut GPermission,
            result: *mut GAsyncResult,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
    pub release: ::std::option::Option<
        unsafe extern "C" fn(
            permission: *mut GPermission,
            cancellable: *mut GCancellable,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
    pub release_async: ::std::option::Option<
        unsafe extern "C" fn(
            permission: *mut GPermission,
            cancellable: *mut GCancellable,
            callback: GAsyncReadyCallback,
            user_data: gpointer,
        ),
    >,
    pub release_finish: ::std::option::Option<
        unsafe extern "C" fn(
            permission: *mut GPermission,
            result: *mut GAsyncResult,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
    pub reserved: [gpointer; 16usize],
}
#[test]
fn bindgen_test_layout__GPermissionClass() {
    assert_eq!(
        ::std::mem::size_of::<_GPermissionClass>(),
        312usize,
        concat!("Size of: ", stringify!(_GPermissionClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_GPermissionClass>(),
        8usize,
        concat!("Alignment of ", stringify!(_GPermissionClass))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GPermissionClass>())).parent_class as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GPermissionClass),
            "::",
            stringify!(parent_class)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GPermissionClass>())).acquire as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_GPermissionClass),
            "::",
            stringify!(acquire)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GPermissionClass>())).acquire_async as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_GPermissionClass),
            "::",
            stringify!(acquire_async)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GPermissionClass>())).acquire_finish as *const _ as usize
        },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(_GPermissionClass),
            "::",
            stringify!(acquire_finish)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GPermissionClass>())).release as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_GPermissionClass),
            "::",
            stringify!(release)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GPermissionClass>())).release_async as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(_GPermissionClass),
            "::",
            stringify!(release_async)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GPermissionClass>())).release_finish as *const _ as usize
        },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(_GPermissionClass),
            "::",
            stringify!(release_finish)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GPermissionClass>())).reserved as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(_GPermissionClass),
            "::",
            stringify!(reserved)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_g_permission_get_type"]
    pub fn g_permission_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_permission_acquire"]
    pub fn g_permission_acquire(
        permission: *mut GPermission,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_permission_acquire_async"]
    pub fn g_permission_acquire_async(
        permission: *mut GPermission,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_permission_acquire_finish"]
    pub fn g_permission_acquire_finish(
        permission: *mut GPermission,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_permission_release"]
    pub fn g_permission_release(
        permission: *mut GPermission,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_permission_release_async"]
    pub fn g_permission_release_async(
        permission: *mut GPermission,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_permission_release_finish"]
    pub fn g_permission_release_finish(
        permission: *mut GPermission,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_permission_get_allowed"]
    pub fn g_permission_get_allowed(permission: *mut GPermission) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_permission_get_can_acquire"]
    pub fn g_permission_get_can_acquire(permission: *mut GPermission) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_permission_get_can_release"]
    pub fn g_permission_get_can_release(permission: *mut GPermission) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_permission_impl_update"]
    pub fn g_permission_impl_update(
        permission: *mut GPermission,
        allowed: gboolean,
        can_acquire: gboolean,
        can_release: gboolean,
    );
}
/// GPollableInputStream:
///
/// An interface for a #GInputStream that can be polled for readability.
///
/// Since: 2.28
pub type GPollableInputStreamInterface = _GPollableInputStreamInterface;
/// GPollableInputStreamInterface:
/// @g_iface: The parent interface.
/// @can_poll: Checks if the #GPollableInputStream instance is actually pollable
/// @is_readable: Checks if the stream is readable
/// @create_source: Creates a #GSource to poll the stream
/// @read_nonblocking: Does a non-blocking read or returns
/// %G_IO_ERROR_WOULD_BLOCK
///
/// The interface for pollable input streams.
///
/// The default implementation of @can_poll always returns %TRUE.
///
/// The default implementation of @read_nonblocking calls
/// g_pollable_input_stream_is_readable(), and then calls
/// g_input_stream_read() if it returns %TRUE. This means you only need
/// to override it if it is possible that your @is_readable
/// implementation may return %TRUE when the stream is not actually
/// readable.
///
/// Since: 2.28
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GPollableInputStreamInterface {
    pub g_iface: GTypeInterface,
    pub can_poll:
        ::std::option::Option<unsafe extern "C" fn(stream: *mut GPollableInputStream) -> gboolean>,
    pub is_readable:
        ::std::option::Option<unsafe extern "C" fn(stream: *mut GPollableInputStream) -> gboolean>,
    pub create_source: ::std::option::Option<
        unsafe extern "C" fn(stream: *mut GPollableInputStream, cancellable: *mut GCancellable)
            -> *mut GSource,
    >,
    pub read_nonblocking: ::std::option::Option<
        unsafe extern "C" fn(
            stream: *mut GPollableInputStream,
            buffer: *mut ::std::os::raw::c_void,
            count: gsize,
            error: *mut *mut GError,
        ) -> gssize,
    >,
}
#[test]
fn bindgen_test_layout__GPollableInputStreamInterface() {
    assert_eq!(
        ::std::mem::size_of::<_GPollableInputStreamInterface>(),
        48usize,
        concat!("Size of: ", stringify!(_GPollableInputStreamInterface))
    );
    assert_eq!(
        ::std::mem::align_of::<_GPollableInputStreamInterface>(),
        8usize,
        concat!("Alignment of ", stringify!(_GPollableInputStreamInterface))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GPollableInputStreamInterface>())).g_iface as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GPollableInputStreamInterface),
            "::",
            stringify!(g_iface)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GPollableInputStreamInterface>())).can_poll as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GPollableInputStreamInterface),
            "::",
            stringify!(can_poll)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GPollableInputStreamInterface>())).is_readable as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GPollableInputStreamInterface),
            "::",
            stringify!(is_readable)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GPollableInputStreamInterface>())).create_source as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_GPollableInputStreamInterface),
            "::",
            stringify!(create_source)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GPollableInputStreamInterface>())).read_nonblocking as *const _
                as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_GPollableInputStreamInterface),
            "::",
            stringify!(read_nonblocking)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_g_pollable_input_stream_get_type"]
    pub fn g_pollable_input_stream_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_pollable_input_stream_can_poll"]
    pub fn g_pollable_input_stream_can_poll(stream: *mut GPollableInputStream) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_pollable_input_stream_is_readable"]
    pub fn g_pollable_input_stream_is_readable(stream: *mut GPollableInputStream) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_pollable_input_stream_create_source"]
    pub fn g_pollable_input_stream_create_source(
        stream: *mut GPollableInputStream,
        cancellable: *mut GCancellable,
    ) -> *mut GSource;
}
extern "C" {
    #[link_name = "\u{1}_g_pollable_input_stream_read_nonblocking"]
    pub fn g_pollable_input_stream_read_nonblocking(
        stream: *mut GPollableInputStream,
        buffer: *mut ::std::os::raw::c_void,
        count: gsize,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gssize;
}
/// GPollableOutputStream:
///
/// An interface for a #GOutputStream that can be polled for readability.
///
/// Since: 2.28
pub type GPollableOutputStreamInterface = _GPollableOutputStreamInterface;
/// GPollableOutputStreamInterface:
/// @g_iface: The parent interface.
/// @can_poll: Checks if the #GPollableOutputStream instance is actually pollable
/// @is_writable: Checks if the stream is writable
/// @create_source: Creates a #GSource to poll the stream
/// @write_nonblocking: Does a non-blocking write or returns
/// %G_IO_ERROR_WOULD_BLOCK
///
/// The interface for pollable output streams.
///
/// The default implementation of @can_poll always returns %TRUE.
///
/// The default implementation of @write_nonblocking calls
/// g_pollable_output_stream_is_writable(), and then calls
/// g_output_stream_write() if it returns %TRUE. This means you only
/// need to override it if it is possible that your @is_writable
/// implementation may return %TRUE when the stream is not actually
/// writable.
///
/// Since: 2.28
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GPollableOutputStreamInterface {
    pub g_iface: GTypeInterface,
    pub can_poll:
        ::std::option::Option<unsafe extern "C" fn(stream: *mut GPollableOutputStream) -> gboolean>,
    pub is_writable:
        ::std::option::Option<unsafe extern "C" fn(stream: *mut GPollableOutputStream) -> gboolean>,
    pub create_source: ::std::option::Option<
        unsafe extern "C" fn(stream: *mut GPollableOutputStream, cancellable: *mut GCancellable)
            -> *mut GSource,
    >,
    pub write_nonblocking: ::std::option::Option<
        unsafe extern "C" fn(
            stream: *mut GPollableOutputStream,
            buffer: *const ::std::os::raw::c_void,
            count: gsize,
            error: *mut *mut GError,
        ) -> gssize,
    >,
}
#[test]
fn bindgen_test_layout__GPollableOutputStreamInterface() {
    assert_eq!(
        ::std::mem::size_of::<_GPollableOutputStreamInterface>(),
        48usize,
        concat!("Size of: ", stringify!(_GPollableOutputStreamInterface))
    );
    assert_eq!(
        ::std::mem::align_of::<_GPollableOutputStreamInterface>(),
        8usize,
        concat!("Alignment of ", stringify!(_GPollableOutputStreamInterface))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GPollableOutputStreamInterface>())).g_iface as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GPollableOutputStreamInterface),
            "::",
            stringify!(g_iface)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GPollableOutputStreamInterface>())).can_poll as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GPollableOutputStreamInterface),
            "::",
            stringify!(can_poll)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GPollableOutputStreamInterface>())).is_writable as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GPollableOutputStreamInterface),
            "::",
            stringify!(is_writable)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GPollableOutputStreamInterface>())).create_source as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_GPollableOutputStreamInterface),
            "::",
            stringify!(create_source)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GPollableOutputStreamInterface>())).write_nonblocking
                as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_GPollableOutputStreamInterface),
            "::",
            stringify!(write_nonblocking)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_g_pollable_output_stream_get_type"]
    pub fn g_pollable_output_stream_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_pollable_output_stream_can_poll"]
    pub fn g_pollable_output_stream_can_poll(stream: *mut GPollableOutputStream) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_pollable_output_stream_is_writable"]
    pub fn g_pollable_output_stream_is_writable(stream: *mut GPollableOutputStream) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_pollable_output_stream_create_source"]
    pub fn g_pollable_output_stream_create_source(
        stream: *mut GPollableOutputStream,
        cancellable: *mut GCancellable,
    ) -> *mut GSource;
}
extern "C" {
    #[link_name = "\u{1}_g_pollable_output_stream_write_nonblocking"]
    pub fn g_pollable_output_stream_write_nonblocking(
        stream: *mut GPollableOutputStream,
        buffer: *const ::std::os::raw::c_void,
        count: gsize,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gssize;
}
extern "C" {
    #[link_name = "\u{1}_g_pollable_source_new"]
    pub fn g_pollable_source_new(pollable_stream: *mut GObject) -> *mut GSource;
}
extern "C" {
    #[link_name = "\u{1}_g_pollable_source_new_full"]
    pub fn g_pollable_source_new_full(
        pollable_stream: gpointer,
        child_source: *mut GSource,
        cancellable: *mut GCancellable,
    ) -> *mut GSource;
}
extern "C" {
    #[link_name = "\u{1}_g_pollable_stream_read"]
    pub fn g_pollable_stream_read(
        stream: *mut GInputStream,
        buffer: *mut ::std::os::raw::c_void,
        count: gsize,
        blocking: gboolean,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gssize;
}
extern "C" {
    #[link_name = "\u{1}_g_pollable_stream_write"]
    pub fn g_pollable_stream_write(
        stream: *mut GOutputStream,
        buffer: *const ::std::os::raw::c_void,
        count: gsize,
        blocking: gboolean,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gssize;
}
extern "C" {
    #[link_name = "\u{1}_g_pollable_stream_write_all"]
    pub fn g_pollable_stream_write_all(
        stream: *mut GOutputStream,
        buffer: *const ::std::os::raw::c_void,
        count: gsize,
        blocking: gboolean,
        bytes_written: *mut gsize,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_property_action_get_type"]
    pub fn g_property_action_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_property_action_new"]
    pub fn g_property_action_new(
        name: *const gchar,
        object: gpointer,
        property_name: *const gchar,
    ) -> *mut GPropertyAction;
}
/// GProxy:
///
/// Interface that handles proxy connection and payload.
///
/// Since: 2.26
pub type GProxyInterface = _GProxyInterface;
/// GProxyInterface:
/// @g_iface: The parent interface.
/// @connect: Connect to proxy server and wrap (if required) the #connection
/// to handle payload.
/// @connect_async: Same as connect() but asynchronous.
/// @connect_finish: Returns the result of connect_async()
/// @supports_hostname: Returns whether the proxy supports hostname lookups.
///
/// Provides an interface for handling proxy connection and payload.
///
/// Since: 2.26
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GProxyInterface {
    pub g_iface: GTypeInterface,
    pub connect: ::std::option::Option<
        unsafe extern "C" fn(
            proxy: *mut GProxy,
            connection: *mut GIOStream,
            proxy_address: *mut GProxyAddress,
            cancellable: *mut GCancellable,
            error: *mut *mut GError,
        ) -> *mut GIOStream,
    >,
    pub connect_async: ::std::option::Option<
        unsafe extern "C" fn(
            proxy: *mut GProxy,
            connection: *mut GIOStream,
            proxy_address: *mut GProxyAddress,
            cancellable: *mut GCancellable,
            callback: GAsyncReadyCallback,
            user_data: gpointer,
        ),
    >,
    pub connect_finish: ::std::option::Option<
        unsafe extern "C" fn(
            proxy: *mut GProxy,
            result: *mut GAsyncResult,
            error: *mut *mut GError,
        ) -> *mut GIOStream,
    >,
    pub supports_hostname:
        ::std::option::Option<unsafe extern "C" fn(proxy: *mut GProxy) -> gboolean>,
}
#[test]
fn bindgen_test_layout__GProxyInterface() {
    assert_eq!(
        ::std::mem::size_of::<_GProxyInterface>(),
        48usize,
        concat!("Size of: ", stringify!(_GProxyInterface))
    );
    assert_eq!(
        ::std::mem::align_of::<_GProxyInterface>(),
        8usize,
        concat!("Alignment of ", stringify!(_GProxyInterface))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GProxyInterface>())).g_iface as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GProxyInterface),
            "::",
            stringify!(g_iface)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GProxyInterface>())).connect as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GProxyInterface),
            "::",
            stringify!(connect)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GProxyInterface>())).connect_async as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GProxyInterface),
            "::",
            stringify!(connect_async)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GProxyInterface>())).connect_finish as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_GProxyInterface),
            "::",
            stringify!(connect_finish)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GProxyInterface>())).supports_hostname as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_GProxyInterface),
            "::",
            stringify!(supports_hostname)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_g_proxy_get_type"]
    pub fn g_proxy_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_proxy_get_default_for_protocol"]
    pub fn g_proxy_get_default_for_protocol(protocol: *const gchar) -> *mut GProxy;
}
extern "C" {
    #[link_name = "\u{1}_g_proxy_connect"]
    pub fn g_proxy_connect(
        proxy: *mut GProxy,
        connection: *mut GIOStream,
        proxy_address: *mut GProxyAddress,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> *mut GIOStream;
}
extern "C" {
    #[link_name = "\u{1}_g_proxy_connect_async"]
    pub fn g_proxy_connect_async(
        proxy: *mut GProxy,
        connection: *mut GIOStream,
        proxy_address: *mut GProxyAddress,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_proxy_connect_finish"]
    pub fn g_proxy_connect_finish(
        proxy: *mut GProxy,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> *mut GIOStream;
}
extern "C" {
    #[link_name = "\u{1}_g_proxy_supports_hostname"]
    pub fn g_proxy_supports_hostname(proxy: *mut GProxy) -> gboolean;
}
pub type GProxyAddressClass = _GProxyAddressClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GProxyAddressPrivate {
    _unused: [u8; 0],
}
pub type GProxyAddressPrivate = _GProxyAddressPrivate;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GProxyAddress {
    pub parent_instance: GInetSocketAddress,
    pub priv_: *mut GProxyAddressPrivate,
}
#[test]
fn bindgen_test_layout__GProxyAddress() {
    assert_eq!(
        ::std::mem::size_of::<_GProxyAddress>(),
        40usize,
        concat!("Size of: ", stringify!(_GProxyAddress))
    );
    assert_eq!(
        ::std::mem::align_of::<_GProxyAddress>(),
        8usize,
        concat!("Alignment of ", stringify!(_GProxyAddress))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GProxyAddress>())).parent_instance as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GProxyAddress),
            "::",
            stringify!(parent_instance)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GProxyAddress>())).priv_ as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_GProxyAddress),
            "::",
            stringify!(priv_)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GProxyAddressClass {
    pub parent_class: GInetSocketAddressClass,
}
#[test]
fn bindgen_test_layout__GProxyAddressClass() {
    assert_eq!(
        ::std::mem::size_of::<_GProxyAddressClass>(),
        160usize,
        concat!("Size of: ", stringify!(_GProxyAddressClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_GProxyAddressClass>(),
        8usize,
        concat!("Alignment of ", stringify!(_GProxyAddressClass))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GProxyAddressClass>())).parent_class as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GProxyAddressClass),
            "::",
            stringify!(parent_class)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_g_proxy_address_get_type"]
    pub fn g_proxy_address_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_proxy_address_new"]
    pub fn g_proxy_address_new(
        inetaddr: *mut GInetAddress,
        port: guint16,
        protocol: *const gchar,
        dest_hostname: *const gchar,
        dest_port: guint16,
        username: *const gchar,
        password: *const gchar,
    ) -> *mut GSocketAddress;
}
extern "C" {
    #[link_name = "\u{1}_g_proxy_address_get_protocol"]
    pub fn g_proxy_address_get_protocol(proxy: *mut GProxyAddress) -> *const gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_proxy_address_get_destination_protocol"]
    pub fn g_proxy_address_get_destination_protocol(proxy: *mut GProxyAddress) -> *const gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_proxy_address_get_destination_hostname"]
    pub fn g_proxy_address_get_destination_hostname(proxy: *mut GProxyAddress) -> *const gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_proxy_address_get_destination_port"]
    pub fn g_proxy_address_get_destination_port(proxy: *mut GProxyAddress) -> guint16;
}
extern "C" {
    #[link_name = "\u{1}_g_proxy_address_get_username"]
    pub fn g_proxy_address_get_username(proxy: *mut GProxyAddress) -> *const gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_proxy_address_get_password"]
    pub fn g_proxy_address_get_password(proxy: *mut GProxyAddress) -> *const gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_proxy_address_get_uri"]
    pub fn g_proxy_address_get_uri(proxy: *mut GProxyAddress) -> *const gchar;
}
/// GSocketAddressEnumerator:
///
/// Enumerator type for objects that contain or generate
/// #GSocketAddress<!-- -->es.
pub type GSocketAddressEnumeratorClass = _GSocketAddressEnumeratorClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GSocketAddressEnumerator {
    pub parent_instance: GObject,
}
#[test]
fn bindgen_test_layout__GSocketAddressEnumerator() {
    assert_eq!(
        ::std::mem::size_of::<_GSocketAddressEnumerator>(),
        24usize,
        concat!("Size of: ", stringify!(_GSocketAddressEnumerator))
    );
    assert_eq!(
        ::std::mem::align_of::<_GSocketAddressEnumerator>(),
        8usize,
        concat!("Alignment of ", stringify!(_GSocketAddressEnumerator))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GSocketAddressEnumerator>())).parent_instance as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSocketAddressEnumerator),
            "::",
            stringify!(parent_instance)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GSocketAddressEnumeratorClass {
    pub parent_class: GObjectClass,
    pub next: ::std::option::Option<
        unsafe extern "C" fn(
            enumerator: *mut GSocketAddressEnumerator,
            cancellable: *mut GCancellable,
            error: *mut *mut GError,
        ) -> *mut GSocketAddress,
    >,
    pub next_async: ::std::option::Option<
        unsafe extern "C" fn(
            enumerator: *mut GSocketAddressEnumerator,
            cancellable: *mut GCancellable,
            callback: GAsyncReadyCallback,
            user_data: gpointer,
        ),
    >,
    pub next_finish: ::std::option::Option<
        unsafe extern "C" fn(
            enumerator: *mut GSocketAddressEnumerator,
            result: *mut GAsyncResult,
            error: *mut *mut GError,
        ) -> *mut GSocketAddress,
    >,
}
#[test]
fn bindgen_test_layout__GSocketAddressEnumeratorClass() {
    assert_eq!(
        ::std::mem::size_of::<_GSocketAddressEnumeratorClass>(),
        160usize,
        concat!("Size of: ", stringify!(_GSocketAddressEnumeratorClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_GSocketAddressEnumeratorClass>(),
        8usize,
        concat!("Alignment of ", stringify!(_GSocketAddressEnumeratorClass))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GSocketAddressEnumeratorClass>())).parent_class as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSocketAddressEnumeratorClass),
            "::",
            stringify!(parent_class)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GSocketAddressEnumeratorClass>())).next as *const _ as usize
        },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSocketAddressEnumeratorClass),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GSocketAddressEnumeratorClass>())).next_async as *const _
                as usize
        },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSocketAddressEnumeratorClass),
            "::",
            stringify!(next_async)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GSocketAddressEnumeratorClass>())).next_finish as *const _
                as usize
        },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSocketAddressEnumeratorClass),
            "::",
            stringify!(next_finish)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_g_socket_address_enumerator_get_type"]
    pub fn g_socket_address_enumerator_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_socket_address_enumerator_next"]
    pub fn g_socket_address_enumerator_next(
        enumerator: *mut GSocketAddressEnumerator,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> *mut GSocketAddress;
}
extern "C" {
    #[link_name = "\u{1}_g_socket_address_enumerator_next_async"]
    pub fn g_socket_address_enumerator_next_async(
        enumerator: *mut GSocketAddressEnumerator,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_socket_address_enumerator_next_finish"]
    pub fn g_socket_address_enumerator_next_finish(
        enumerator: *mut GSocketAddressEnumerator,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> *mut GSocketAddress;
}
/// GProxyAddressEnumerator:
///
/// A subclass of #GSocketAddressEnumerator that takes another address
/// enumerator and wraps its results in #GProxyAddress<!-- -->es as
/// directed by the default #GProxyResolver.
pub type GProxyAddressEnumeratorClass = _GProxyAddressEnumeratorClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GProxyAddressEnumeratorPrivate {
    _unused: [u8; 0],
}
pub type GProxyAddressEnumeratorPrivate = _GProxyAddressEnumeratorPrivate;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GProxyAddressEnumerator {
    pub parent_instance: GSocketAddressEnumerator,
    pub priv_: *mut GProxyAddressEnumeratorPrivate,
}
#[test]
fn bindgen_test_layout__GProxyAddressEnumerator() {
    assert_eq!(
        ::std::mem::size_of::<_GProxyAddressEnumerator>(),
        32usize,
        concat!("Size of: ", stringify!(_GProxyAddressEnumerator))
    );
    assert_eq!(
        ::std::mem::align_of::<_GProxyAddressEnumerator>(),
        8usize,
        concat!("Alignment of ", stringify!(_GProxyAddressEnumerator))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GProxyAddressEnumerator>())).parent_instance as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GProxyAddressEnumerator),
            "::",
            stringify!(parent_instance)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GProxyAddressEnumerator>())).priv_ as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GProxyAddressEnumerator),
            "::",
            stringify!(priv_)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GProxyAddressEnumeratorClass {
    pub parent_class: GSocketAddressEnumeratorClass,
    pub _g_reserved1: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved2: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved3: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved4: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved5: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved6: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved7: ::std::option::Option<unsafe extern "C" fn()>,
}
#[test]
fn bindgen_test_layout__GProxyAddressEnumeratorClass() {
    assert_eq!(
        ::std::mem::size_of::<_GProxyAddressEnumeratorClass>(),
        216usize,
        concat!("Size of: ", stringify!(_GProxyAddressEnumeratorClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_GProxyAddressEnumeratorClass>(),
        8usize,
        concat!("Alignment of ", stringify!(_GProxyAddressEnumeratorClass))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GProxyAddressEnumeratorClass>())).parent_class as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GProxyAddressEnumeratorClass),
            "::",
            stringify!(parent_class)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GProxyAddressEnumeratorClass>()))._g_reserved1 as *const _
                as usize
        },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_GProxyAddressEnumeratorClass),
            "::",
            stringify!(_g_reserved1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GProxyAddressEnumeratorClass>()))._g_reserved2 as *const _
                as usize
        },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(_GProxyAddressEnumeratorClass),
            "::",
            stringify!(_g_reserved2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GProxyAddressEnumeratorClass>()))._g_reserved3 as *const _
                as usize
        },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(_GProxyAddressEnumeratorClass),
            "::",
            stringify!(_g_reserved3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GProxyAddressEnumeratorClass>()))._g_reserved4 as *const _
                as usize
        },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(_GProxyAddressEnumeratorClass),
            "::",
            stringify!(_g_reserved4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GProxyAddressEnumeratorClass>()))._g_reserved5 as *const _
                as usize
        },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(_GProxyAddressEnumeratorClass),
            "::",
            stringify!(_g_reserved5)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GProxyAddressEnumeratorClass>()))._g_reserved6 as *const _
                as usize
        },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(_GProxyAddressEnumeratorClass),
            "::",
            stringify!(_g_reserved6)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GProxyAddressEnumeratorClass>()))._g_reserved7 as *const _
                as usize
        },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(_GProxyAddressEnumeratorClass),
            "::",
            stringify!(_g_reserved7)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_g_proxy_address_enumerator_get_type"]
    pub fn g_proxy_address_enumerator_get_type() -> GType;
}
pub type GProxyResolverInterface = _GProxyResolverInterface;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GProxyResolverInterface {
    pub g_iface: GTypeInterface,
    pub is_supported:
        ::std::option::Option<unsafe extern "C" fn(resolver: *mut GProxyResolver) -> gboolean>,
    pub lookup: ::std::option::Option<
        unsafe extern "C" fn(
            resolver: *mut GProxyResolver,
            uri: *const gchar,
            cancellable: *mut GCancellable,
            error: *mut *mut GError,
        ) -> *mut *mut gchar,
    >,
    pub lookup_async: ::std::option::Option<
        unsafe extern "C" fn(
            resolver: *mut GProxyResolver,
            uri: *const gchar,
            cancellable: *mut GCancellable,
            callback: GAsyncReadyCallback,
            user_data: gpointer,
        ),
    >,
    pub lookup_finish: ::std::option::Option<
        unsafe extern "C" fn(
            resolver: *mut GProxyResolver,
            result: *mut GAsyncResult,
            error: *mut *mut GError,
        ) -> *mut *mut gchar,
    >,
}
#[test]
fn bindgen_test_layout__GProxyResolverInterface() {
    assert_eq!(
        ::std::mem::size_of::<_GProxyResolverInterface>(),
        48usize,
        concat!("Size of: ", stringify!(_GProxyResolverInterface))
    );
    assert_eq!(
        ::std::mem::align_of::<_GProxyResolverInterface>(),
        8usize,
        concat!("Alignment of ", stringify!(_GProxyResolverInterface))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GProxyResolverInterface>())).g_iface as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GProxyResolverInterface),
            "::",
            stringify!(g_iface)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GProxyResolverInterface>())).is_supported as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GProxyResolverInterface),
            "::",
            stringify!(is_supported)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GProxyResolverInterface>())).lookup as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GProxyResolverInterface),
            "::",
            stringify!(lookup)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GProxyResolverInterface>())).lookup_async as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_GProxyResolverInterface),
            "::",
            stringify!(lookup_async)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GProxyResolverInterface>())).lookup_finish as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_GProxyResolverInterface),
            "::",
            stringify!(lookup_finish)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_g_proxy_resolver_get_type"]
    pub fn g_proxy_resolver_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_proxy_resolver_get_default"]
    pub fn g_proxy_resolver_get_default() -> *mut GProxyResolver;
}
extern "C" {
    #[link_name = "\u{1}_g_proxy_resolver_is_supported"]
    pub fn g_proxy_resolver_is_supported(resolver: *mut GProxyResolver) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_proxy_resolver_lookup"]
    pub fn g_proxy_resolver_lookup(
        resolver: *mut GProxyResolver,
        uri: *const gchar,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> *mut *mut gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_proxy_resolver_lookup_async"]
    pub fn g_proxy_resolver_lookup_async(
        resolver: *mut GProxyResolver,
        uri: *const gchar,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_proxy_resolver_lookup_finish"]
    pub fn g_proxy_resolver_lookup_finish(
        resolver: *mut GProxyResolver,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> *mut *mut gchar;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GResolverPrivate {
    _unused: [u8; 0],
}
pub type GResolverPrivate = _GResolverPrivate;
pub type GResolverClass = _GResolverClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GResolver {
    pub parent_instance: GObject,
    pub priv_: *mut GResolverPrivate,
}
#[test]
fn bindgen_test_layout__GResolver() {
    assert_eq!(
        ::std::mem::size_of::<_GResolver>(),
        32usize,
        concat!("Size of: ", stringify!(_GResolver))
    );
    assert_eq!(
        ::std::mem::align_of::<_GResolver>(),
        8usize,
        concat!("Alignment of ", stringify!(_GResolver))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GResolver>())).parent_instance as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GResolver),
            "::",
            stringify!(parent_instance)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GResolver>())).priv_ as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GResolver),
            "::",
            stringify!(priv_)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GResolverClass {
    pub parent_class: GObjectClass,
    pub reload: ::std::option::Option<unsafe extern "C" fn(resolver: *mut GResolver)>,
    pub lookup_by_name: ::std::option::Option<
        unsafe extern "C" fn(
            resolver: *mut GResolver,
            hostname: *const gchar,
            cancellable: *mut GCancellable,
            error: *mut *mut GError,
        ) -> *mut GList,
    >,
    pub lookup_by_name_async: ::std::option::Option<
        unsafe extern "C" fn(
            resolver: *mut GResolver,
            hostname: *const gchar,
            cancellable: *mut GCancellable,
            callback: GAsyncReadyCallback,
            user_data: gpointer,
        ),
    >,
    pub lookup_by_name_finish: ::std::option::Option<
        unsafe extern "C" fn(
            resolver: *mut GResolver,
            result: *mut GAsyncResult,
            error: *mut *mut GError,
        ) -> *mut GList,
    >,
    pub lookup_by_address: ::std::option::Option<
        unsafe extern "C" fn(
            resolver: *mut GResolver,
            address: *mut GInetAddress,
            cancellable: *mut GCancellable,
            error: *mut *mut GError,
        ) -> *mut gchar,
    >,
    pub lookup_by_address_async: ::std::option::Option<
        unsafe extern "C" fn(
            resolver: *mut GResolver,
            address: *mut GInetAddress,
            cancellable: *mut GCancellable,
            callback: GAsyncReadyCallback,
            user_data: gpointer,
        ),
    >,
    pub lookup_by_address_finish: ::std::option::Option<
        unsafe extern "C" fn(
            resolver: *mut GResolver,
            result: *mut GAsyncResult,
            error: *mut *mut GError,
        ) -> *mut gchar,
    >,
    pub lookup_service: ::std::option::Option<
        unsafe extern "C" fn(
            resolver: *mut GResolver,
            rrname: *const gchar,
            cancellable: *mut GCancellable,
            error: *mut *mut GError,
        ) -> *mut GList,
    >,
    pub lookup_service_async: ::std::option::Option<
        unsafe extern "C" fn(
            resolver: *mut GResolver,
            rrname: *const gchar,
            cancellable: *mut GCancellable,
            callback: GAsyncReadyCallback,
            user_data: gpointer,
        ),
    >,
    pub lookup_service_finish: ::std::option::Option<
        unsafe extern "C" fn(
            resolver: *mut GResolver,
            result: *mut GAsyncResult,
            error: *mut *mut GError,
        ) -> *mut GList,
    >,
    pub lookup_records: ::std::option::Option<
        unsafe extern "C" fn(
            resolver: *mut GResolver,
            rrname: *const gchar,
            record_type: GResolverRecordType,
            cancellable: *mut GCancellable,
            error: *mut *mut GError,
        ) -> *mut GList,
    >,
    pub lookup_records_async: ::std::option::Option<
        unsafe extern "C" fn(
            resolver: *mut GResolver,
            rrname: *const gchar,
            record_type: GResolverRecordType,
            cancellable: *mut GCancellable,
            callback: GAsyncReadyCallback,
            user_data: gpointer,
        ),
    >,
    pub lookup_records_finish: ::std::option::Option<
        unsafe extern "C" fn(
            resolver: *mut GResolver,
            result: *mut GAsyncResult,
            error: *mut *mut GError,
        ) -> *mut GList,
    >,
    pub _g_reserved4: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved5: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved6: ::std::option::Option<unsafe extern "C" fn()>,
}
#[test]
fn bindgen_test_layout__GResolverClass() {
    assert_eq!(
        ::std::mem::size_of::<_GResolverClass>(),
        264usize,
        concat!("Size of: ", stringify!(_GResolverClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_GResolverClass>(),
        8usize,
        concat!("Alignment of ", stringify!(_GResolverClass))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GResolverClass>())).parent_class as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GResolverClass),
            "::",
            stringify!(parent_class)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GResolverClass>())).reload as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_GResolverClass),
            "::",
            stringify!(reload)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GResolverClass>())).lookup_by_name as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_GResolverClass),
            "::",
            stringify!(lookup_by_name)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GResolverClass>())).lookup_by_name_async as *const _ as usize
        },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(_GResolverClass),
            "::",
            stringify!(lookup_by_name_async)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GResolverClass>())).lookup_by_name_finish as *const _ as usize
        },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_GResolverClass),
            "::",
            stringify!(lookup_by_name_finish)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GResolverClass>())).lookup_by_address as *const _ as usize
        },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(_GResolverClass),
            "::",
            stringify!(lookup_by_address)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GResolverClass>())).lookup_by_address_async as *const _ as usize
        },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(_GResolverClass),
            "::",
            stringify!(lookup_by_address_async)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GResolverClass>())).lookup_by_address_finish as *const _
                as usize
        },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(_GResolverClass),
            "::",
            stringify!(lookup_by_address_finish)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GResolverClass>())).lookup_service as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(_GResolverClass),
            "::",
            stringify!(lookup_service)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GResolverClass>())).lookup_service_async as *const _ as usize
        },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(_GResolverClass),
            "::",
            stringify!(lookup_service_async)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GResolverClass>())).lookup_service_finish as *const _ as usize
        },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(_GResolverClass),
            "::",
            stringify!(lookup_service_finish)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GResolverClass>())).lookup_records as *const _ as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(_GResolverClass),
            "::",
            stringify!(lookup_records)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GResolverClass>())).lookup_records_async as *const _ as usize
        },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(_GResolverClass),
            "::",
            stringify!(lookup_records_async)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GResolverClass>())).lookup_records_finish as *const _ as usize
        },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(_GResolverClass),
            "::",
            stringify!(lookup_records_finish)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GResolverClass>()))._g_reserved4 as *const _ as usize },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(_GResolverClass),
            "::",
            stringify!(_g_reserved4)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GResolverClass>()))._g_reserved5 as *const _ as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(_GResolverClass),
            "::",
            stringify!(_g_reserved5)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GResolverClass>()))._g_reserved6 as *const _ as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(_GResolverClass),
            "::",
            stringify!(_g_reserved6)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_g_resolver_get_type"]
    pub fn g_resolver_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_resolver_get_default"]
    pub fn g_resolver_get_default() -> *mut GResolver;
}
extern "C" {
    #[link_name = "\u{1}_g_resolver_set_default"]
    pub fn g_resolver_set_default(resolver: *mut GResolver);
}
extern "C" {
    #[link_name = "\u{1}_g_resolver_lookup_by_name"]
    pub fn g_resolver_lookup_by_name(
        resolver: *mut GResolver,
        hostname: *const gchar,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> *mut GList;
}
extern "C" {
    #[link_name = "\u{1}_g_resolver_lookup_by_name_async"]
    pub fn g_resolver_lookup_by_name_async(
        resolver: *mut GResolver,
        hostname: *const gchar,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_resolver_lookup_by_name_finish"]
    pub fn g_resolver_lookup_by_name_finish(
        resolver: *mut GResolver,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> *mut GList;
}
extern "C" {
    #[link_name = "\u{1}_g_resolver_free_addresses"]
    pub fn g_resolver_free_addresses(addresses: *mut GList);
}
extern "C" {
    #[link_name = "\u{1}_g_resolver_lookup_by_address"]
    pub fn g_resolver_lookup_by_address(
        resolver: *mut GResolver,
        address: *mut GInetAddress,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> *mut gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_resolver_lookup_by_address_async"]
    pub fn g_resolver_lookup_by_address_async(
        resolver: *mut GResolver,
        address: *mut GInetAddress,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_resolver_lookup_by_address_finish"]
    pub fn g_resolver_lookup_by_address_finish(
        resolver: *mut GResolver,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> *mut gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_resolver_lookup_service"]
    pub fn g_resolver_lookup_service(
        resolver: *mut GResolver,
        service: *const gchar,
        protocol: *const gchar,
        domain: *const gchar,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> *mut GList;
}
extern "C" {
    #[link_name = "\u{1}_g_resolver_lookup_service_async"]
    pub fn g_resolver_lookup_service_async(
        resolver: *mut GResolver,
        service: *const gchar,
        protocol: *const gchar,
        domain: *const gchar,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_resolver_lookup_service_finish"]
    pub fn g_resolver_lookup_service_finish(
        resolver: *mut GResolver,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> *mut GList;
}
extern "C" {
    #[link_name = "\u{1}_g_resolver_lookup_records"]
    pub fn g_resolver_lookup_records(
        resolver: *mut GResolver,
        rrname: *const gchar,
        record_type: GResolverRecordType,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> *mut GList;
}
extern "C" {
    #[link_name = "\u{1}_g_resolver_lookup_records_async"]
    pub fn g_resolver_lookup_records_async(
        resolver: *mut GResolver,
        rrname: *const gchar,
        record_type: GResolverRecordType,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_resolver_lookup_records_finish"]
    pub fn g_resolver_lookup_records_finish(
        resolver: *mut GResolver,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> *mut GList;
}
extern "C" {
    #[link_name = "\u{1}_g_resolver_free_targets"]
    pub fn g_resolver_free_targets(targets: *mut GList);
}
extern "C" {
    #[link_name = "\u{1}_g_resolver_error_quark"]
    pub fn g_resolver_error_quark() -> GQuark;
}
extern "C" {
    #[link_name = "\u{1}_g_resource_error_quark"]
    pub fn g_resource_error_quark() -> GQuark;
}
pub type GStaticResource = _GStaticResource;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GStaticResource {
    pub data: *const guint8,
    pub data_len: gsize,
    pub resource: *mut GResource,
    pub next: *mut GStaticResource,
    pub padding: gpointer,
}
#[test]
fn bindgen_test_layout__GStaticResource() {
    assert_eq!(
        ::std::mem::size_of::<_GStaticResource>(),
        40usize,
        concat!("Size of: ", stringify!(_GStaticResource))
    );
    assert_eq!(
        ::std::mem::align_of::<_GStaticResource>(),
        8usize,
        concat!("Alignment of ", stringify!(_GStaticResource))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GStaticResource>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GStaticResource),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GStaticResource>())).data_len as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GStaticResource),
            "::",
            stringify!(data_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GStaticResource>())).resource as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GStaticResource),
            "::",
            stringify!(resource)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GStaticResource>())).next as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GStaticResource),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GStaticResource>())).padding as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_GStaticResource),
            "::",
            stringify!(padding)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_g_resource_get_type"]
    pub fn g_resource_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_resource_new_from_data"]
    pub fn g_resource_new_from_data(data: *mut GBytes, error: *mut *mut GError) -> *mut GResource;
}
extern "C" {
    #[link_name = "\u{1}_g_resource_ref"]
    pub fn g_resource_ref(resource: *mut GResource) -> *mut GResource;
}
extern "C" {
    #[link_name = "\u{1}_g_resource_unref"]
    pub fn g_resource_unref(resource: *mut GResource);
}
extern "C" {
    #[link_name = "\u{1}_g_resource_load"]
    pub fn g_resource_load(filename: *const gchar, error: *mut *mut GError) -> *mut GResource;
}
extern "C" {
    #[link_name = "\u{1}_g_resource_open_stream"]
    pub fn g_resource_open_stream(
        resource: *mut GResource,
        path: *const ::std::os::raw::c_char,
        lookup_flags: GResourceLookupFlags,
        error: *mut *mut GError,
    ) -> *mut GInputStream;
}
extern "C" {
    #[link_name = "\u{1}_g_resource_lookup_data"]
    pub fn g_resource_lookup_data(
        resource: *mut GResource,
        path: *const ::std::os::raw::c_char,
        lookup_flags: GResourceLookupFlags,
        error: *mut *mut GError,
    ) -> *mut GBytes;
}
extern "C" {
    #[link_name = "\u{1}_g_resource_enumerate_children"]
    pub fn g_resource_enumerate_children(
        resource: *mut GResource,
        path: *const ::std::os::raw::c_char,
        lookup_flags: GResourceLookupFlags,
        error: *mut *mut GError,
    ) -> *mut *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_g_resource_get_info"]
    pub fn g_resource_get_info(
        resource: *mut GResource,
        path: *const ::std::os::raw::c_char,
        lookup_flags: GResourceLookupFlags,
        size: *mut gsize,
        flags: *mut guint32,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_resources_register"]
    pub fn g_resources_register(resource: *mut GResource);
}
extern "C" {
    #[link_name = "\u{1}_g_resources_unregister"]
    pub fn g_resources_unregister(resource: *mut GResource);
}
extern "C" {
    #[link_name = "\u{1}_g_resources_open_stream"]
    pub fn g_resources_open_stream(
        path: *const ::std::os::raw::c_char,
        lookup_flags: GResourceLookupFlags,
        error: *mut *mut GError,
    ) -> *mut GInputStream;
}
extern "C" {
    #[link_name = "\u{1}_g_resources_lookup_data"]
    pub fn g_resources_lookup_data(
        path: *const ::std::os::raw::c_char,
        lookup_flags: GResourceLookupFlags,
        error: *mut *mut GError,
    ) -> *mut GBytes;
}
extern "C" {
    #[link_name = "\u{1}_g_resources_enumerate_children"]
    pub fn g_resources_enumerate_children(
        path: *const ::std::os::raw::c_char,
        lookup_flags: GResourceLookupFlags,
        error: *mut *mut GError,
    ) -> *mut *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_g_resources_get_info"]
    pub fn g_resources_get_info(
        path: *const ::std::os::raw::c_char,
        lookup_flags: GResourceLookupFlags,
        size: *mut gsize,
        flags: *mut guint32,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_static_resource_init"]
    pub fn g_static_resource_init(static_resource: *mut GStaticResource);
}
extern "C" {
    #[link_name = "\u{1}_g_static_resource_fini"]
    pub fn g_static_resource_fini(static_resource: *mut GStaticResource);
}
extern "C" {
    #[link_name = "\u{1}_g_static_resource_get_resource"]
    pub fn g_static_resource_get_resource(static_resource: *mut GStaticResource) -> *mut GResource;
}
/// GSeekable:
///
/// Seek object for streaming operations.
pub type GSeekableIface = _GSeekableIface;
/// GSeekableIface:
/// @g_iface: The parent interface.
/// @tell: Tells the current location within a stream.
/// @can_seek: Checks if seeking is supported by the stream.
/// @seek: Seeks to a location within a stream.
/// @can_truncate: Checks if truncation is supported by the stream.
/// @truncate_fn: Truncates a stream.
///
/// Provides an interface for implementing seekable functionality on I/O Streams.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GSeekableIface {
    pub g_iface: GTypeInterface,
    pub tell: ::std::option::Option<unsafe extern "C" fn(seekable: *mut GSeekable) -> goffset>,
    pub can_seek: ::std::option::Option<unsafe extern "C" fn(seekable: *mut GSeekable) -> gboolean>,
    pub seek: ::std::option::Option<
        unsafe extern "C" fn(
            seekable: *mut GSeekable,
            offset: goffset,
            type_: GSeekType,
            cancellable: *mut GCancellable,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
    pub can_truncate:
        ::std::option::Option<unsafe extern "C" fn(seekable: *mut GSeekable) -> gboolean>,
    pub truncate_fn: ::std::option::Option<
        unsafe extern "C" fn(
            seekable: *mut GSeekable,
            offset: goffset,
            cancellable: *mut GCancellable,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
}
#[test]
fn bindgen_test_layout__GSeekableIface() {
    assert_eq!(
        ::std::mem::size_of::<_GSeekableIface>(),
        56usize,
        concat!("Size of: ", stringify!(_GSeekableIface))
    );
    assert_eq!(
        ::std::mem::align_of::<_GSeekableIface>(),
        8usize,
        concat!("Alignment of ", stringify!(_GSeekableIface))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GSeekableIface>())).g_iface as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSeekableIface),
            "::",
            stringify!(g_iface)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GSeekableIface>())).tell as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSeekableIface),
            "::",
            stringify!(tell)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GSeekableIface>())).can_seek as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSeekableIface),
            "::",
            stringify!(can_seek)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GSeekableIface>())).seek as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSeekableIface),
            "::",
            stringify!(seek)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GSeekableIface>())).can_truncate as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSeekableIface),
            "::",
            stringify!(can_truncate)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GSeekableIface>())).truncate_fn as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSeekableIface),
            "::",
            stringify!(truncate_fn)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_g_seekable_get_type"]
    pub fn g_seekable_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_seekable_tell"]
    pub fn g_seekable_tell(seekable: *mut GSeekable) -> goffset;
}
extern "C" {
    #[link_name = "\u{1}_g_seekable_can_seek"]
    pub fn g_seekable_can_seek(seekable: *mut GSeekable) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_seekable_seek"]
    pub fn g_seekable_seek(
        seekable: *mut GSeekable,
        offset: goffset,
        type_: GSeekType,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_seekable_can_truncate"]
    pub fn g_seekable_can_truncate(seekable: *mut GSeekable) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_seekable_truncate"]
    pub fn g_seekable_truncate(
        seekable: *mut GSeekable,
        offset: goffset,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gboolean;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GSettingsSchemaSource {
    _unused: [u8; 0],
}
pub type GSettingsSchemaSource = _GSettingsSchemaSource;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GSettingsSchema {
    _unused: [u8; 0],
}
pub type GSettingsSchema = _GSettingsSchema;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GSettingsSchemaKey {
    _unused: [u8; 0],
}
pub type GSettingsSchemaKey = _GSettingsSchemaKey;
extern "C" {
    #[link_name = "\u{1}_g_settings_schema_source_get_type"]
    pub fn g_settings_schema_source_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_settings_schema_source_get_default"]
    pub fn g_settings_schema_source_get_default() -> *mut GSettingsSchemaSource;
}
extern "C" {
    #[link_name = "\u{1}_g_settings_schema_source_ref"]
    pub fn g_settings_schema_source_ref(
        source: *mut GSettingsSchemaSource,
    ) -> *mut GSettingsSchemaSource;
}
extern "C" {
    #[link_name = "\u{1}_g_settings_schema_source_unref"]
    pub fn g_settings_schema_source_unref(source: *mut GSettingsSchemaSource);
}
extern "C" {
    #[link_name = "\u{1}_g_settings_schema_source_new_from_directory"]
    pub fn g_settings_schema_source_new_from_directory(
        directory: *const gchar,
        parent: *mut GSettingsSchemaSource,
        trusted: gboolean,
        error: *mut *mut GError,
    ) -> *mut GSettingsSchemaSource;
}
extern "C" {
    #[link_name = "\u{1}_g_settings_schema_source_lookup"]
    pub fn g_settings_schema_source_lookup(
        source: *mut GSettingsSchemaSource,
        schema_id: *const gchar,
        recursive: gboolean,
    ) -> *mut GSettingsSchema;
}
extern "C" {
    #[link_name = "\u{1}_g_settings_schema_source_list_schemas"]
    pub fn g_settings_schema_source_list_schemas(
        source: *mut GSettingsSchemaSource,
        recursive: gboolean,
        non_relocatable: *mut *mut *mut gchar,
        relocatable: *mut *mut *mut gchar,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_settings_schema_get_type"]
    pub fn g_settings_schema_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_settings_schema_ref"]
    pub fn g_settings_schema_ref(schema: *mut GSettingsSchema) -> *mut GSettingsSchema;
}
extern "C" {
    #[link_name = "\u{1}_g_settings_schema_unref"]
    pub fn g_settings_schema_unref(schema: *mut GSettingsSchema);
}
extern "C" {
    #[link_name = "\u{1}_g_settings_schema_get_id"]
    pub fn g_settings_schema_get_id(schema: *mut GSettingsSchema) -> *const gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_settings_schema_get_path"]
    pub fn g_settings_schema_get_path(schema: *mut GSettingsSchema) -> *const gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_settings_schema_get_key"]
    pub fn g_settings_schema_get_key(
        schema: *mut GSettingsSchema,
        name: *const gchar,
    ) -> *mut GSettingsSchemaKey;
}
extern "C" {
    #[link_name = "\u{1}_g_settings_schema_has_key"]
    pub fn g_settings_schema_has_key(schema: *mut GSettingsSchema, name: *const gchar) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_settings_schema_list_keys"]
    pub fn g_settings_schema_list_keys(schema: *mut GSettingsSchema) -> *mut *mut gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_settings_schema_list_children"]
    pub fn g_settings_schema_list_children(schema: *mut GSettingsSchema) -> *mut *mut gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_settings_schema_key_get_type"]
    pub fn g_settings_schema_key_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_settings_schema_key_ref"]
    pub fn g_settings_schema_key_ref(key: *mut GSettingsSchemaKey) -> *mut GSettingsSchemaKey;
}
extern "C" {
    #[link_name = "\u{1}_g_settings_schema_key_unref"]
    pub fn g_settings_schema_key_unref(key: *mut GSettingsSchemaKey);
}
extern "C" {
    #[link_name = "\u{1}_g_settings_schema_key_get_value_type"]
    pub fn g_settings_schema_key_get_value_type(
        key: *mut GSettingsSchemaKey,
    ) -> *const GVariantType;
}
extern "C" {
    #[link_name = "\u{1}_g_settings_schema_key_get_default_value"]
    pub fn g_settings_schema_key_get_default_value(key: *mut GSettingsSchemaKey) -> *mut GVariant;
}
extern "C" {
    #[link_name = "\u{1}_g_settings_schema_key_get_range"]
    pub fn g_settings_schema_key_get_range(key: *mut GSettingsSchemaKey) -> *mut GVariant;
}
extern "C" {
    #[link_name = "\u{1}_g_settings_schema_key_range_check"]
    pub fn g_settings_schema_key_range_check(
        key: *mut GSettingsSchemaKey,
        value: *mut GVariant,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_settings_schema_key_get_name"]
    pub fn g_settings_schema_key_get_name(key: *mut GSettingsSchemaKey) -> *const gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_settings_schema_key_get_summary"]
    pub fn g_settings_schema_key_get_summary(key: *mut GSettingsSchemaKey) -> *const gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_settings_schema_key_get_description"]
    pub fn g_settings_schema_key_get_description(key: *mut GSettingsSchemaKey) -> *const gchar;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GSettingsPrivate {
    _unused: [u8; 0],
}
pub type GSettingsPrivate = _GSettingsPrivate;
pub type GSettingsClass = _GSettingsClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GSettingsClass {
    pub parent_class: GObjectClass,
    pub writable_changed:
        ::std::option::Option<unsafe extern "C" fn(settings: *mut GSettings, key: *const gchar)>,
    pub changed:
        ::std::option::Option<unsafe extern "C" fn(settings: *mut GSettings, key: *const gchar)>,
    pub writable_change_event: ::std::option::Option<
        unsafe extern "C" fn(settings: *mut GSettings, key: GQuark) -> gboolean,
    >,
    pub change_event: ::std::option::Option<
        unsafe extern "C" fn(settings: *mut GSettings, keys: *const GQuark, n_keys: gint)
            -> gboolean,
    >,
    pub padding: [gpointer; 20usize],
}
#[test]
fn bindgen_test_layout__GSettingsClass() {
    assert_eq!(
        ::std::mem::size_of::<_GSettingsClass>(),
        328usize,
        concat!("Size of: ", stringify!(_GSettingsClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_GSettingsClass>(),
        8usize,
        concat!("Alignment of ", stringify!(_GSettingsClass))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GSettingsClass>())).parent_class as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSettingsClass),
            "::",
            stringify!(parent_class)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GSettingsClass>())).writable_changed as *const _ as usize
        },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSettingsClass),
            "::",
            stringify!(writable_changed)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GSettingsClass>())).changed as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSettingsClass),
            "::",
            stringify!(changed)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GSettingsClass>())).writable_change_event as *const _ as usize
        },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSettingsClass),
            "::",
            stringify!(writable_change_event)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GSettingsClass>())).change_event as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSettingsClass),
            "::",
            stringify!(change_event)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GSettingsClass>())).padding as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSettingsClass),
            "::",
            stringify!(padding)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GSettings {
    pub parent_instance: GObject,
    pub priv_: *mut GSettingsPrivate,
}
#[test]
fn bindgen_test_layout__GSettings() {
    assert_eq!(
        ::std::mem::size_of::<_GSettings>(),
        32usize,
        concat!("Size of: ", stringify!(_GSettings))
    );
    assert_eq!(
        ::std::mem::align_of::<_GSettings>(),
        8usize,
        concat!("Alignment of ", stringify!(_GSettings))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GSettings>())).parent_instance as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSettings),
            "::",
            stringify!(parent_instance)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GSettings>())).priv_ as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSettings),
            "::",
            stringify!(priv_)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_g_settings_get_type"]
    pub fn g_settings_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_settings_list_schemas"]
    pub fn g_settings_list_schemas() -> *const *const gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_settings_list_relocatable_schemas"]
    pub fn g_settings_list_relocatable_schemas() -> *const *const gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_settings_new"]
    pub fn g_settings_new(schema_id: *const gchar) -> *mut GSettings;
}
extern "C" {
    #[link_name = "\u{1}_g_settings_new_with_path"]
    pub fn g_settings_new_with_path(schema_id: *const gchar, path: *const gchar) -> *mut GSettings;
}
extern "C" {
    #[link_name = "\u{1}_g_settings_new_with_backend"]
    pub fn g_settings_new_with_backend(
        schema_id: *const gchar,
        backend: *mut GSettingsBackend,
    ) -> *mut GSettings;
}
extern "C" {
    #[link_name = "\u{1}_g_settings_new_with_backend_and_path"]
    pub fn g_settings_new_with_backend_and_path(
        schema_id: *const gchar,
        backend: *mut GSettingsBackend,
        path: *const gchar,
    ) -> *mut GSettings;
}
extern "C" {
    #[link_name = "\u{1}_g_settings_new_full"]
    pub fn g_settings_new_full(
        schema: *mut GSettingsSchema,
        backend: *mut GSettingsBackend,
        path: *const gchar,
    ) -> *mut GSettings;
}
extern "C" {
    #[link_name = "\u{1}_g_settings_list_children"]
    pub fn g_settings_list_children(settings: *mut GSettings) -> *mut *mut gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_settings_list_keys"]
    pub fn g_settings_list_keys(settings: *mut GSettings) -> *mut *mut gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_settings_get_range"]
    pub fn g_settings_get_range(settings: *mut GSettings, key: *const gchar) -> *mut GVariant;
}
extern "C" {
    #[link_name = "\u{1}_g_settings_range_check"]
    pub fn g_settings_range_check(
        settings: *mut GSettings,
        key: *const gchar,
        value: *mut GVariant,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_settings_set_value"]
    pub fn g_settings_set_value(
        settings: *mut GSettings,
        key: *const gchar,
        value: *mut GVariant,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_settings_get_value"]
    pub fn g_settings_get_value(settings: *mut GSettings, key: *const gchar) -> *mut GVariant;
}
extern "C" {
    #[link_name = "\u{1}_g_settings_get_user_value"]
    pub fn g_settings_get_user_value(settings: *mut GSettings, key: *const gchar) -> *mut GVariant;
}
extern "C" {
    #[link_name = "\u{1}_g_settings_get_default_value"]
    pub fn g_settings_get_default_value(
        settings: *mut GSettings,
        key: *const gchar,
    ) -> *mut GVariant;
}
extern "C" {
    #[link_name = "\u{1}_g_settings_set"]
    pub fn g_settings_set(
        settings: *mut GSettings,
        key: *const gchar,
        format: *const gchar,
        ...
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_settings_get"]
    pub fn g_settings_get(settings: *mut GSettings, key: *const gchar, format: *const gchar, ...);
}
extern "C" {
    #[link_name = "\u{1}_g_settings_reset"]
    pub fn g_settings_reset(settings: *mut GSettings, key: *const gchar);
}
extern "C" {
    #[link_name = "\u{1}_g_settings_get_int"]
    pub fn g_settings_get_int(settings: *mut GSettings, key: *const gchar) -> gint;
}
extern "C" {
    #[link_name = "\u{1}_g_settings_set_int"]
    pub fn g_settings_set_int(settings: *mut GSettings, key: *const gchar, value: gint)
        -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_settings_get_int64"]
    pub fn g_settings_get_int64(settings: *mut GSettings, key: *const gchar) -> gint64;
}
extern "C" {
    #[link_name = "\u{1}_g_settings_set_int64"]
    pub fn g_settings_set_int64(
        settings: *mut GSettings,
        key: *const gchar,
        value: gint64,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_settings_get_uint"]
    pub fn g_settings_get_uint(settings: *mut GSettings, key: *const gchar) -> guint;
}
extern "C" {
    #[link_name = "\u{1}_g_settings_set_uint"]
    pub fn g_settings_set_uint(
        settings: *mut GSettings,
        key: *const gchar,
        value: guint,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_settings_get_uint64"]
    pub fn g_settings_get_uint64(settings: *mut GSettings, key: *const gchar) -> guint64;
}
extern "C" {
    #[link_name = "\u{1}_g_settings_set_uint64"]
    pub fn g_settings_set_uint64(
        settings: *mut GSettings,
        key: *const gchar,
        value: guint64,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_settings_get_string"]
    pub fn g_settings_get_string(settings: *mut GSettings, key: *const gchar) -> *mut gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_settings_set_string"]
    pub fn g_settings_set_string(
        settings: *mut GSettings,
        key: *const gchar,
        value: *const gchar,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_settings_get_boolean"]
    pub fn g_settings_get_boolean(settings: *mut GSettings, key: *const gchar) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_settings_set_boolean"]
    pub fn g_settings_set_boolean(
        settings: *mut GSettings,
        key: *const gchar,
        value: gboolean,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_settings_get_double"]
    pub fn g_settings_get_double(settings: *mut GSettings, key: *const gchar) -> gdouble;
}
extern "C" {
    #[link_name = "\u{1}_g_settings_set_double"]
    pub fn g_settings_set_double(
        settings: *mut GSettings,
        key: *const gchar,
        value: gdouble,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_settings_get_strv"]
    pub fn g_settings_get_strv(settings: *mut GSettings, key: *const gchar) -> *mut *mut gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_settings_set_strv"]
    pub fn g_settings_set_strv(
        settings: *mut GSettings,
        key: *const gchar,
        value: *const *const gchar,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_settings_get_enum"]
    pub fn g_settings_get_enum(settings: *mut GSettings, key: *const gchar) -> gint;
}
extern "C" {
    #[link_name = "\u{1}_g_settings_set_enum"]
    pub fn g_settings_set_enum(
        settings: *mut GSettings,
        key: *const gchar,
        value: gint,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_settings_get_flags"]
    pub fn g_settings_get_flags(settings: *mut GSettings, key: *const gchar) -> guint;
}
extern "C" {
    #[link_name = "\u{1}_g_settings_set_flags"]
    pub fn g_settings_set_flags(
        settings: *mut GSettings,
        key: *const gchar,
        value: guint,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_settings_get_child"]
    pub fn g_settings_get_child(settings: *mut GSettings, name: *const gchar) -> *mut GSettings;
}
extern "C" {
    #[link_name = "\u{1}_g_settings_is_writable"]
    pub fn g_settings_is_writable(settings: *mut GSettings, name: *const gchar) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_settings_delay"]
    pub fn g_settings_delay(settings: *mut GSettings);
}
extern "C" {
    #[link_name = "\u{1}_g_settings_apply"]
    pub fn g_settings_apply(settings: *mut GSettings);
}
extern "C" {
    #[link_name = "\u{1}_g_settings_revert"]
    pub fn g_settings_revert(settings: *mut GSettings);
}
extern "C" {
    #[link_name = "\u{1}_g_settings_get_has_unapplied"]
    pub fn g_settings_get_has_unapplied(settings: *mut GSettings) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_settings_sync"]
    pub fn g_settings_sync();
}
/// GSettingsBindSetMapping:
/// @value: a #GValue containing the property value to map
/// @expected_type: the #GVariantType to create
/// @user_data: user data that was specified when the binding was created
///
/// The type for the function that is used to convert an object property
/// value to a #GVariant for storing it in #GSettings.
///
/// Returns: a new #GVariant holding the data from @value,
/// or %NULL in case of an error
pub type GSettingsBindSetMapping = ::std::option::Option<
    unsafe extern "C" fn(
        value: *const GValue,
        expected_type: *const GVariantType,
        user_data: gpointer,
    ) -> *mut GVariant,
>;
/// GSettingsBindGetMapping:
/// @value: return location for the property value
/// @variant: the #GVariant
/// @user_data: user data that was specified when the binding was created
///
/// The type for the function that is used to convert from #GSettings to
/// an object property. The @value is already initialized to hold values
/// of the appropriate type.
///
/// Returns: %TRUE if the conversion succeeded, %FALSE in case of an error
pub type GSettingsBindGetMapping = ::std::option::Option<
    unsafe extern "C" fn(value: *mut GValue, variant: *mut GVariant, user_data: gpointer)
        -> gboolean,
>;
/// GSettingsGetMapping:
/// @value: the #GVariant to map, or %NULL
/// @result: (out): the result of the mapping
/// @user_data: (closure): the user data that was passed to
/// g_settings_get_mapped()
///
/// The type of the function that is used to convert from a value stored
/// in a #GSettings to a value that is useful to the application.
///
/// If the value is successfully mapped, the result should be stored at
/// @result and %TRUE returned.  If mapping fails (for example, if @value
/// is not in the right format) then %FALSE should be returned.
///
/// If @value is %NULL then it means that the mapping function is being
/// given a "last chance" to successfully return a valid value.  %TRUE
/// must be returned in this case.
///
/// Returns: %TRUE if the conversion succeeded, %FALSE in case of an error
pub type GSettingsGetMapping = ::std::option::Option<
    unsafe extern "C" fn(value: *mut GVariant, result: *mut gpointer, user_data: gpointer)
        -> gboolean,
>;
pub const GSettingsBindFlags_G_SETTINGS_BIND_DEFAULT: GSettingsBindFlags = 0;
pub const GSettingsBindFlags_G_SETTINGS_BIND_GET: GSettingsBindFlags = 1;
pub const GSettingsBindFlags_G_SETTINGS_BIND_SET: GSettingsBindFlags = 2;
pub const GSettingsBindFlags_G_SETTINGS_BIND_NO_SENSITIVITY: GSettingsBindFlags = 4;
pub const GSettingsBindFlags_G_SETTINGS_BIND_GET_NO_CHANGES: GSettingsBindFlags = 8;
pub const GSettingsBindFlags_G_SETTINGS_BIND_INVERT_BOOLEAN: GSettingsBindFlags = 16;
/// GSettingsBindFlags:
/// @G_SETTINGS_BIND_DEFAULT: Equivalent to `G_SETTINGS_BIND_GET|G_SETTINGS_BIND_SET`
/// @G_SETTINGS_BIND_GET: Update the #GObject property when the setting changes.
/// It is an error to use this flag if the property is not writable.
/// @G_SETTINGS_BIND_SET: Update the setting when the #GObject property changes.
/// It is an error to use this flag if the property is not readable.
/// @G_SETTINGS_BIND_NO_SENSITIVITY: Do not try to bind a "sensitivity" property to the writability of the setting
/// @G_SETTINGS_BIND_GET_NO_CHANGES: When set in addition to #G_SETTINGS_BIND_GET, set the #GObject property
/// value initially from the setting, but do not listen for changes of the setting
/// @G_SETTINGS_BIND_INVERT_BOOLEAN: When passed to g_settings_bind(), uses a pair of mapping functions that invert
/// the boolean value when mapping between the setting and the property.  The setting and property must both
/// be booleans.  You cannot pass this flag to g_settings_bind_with_mapping().
///
/// Flags used when creating a binding. These flags determine in which
/// direction the binding works. The default is to synchronize in both
/// directions.
pub type GSettingsBindFlags = u32;
extern "C" {
    #[link_name = "\u{1}_g_settings_bind"]
    pub fn g_settings_bind(
        settings: *mut GSettings,
        key: *const gchar,
        object: gpointer,
        property: *const gchar,
        flags: GSettingsBindFlags,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_settings_bind_with_mapping"]
    pub fn g_settings_bind_with_mapping(
        settings: *mut GSettings,
        key: *const gchar,
        object: gpointer,
        property: *const gchar,
        flags: GSettingsBindFlags,
        get_mapping: GSettingsBindGetMapping,
        set_mapping: GSettingsBindSetMapping,
        user_data: gpointer,
        destroy: GDestroyNotify,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_settings_bind_writable"]
    pub fn g_settings_bind_writable(
        settings: *mut GSettings,
        key: *const gchar,
        object: gpointer,
        property: *const gchar,
        inverted: gboolean,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_settings_unbind"]
    pub fn g_settings_unbind(object: gpointer, property: *const gchar);
}
extern "C" {
    #[link_name = "\u{1}_g_settings_create_action"]
    pub fn g_settings_create_action(settings: *mut GSettings, key: *const gchar) -> *mut GAction;
}
extern "C" {
    #[link_name = "\u{1}_g_settings_get_mapped"]
    pub fn g_settings_get_mapped(
        settings: *mut GSettings,
        key: *const gchar,
        mapping: GSettingsGetMapping,
        user_data: gpointer,
    ) -> gpointer;
}
extern "C" {
    #[link_name = "\u{1}_g_simple_action_get_type"]
    pub fn g_simple_action_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_simple_action_new"]
    pub fn g_simple_action_new(
        name: *const gchar,
        parameter_type: *const GVariantType,
    ) -> *mut GSimpleAction;
}
extern "C" {
    #[link_name = "\u{1}_g_simple_action_new_stateful"]
    pub fn g_simple_action_new_stateful(
        name: *const gchar,
        parameter_type: *const GVariantType,
        state: *mut GVariant,
    ) -> *mut GSimpleAction;
}
extern "C" {
    #[link_name = "\u{1}_g_simple_action_set_enabled"]
    pub fn g_simple_action_set_enabled(simple: *mut GSimpleAction, enabled: gboolean);
}
extern "C" {
    #[link_name = "\u{1}_g_simple_action_set_state"]
    pub fn g_simple_action_set_state(simple: *mut GSimpleAction, value: *mut GVariant);
}
extern "C" {
    #[link_name = "\u{1}_g_simple_action_set_state_hint"]
    pub fn g_simple_action_set_state_hint(simple: *mut GSimpleAction, state_hint: *mut GVariant);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GSimpleActionGroupPrivate {
    _unused: [u8; 0],
}
pub type GSimpleActionGroupPrivate = _GSimpleActionGroupPrivate;
pub type GSimpleActionGroupClass = _GSimpleActionGroupClass;
/// GSimpleActionGroup:
///
/// The #GSimpleActionGroup structure contains private data and should only be accessed using the provided API.
///
/// Since: 2.28
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GSimpleActionGroup {
    pub parent_instance: GObject,
    pub priv_: *mut GSimpleActionGroupPrivate,
}
#[test]
fn bindgen_test_layout__GSimpleActionGroup() {
    assert_eq!(
        ::std::mem::size_of::<_GSimpleActionGroup>(),
        32usize,
        concat!("Size of: ", stringify!(_GSimpleActionGroup))
    );
    assert_eq!(
        ::std::mem::align_of::<_GSimpleActionGroup>(),
        8usize,
        concat!("Alignment of ", stringify!(_GSimpleActionGroup))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GSimpleActionGroup>())).parent_instance as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSimpleActionGroup),
            "::",
            stringify!(parent_instance)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GSimpleActionGroup>())).priv_ as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSimpleActionGroup),
            "::",
            stringify!(priv_)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GSimpleActionGroupClass {
    pub parent_class: GObjectClass,
    pub padding: [gpointer; 12usize],
}
#[test]
fn bindgen_test_layout__GSimpleActionGroupClass() {
    assert_eq!(
        ::std::mem::size_of::<_GSimpleActionGroupClass>(),
        232usize,
        concat!("Size of: ", stringify!(_GSimpleActionGroupClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_GSimpleActionGroupClass>(),
        8usize,
        concat!("Alignment of ", stringify!(_GSimpleActionGroupClass))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GSimpleActionGroupClass>())).parent_class as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSimpleActionGroupClass),
            "::",
            stringify!(parent_class)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GSimpleActionGroupClass>())).padding as *const _ as usize
        },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSimpleActionGroupClass),
            "::",
            stringify!(padding)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_g_simple_action_group_get_type"]
    pub fn g_simple_action_group_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_simple_action_group_new"]
    pub fn g_simple_action_group_new() -> *mut GSimpleActionGroup;
}
extern "C" {
    #[link_name = "\u{1}_g_simple_action_group_lookup"]
    pub fn g_simple_action_group_lookup(
        simple: *mut GSimpleActionGroup,
        action_name: *const gchar,
    ) -> *mut GAction;
}
extern "C" {
    #[link_name = "\u{1}_g_simple_action_group_insert"]
    pub fn g_simple_action_group_insert(simple: *mut GSimpleActionGroup, action: *mut GAction);
}
extern "C" {
    #[link_name = "\u{1}_g_simple_action_group_remove"]
    pub fn g_simple_action_group_remove(simple: *mut GSimpleActionGroup, action_name: *const gchar);
}
extern "C" {
    #[link_name = "\u{1}_g_simple_action_group_add_entries"]
    pub fn g_simple_action_group_add_entries(
        simple: *mut GSimpleActionGroup,
        entries: *const GActionEntry,
        n_entries: gint,
        user_data: gpointer,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GSimpleAsyncResultClass {
    _unused: [u8; 0],
}
/// GSimpleAsyncResult:
///
/// A simple implementation of #GAsyncResult.
pub type GSimpleAsyncResultClass = _GSimpleAsyncResultClass;
extern "C" {
    #[link_name = "\u{1}_g_simple_async_result_get_type"]
    pub fn g_simple_async_result_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_simple_async_result_new"]
    pub fn g_simple_async_result_new(
        source_object: *mut GObject,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
        source_tag: gpointer,
    ) -> *mut GSimpleAsyncResult;
}
extern "C" {
    #[link_name = "\u{1}_g_simple_async_result_new_error"]
    pub fn g_simple_async_result_new_error(
        source_object: *mut GObject,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
        domain: GQuark,
        code: gint,
        format: *const ::std::os::raw::c_char,
        ...
    ) -> *mut GSimpleAsyncResult;
}
extern "C" {
    #[link_name = "\u{1}_g_simple_async_result_new_from_error"]
    pub fn g_simple_async_result_new_from_error(
        source_object: *mut GObject,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
        error: *const GError,
    ) -> *mut GSimpleAsyncResult;
}
extern "C" {
    #[link_name = "\u{1}_g_simple_async_result_new_take_error"]
    pub fn g_simple_async_result_new_take_error(
        source_object: *mut GObject,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
        error: *mut GError,
    ) -> *mut GSimpleAsyncResult;
}
extern "C" {
    #[link_name = "\u{1}_g_simple_async_result_set_op_res_gpointer"]
    pub fn g_simple_async_result_set_op_res_gpointer(
        simple: *mut GSimpleAsyncResult,
        op_res: gpointer,
        destroy_op_res: GDestroyNotify,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_simple_async_result_get_op_res_gpointer"]
    pub fn g_simple_async_result_get_op_res_gpointer(simple: *mut GSimpleAsyncResult) -> gpointer;
}
extern "C" {
    #[link_name = "\u{1}_g_simple_async_result_set_op_res_gssize"]
    pub fn g_simple_async_result_set_op_res_gssize(simple: *mut GSimpleAsyncResult, op_res: gssize);
}
extern "C" {
    #[link_name = "\u{1}_g_simple_async_result_get_op_res_gssize"]
    pub fn g_simple_async_result_get_op_res_gssize(simple: *mut GSimpleAsyncResult) -> gssize;
}
extern "C" {
    #[link_name = "\u{1}_g_simple_async_result_set_op_res_gboolean"]
    pub fn g_simple_async_result_set_op_res_gboolean(
        simple: *mut GSimpleAsyncResult,
        op_res: gboolean,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_simple_async_result_get_op_res_gboolean"]
    pub fn g_simple_async_result_get_op_res_gboolean(simple: *mut GSimpleAsyncResult) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_simple_async_result_set_check_cancellable"]
    pub fn g_simple_async_result_set_check_cancellable(
        simple: *mut GSimpleAsyncResult,
        check_cancellable: *mut GCancellable,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_simple_async_result_get_source_tag"]
    pub fn g_simple_async_result_get_source_tag(simple: *mut GSimpleAsyncResult) -> gpointer;
}
extern "C" {
    #[link_name = "\u{1}_g_simple_async_result_set_handle_cancellation"]
    pub fn g_simple_async_result_set_handle_cancellation(
        simple: *mut GSimpleAsyncResult,
        handle_cancellation: gboolean,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_simple_async_result_complete"]
    pub fn g_simple_async_result_complete(simple: *mut GSimpleAsyncResult);
}
extern "C" {
    #[link_name = "\u{1}_g_simple_async_result_complete_in_idle"]
    pub fn g_simple_async_result_complete_in_idle(simple: *mut GSimpleAsyncResult);
}
extern "C" {
    #[link_name = "\u{1}_g_simple_async_result_run_in_thread"]
    pub fn g_simple_async_result_run_in_thread(
        simple: *mut GSimpleAsyncResult,
        func: GSimpleAsyncThreadFunc,
        io_priority: ::std::os::raw::c_int,
        cancellable: *mut GCancellable,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_simple_async_result_set_from_error"]
    pub fn g_simple_async_result_set_from_error(
        simple: *mut GSimpleAsyncResult,
        error: *const GError,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_simple_async_result_take_error"]
    pub fn g_simple_async_result_take_error(simple: *mut GSimpleAsyncResult, error: *mut GError);
}
extern "C" {
    #[link_name = "\u{1}_g_simple_async_result_propagate_error"]
    pub fn g_simple_async_result_propagate_error(
        simple: *mut GSimpleAsyncResult,
        dest: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_simple_async_result_set_error"]
    pub fn g_simple_async_result_set_error(
        simple: *mut GSimpleAsyncResult,
        domain: GQuark,
        code: gint,
        format: *const ::std::os::raw::c_char,
        ...
    );
}
extern "C" {
    #[link_name = "\u{1}_g_simple_async_result_set_error_va"]
    pub fn g_simple_async_result_set_error_va(
        simple: *mut GSimpleAsyncResult,
        domain: GQuark,
        code: gint,
        format: *const ::std::os::raw::c_char,
        args: *mut __va_list_tag,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_simple_async_result_is_valid"]
    pub fn g_simple_async_result_is_valid(
        result: *mut GAsyncResult,
        source: *mut GObject,
        source_tag: gpointer,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_simple_async_report_error_in_idle"]
    pub fn g_simple_async_report_error_in_idle(
        object: *mut GObject,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
        domain: GQuark,
        code: gint,
        format: *const ::std::os::raw::c_char,
        ...
    );
}
extern "C" {
    #[link_name = "\u{1}_g_simple_async_report_gerror_in_idle"]
    pub fn g_simple_async_report_gerror_in_idle(
        object: *mut GObject,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
        error: *const GError,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_simple_async_report_take_gerror_in_idle"]
    pub fn g_simple_async_report_take_gerror_in_idle(
        object: *mut GObject,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
        error: *mut GError,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_simple_io_stream_get_type"]
    pub fn g_simple_io_stream_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_simple_io_stream_new"]
    pub fn g_simple_io_stream_new(
        input_stream: *mut GInputStream,
        output_stream: *mut GOutputStream,
    ) -> *mut GIOStream;
}
extern "C" {
    #[link_name = "\u{1}_g_simple_permission_get_type"]
    pub fn g_simple_permission_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_simple_permission_new"]
    pub fn g_simple_permission_new(allowed: gboolean) -> *mut GPermission;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GSocketClientPrivate {
    _unused: [u8; 0],
}
pub type GSocketClientPrivate = _GSocketClientPrivate;
pub type GSocketClientClass = _GSocketClientClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GSocketClientClass {
    pub parent_class: GObjectClass,
    pub event: ::std::option::Option<
        unsafe extern "C" fn(
            client: *mut GSocketClient,
            event: GSocketClientEvent,
            connectable: *mut GSocketConnectable,
            connection: *mut GIOStream,
        ),
    >,
    pub _g_reserved1: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved2: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved3: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved4: ::std::option::Option<unsafe extern "C" fn()>,
}
#[test]
fn bindgen_test_layout__GSocketClientClass() {
    assert_eq!(
        ::std::mem::size_of::<_GSocketClientClass>(),
        176usize,
        concat!("Size of: ", stringify!(_GSocketClientClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_GSocketClientClass>(),
        8usize,
        concat!("Alignment of ", stringify!(_GSocketClientClass))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GSocketClientClass>())).parent_class as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSocketClientClass),
            "::",
            stringify!(parent_class)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GSocketClientClass>())).event as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSocketClientClass),
            "::",
            stringify!(event)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GSocketClientClass>()))._g_reserved1 as *const _ as usize
        },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSocketClientClass),
            "::",
            stringify!(_g_reserved1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GSocketClientClass>()))._g_reserved2 as *const _ as usize
        },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSocketClientClass),
            "::",
            stringify!(_g_reserved2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GSocketClientClass>()))._g_reserved3 as *const _ as usize
        },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSocketClientClass),
            "::",
            stringify!(_g_reserved3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GSocketClientClass>()))._g_reserved4 as *const _ as usize
        },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSocketClientClass),
            "::",
            stringify!(_g_reserved4)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GSocketClient {
    pub parent_instance: GObject,
    pub priv_: *mut GSocketClientPrivate,
}
#[test]
fn bindgen_test_layout__GSocketClient() {
    assert_eq!(
        ::std::mem::size_of::<_GSocketClient>(),
        32usize,
        concat!("Size of: ", stringify!(_GSocketClient))
    );
    assert_eq!(
        ::std::mem::align_of::<_GSocketClient>(),
        8usize,
        concat!("Alignment of ", stringify!(_GSocketClient))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GSocketClient>())).parent_instance as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSocketClient),
            "::",
            stringify!(parent_instance)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GSocketClient>())).priv_ as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSocketClient),
            "::",
            stringify!(priv_)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_g_socket_client_get_type"]
    pub fn g_socket_client_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_socket_client_new"]
    pub fn g_socket_client_new() -> *mut GSocketClient;
}
extern "C" {
    #[link_name = "\u{1}_g_socket_client_get_family"]
    pub fn g_socket_client_get_family(client: *mut GSocketClient) -> GSocketFamily;
}
extern "C" {
    #[link_name = "\u{1}_g_socket_client_set_family"]
    pub fn g_socket_client_set_family(client: *mut GSocketClient, family: GSocketFamily);
}
extern "C" {
    #[link_name = "\u{1}_g_socket_client_get_socket_type"]
    pub fn g_socket_client_get_socket_type(client: *mut GSocketClient) -> GSocketType;
}
extern "C" {
    #[link_name = "\u{1}_g_socket_client_set_socket_type"]
    pub fn g_socket_client_set_socket_type(client: *mut GSocketClient, type_: GSocketType);
}
extern "C" {
    #[link_name = "\u{1}_g_socket_client_get_protocol"]
    pub fn g_socket_client_get_protocol(client: *mut GSocketClient) -> GSocketProtocol;
}
extern "C" {
    #[link_name = "\u{1}_g_socket_client_set_protocol"]
    pub fn g_socket_client_set_protocol(client: *mut GSocketClient, protocol: GSocketProtocol);
}
extern "C" {
    #[link_name = "\u{1}_g_socket_client_get_local_address"]
    pub fn g_socket_client_get_local_address(client: *mut GSocketClient) -> *mut GSocketAddress;
}
extern "C" {
    #[link_name = "\u{1}_g_socket_client_set_local_address"]
    pub fn g_socket_client_set_local_address(
        client: *mut GSocketClient,
        address: *mut GSocketAddress,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_socket_client_get_timeout"]
    pub fn g_socket_client_get_timeout(client: *mut GSocketClient) -> guint;
}
extern "C" {
    #[link_name = "\u{1}_g_socket_client_set_timeout"]
    pub fn g_socket_client_set_timeout(client: *mut GSocketClient, timeout: guint);
}
extern "C" {
    #[link_name = "\u{1}_g_socket_client_get_enable_proxy"]
    pub fn g_socket_client_get_enable_proxy(client: *mut GSocketClient) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_socket_client_set_enable_proxy"]
    pub fn g_socket_client_set_enable_proxy(client: *mut GSocketClient, enable: gboolean);
}
extern "C" {
    #[link_name = "\u{1}_g_socket_client_get_tls"]
    pub fn g_socket_client_get_tls(client: *mut GSocketClient) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_socket_client_set_tls"]
    pub fn g_socket_client_set_tls(client: *mut GSocketClient, tls: gboolean);
}
extern "C" {
    #[link_name = "\u{1}_g_socket_client_get_tls_validation_flags"]
    pub fn g_socket_client_get_tls_validation_flags(
        client: *mut GSocketClient,
    ) -> GTlsCertificateFlags;
}
extern "C" {
    #[link_name = "\u{1}_g_socket_client_set_tls_validation_flags"]
    pub fn g_socket_client_set_tls_validation_flags(
        client: *mut GSocketClient,
        flags: GTlsCertificateFlags,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_socket_client_get_proxy_resolver"]
    pub fn g_socket_client_get_proxy_resolver(client: *mut GSocketClient) -> *mut GProxyResolver;
}
extern "C" {
    #[link_name = "\u{1}_g_socket_client_set_proxy_resolver"]
    pub fn g_socket_client_set_proxy_resolver(
        client: *mut GSocketClient,
        proxy_resolver: *mut GProxyResolver,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_socket_client_connect"]
    pub fn g_socket_client_connect(
        client: *mut GSocketClient,
        connectable: *mut GSocketConnectable,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> *mut GSocketConnection;
}
extern "C" {
    #[link_name = "\u{1}_g_socket_client_connect_to_host"]
    pub fn g_socket_client_connect_to_host(
        client: *mut GSocketClient,
        host_and_port: *const gchar,
        default_port: guint16,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> *mut GSocketConnection;
}
extern "C" {
    #[link_name = "\u{1}_g_socket_client_connect_to_service"]
    pub fn g_socket_client_connect_to_service(
        client: *mut GSocketClient,
        domain: *const gchar,
        service: *const gchar,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> *mut GSocketConnection;
}
extern "C" {
    #[link_name = "\u{1}_g_socket_client_connect_to_uri"]
    pub fn g_socket_client_connect_to_uri(
        client: *mut GSocketClient,
        uri: *const gchar,
        default_port: guint16,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> *mut GSocketConnection;
}
extern "C" {
    #[link_name = "\u{1}_g_socket_client_connect_async"]
    pub fn g_socket_client_connect_async(
        client: *mut GSocketClient,
        connectable: *mut GSocketConnectable,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_socket_client_connect_finish"]
    pub fn g_socket_client_connect_finish(
        client: *mut GSocketClient,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> *mut GSocketConnection;
}
extern "C" {
    #[link_name = "\u{1}_g_socket_client_connect_to_host_async"]
    pub fn g_socket_client_connect_to_host_async(
        client: *mut GSocketClient,
        host_and_port: *const gchar,
        default_port: guint16,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_socket_client_connect_to_host_finish"]
    pub fn g_socket_client_connect_to_host_finish(
        client: *mut GSocketClient,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> *mut GSocketConnection;
}
extern "C" {
    #[link_name = "\u{1}_g_socket_client_connect_to_service_async"]
    pub fn g_socket_client_connect_to_service_async(
        client: *mut GSocketClient,
        domain: *const gchar,
        service: *const gchar,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_socket_client_connect_to_service_finish"]
    pub fn g_socket_client_connect_to_service_finish(
        client: *mut GSocketClient,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> *mut GSocketConnection;
}
extern "C" {
    #[link_name = "\u{1}_g_socket_client_connect_to_uri_async"]
    pub fn g_socket_client_connect_to_uri_async(
        client: *mut GSocketClient,
        uri: *const gchar,
        default_port: guint16,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_socket_client_connect_to_uri_finish"]
    pub fn g_socket_client_connect_to_uri_finish(
        client: *mut GSocketClient,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> *mut GSocketConnection;
}
extern "C" {
    #[link_name = "\u{1}_g_socket_client_add_application_proxy"]
    pub fn g_socket_client_add_application_proxy(
        client: *mut GSocketClient,
        protocol: *const gchar,
    );
}
/// GSocketConnectable:
///
/// Interface for objects that contain or generate #GSocketAddress<!-- -->es.
pub type GSocketConnectableIface = _GSocketConnectableIface;
/// GSocketConnectableIface:
/// @g_iface: The parent interface.
/// @enumerate: Creates a #GSocketAddressEnumerator
/// @proxy_enumerate: Creates a #GProxyAddressEnumerator
/// @to_string: Format the connectable’s address as a string for debugging.
/// Implementing this is optional. (Since: 2.48)
///
/// Provides an interface for returning a #GSocketAddressEnumerator
/// and #GProxyAddressEnumerator
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GSocketConnectableIface {
    pub g_iface: GTypeInterface,
    pub enumerate: ::std::option::Option<
        unsafe extern "C" fn(connectable: *mut GSocketConnectable) -> *mut GSocketAddressEnumerator,
    >,
    pub proxy_enumerate: ::std::option::Option<
        unsafe extern "C" fn(connectable: *mut GSocketConnectable) -> *mut GSocketAddressEnumerator,
    >,
    pub to_string: ::std::option::Option<
        unsafe extern "C" fn(connectable: *mut GSocketConnectable) -> *mut gchar,
    >,
}
#[test]
fn bindgen_test_layout__GSocketConnectableIface() {
    assert_eq!(
        ::std::mem::size_of::<_GSocketConnectableIface>(),
        40usize,
        concat!("Size of: ", stringify!(_GSocketConnectableIface))
    );
    assert_eq!(
        ::std::mem::align_of::<_GSocketConnectableIface>(),
        8usize,
        concat!("Alignment of ", stringify!(_GSocketConnectableIface))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GSocketConnectableIface>())).g_iface as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSocketConnectableIface),
            "::",
            stringify!(g_iface)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GSocketConnectableIface>())).enumerate as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSocketConnectableIface),
            "::",
            stringify!(enumerate)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GSocketConnectableIface>())).proxy_enumerate as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSocketConnectableIface),
            "::",
            stringify!(proxy_enumerate)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GSocketConnectableIface>())).to_string as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSocketConnectableIface),
            "::",
            stringify!(to_string)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_g_socket_connectable_get_type"]
    pub fn g_socket_connectable_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_socket_connectable_enumerate"]
    pub fn g_socket_connectable_enumerate(
        connectable: *mut GSocketConnectable,
    ) -> *mut GSocketAddressEnumerator;
}
extern "C" {
    #[link_name = "\u{1}_g_socket_connectable_proxy_enumerate"]
    pub fn g_socket_connectable_proxy_enumerate(
        connectable: *mut GSocketConnectable,
    ) -> *mut GSocketAddressEnumerator;
}
extern "C" {
    #[link_name = "\u{1}_g_socket_connectable_to_string"]
    pub fn g_socket_connectable_to_string(connectable: *mut GSocketConnectable) -> *mut gchar;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GSocketPrivate {
    _unused: [u8; 0],
}
pub type GSocketPrivate = _GSocketPrivate;
pub type GSocketClass = _GSocketClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GSocketClass {
    pub parent_class: GObjectClass,
    pub _g_reserved1: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved2: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved3: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved4: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved5: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved6: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved7: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved8: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved9: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved10: ::std::option::Option<unsafe extern "C" fn()>,
}
#[test]
fn bindgen_test_layout__GSocketClass() {
    assert_eq!(
        ::std::mem::size_of::<_GSocketClass>(),
        216usize,
        concat!("Size of: ", stringify!(_GSocketClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_GSocketClass>(),
        8usize,
        concat!("Alignment of ", stringify!(_GSocketClass))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GSocketClass>())).parent_class as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSocketClass),
            "::",
            stringify!(parent_class)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GSocketClass>()))._g_reserved1 as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSocketClass),
            "::",
            stringify!(_g_reserved1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GSocketClass>()))._g_reserved2 as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSocketClass),
            "::",
            stringify!(_g_reserved2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GSocketClass>()))._g_reserved3 as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSocketClass),
            "::",
            stringify!(_g_reserved3)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GSocketClass>()))._g_reserved4 as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSocketClass),
            "::",
            stringify!(_g_reserved4)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GSocketClass>()))._g_reserved5 as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSocketClass),
            "::",
            stringify!(_g_reserved5)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GSocketClass>()))._g_reserved6 as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSocketClass),
            "::",
            stringify!(_g_reserved6)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GSocketClass>()))._g_reserved7 as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSocketClass),
            "::",
            stringify!(_g_reserved7)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GSocketClass>()))._g_reserved8 as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSocketClass),
            "::",
            stringify!(_g_reserved8)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GSocketClass>()))._g_reserved9 as *const _ as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSocketClass),
            "::",
            stringify!(_g_reserved9)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GSocketClass>()))._g_reserved10 as *const _ as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSocketClass),
            "::",
            stringify!(_g_reserved10)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GSocket {
    pub parent_instance: GObject,
    pub priv_: *mut GSocketPrivate,
}
#[test]
fn bindgen_test_layout__GSocket() {
    assert_eq!(
        ::std::mem::size_of::<_GSocket>(),
        32usize,
        concat!("Size of: ", stringify!(_GSocket))
    );
    assert_eq!(
        ::std::mem::align_of::<_GSocket>(),
        8usize,
        concat!("Alignment of ", stringify!(_GSocket))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GSocket>())).parent_instance as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSocket),
            "::",
            stringify!(parent_instance)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GSocket>())).priv_ as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSocket),
            "::",
            stringify!(priv_)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_g_socket_get_type"]
    pub fn g_socket_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_socket_new"]
    pub fn g_socket_new(
        family: GSocketFamily,
        type_: GSocketType,
        protocol: GSocketProtocol,
        error: *mut *mut GError,
    ) -> *mut GSocket;
}
extern "C" {
    #[link_name = "\u{1}_g_socket_new_from_fd"]
    pub fn g_socket_new_from_fd(fd: gint, error: *mut *mut GError) -> *mut GSocket;
}
extern "C" {
    #[link_name = "\u{1}_g_socket_get_fd"]
    pub fn g_socket_get_fd(socket: *mut GSocket) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_g_socket_get_family"]
    pub fn g_socket_get_family(socket: *mut GSocket) -> GSocketFamily;
}
extern "C" {
    #[link_name = "\u{1}_g_socket_get_socket_type"]
    pub fn g_socket_get_socket_type(socket: *mut GSocket) -> GSocketType;
}
extern "C" {
    #[link_name = "\u{1}_g_socket_get_protocol"]
    pub fn g_socket_get_protocol(socket: *mut GSocket) -> GSocketProtocol;
}
extern "C" {
    #[link_name = "\u{1}_g_socket_get_local_address"]
    pub fn g_socket_get_local_address(
        socket: *mut GSocket,
        error: *mut *mut GError,
    ) -> *mut GSocketAddress;
}
extern "C" {
    #[link_name = "\u{1}_g_socket_get_remote_address"]
    pub fn g_socket_get_remote_address(
        socket: *mut GSocket,
        error: *mut *mut GError,
    ) -> *mut GSocketAddress;
}
extern "C" {
    #[link_name = "\u{1}_g_socket_set_blocking"]
    pub fn g_socket_set_blocking(socket: *mut GSocket, blocking: gboolean);
}
extern "C" {
    #[link_name = "\u{1}_g_socket_get_blocking"]
    pub fn g_socket_get_blocking(socket: *mut GSocket) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_socket_set_keepalive"]
    pub fn g_socket_set_keepalive(socket: *mut GSocket, keepalive: gboolean);
}
extern "C" {
    #[link_name = "\u{1}_g_socket_get_keepalive"]
    pub fn g_socket_get_keepalive(socket: *mut GSocket) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_socket_get_listen_backlog"]
    pub fn g_socket_get_listen_backlog(socket: *mut GSocket) -> gint;
}
extern "C" {
    #[link_name = "\u{1}_g_socket_set_listen_backlog"]
    pub fn g_socket_set_listen_backlog(socket: *mut GSocket, backlog: gint);
}
extern "C" {
    #[link_name = "\u{1}_g_socket_get_timeout"]
    pub fn g_socket_get_timeout(socket: *mut GSocket) -> guint;
}
extern "C" {
    #[link_name = "\u{1}_g_socket_set_timeout"]
    pub fn g_socket_set_timeout(socket: *mut GSocket, timeout: guint);
}
extern "C" {
    #[link_name = "\u{1}_g_socket_get_ttl"]
    pub fn g_socket_get_ttl(socket: *mut GSocket) -> guint;
}
extern "C" {
    #[link_name = "\u{1}_g_socket_set_ttl"]
    pub fn g_socket_set_ttl(socket: *mut GSocket, ttl: guint);
}
extern "C" {
    #[link_name = "\u{1}_g_socket_get_broadcast"]
    pub fn g_socket_get_broadcast(socket: *mut GSocket) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_socket_set_broadcast"]
    pub fn g_socket_set_broadcast(socket: *mut GSocket, broadcast: gboolean);
}
extern "C" {
    #[link_name = "\u{1}_g_socket_get_multicast_loopback"]
    pub fn g_socket_get_multicast_loopback(socket: *mut GSocket) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_socket_set_multicast_loopback"]
    pub fn g_socket_set_multicast_loopback(socket: *mut GSocket, loopback: gboolean);
}
extern "C" {
    #[link_name = "\u{1}_g_socket_get_multicast_ttl"]
    pub fn g_socket_get_multicast_ttl(socket: *mut GSocket) -> guint;
}
extern "C" {
    #[link_name = "\u{1}_g_socket_set_multicast_ttl"]
    pub fn g_socket_set_multicast_ttl(socket: *mut GSocket, ttl: guint);
}
extern "C" {
    #[link_name = "\u{1}_g_socket_is_connected"]
    pub fn g_socket_is_connected(socket: *mut GSocket) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_socket_bind"]
    pub fn g_socket_bind(
        socket: *mut GSocket,
        address: *mut GSocketAddress,
        allow_reuse: gboolean,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_socket_join_multicast_group"]
    pub fn g_socket_join_multicast_group(
        socket: *mut GSocket,
        group: *mut GInetAddress,
        source_specific: gboolean,
        iface: *const gchar,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_socket_leave_multicast_group"]
    pub fn g_socket_leave_multicast_group(
        socket: *mut GSocket,
        group: *mut GInetAddress,
        source_specific: gboolean,
        iface: *const gchar,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_socket_connect"]
    pub fn g_socket_connect(
        socket: *mut GSocket,
        address: *mut GSocketAddress,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_socket_check_connect_result"]
    pub fn g_socket_check_connect_result(socket: *mut GSocket, error: *mut *mut GError)
        -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_socket_get_available_bytes"]
    pub fn g_socket_get_available_bytes(socket: *mut GSocket) -> gssize;
}
extern "C" {
    #[link_name = "\u{1}_g_socket_condition_check"]
    pub fn g_socket_condition_check(socket: *mut GSocket, condition: GIOCondition) -> GIOCondition;
}
extern "C" {
    #[link_name = "\u{1}_g_socket_condition_wait"]
    pub fn g_socket_condition_wait(
        socket: *mut GSocket,
        condition: GIOCondition,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_socket_condition_timed_wait"]
    pub fn g_socket_condition_timed_wait(
        socket: *mut GSocket,
        condition: GIOCondition,
        timeout: gint64,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_socket_accept"]
    pub fn g_socket_accept(
        socket: *mut GSocket,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> *mut GSocket;
}
extern "C" {
    #[link_name = "\u{1}_g_socket_listen"]
    pub fn g_socket_listen(socket: *mut GSocket, error: *mut *mut GError) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_socket_receive"]
    pub fn g_socket_receive(
        socket: *mut GSocket,
        buffer: *mut gchar,
        size: gsize,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gssize;
}
extern "C" {
    #[link_name = "\u{1}_g_socket_receive_from"]
    pub fn g_socket_receive_from(
        socket: *mut GSocket,
        address: *mut *mut GSocketAddress,
        buffer: *mut gchar,
        size: gsize,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gssize;
}
extern "C" {
    #[link_name = "\u{1}_g_socket_send"]
    pub fn g_socket_send(
        socket: *mut GSocket,
        buffer: *const gchar,
        size: gsize,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gssize;
}
extern "C" {
    #[link_name = "\u{1}_g_socket_send_to"]
    pub fn g_socket_send_to(
        socket: *mut GSocket,
        address: *mut GSocketAddress,
        buffer: *const gchar,
        size: gsize,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gssize;
}
extern "C" {
    #[link_name = "\u{1}_g_socket_receive_message"]
    pub fn g_socket_receive_message(
        socket: *mut GSocket,
        address: *mut *mut GSocketAddress,
        vectors: *mut GInputVector,
        num_vectors: gint,
        messages: *mut *mut *mut GSocketControlMessage,
        num_messages: *mut gint,
        flags: *mut gint,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gssize;
}
extern "C" {
    #[link_name = "\u{1}_g_socket_send_message"]
    pub fn g_socket_send_message(
        socket: *mut GSocket,
        address: *mut GSocketAddress,
        vectors: *mut GOutputVector,
        num_vectors: gint,
        messages: *mut *mut GSocketControlMessage,
        num_messages: gint,
        flags: gint,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gssize;
}
extern "C" {
    #[link_name = "\u{1}_g_socket_receive_messages"]
    pub fn g_socket_receive_messages(
        socket: *mut GSocket,
        messages: *mut GInputMessage,
        num_messages: guint,
        flags: gint,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gint;
}
extern "C" {
    #[link_name = "\u{1}_g_socket_send_messages"]
    pub fn g_socket_send_messages(
        socket: *mut GSocket,
        messages: *mut GOutputMessage,
        num_messages: guint,
        flags: gint,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gint;
}
extern "C" {
    #[link_name = "\u{1}_g_socket_close"]
    pub fn g_socket_close(socket: *mut GSocket, error: *mut *mut GError) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_socket_shutdown"]
    pub fn g_socket_shutdown(
        socket: *mut GSocket,
        shutdown_read: gboolean,
        shutdown_write: gboolean,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_socket_is_closed"]
    pub fn g_socket_is_closed(socket: *mut GSocket) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_socket_create_source"]
    pub fn g_socket_create_source(
        socket: *mut GSocket,
        condition: GIOCondition,
        cancellable: *mut GCancellable,
    ) -> *mut GSource;
}
extern "C" {
    #[link_name = "\u{1}_g_socket_speaks_ipv4"]
    pub fn g_socket_speaks_ipv4(socket: *mut GSocket) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_socket_get_credentials"]
    pub fn g_socket_get_credentials(
        socket: *mut GSocket,
        error: *mut *mut GError,
    ) -> *mut GCredentials;
}
extern "C" {
    #[link_name = "\u{1}_g_socket_receive_with_blocking"]
    pub fn g_socket_receive_with_blocking(
        socket: *mut GSocket,
        buffer: *mut gchar,
        size: gsize,
        blocking: gboolean,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gssize;
}
extern "C" {
    #[link_name = "\u{1}_g_socket_send_with_blocking"]
    pub fn g_socket_send_with_blocking(
        socket: *mut GSocket,
        buffer: *const gchar,
        size: gsize,
        blocking: gboolean,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gssize;
}
extern "C" {
    #[link_name = "\u{1}_g_socket_get_option"]
    pub fn g_socket_get_option(
        socket: *mut GSocket,
        level: gint,
        optname: gint,
        value: *mut gint,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_socket_set_option"]
    pub fn g_socket_set_option(
        socket: *mut GSocket,
        level: gint,
        optname: gint,
        value: gint,
        error: *mut *mut GError,
    ) -> gboolean;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GSocketConnectionPrivate {
    _unused: [u8; 0],
}
pub type GSocketConnectionPrivate = _GSocketConnectionPrivate;
pub type GSocketConnectionClass = _GSocketConnectionClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GSocketConnectionClass {
    pub parent_class: GIOStreamClass,
    pub _g_reserved1: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved2: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved3: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved4: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved5: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved6: ::std::option::Option<unsafe extern "C" fn()>,
}
#[test]
fn bindgen_test_layout__GSocketConnectionClass() {
    assert_eq!(
        ::std::mem::size_of::<_GSocketConnectionClass>(),
        304usize,
        concat!("Size of: ", stringify!(_GSocketConnectionClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_GSocketConnectionClass>(),
        8usize,
        concat!("Alignment of ", stringify!(_GSocketConnectionClass))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GSocketConnectionClass>())).parent_class as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSocketConnectionClass),
            "::",
            stringify!(parent_class)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GSocketConnectionClass>()))._g_reserved1 as *const _ as usize
        },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSocketConnectionClass),
            "::",
            stringify!(_g_reserved1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GSocketConnectionClass>()))._g_reserved2 as *const _ as usize
        },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSocketConnectionClass),
            "::",
            stringify!(_g_reserved2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GSocketConnectionClass>()))._g_reserved3 as *const _ as usize
        },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSocketConnectionClass),
            "::",
            stringify!(_g_reserved3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GSocketConnectionClass>()))._g_reserved4 as *const _ as usize
        },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSocketConnectionClass),
            "::",
            stringify!(_g_reserved4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GSocketConnectionClass>()))._g_reserved5 as *const _ as usize
        },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSocketConnectionClass),
            "::",
            stringify!(_g_reserved5)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GSocketConnectionClass>()))._g_reserved6 as *const _ as usize
        },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSocketConnectionClass),
            "::",
            stringify!(_g_reserved6)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GSocketConnection {
    pub parent_instance: GIOStream,
    pub priv_: *mut GSocketConnectionPrivate,
}
#[test]
fn bindgen_test_layout__GSocketConnection() {
    assert_eq!(
        ::std::mem::size_of::<_GSocketConnection>(),
        40usize,
        concat!("Size of: ", stringify!(_GSocketConnection))
    );
    assert_eq!(
        ::std::mem::align_of::<_GSocketConnection>(),
        8usize,
        concat!("Alignment of ", stringify!(_GSocketConnection))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GSocketConnection>())).parent_instance as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSocketConnection),
            "::",
            stringify!(parent_instance)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GSocketConnection>())).priv_ as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSocketConnection),
            "::",
            stringify!(priv_)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_g_socket_connection_get_type"]
    pub fn g_socket_connection_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_socket_connection_is_connected"]
    pub fn g_socket_connection_is_connected(connection: *mut GSocketConnection) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_socket_connection_connect"]
    pub fn g_socket_connection_connect(
        connection: *mut GSocketConnection,
        address: *mut GSocketAddress,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_socket_connection_connect_async"]
    pub fn g_socket_connection_connect_async(
        connection: *mut GSocketConnection,
        address: *mut GSocketAddress,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_socket_connection_connect_finish"]
    pub fn g_socket_connection_connect_finish(
        connection: *mut GSocketConnection,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_socket_connection_get_socket"]
    pub fn g_socket_connection_get_socket(connection: *mut GSocketConnection) -> *mut GSocket;
}
extern "C" {
    #[link_name = "\u{1}_g_socket_connection_get_local_address"]
    pub fn g_socket_connection_get_local_address(
        connection: *mut GSocketConnection,
        error: *mut *mut GError,
    ) -> *mut GSocketAddress;
}
extern "C" {
    #[link_name = "\u{1}_g_socket_connection_get_remote_address"]
    pub fn g_socket_connection_get_remote_address(
        connection: *mut GSocketConnection,
        error: *mut *mut GError,
    ) -> *mut GSocketAddress;
}
extern "C" {
    #[link_name = "\u{1}_g_socket_connection_factory_register_type"]
    pub fn g_socket_connection_factory_register_type(
        g_type: GType,
        family: GSocketFamily,
        type_: GSocketType,
        protocol: gint,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_socket_connection_factory_lookup_type"]
    pub fn g_socket_connection_factory_lookup_type(
        family: GSocketFamily,
        type_: GSocketType,
        protocol_id: gint,
    ) -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_socket_connection_factory_create_connection"]
    pub fn g_socket_connection_factory_create_connection(
        socket: *mut GSocket,
    ) -> *mut GSocketConnection;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GSocketControlMessagePrivate {
    _unused: [u8; 0],
}
pub type GSocketControlMessagePrivate = _GSocketControlMessagePrivate;
pub type GSocketControlMessageClass = _GSocketControlMessageClass;
/// GSocketControlMessageClass:
/// @get_size: gets the size of the message.
/// @get_level: gets the protocol of the message.
/// @get_type: gets the protocol specific type of the message.
/// @serialize: Writes out the message data.
/// @deserialize: Tries to deserialize a message.
///
/// Class structure for #GSocketControlMessage.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GSocketControlMessageClass {
    pub parent_class: GObjectClass,
    pub get_size:
        ::std::option::Option<unsafe extern "C" fn(message: *mut GSocketControlMessage) -> gsize>,
    pub get_level: ::std::option::Option<
        unsafe extern "C" fn(message: *mut GSocketControlMessage) -> ::std::os::raw::c_int,
    >,
    pub get_type: ::std::option::Option<
        unsafe extern "C" fn(message: *mut GSocketControlMessage) -> ::std::os::raw::c_int,
    >,
    pub serialize: ::std::option::Option<
        unsafe extern "C" fn(message: *mut GSocketControlMessage, data: gpointer),
    >,
    pub deserialize: ::std::option::Option<
        unsafe extern "C" fn(
            level: ::std::os::raw::c_int,
            type_: ::std::os::raw::c_int,
            size: gsize,
            data: gpointer,
        ) -> *mut GSocketControlMessage,
    >,
    pub _g_reserved1: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved2: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved3: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved4: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved5: ::std::option::Option<unsafe extern "C" fn()>,
}
#[test]
fn bindgen_test_layout__GSocketControlMessageClass() {
    assert_eq!(
        ::std::mem::size_of::<_GSocketControlMessageClass>(),
        216usize,
        concat!("Size of: ", stringify!(_GSocketControlMessageClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_GSocketControlMessageClass>(),
        8usize,
        concat!("Alignment of ", stringify!(_GSocketControlMessageClass))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GSocketControlMessageClass>())).parent_class as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSocketControlMessageClass),
            "::",
            stringify!(parent_class)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GSocketControlMessageClass>())).get_size as *const _ as usize
        },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSocketControlMessageClass),
            "::",
            stringify!(get_size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GSocketControlMessageClass>())).get_level as *const _ as usize
        },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSocketControlMessageClass),
            "::",
            stringify!(get_level)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GSocketControlMessageClass>())).get_type as *const _ as usize
        },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSocketControlMessageClass),
            "::",
            stringify!(get_type)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GSocketControlMessageClass>())).serialize as *const _ as usize
        },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSocketControlMessageClass),
            "::",
            stringify!(serialize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GSocketControlMessageClass>())).deserialize as *const _ as usize
        },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSocketControlMessageClass),
            "::",
            stringify!(deserialize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GSocketControlMessageClass>()))._g_reserved1 as *const _
                as usize
        },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSocketControlMessageClass),
            "::",
            stringify!(_g_reserved1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GSocketControlMessageClass>()))._g_reserved2 as *const _
                as usize
        },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSocketControlMessageClass),
            "::",
            stringify!(_g_reserved2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GSocketControlMessageClass>()))._g_reserved3 as *const _
                as usize
        },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSocketControlMessageClass),
            "::",
            stringify!(_g_reserved3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GSocketControlMessageClass>()))._g_reserved4 as *const _
                as usize
        },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSocketControlMessageClass),
            "::",
            stringify!(_g_reserved4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GSocketControlMessageClass>()))._g_reserved5 as *const _
                as usize
        },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSocketControlMessageClass),
            "::",
            stringify!(_g_reserved5)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GSocketControlMessage {
    pub parent_instance: GObject,
    pub priv_: *mut GSocketControlMessagePrivate,
}
#[test]
fn bindgen_test_layout__GSocketControlMessage() {
    assert_eq!(
        ::std::mem::size_of::<_GSocketControlMessage>(),
        32usize,
        concat!("Size of: ", stringify!(_GSocketControlMessage))
    );
    assert_eq!(
        ::std::mem::align_of::<_GSocketControlMessage>(),
        8usize,
        concat!("Alignment of ", stringify!(_GSocketControlMessage))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GSocketControlMessage>())).parent_instance as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSocketControlMessage),
            "::",
            stringify!(parent_instance)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GSocketControlMessage>())).priv_ as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSocketControlMessage),
            "::",
            stringify!(priv_)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_g_socket_control_message_get_type"]
    pub fn g_socket_control_message_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_socket_control_message_get_size"]
    pub fn g_socket_control_message_get_size(message: *mut GSocketControlMessage) -> gsize;
}
extern "C" {
    #[link_name = "\u{1}_g_socket_control_message_get_level"]
    pub fn g_socket_control_message_get_level(
        message: *mut GSocketControlMessage,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_g_socket_control_message_get_msg_type"]
    pub fn g_socket_control_message_get_msg_type(
        message: *mut GSocketControlMessage,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_g_socket_control_message_serialize"]
    pub fn g_socket_control_message_serialize(message: *mut GSocketControlMessage, data: gpointer);
}
extern "C" {
    #[link_name = "\u{1}_g_socket_control_message_deserialize"]
    pub fn g_socket_control_message_deserialize(
        level: ::std::os::raw::c_int,
        type_: ::std::os::raw::c_int,
        size: gsize,
        data: gpointer,
    ) -> *mut GSocketControlMessage;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GSocketListenerPrivate {
    _unused: [u8; 0],
}
pub type GSocketListenerPrivate = _GSocketListenerPrivate;
pub type GSocketListenerClass = _GSocketListenerClass;
/// GSocketListenerClass:
/// @changed: virtual method called when the set of socket listened to changes
///
/// Class structure for #GSocketListener.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GSocketListenerClass {
    pub parent_class: GObjectClass,
    pub changed: ::std::option::Option<unsafe extern "C" fn(listener: *mut GSocketListener)>,
    pub event: ::std::option::Option<
        unsafe extern "C" fn(
            listener: *mut GSocketListener,
            event: GSocketListenerEvent,
            socket: *mut GSocket,
        ),
    >,
    pub _g_reserved2: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved3: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved4: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved5: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved6: ::std::option::Option<unsafe extern "C" fn()>,
}
#[test]
fn bindgen_test_layout__GSocketListenerClass() {
    assert_eq!(
        ::std::mem::size_of::<_GSocketListenerClass>(),
        192usize,
        concat!("Size of: ", stringify!(_GSocketListenerClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_GSocketListenerClass>(),
        8usize,
        concat!("Alignment of ", stringify!(_GSocketListenerClass))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GSocketListenerClass>())).parent_class as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSocketListenerClass),
            "::",
            stringify!(parent_class)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GSocketListenerClass>())).changed as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSocketListenerClass),
            "::",
            stringify!(changed)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GSocketListenerClass>())).event as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSocketListenerClass),
            "::",
            stringify!(event)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GSocketListenerClass>()))._g_reserved2 as *const _ as usize
        },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSocketListenerClass),
            "::",
            stringify!(_g_reserved2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GSocketListenerClass>()))._g_reserved3 as *const _ as usize
        },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSocketListenerClass),
            "::",
            stringify!(_g_reserved3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GSocketListenerClass>()))._g_reserved4 as *const _ as usize
        },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSocketListenerClass),
            "::",
            stringify!(_g_reserved4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GSocketListenerClass>()))._g_reserved5 as *const _ as usize
        },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSocketListenerClass),
            "::",
            stringify!(_g_reserved5)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GSocketListenerClass>()))._g_reserved6 as *const _ as usize
        },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSocketListenerClass),
            "::",
            stringify!(_g_reserved6)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GSocketListener {
    pub parent_instance: GObject,
    pub priv_: *mut GSocketListenerPrivate,
}
#[test]
fn bindgen_test_layout__GSocketListener() {
    assert_eq!(
        ::std::mem::size_of::<_GSocketListener>(),
        32usize,
        concat!("Size of: ", stringify!(_GSocketListener))
    );
    assert_eq!(
        ::std::mem::align_of::<_GSocketListener>(),
        8usize,
        concat!("Alignment of ", stringify!(_GSocketListener))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GSocketListener>())).parent_instance as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSocketListener),
            "::",
            stringify!(parent_instance)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GSocketListener>())).priv_ as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSocketListener),
            "::",
            stringify!(priv_)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_g_socket_listener_get_type"]
    pub fn g_socket_listener_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_socket_listener_new"]
    pub fn g_socket_listener_new() -> *mut GSocketListener;
}
extern "C" {
    #[link_name = "\u{1}_g_socket_listener_set_backlog"]
    pub fn g_socket_listener_set_backlog(
        listener: *mut GSocketListener,
        listen_backlog: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_socket_listener_add_socket"]
    pub fn g_socket_listener_add_socket(
        listener: *mut GSocketListener,
        socket: *mut GSocket,
        source_object: *mut GObject,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_socket_listener_add_address"]
    pub fn g_socket_listener_add_address(
        listener: *mut GSocketListener,
        address: *mut GSocketAddress,
        type_: GSocketType,
        protocol: GSocketProtocol,
        source_object: *mut GObject,
        effective_address: *mut *mut GSocketAddress,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_socket_listener_add_inet_port"]
    pub fn g_socket_listener_add_inet_port(
        listener: *mut GSocketListener,
        port: guint16,
        source_object: *mut GObject,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_socket_listener_add_any_inet_port"]
    pub fn g_socket_listener_add_any_inet_port(
        listener: *mut GSocketListener,
        source_object: *mut GObject,
        error: *mut *mut GError,
    ) -> guint16;
}
extern "C" {
    #[link_name = "\u{1}_g_socket_listener_accept_socket"]
    pub fn g_socket_listener_accept_socket(
        listener: *mut GSocketListener,
        source_object: *mut *mut GObject,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> *mut GSocket;
}
extern "C" {
    #[link_name = "\u{1}_g_socket_listener_accept_socket_async"]
    pub fn g_socket_listener_accept_socket_async(
        listener: *mut GSocketListener,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_socket_listener_accept_socket_finish"]
    pub fn g_socket_listener_accept_socket_finish(
        listener: *mut GSocketListener,
        result: *mut GAsyncResult,
        source_object: *mut *mut GObject,
        error: *mut *mut GError,
    ) -> *mut GSocket;
}
extern "C" {
    #[link_name = "\u{1}_g_socket_listener_accept"]
    pub fn g_socket_listener_accept(
        listener: *mut GSocketListener,
        source_object: *mut *mut GObject,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> *mut GSocketConnection;
}
extern "C" {
    #[link_name = "\u{1}_g_socket_listener_accept_async"]
    pub fn g_socket_listener_accept_async(
        listener: *mut GSocketListener,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_socket_listener_accept_finish"]
    pub fn g_socket_listener_accept_finish(
        listener: *mut GSocketListener,
        result: *mut GAsyncResult,
        source_object: *mut *mut GObject,
        error: *mut *mut GError,
    ) -> *mut GSocketConnection;
}
extern "C" {
    #[link_name = "\u{1}_g_socket_listener_close"]
    pub fn g_socket_listener_close(listener: *mut GSocketListener);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GSocketServicePrivate {
    _unused: [u8; 0],
}
pub type GSocketServicePrivate = _GSocketServicePrivate;
pub type GSocketServiceClass = _GSocketServiceClass;
/// GSocketServiceClass:
/// @incomming: signal emitted when new connections are accepted
///
/// Class structure for #GSocketService.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GSocketServiceClass {
    pub parent_class: GSocketListenerClass,
    pub incoming: ::std::option::Option<
        unsafe extern "C" fn(
            service: *mut GSocketService,
            connection: *mut GSocketConnection,
            source_object: *mut GObject,
        ) -> gboolean,
    >,
    pub _g_reserved1: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved2: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved3: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved4: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved5: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved6: ::std::option::Option<unsafe extern "C" fn()>,
}
#[test]
fn bindgen_test_layout__GSocketServiceClass() {
    assert_eq!(
        ::std::mem::size_of::<_GSocketServiceClass>(),
        248usize,
        concat!("Size of: ", stringify!(_GSocketServiceClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_GSocketServiceClass>(),
        8usize,
        concat!("Alignment of ", stringify!(_GSocketServiceClass))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GSocketServiceClass>())).parent_class as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSocketServiceClass),
            "::",
            stringify!(parent_class)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GSocketServiceClass>())).incoming as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSocketServiceClass),
            "::",
            stringify!(incoming)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GSocketServiceClass>()))._g_reserved1 as *const _ as usize
        },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSocketServiceClass),
            "::",
            stringify!(_g_reserved1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GSocketServiceClass>()))._g_reserved2 as *const _ as usize
        },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSocketServiceClass),
            "::",
            stringify!(_g_reserved2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GSocketServiceClass>()))._g_reserved3 as *const _ as usize
        },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSocketServiceClass),
            "::",
            stringify!(_g_reserved3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GSocketServiceClass>()))._g_reserved4 as *const _ as usize
        },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSocketServiceClass),
            "::",
            stringify!(_g_reserved4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GSocketServiceClass>()))._g_reserved5 as *const _ as usize
        },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSocketServiceClass),
            "::",
            stringify!(_g_reserved5)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GSocketServiceClass>()))._g_reserved6 as *const _ as usize
        },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSocketServiceClass),
            "::",
            stringify!(_g_reserved6)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GSocketService {
    pub parent_instance: GSocketListener,
    pub priv_: *mut GSocketServicePrivate,
}
#[test]
fn bindgen_test_layout__GSocketService() {
    assert_eq!(
        ::std::mem::size_of::<_GSocketService>(),
        40usize,
        concat!("Size of: ", stringify!(_GSocketService))
    );
    assert_eq!(
        ::std::mem::align_of::<_GSocketService>(),
        8usize,
        concat!("Alignment of ", stringify!(_GSocketService))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GSocketService>())).parent_instance as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSocketService),
            "::",
            stringify!(parent_instance)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GSocketService>())).priv_ as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSocketService),
            "::",
            stringify!(priv_)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_g_socket_service_get_type"]
    pub fn g_socket_service_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_socket_service_new"]
    pub fn g_socket_service_new() -> *mut GSocketService;
}
extern "C" {
    #[link_name = "\u{1}_g_socket_service_start"]
    pub fn g_socket_service_start(service: *mut GSocketService);
}
extern "C" {
    #[link_name = "\u{1}_g_socket_service_stop"]
    pub fn g_socket_service_stop(service: *mut GSocketService);
}
extern "C" {
    #[link_name = "\u{1}_g_socket_service_is_active"]
    pub fn g_socket_service_is_active(service: *mut GSocketService) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_srv_target_get_type"]
    pub fn g_srv_target_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_srv_target_new"]
    pub fn g_srv_target_new(
        hostname: *const gchar,
        port: guint16,
        priority: guint16,
        weight: guint16,
    ) -> *mut GSrvTarget;
}
extern "C" {
    #[link_name = "\u{1}_g_srv_target_copy"]
    pub fn g_srv_target_copy(target: *mut GSrvTarget) -> *mut GSrvTarget;
}
extern "C" {
    #[link_name = "\u{1}_g_srv_target_free"]
    pub fn g_srv_target_free(target: *mut GSrvTarget);
}
extern "C" {
    #[link_name = "\u{1}_g_srv_target_get_hostname"]
    pub fn g_srv_target_get_hostname(target: *mut GSrvTarget) -> *const gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_srv_target_get_port"]
    pub fn g_srv_target_get_port(target: *mut GSrvTarget) -> guint16;
}
extern "C" {
    #[link_name = "\u{1}_g_srv_target_get_priority"]
    pub fn g_srv_target_get_priority(target: *mut GSrvTarget) -> guint16;
}
extern "C" {
    #[link_name = "\u{1}_g_srv_target_get_weight"]
    pub fn g_srv_target_get_weight(target: *mut GSrvTarget) -> guint16;
}
extern "C" {
    #[link_name = "\u{1}_g_srv_target_list_sort"]
    pub fn g_srv_target_list_sort(targets: *mut GList) -> *mut GList;
}
/// GSimpleProxyResolver:
///
/// A #GProxyResolver implementation for using a fixed set of proxies.
pub type GSimpleProxyResolver = _GSimpleProxyResolver;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GSimpleProxyResolverPrivate {
    _unused: [u8; 0],
}
pub type GSimpleProxyResolverPrivate = _GSimpleProxyResolverPrivate;
pub type GSimpleProxyResolverClass = _GSimpleProxyResolverClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GSimpleProxyResolver {
    pub parent_instance: GObject,
    pub priv_: *mut GSimpleProxyResolverPrivate,
}
#[test]
fn bindgen_test_layout__GSimpleProxyResolver() {
    assert_eq!(
        ::std::mem::size_of::<_GSimpleProxyResolver>(),
        32usize,
        concat!("Size of: ", stringify!(_GSimpleProxyResolver))
    );
    assert_eq!(
        ::std::mem::align_of::<_GSimpleProxyResolver>(),
        8usize,
        concat!("Alignment of ", stringify!(_GSimpleProxyResolver))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GSimpleProxyResolver>())).parent_instance as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSimpleProxyResolver),
            "::",
            stringify!(parent_instance)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GSimpleProxyResolver>())).priv_ as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSimpleProxyResolver),
            "::",
            stringify!(priv_)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GSimpleProxyResolverClass {
    pub parent_class: GObjectClass,
    pub _g_reserved1: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved2: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved3: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved4: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved5: ::std::option::Option<unsafe extern "C" fn()>,
}
#[test]
fn bindgen_test_layout__GSimpleProxyResolverClass() {
    assert_eq!(
        ::std::mem::size_of::<_GSimpleProxyResolverClass>(),
        176usize,
        concat!("Size of: ", stringify!(_GSimpleProxyResolverClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_GSimpleProxyResolverClass>(),
        8usize,
        concat!("Alignment of ", stringify!(_GSimpleProxyResolverClass))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GSimpleProxyResolverClass>())).parent_class as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSimpleProxyResolverClass),
            "::",
            stringify!(parent_class)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GSimpleProxyResolverClass>()))._g_reserved1 as *const _ as usize
        },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSimpleProxyResolverClass),
            "::",
            stringify!(_g_reserved1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GSimpleProxyResolverClass>()))._g_reserved2 as *const _ as usize
        },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSimpleProxyResolverClass),
            "::",
            stringify!(_g_reserved2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GSimpleProxyResolverClass>()))._g_reserved3 as *const _ as usize
        },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSimpleProxyResolverClass),
            "::",
            stringify!(_g_reserved3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GSimpleProxyResolverClass>()))._g_reserved4 as *const _ as usize
        },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSimpleProxyResolverClass),
            "::",
            stringify!(_g_reserved4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GSimpleProxyResolverClass>()))._g_reserved5 as *const _ as usize
        },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(_GSimpleProxyResolverClass),
            "::",
            stringify!(_g_reserved5)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_g_simple_proxy_resolver_get_type"]
    pub fn g_simple_proxy_resolver_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_simple_proxy_resolver_new"]
    pub fn g_simple_proxy_resolver_new(
        default_proxy: *const gchar,
        ignore_hosts: *mut *mut gchar,
    ) -> *mut GProxyResolver;
}
extern "C" {
    #[link_name = "\u{1}_g_simple_proxy_resolver_set_default_proxy"]
    pub fn g_simple_proxy_resolver_set_default_proxy(
        resolver: *mut GSimpleProxyResolver,
        default_proxy: *const gchar,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_simple_proxy_resolver_set_ignore_hosts"]
    pub fn g_simple_proxy_resolver_set_ignore_hosts(
        resolver: *mut GSimpleProxyResolver,
        ignore_hosts: *mut *mut gchar,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_simple_proxy_resolver_set_uri_proxy"]
    pub fn g_simple_proxy_resolver_set_uri_proxy(
        resolver: *mut GSimpleProxyResolver,
        uri_scheme: *const gchar,
        proxy: *const gchar,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GTaskClass {
    _unused: [u8; 0],
}
pub type GTaskClass = _GTaskClass;
extern "C" {
    #[link_name = "\u{1}_g_task_get_type"]
    pub fn g_task_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_task_new"]
    pub fn g_task_new(
        source_object: gpointer,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        callback_data: gpointer,
    ) -> *mut GTask;
}
extern "C" {
    #[link_name = "\u{1}_g_task_report_error"]
    pub fn g_task_report_error(
        source_object: gpointer,
        callback: GAsyncReadyCallback,
        callback_data: gpointer,
        source_tag: gpointer,
        error: *mut GError,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_task_report_new_error"]
    pub fn g_task_report_new_error(
        source_object: gpointer,
        callback: GAsyncReadyCallback,
        callback_data: gpointer,
        source_tag: gpointer,
        domain: GQuark,
        code: gint,
        format: *const ::std::os::raw::c_char,
        ...
    );
}
extern "C" {
    #[link_name = "\u{1}_g_task_set_task_data"]
    pub fn g_task_set_task_data(
        task: *mut GTask,
        task_data: gpointer,
        task_data_destroy: GDestroyNotify,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_task_set_priority"]
    pub fn g_task_set_priority(task: *mut GTask, priority: gint);
}
extern "C" {
    #[link_name = "\u{1}_g_task_set_check_cancellable"]
    pub fn g_task_set_check_cancellable(task: *mut GTask, check_cancellable: gboolean);
}
extern "C" {
    #[link_name = "\u{1}_g_task_set_source_tag"]
    pub fn g_task_set_source_tag(task: *mut GTask, source_tag: gpointer);
}
extern "C" {
    #[link_name = "\u{1}_g_task_get_source_object"]
    pub fn g_task_get_source_object(task: *mut GTask) -> gpointer;
}
extern "C" {
    #[link_name = "\u{1}_g_task_get_task_data"]
    pub fn g_task_get_task_data(task: *mut GTask) -> gpointer;
}
extern "C" {
    #[link_name = "\u{1}_g_task_get_priority"]
    pub fn g_task_get_priority(task: *mut GTask) -> gint;
}
extern "C" {
    #[link_name = "\u{1}_g_task_get_context"]
    pub fn g_task_get_context(task: *mut GTask) -> *mut GMainContext;
}
extern "C" {
    #[link_name = "\u{1}_g_task_get_cancellable"]
    pub fn g_task_get_cancellable(task: *mut GTask) -> *mut GCancellable;
}
extern "C" {
    #[link_name = "\u{1}_g_task_get_check_cancellable"]
    pub fn g_task_get_check_cancellable(task: *mut GTask) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_task_get_source_tag"]
    pub fn g_task_get_source_tag(task: *mut GTask) -> gpointer;
}
extern "C" {
    #[link_name = "\u{1}_g_task_is_valid"]
    pub fn g_task_is_valid(result: gpointer, source_object: gpointer) -> gboolean;
}
pub type GTaskThreadFunc = ::std::option::Option<
    unsafe extern "C" fn(
        task: *mut GTask,
        source_object: gpointer,
        task_data: gpointer,
        cancellable: *mut GCancellable,
    ),
>;
extern "C" {
    #[link_name = "\u{1}_g_task_run_in_thread"]
    pub fn g_task_run_in_thread(task: *mut GTask, task_func: GTaskThreadFunc);
}
extern "C" {
    #[link_name = "\u{1}_g_task_run_in_thread_sync"]
    pub fn g_task_run_in_thread_sync(task: *mut GTask, task_func: GTaskThreadFunc);
}
extern "C" {
    #[link_name = "\u{1}_g_task_set_return_on_cancel"]
    pub fn g_task_set_return_on_cancel(task: *mut GTask, return_on_cancel: gboolean) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_task_get_return_on_cancel"]
    pub fn g_task_get_return_on_cancel(task: *mut GTask) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_task_attach_source"]
    pub fn g_task_attach_source(task: *mut GTask, source: *mut GSource, callback: GSourceFunc);
}
extern "C" {
    #[link_name = "\u{1}_g_task_return_pointer"]
    pub fn g_task_return_pointer(
        task: *mut GTask,
        result: gpointer,
        result_destroy: GDestroyNotify,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_task_return_boolean"]
    pub fn g_task_return_boolean(task: *mut GTask, result: gboolean);
}
extern "C" {
    #[link_name = "\u{1}_g_task_return_int"]
    pub fn g_task_return_int(task: *mut GTask, result: gssize);
}
extern "C" {
    #[link_name = "\u{1}_g_task_return_error"]
    pub fn g_task_return_error(task: *mut GTask, error: *mut GError);
}
extern "C" {
    #[link_name = "\u{1}_g_task_return_new_error"]
    pub fn g_task_return_new_error(
        task: *mut GTask,
        domain: GQuark,
        code: gint,
        format: *const ::std::os::raw::c_char,
        ...
    );
}
extern "C" {
    #[link_name = "\u{1}_g_task_return_error_if_cancelled"]
    pub fn g_task_return_error_if_cancelled(task: *mut GTask) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_task_propagate_pointer"]
    pub fn g_task_propagate_pointer(task: *mut GTask, error: *mut *mut GError) -> gpointer;
}
extern "C" {
    #[link_name = "\u{1}_g_task_propagate_boolean"]
    pub fn g_task_propagate_boolean(task: *mut GTask, error: *mut *mut GError) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_task_propagate_int"]
    pub fn g_task_propagate_int(task: *mut GTask, error: *mut *mut GError) -> gssize;
}
extern "C" {
    #[link_name = "\u{1}_g_task_had_error"]
    pub fn g_task_had_error(task: *mut GTask) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_task_get_completed"]
    pub fn g_task_get_completed(task: *mut GTask) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_subprocess_get_type"]
    pub fn g_subprocess_get_type() -> GType;
}
extern "C" {
    /// Core API
    #[link_name = "\u{1}_g_subprocess_new"]
    pub fn g_subprocess_new(
        flags: GSubprocessFlags,
        error: *mut *mut GError,
        argv0: *const gchar,
        ...
    ) -> *mut GSubprocess;
}
extern "C" {
    #[link_name = "\u{1}_g_subprocess_newv"]
    pub fn g_subprocess_newv(
        argv: *const *const gchar,
        flags: GSubprocessFlags,
        error: *mut *mut GError,
    ) -> *mut GSubprocess;
}
extern "C" {
    #[link_name = "\u{1}_g_subprocess_get_stdin_pipe"]
    pub fn g_subprocess_get_stdin_pipe(subprocess: *mut GSubprocess) -> *mut GOutputStream;
}
extern "C" {
    #[link_name = "\u{1}_g_subprocess_get_stdout_pipe"]
    pub fn g_subprocess_get_stdout_pipe(subprocess: *mut GSubprocess) -> *mut GInputStream;
}
extern "C" {
    #[link_name = "\u{1}_g_subprocess_get_stderr_pipe"]
    pub fn g_subprocess_get_stderr_pipe(subprocess: *mut GSubprocess) -> *mut GInputStream;
}
extern "C" {
    #[link_name = "\u{1}_g_subprocess_get_identifier"]
    pub fn g_subprocess_get_identifier(subprocess: *mut GSubprocess) -> *const gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_subprocess_send_signal"]
    pub fn g_subprocess_send_signal(subprocess: *mut GSubprocess, signal_num: gint);
}
extern "C" {
    #[link_name = "\u{1}_g_subprocess_force_exit"]
    pub fn g_subprocess_force_exit(subprocess: *mut GSubprocess);
}
extern "C" {
    #[link_name = "\u{1}_g_subprocess_wait"]
    pub fn g_subprocess_wait(
        subprocess: *mut GSubprocess,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_subprocess_wait_async"]
    pub fn g_subprocess_wait_async(
        subprocess: *mut GSubprocess,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_subprocess_wait_finish"]
    pub fn g_subprocess_wait_finish(
        subprocess: *mut GSubprocess,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_subprocess_wait_check"]
    pub fn g_subprocess_wait_check(
        subprocess: *mut GSubprocess,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_subprocess_wait_check_async"]
    pub fn g_subprocess_wait_check_async(
        subprocess: *mut GSubprocess,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_subprocess_wait_check_finish"]
    pub fn g_subprocess_wait_check_finish(
        subprocess: *mut GSubprocess,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_subprocess_get_status"]
    pub fn g_subprocess_get_status(subprocess: *mut GSubprocess) -> gint;
}
extern "C" {
    #[link_name = "\u{1}_g_subprocess_get_successful"]
    pub fn g_subprocess_get_successful(subprocess: *mut GSubprocess) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_subprocess_get_if_exited"]
    pub fn g_subprocess_get_if_exited(subprocess: *mut GSubprocess) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_subprocess_get_exit_status"]
    pub fn g_subprocess_get_exit_status(subprocess: *mut GSubprocess) -> gint;
}
extern "C" {
    #[link_name = "\u{1}_g_subprocess_get_if_signaled"]
    pub fn g_subprocess_get_if_signaled(subprocess: *mut GSubprocess) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_subprocess_get_term_sig"]
    pub fn g_subprocess_get_term_sig(subprocess: *mut GSubprocess) -> gint;
}
extern "C" {
    #[link_name = "\u{1}_g_subprocess_communicate"]
    pub fn g_subprocess_communicate(
        subprocess: *mut GSubprocess,
        stdin_buf: *mut GBytes,
        cancellable: *mut GCancellable,
        stdout_buf: *mut *mut GBytes,
        stderr_buf: *mut *mut GBytes,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_subprocess_communicate_async"]
    pub fn g_subprocess_communicate_async(
        subprocess: *mut GSubprocess,
        stdin_buf: *mut GBytes,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_subprocess_communicate_finish"]
    pub fn g_subprocess_communicate_finish(
        subprocess: *mut GSubprocess,
        result: *mut GAsyncResult,
        stdout_buf: *mut *mut GBytes,
        stderr_buf: *mut *mut GBytes,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_subprocess_communicate_utf8"]
    pub fn g_subprocess_communicate_utf8(
        subprocess: *mut GSubprocess,
        stdin_buf: *const ::std::os::raw::c_char,
        cancellable: *mut GCancellable,
        stdout_buf: *mut *mut ::std::os::raw::c_char,
        stderr_buf: *mut *mut ::std::os::raw::c_char,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_subprocess_communicate_utf8_async"]
    pub fn g_subprocess_communicate_utf8_async(
        subprocess: *mut GSubprocess,
        stdin_buf: *const ::std::os::raw::c_char,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_subprocess_communicate_utf8_finish"]
    pub fn g_subprocess_communicate_utf8_finish(
        subprocess: *mut GSubprocess,
        result: *mut GAsyncResult,
        stdout_buf: *mut *mut ::std::os::raw::c_char,
        stderr_buf: *mut *mut ::std::os::raw::c_char,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_subprocess_launcher_get_type"]
    pub fn g_subprocess_launcher_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_subprocess_launcher_new"]
    pub fn g_subprocess_launcher_new(flags: GSubprocessFlags) -> *mut GSubprocessLauncher;
}
extern "C" {
    #[link_name = "\u{1}_g_subprocess_launcher_spawn"]
    pub fn g_subprocess_launcher_spawn(
        self_: *mut GSubprocessLauncher,
        error: *mut *mut GError,
        argv0: *const gchar,
        ...
    ) -> *mut GSubprocess;
}
extern "C" {
    #[link_name = "\u{1}_g_subprocess_launcher_spawnv"]
    pub fn g_subprocess_launcher_spawnv(
        self_: *mut GSubprocessLauncher,
        argv: *const *const gchar,
        error: *mut *mut GError,
    ) -> *mut GSubprocess;
}
extern "C" {
    #[link_name = "\u{1}_g_subprocess_launcher_set_environ"]
    pub fn g_subprocess_launcher_set_environ(self_: *mut GSubprocessLauncher, env: *mut *mut gchar);
}
extern "C" {
    #[link_name = "\u{1}_g_subprocess_launcher_setenv"]
    pub fn g_subprocess_launcher_setenv(
        self_: *mut GSubprocessLauncher,
        variable: *const gchar,
        value: *const gchar,
        overwrite: gboolean,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_subprocess_launcher_unsetenv"]
    pub fn g_subprocess_launcher_unsetenv(self_: *mut GSubprocessLauncher, variable: *const gchar);
}
extern "C" {
    #[link_name = "\u{1}_g_subprocess_launcher_getenv"]
    pub fn g_subprocess_launcher_getenv(
        self_: *mut GSubprocessLauncher,
        variable: *const gchar,
    ) -> *const gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_subprocess_launcher_set_cwd"]
    pub fn g_subprocess_launcher_set_cwd(self_: *mut GSubprocessLauncher, cwd: *const gchar);
}
extern "C" {
    #[link_name = "\u{1}_g_subprocess_launcher_set_flags"]
    pub fn g_subprocess_launcher_set_flags(
        self_: *mut GSubprocessLauncher,
        flags: GSubprocessFlags,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_subprocess_launcher_set_stdin_file_path"]
    pub fn g_subprocess_launcher_set_stdin_file_path(
        self_: *mut GSubprocessLauncher,
        path: *const gchar,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_subprocess_launcher_take_stdin_fd"]
    pub fn g_subprocess_launcher_take_stdin_fd(self_: *mut GSubprocessLauncher, fd: gint);
}
extern "C" {
    #[link_name = "\u{1}_g_subprocess_launcher_set_stdout_file_path"]
    pub fn g_subprocess_launcher_set_stdout_file_path(
        self_: *mut GSubprocessLauncher,
        path: *const gchar,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_subprocess_launcher_take_stdout_fd"]
    pub fn g_subprocess_launcher_take_stdout_fd(self_: *mut GSubprocessLauncher, fd: gint);
}
extern "C" {
    #[link_name = "\u{1}_g_subprocess_launcher_set_stderr_file_path"]
    pub fn g_subprocess_launcher_set_stderr_file_path(
        self_: *mut GSubprocessLauncher,
        path: *const gchar,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_subprocess_launcher_take_stderr_fd"]
    pub fn g_subprocess_launcher_take_stderr_fd(self_: *mut GSubprocessLauncher, fd: gint);
}
extern "C" {
    #[link_name = "\u{1}_g_subprocess_launcher_take_fd"]
    pub fn g_subprocess_launcher_take_fd(
        self_: *mut GSubprocessLauncher,
        source_fd: gint,
        target_fd: gint,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_subprocess_launcher_set_child_setup"]
    pub fn g_subprocess_launcher_set_child_setup(
        self_: *mut GSubprocessLauncher,
        child_setup: GSpawnChildSetupFunc,
        user_data: gpointer,
        destroy_notify: GDestroyNotify,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GTcpConnectionPrivate {
    _unused: [u8; 0],
}
pub type GTcpConnectionPrivate = _GTcpConnectionPrivate;
pub type GTcpConnectionClass = _GTcpConnectionClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GTcpConnectionClass {
    pub parent_class: GSocketConnectionClass,
}
#[test]
fn bindgen_test_layout__GTcpConnectionClass() {
    assert_eq!(
        ::std::mem::size_of::<_GTcpConnectionClass>(),
        304usize,
        concat!("Size of: ", stringify!(_GTcpConnectionClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_GTcpConnectionClass>(),
        8usize,
        concat!("Alignment of ", stringify!(_GTcpConnectionClass))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GTcpConnectionClass>())).parent_class as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTcpConnectionClass),
            "::",
            stringify!(parent_class)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GTcpConnection {
    pub parent_instance: GSocketConnection,
    pub priv_: *mut GTcpConnectionPrivate,
}
#[test]
fn bindgen_test_layout__GTcpConnection() {
    assert_eq!(
        ::std::mem::size_of::<_GTcpConnection>(),
        48usize,
        concat!("Size of: ", stringify!(_GTcpConnection))
    );
    assert_eq!(
        ::std::mem::align_of::<_GTcpConnection>(),
        8usize,
        concat!("Alignment of ", stringify!(_GTcpConnection))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GTcpConnection>())).parent_instance as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTcpConnection),
            "::",
            stringify!(parent_instance)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GTcpConnection>())).priv_ as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTcpConnection),
            "::",
            stringify!(priv_)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_g_tcp_connection_get_type"]
    pub fn g_tcp_connection_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_tcp_connection_set_graceful_disconnect"]
    pub fn g_tcp_connection_set_graceful_disconnect(
        connection: *mut GTcpConnection,
        graceful_disconnect: gboolean,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_tcp_connection_get_graceful_disconnect"]
    pub fn g_tcp_connection_get_graceful_disconnect(connection: *mut GTcpConnection) -> gboolean;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GTcpWrapperConnectionPrivate {
    _unused: [u8; 0],
}
pub type GTcpWrapperConnectionPrivate = _GTcpWrapperConnectionPrivate;
pub type GTcpWrapperConnectionClass = _GTcpWrapperConnectionClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GTcpWrapperConnectionClass {
    pub parent_class: GTcpConnectionClass,
}
#[test]
fn bindgen_test_layout__GTcpWrapperConnectionClass() {
    assert_eq!(
        ::std::mem::size_of::<_GTcpWrapperConnectionClass>(),
        304usize,
        concat!("Size of: ", stringify!(_GTcpWrapperConnectionClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_GTcpWrapperConnectionClass>(),
        8usize,
        concat!("Alignment of ", stringify!(_GTcpWrapperConnectionClass))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GTcpWrapperConnectionClass>())).parent_class as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTcpWrapperConnectionClass),
            "::",
            stringify!(parent_class)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GTcpWrapperConnection {
    pub parent_instance: GTcpConnection,
    pub priv_: *mut GTcpWrapperConnectionPrivate,
}
#[test]
fn bindgen_test_layout__GTcpWrapperConnection() {
    assert_eq!(
        ::std::mem::size_of::<_GTcpWrapperConnection>(),
        56usize,
        concat!("Size of: ", stringify!(_GTcpWrapperConnection))
    );
    assert_eq!(
        ::std::mem::align_of::<_GTcpWrapperConnection>(),
        8usize,
        concat!("Alignment of ", stringify!(_GTcpWrapperConnection))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GTcpWrapperConnection>())).parent_instance as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTcpWrapperConnection),
            "::",
            stringify!(parent_instance)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GTcpWrapperConnection>())).priv_ as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTcpWrapperConnection),
            "::",
            stringify!(priv_)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_g_tcp_wrapper_connection_get_type"]
    pub fn g_tcp_wrapper_connection_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_tcp_wrapper_connection_new"]
    pub fn g_tcp_wrapper_connection_new(
        base_io_stream: *mut GIOStream,
        socket: *mut GSocket,
    ) -> *mut GSocketConnection;
}
extern "C" {
    #[link_name = "\u{1}_g_tcp_wrapper_connection_get_base_io_stream"]
    pub fn g_tcp_wrapper_connection_get_base_io_stream(
        conn: *mut GTcpWrapperConnection,
    ) -> *mut GIOStream;
}
extern "C" {
    #[link_name = "\u{1}_g_test_dbus_get_type"]
    pub fn g_test_dbus_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_test_dbus_new"]
    pub fn g_test_dbus_new(flags: GTestDBusFlags) -> *mut GTestDBus;
}
extern "C" {
    #[link_name = "\u{1}_g_test_dbus_get_flags"]
    pub fn g_test_dbus_get_flags(self_: *mut GTestDBus) -> GTestDBusFlags;
}
extern "C" {
    #[link_name = "\u{1}_g_test_dbus_get_bus_address"]
    pub fn g_test_dbus_get_bus_address(self_: *mut GTestDBus) -> *const gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_test_dbus_add_service_dir"]
    pub fn g_test_dbus_add_service_dir(self_: *mut GTestDBus, path: *const gchar);
}
extern "C" {
    #[link_name = "\u{1}_g_test_dbus_up"]
    pub fn g_test_dbus_up(self_: *mut GTestDBus);
}
extern "C" {
    #[link_name = "\u{1}_g_test_dbus_stop"]
    pub fn g_test_dbus_stop(self_: *mut GTestDBus);
}
extern "C" {
    #[link_name = "\u{1}_g_test_dbus_down"]
    pub fn g_test_dbus_down(self_: *mut GTestDBus);
}
extern "C" {
    #[link_name = "\u{1}_g_test_dbus_unset"]
    pub fn g_test_dbus_unset();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GThemedIconClass {
    _unused: [u8; 0],
}
/// GThemedIcon:
///
/// An implementation of #GIcon for themed icons.
pub type GThemedIconClass = _GThemedIconClass;
extern "C" {
    #[link_name = "\u{1}_g_themed_icon_get_type"]
    pub fn g_themed_icon_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_themed_icon_new"]
    pub fn g_themed_icon_new(iconname: *const ::std::os::raw::c_char) -> *mut GIcon;
}
extern "C" {
    #[link_name = "\u{1}_g_themed_icon_new_with_default_fallbacks"]
    pub fn g_themed_icon_new_with_default_fallbacks(
        iconname: *const ::std::os::raw::c_char,
    ) -> *mut GIcon;
}
extern "C" {
    #[link_name = "\u{1}_g_themed_icon_new_from_names"]
    pub fn g_themed_icon_new_from_names(
        iconnames: *mut *mut ::std::os::raw::c_char,
        len: ::std::os::raw::c_int,
    ) -> *mut GIcon;
}
extern "C" {
    #[link_name = "\u{1}_g_themed_icon_prepend_name"]
    pub fn g_themed_icon_prepend_name(
        icon: *mut GThemedIcon,
        iconname: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_themed_icon_append_name"]
    pub fn g_themed_icon_append_name(
        icon: *mut GThemedIcon,
        iconname: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_themed_icon_get_names"]
    pub fn g_themed_icon_get_names(icon: *mut GThemedIcon) -> *const *const gchar;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GThreadedSocketServicePrivate {
    _unused: [u8; 0],
}
pub type GThreadedSocketServicePrivate = _GThreadedSocketServicePrivate;
pub type GThreadedSocketServiceClass = _GThreadedSocketServiceClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GThreadedSocketServiceClass {
    pub parent_class: GSocketServiceClass,
    pub run: ::std::option::Option<
        unsafe extern "C" fn(
            service: *mut GThreadedSocketService,
            connection: *mut GSocketConnection,
            source_object: *mut GObject,
        ) -> gboolean,
    >,
    pub _g_reserved1: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved2: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved3: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved4: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved5: ::std::option::Option<unsafe extern "C" fn()>,
}
#[test]
fn bindgen_test_layout__GThreadedSocketServiceClass() {
    assert_eq!(
        ::std::mem::size_of::<_GThreadedSocketServiceClass>(),
        296usize,
        concat!("Size of: ", stringify!(_GThreadedSocketServiceClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_GThreadedSocketServiceClass>(),
        8usize,
        concat!("Alignment of ", stringify!(_GThreadedSocketServiceClass))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GThreadedSocketServiceClass>())).parent_class as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GThreadedSocketServiceClass),
            "::",
            stringify!(parent_class)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GThreadedSocketServiceClass>())).run as *const _ as usize
        },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(_GThreadedSocketServiceClass),
            "::",
            stringify!(run)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GThreadedSocketServiceClass>()))._g_reserved1 as *const _
                as usize
        },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(_GThreadedSocketServiceClass),
            "::",
            stringify!(_g_reserved1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GThreadedSocketServiceClass>()))._g_reserved2 as *const _
                as usize
        },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(_GThreadedSocketServiceClass),
            "::",
            stringify!(_g_reserved2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GThreadedSocketServiceClass>()))._g_reserved3 as *const _
                as usize
        },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(_GThreadedSocketServiceClass),
            "::",
            stringify!(_g_reserved3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GThreadedSocketServiceClass>()))._g_reserved4 as *const _
                as usize
        },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(_GThreadedSocketServiceClass),
            "::",
            stringify!(_g_reserved4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GThreadedSocketServiceClass>()))._g_reserved5 as *const _
                as usize
        },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(_GThreadedSocketServiceClass),
            "::",
            stringify!(_g_reserved5)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GThreadedSocketService {
    pub parent_instance: GSocketService,
    pub priv_: *mut GThreadedSocketServicePrivate,
}
#[test]
fn bindgen_test_layout__GThreadedSocketService() {
    assert_eq!(
        ::std::mem::size_of::<_GThreadedSocketService>(),
        48usize,
        concat!("Size of: ", stringify!(_GThreadedSocketService))
    );
    assert_eq!(
        ::std::mem::align_of::<_GThreadedSocketService>(),
        8usize,
        concat!("Alignment of ", stringify!(_GThreadedSocketService))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GThreadedSocketService>())).parent_instance as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GThreadedSocketService),
            "::",
            stringify!(parent_instance)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GThreadedSocketService>())).priv_ as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_GThreadedSocketService),
            "::",
            stringify!(priv_)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_g_threaded_socket_service_get_type"]
    pub fn g_threaded_socket_service_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_threaded_socket_service_new"]
    pub fn g_threaded_socket_service_new(max_threads: ::std::os::raw::c_int)
        -> *mut GSocketService;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GTlsBackend {
    _unused: [u8; 0],
}
pub type GTlsBackend = _GTlsBackend;
pub type GTlsBackendInterface = _GTlsBackendInterface;
/// GTlsBackendInterface:
/// @g_iface: The parent interface.
/// @supports_tls: returns whether the backend supports TLS.
/// @supports_dtls: returns whether the backend supports DTLS
/// @get_default_database: returns a default #GTlsDatabase instance.
/// @get_certificate_type: returns the #GTlsCertificate implementation type
/// @get_client_connection_type: returns the #GTlsClientConnection implementation type
/// @get_server_connection_type: returns the #GTlsServerConnection implementation type
/// @get_file_database_type: returns the #GTlsFileDatabase implementation type.
/// @get_dtls_client_connection_type: returns the #GDtlsClientConnection implementation type
/// @get_dtls_server_connection_type: returns the #GDtlsServerConnection implementation type
///
/// Provides an interface for describing TLS-related types.
///
/// Since: 2.28
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GTlsBackendInterface {
    pub g_iface: GTypeInterface,
    pub supports_tls:
        ::std::option::Option<unsafe extern "C" fn(backend: *mut GTlsBackend) -> gboolean>,
    pub get_certificate_type: ::std::option::Option<unsafe extern "C" fn() -> GType>,
    pub get_client_connection_type: ::std::option::Option<unsafe extern "C" fn() -> GType>,
    pub get_server_connection_type: ::std::option::Option<unsafe extern "C" fn() -> GType>,
    pub get_file_database_type: ::std::option::Option<unsafe extern "C" fn() -> GType>,
    pub get_default_database:
        ::std::option::Option<unsafe extern "C" fn(backend: *mut GTlsBackend) -> *mut GTlsDatabase>,
    pub supports_dtls:
        ::std::option::Option<unsafe extern "C" fn(backend: *mut GTlsBackend) -> gboolean>,
    pub get_dtls_client_connection_type: ::std::option::Option<unsafe extern "C" fn() -> GType>,
    pub get_dtls_server_connection_type: ::std::option::Option<unsafe extern "C" fn() -> GType>,
}
#[test]
fn bindgen_test_layout__GTlsBackendInterface() {
    assert_eq!(
        ::std::mem::size_of::<_GTlsBackendInterface>(),
        88usize,
        concat!("Size of: ", stringify!(_GTlsBackendInterface))
    );
    assert_eq!(
        ::std::mem::align_of::<_GTlsBackendInterface>(),
        8usize,
        concat!("Alignment of ", stringify!(_GTlsBackendInterface))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GTlsBackendInterface>())).g_iface as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTlsBackendInterface),
            "::",
            stringify!(g_iface)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GTlsBackendInterface>())).supports_tls as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTlsBackendInterface),
            "::",
            stringify!(supports_tls)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GTlsBackendInterface>())).get_certificate_type as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTlsBackendInterface),
            "::",
            stringify!(get_certificate_type)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GTlsBackendInterface>())).get_client_connection_type as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTlsBackendInterface),
            "::",
            stringify!(get_client_connection_type)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GTlsBackendInterface>())).get_server_connection_type as *const _
                as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTlsBackendInterface),
            "::",
            stringify!(get_server_connection_type)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GTlsBackendInterface>())).get_file_database_type as *const _
                as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTlsBackendInterface),
            "::",
            stringify!(get_file_database_type)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GTlsBackendInterface>())).get_default_database as *const _
                as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTlsBackendInterface),
            "::",
            stringify!(get_default_database)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GTlsBackendInterface>())).supports_dtls as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTlsBackendInterface),
            "::",
            stringify!(supports_dtls)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GTlsBackendInterface>())).get_dtls_client_connection_type
                as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTlsBackendInterface),
            "::",
            stringify!(get_dtls_client_connection_type)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GTlsBackendInterface>())).get_dtls_server_connection_type
                as *const _ as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTlsBackendInterface),
            "::",
            stringify!(get_dtls_server_connection_type)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_g_tls_backend_get_type"]
    pub fn g_tls_backend_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_tls_backend_get_default"]
    pub fn g_tls_backend_get_default() -> *mut GTlsBackend;
}
extern "C" {
    #[link_name = "\u{1}_g_tls_backend_get_default_database"]
    pub fn g_tls_backend_get_default_database(backend: *mut GTlsBackend) -> *mut GTlsDatabase;
}
extern "C" {
    #[link_name = "\u{1}_g_tls_backend_supports_tls"]
    pub fn g_tls_backend_supports_tls(backend: *mut GTlsBackend) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_tls_backend_supports_dtls"]
    pub fn g_tls_backend_supports_dtls(backend: *mut GTlsBackend) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_tls_backend_get_certificate_type"]
    pub fn g_tls_backend_get_certificate_type(backend: *mut GTlsBackend) -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_tls_backend_get_client_connection_type"]
    pub fn g_tls_backend_get_client_connection_type(backend: *mut GTlsBackend) -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_tls_backend_get_server_connection_type"]
    pub fn g_tls_backend_get_server_connection_type(backend: *mut GTlsBackend) -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_tls_backend_get_file_database_type"]
    pub fn g_tls_backend_get_file_database_type(backend: *mut GTlsBackend) -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_tls_backend_get_dtls_client_connection_type"]
    pub fn g_tls_backend_get_dtls_client_connection_type(backend: *mut GTlsBackend) -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_tls_backend_get_dtls_server_connection_type"]
    pub fn g_tls_backend_get_dtls_server_connection_type(backend: *mut GTlsBackend) -> GType;
}
pub type GTlsCertificateClass = _GTlsCertificateClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GTlsCertificatePrivate {
    _unused: [u8; 0],
}
pub type GTlsCertificatePrivate = _GTlsCertificatePrivate;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GTlsCertificate {
    pub parent_instance: GObject,
    pub priv_: *mut GTlsCertificatePrivate,
}
#[test]
fn bindgen_test_layout__GTlsCertificate() {
    assert_eq!(
        ::std::mem::size_of::<_GTlsCertificate>(),
        32usize,
        concat!("Size of: ", stringify!(_GTlsCertificate))
    );
    assert_eq!(
        ::std::mem::align_of::<_GTlsCertificate>(),
        8usize,
        concat!("Alignment of ", stringify!(_GTlsCertificate))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GTlsCertificate>())).parent_instance as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTlsCertificate),
            "::",
            stringify!(parent_instance)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GTlsCertificate>())).priv_ as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTlsCertificate),
            "::",
            stringify!(priv_)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GTlsCertificateClass {
    pub parent_class: GObjectClass,
    pub verify: ::std::option::Option<
        unsafe extern "C" fn(
            cert: *mut GTlsCertificate,
            identity: *mut GSocketConnectable,
            trusted_ca: *mut GTlsCertificate,
        ) -> GTlsCertificateFlags,
    >,
    pub padding: [gpointer; 8usize],
}
#[test]
fn bindgen_test_layout__GTlsCertificateClass() {
    assert_eq!(
        ::std::mem::size_of::<_GTlsCertificateClass>(),
        208usize,
        concat!("Size of: ", stringify!(_GTlsCertificateClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_GTlsCertificateClass>(),
        8usize,
        concat!("Alignment of ", stringify!(_GTlsCertificateClass))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GTlsCertificateClass>())).parent_class as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTlsCertificateClass),
            "::",
            stringify!(parent_class)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GTlsCertificateClass>())).verify as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTlsCertificateClass),
            "::",
            stringify!(verify)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GTlsCertificateClass>())).padding as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTlsCertificateClass),
            "::",
            stringify!(padding)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_g_tls_certificate_get_type"]
    pub fn g_tls_certificate_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_tls_certificate_new_from_pem"]
    pub fn g_tls_certificate_new_from_pem(
        data: *const gchar,
        length: gssize,
        error: *mut *mut GError,
    ) -> *mut GTlsCertificate;
}
extern "C" {
    #[link_name = "\u{1}_g_tls_certificate_new_from_file"]
    pub fn g_tls_certificate_new_from_file(
        file: *const gchar,
        error: *mut *mut GError,
    ) -> *mut GTlsCertificate;
}
extern "C" {
    #[link_name = "\u{1}_g_tls_certificate_new_from_files"]
    pub fn g_tls_certificate_new_from_files(
        cert_file: *const gchar,
        key_file: *const gchar,
        error: *mut *mut GError,
    ) -> *mut GTlsCertificate;
}
extern "C" {
    #[link_name = "\u{1}_g_tls_certificate_list_new_from_file"]
    pub fn g_tls_certificate_list_new_from_file(
        file: *const gchar,
        error: *mut *mut GError,
    ) -> *mut GList;
}
extern "C" {
    #[link_name = "\u{1}_g_tls_certificate_get_issuer"]
    pub fn g_tls_certificate_get_issuer(cert: *mut GTlsCertificate) -> *mut GTlsCertificate;
}
extern "C" {
    #[link_name = "\u{1}_g_tls_certificate_verify"]
    pub fn g_tls_certificate_verify(
        cert: *mut GTlsCertificate,
        identity: *mut GSocketConnectable,
        trusted_ca: *mut GTlsCertificate,
    ) -> GTlsCertificateFlags;
}
extern "C" {
    #[link_name = "\u{1}_g_tls_certificate_is_same"]
    pub fn g_tls_certificate_is_same(
        cert_one: *mut GTlsCertificate,
        cert_two: *mut GTlsCertificate,
    ) -> gboolean;
}
pub type GTlsConnectionClass = _GTlsConnectionClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GTlsConnectionPrivate {
    _unused: [u8; 0],
}
pub type GTlsConnectionPrivate = _GTlsConnectionPrivate;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GTlsConnection {
    pub parent_instance: GIOStream,
    pub priv_: *mut GTlsConnectionPrivate,
}
#[test]
fn bindgen_test_layout__GTlsConnection() {
    assert_eq!(
        ::std::mem::size_of::<_GTlsConnection>(),
        40usize,
        concat!("Size of: ", stringify!(_GTlsConnection))
    );
    assert_eq!(
        ::std::mem::align_of::<_GTlsConnection>(),
        8usize,
        concat!("Alignment of ", stringify!(_GTlsConnection))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GTlsConnection>())).parent_instance as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTlsConnection),
            "::",
            stringify!(parent_instance)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GTlsConnection>())).priv_ as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTlsConnection),
            "::",
            stringify!(priv_)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GTlsConnectionClass {
    pub parent_class: GIOStreamClass,
    pub accept_certificate: ::std::option::Option<
        unsafe extern "C" fn(
            connection: *mut GTlsConnection,
            peer_cert: *mut GTlsCertificate,
            errors: GTlsCertificateFlags,
        ) -> gboolean,
    >,
    pub handshake: ::std::option::Option<
        unsafe extern "C" fn(
            conn: *mut GTlsConnection,
            cancellable: *mut GCancellable,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
    pub handshake_async: ::std::option::Option<
        unsafe extern "C" fn(
            conn: *mut GTlsConnection,
            io_priority: ::std::os::raw::c_int,
            cancellable: *mut GCancellable,
            callback: GAsyncReadyCallback,
            user_data: gpointer,
        ),
    >,
    pub handshake_finish: ::std::option::Option<
        unsafe extern "C" fn(
            conn: *mut GTlsConnection,
            result: *mut GAsyncResult,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
    pub padding: [gpointer; 8usize],
}
#[test]
fn bindgen_test_layout__GTlsConnectionClass() {
    assert_eq!(
        ::std::mem::size_of::<_GTlsConnectionClass>(),
        352usize,
        concat!("Size of: ", stringify!(_GTlsConnectionClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_GTlsConnectionClass>(),
        8usize,
        concat!("Alignment of ", stringify!(_GTlsConnectionClass))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GTlsConnectionClass>())).parent_class as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTlsConnectionClass),
            "::",
            stringify!(parent_class)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GTlsConnectionClass>())).accept_certificate as *const _ as usize
        },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTlsConnectionClass),
            "::",
            stringify!(accept_certificate)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GTlsConnectionClass>())).handshake as *const _ as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTlsConnectionClass),
            "::",
            stringify!(handshake)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GTlsConnectionClass>())).handshake_async as *const _ as usize
        },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTlsConnectionClass),
            "::",
            stringify!(handshake_async)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GTlsConnectionClass>())).handshake_finish as *const _ as usize
        },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTlsConnectionClass),
            "::",
            stringify!(handshake_finish)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GTlsConnectionClass>())).padding as *const _ as usize },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTlsConnectionClass),
            "::",
            stringify!(padding)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_g_tls_connection_get_type"]
    pub fn g_tls_connection_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_tls_connection_set_use_system_certdb"]
    pub fn g_tls_connection_set_use_system_certdb(
        conn: *mut GTlsConnection,
        use_system_certdb: gboolean,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_tls_connection_get_use_system_certdb"]
    pub fn g_tls_connection_get_use_system_certdb(conn: *mut GTlsConnection) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_tls_connection_set_database"]
    pub fn g_tls_connection_set_database(conn: *mut GTlsConnection, database: *mut GTlsDatabase);
}
extern "C" {
    #[link_name = "\u{1}_g_tls_connection_get_database"]
    pub fn g_tls_connection_get_database(conn: *mut GTlsConnection) -> *mut GTlsDatabase;
}
extern "C" {
    #[link_name = "\u{1}_g_tls_connection_set_certificate"]
    pub fn g_tls_connection_set_certificate(
        conn: *mut GTlsConnection,
        certificate: *mut GTlsCertificate,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_tls_connection_get_certificate"]
    pub fn g_tls_connection_get_certificate(conn: *mut GTlsConnection) -> *mut GTlsCertificate;
}
extern "C" {
    #[link_name = "\u{1}_g_tls_connection_set_interaction"]
    pub fn g_tls_connection_set_interaction(
        conn: *mut GTlsConnection,
        interaction: *mut GTlsInteraction,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_tls_connection_get_interaction"]
    pub fn g_tls_connection_get_interaction(conn: *mut GTlsConnection) -> *mut GTlsInteraction;
}
extern "C" {
    #[link_name = "\u{1}_g_tls_connection_get_peer_certificate"]
    pub fn g_tls_connection_get_peer_certificate(conn: *mut GTlsConnection)
        -> *mut GTlsCertificate;
}
extern "C" {
    #[link_name = "\u{1}_g_tls_connection_get_peer_certificate_errors"]
    pub fn g_tls_connection_get_peer_certificate_errors(
        conn: *mut GTlsConnection,
    ) -> GTlsCertificateFlags;
}
extern "C" {
    #[link_name = "\u{1}_g_tls_connection_set_require_close_notify"]
    pub fn g_tls_connection_set_require_close_notify(
        conn: *mut GTlsConnection,
        require_close_notify: gboolean,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_tls_connection_get_require_close_notify"]
    pub fn g_tls_connection_get_require_close_notify(conn: *mut GTlsConnection) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_tls_connection_set_rehandshake_mode"]
    pub fn g_tls_connection_set_rehandshake_mode(
        conn: *mut GTlsConnection,
        mode: GTlsRehandshakeMode,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_tls_connection_get_rehandshake_mode"]
    pub fn g_tls_connection_get_rehandshake_mode(conn: *mut GTlsConnection) -> GTlsRehandshakeMode;
}
extern "C" {
    #[link_name = "\u{1}_g_tls_connection_handshake"]
    pub fn g_tls_connection_handshake(
        conn: *mut GTlsConnection,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_tls_connection_handshake_async"]
    pub fn g_tls_connection_handshake_async(
        conn: *mut GTlsConnection,
        io_priority: ::std::os::raw::c_int,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_tls_connection_handshake_finish"]
    pub fn g_tls_connection_handshake_finish(
        conn: *mut GTlsConnection,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_tls_error_quark"]
    pub fn g_tls_error_quark() -> GQuark;
}
extern "C" {
    #[link_name = "\u{1}_g_tls_connection_emit_accept_certificate"]
    pub fn g_tls_connection_emit_accept_certificate(
        conn: *mut GTlsConnection,
        peer_cert: *mut GTlsCertificate,
        errors: GTlsCertificateFlags,
    ) -> gboolean;
}
pub type GTlsClientConnectionInterface = _GTlsClientConnectionInterface;
/// GTlsClientConnectionInterface:
/// @g_iface: The parent interface.
/// @copy_session_state: Copies session state from one #GTlsClientConnection to another.
///
/// vtable for a #GTlsClientConnection implementation.
///
/// Since: 2.26
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GTlsClientConnectionInterface {
    pub g_iface: GTypeInterface,
    pub copy_session_state: ::std::option::Option<
        unsafe extern "C" fn(conn: *mut GTlsClientConnection, source: *mut GTlsClientConnection),
    >,
}
#[test]
fn bindgen_test_layout__GTlsClientConnectionInterface() {
    assert_eq!(
        ::std::mem::size_of::<_GTlsClientConnectionInterface>(),
        24usize,
        concat!("Size of: ", stringify!(_GTlsClientConnectionInterface))
    );
    assert_eq!(
        ::std::mem::align_of::<_GTlsClientConnectionInterface>(),
        8usize,
        concat!("Alignment of ", stringify!(_GTlsClientConnectionInterface))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GTlsClientConnectionInterface>())).g_iface as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTlsClientConnectionInterface),
            "::",
            stringify!(g_iface)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GTlsClientConnectionInterface>())).copy_session_state
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTlsClientConnectionInterface),
            "::",
            stringify!(copy_session_state)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_g_tls_client_connection_get_type"]
    pub fn g_tls_client_connection_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_tls_client_connection_new"]
    pub fn g_tls_client_connection_new(
        base_io_stream: *mut GIOStream,
        server_identity: *mut GSocketConnectable,
        error: *mut *mut GError,
    ) -> *mut GIOStream;
}
extern "C" {
    #[link_name = "\u{1}_g_tls_client_connection_get_validation_flags"]
    pub fn g_tls_client_connection_get_validation_flags(
        conn: *mut GTlsClientConnection,
    ) -> GTlsCertificateFlags;
}
extern "C" {
    #[link_name = "\u{1}_g_tls_client_connection_set_validation_flags"]
    pub fn g_tls_client_connection_set_validation_flags(
        conn: *mut GTlsClientConnection,
        flags: GTlsCertificateFlags,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_tls_client_connection_get_server_identity"]
    pub fn g_tls_client_connection_get_server_identity(
        conn: *mut GTlsClientConnection,
    ) -> *mut GSocketConnectable;
}
extern "C" {
    #[link_name = "\u{1}_g_tls_client_connection_set_server_identity"]
    pub fn g_tls_client_connection_set_server_identity(
        conn: *mut GTlsClientConnection,
        identity: *mut GSocketConnectable,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_tls_client_connection_get_use_ssl3"]
    pub fn g_tls_client_connection_get_use_ssl3(conn: *mut GTlsClientConnection) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_tls_client_connection_set_use_ssl3"]
    pub fn g_tls_client_connection_set_use_ssl3(
        conn: *mut GTlsClientConnection,
        use_ssl3: gboolean,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_tls_client_connection_get_accepted_cas"]
    pub fn g_tls_client_connection_get_accepted_cas(conn: *mut GTlsClientConnection) -> *mut GList;
}
extern "C" {
    #[link_name = "\u{1}_g_tls_client_connection_copy_session_state"]
    pub fn g_tls_client_connection_copy_session_state(
        conn: *mut GTlsClientConnection,
        source: *mut GTlsClientConnection,
    );
}
pub type GTlsDatabaseClass = _GTlsDatabaseClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GTlsDatabasePrivate {
    _unused: [u8; 0],
}
pub type GTlsDatabasePrivate = _GTlsDatabasePrivate;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GTlsDatabase {
    pub parent_instance: GObject,
    pub priv_: *mut GTlsDatabasePrivate,
}
#[test]
fn bindgen_test_layout__GTlsDatabase() {
    assert_eq!(
        ::std::mem::size_of::<_GTlsDatabase>(),
        32usize,
        concat!("Size of: ", stringify!(_GTlsDatabase))
    );
    assert_eq!(
        ::std::mem::align_of::<_GTlsDatabase>(),
        8usize,
        concat!("Alignment of ", stringify!(_GTlsDatabase))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GTlsDatabase>())).parent_instance as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTlsDatabase),
            "::",
            stringify!(parent_instance)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GTlsDatabase>())).priv_ as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTlsDatabase),
            "::",
            stringify!(priv_)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GTlsDatabaseClass {
    pub parent_class: GObjectClass,
    pub verify_chain: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut GTlsDatabase,
            chain: *mut GTlsCertificate,
            purpose: *const gchar,
            identity: *mut GSocketConnectable,
            interaction: *mut GTlsInteraction,
            flags: GTlsDatabaseVerifyFlags,
            cancellable: *mut GCancellable,
            error: *mut *mut GError,
        ) -> GTlsCertificateFlags,
    >,
    pub verify_chain_async: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut GTlsDatabase,
            chain: *mut GTlsCertificate,
            purpose: *const gchar,
            identity: *mut GSocketConnectable,
            interaction: *mut GTlsInteraction,
            flags: GTlsDatabaseVerifyFlags,
            cancellable: *mut GCancellable,
            callback: GAsyncReadyCallback,
            user_data: gpointer,
        ),
    >,
    pub verify_chain_finish: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut GTlsDatabase,
            result: *mut GAsyncResult,
            error: *mut *mut GError,
        ) -> GTlsCertificateFlags,
    >,
    pub create_certificate_handle: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut GTlsDatabase, certificate: *mut GTlsCertificate)
            -> *mut gchar,
    >,
    pub lookup_certificate_for_handle: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut GTlsDatabase,
            handle: *const gchar,
            interaction: *mut GTlsInteraction,
            flags: GTlsDatabaseLookupFlags,
            cancellable: *mut GCancellable,
            error: *mut *mut GError,
        ) -> *mut GTlsCertificate,
    >,
    pub lookup_certificate_for_handle_async: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut GTlsDatabase,
            handle: *const gchar,
            interaction: *mut GTlsInteraction,
            flags: GTlsDatabaseLookupFlags,
            cancellable: *mut GCancellable,
            callback: GAsyncReadyCallback,
            user_data: gpointer,
        ),
    >,
    pub lookup_certificate_for_handle_finish: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut GTlsDatabase,
            result: *mut GAsyncResult,
            error: *mut *mut GError,
        ) -> *mut GTlsCertificate,
    >,
    pub lookup_certificate_issuer: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut GTlsDatabase,
            certificate: *mut GTlsCertificate,
            interaction: *mut GTlsInteraction,
            flags: GTlsDatabaseLookupFlags,
            cancellable: *mut GCancellable,
            error: *mut *mut GError,
        ) -> *mut GTlsCertificate,
    >,
    pub lookup_certificate_issuer_async: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut GTlsDatabase,
            certificate: *mut GTlsCertificate,
            interaction: *mut GTlsInteraction,
            flags: GTlsDatabaseLookupFlags,
            cancellable: *mut GCancellable,
            callback: GAsyncReadyCallback,
            user_data: gpointer,
        ),
    >,
    pub lookup_certificate_issuer_finish: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut GTlsDatabase,
            result: *mut GAsyncResult,
            error: *mut *mut GError,
        ) -> *mut GTlsCertificate,
    >,
    pub lookup_certificates_issued_by: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut GTlsDatabase,
            issuer_raw_dn: *mut GByteArray,
            interaction: *mut GTlsInteraction,
            flags: GTlsDatabaseLookupFlags,
            cancellable: *mut GCancellable,
            error: *mut *mut GError,
        ) -> *mut GList,
    >,
    pub lookup_certificates_issued_by_async: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut GTlsDatabase,
            issuer_raw_dn: *mut GByteArray,
            interaction: *mut GTlsInteraction,
            flags: GTlsDatabaseLookupFlags,
            cancellable: *mut GCancellable,
            callback: GAsyncReadyCallback,
            user_data: gpointer,
        ),
    >,
    pub lookup_certificates_issued_by_finish: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut GTlsDatabase,
            result: *mut GAsyncResult,
            error: *mut *mut GError,
        ) -> *mut GList,
    >,
    pub padding: [gpointer; 16usize],
}
#[test]
fn bindgen_test_layout__GTlsDatabaseClass() {
    assert_eq!(
        ::std::mem::size_of::<_GTlsDatabaseClass>(),
        368usize,
        concat!("Size of: ", stringify!(_GTlsDatabaseClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_GTlsDatabaseClass>(),
        8usize,
        concat!("Alignment of ", stringify!(_GTlsDatabaseClass))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GTlsDatabaseClass>())).parent_class as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTlsDatabaseClass),
            "::",
            stringify!(parent_class)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GTlsDatabaseClass>())).verify_chain as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTlsDatabaseClass),
            "::",
            stringify!(verify_chain)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GTlsDatabaseClass>())).verify_chain_async as *const _ as usize
        },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTlsDatabaseClass),
            "::",
            stringify!(verify_chain_async)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GTlsDatabaseClass>())).verify_chain_finish as *const _ as usize
        },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTlsDatabaseClass),
            "::",
            stringify!(verify_chain_finish)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GTlsDatabaseClass>())).create_certificate_handle as *const _
                as usize
        },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTlsDatabaseClass),
            "::",
            stringify!(create_certificate_handle)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GTlsDatabaseClass>())).lookup_certificate_for_handle as *const _
                as usize
        },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTlsDatabaseClass),
            "::",
            stringify!(lookup_certificate_for_handle)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GTlsDatabaseClass>())).lookup_certificate_for_handle_async
                as *const _ as usize
        },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTlsDatabaseClass),
            "::",
            stringify!(lookup_certificate_for_handle_async)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GTlsDatabaseClass>())).lookup_certificate_for_handle_finish
                as *const _ as usize
        },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTlsDatabaseClass),
            "::",
            stringify!(lookup_certificate_for_handle_finish)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GTlsDatabaseClass>())).lookup_certificate_issuer as *const _
                as usize
        },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTlsDatabaseClass),
            "::",
            stringify!(lookup_certificate_issuer)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GTlsDatabaseClass>())).lookup_certificate_issuer_async
                as *const _ as usize
        },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTlsDatabaseClass),
            "::",
            stringify!(lookup_certificate_issuer_async)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GTlsDatabaseClass>())).lookup_certificate_issuer_finish
                as *const _ as usize
        },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTlsDatabaseClass),
            "::",
            stringify!(lookup_certificate_issuer_finish)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GTlsDatabaseClass>())).lookup_certificates_issued_by as *const _
                as usize
        },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTlsDatabaseClass),
            "::",
            stringify!(lookup_certificates_issued_by)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GTlsDatabaseClass>())).lookup_certificates_issued_by_async
                as *const _ as usize
        },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTlsDatabaseClass),
            "::",
            stringify!(lookup_certificates_issued_by_async)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GTlsDatabaseClass>())).lookup_certificates_issued_by_finish
                as *const _ as usize
        },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTlsDatabaseClass),
            "::",
            stringify!(lookup_certificates_issued_by_finish)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GTlsDatabaseClass>())).padding as *const _ as usize },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTlsDatabaseClass),
            "::",
            stringify!(padding)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_g_tls_database_get_type"]
    pub fn g_tls_database_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_tls_database_verify_chain"]
    pub fn g_tls_database_verify_chain(
        self_: *mut GTlsDatabase,
        chain: *mut GTlsCertificate,
        purpose: *const gchar,
        identity: *mut GSocketConnectable,
        interaction: *mut GTlsInteraction,
        flags: GTlsDatabaseVerifyFlags,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> GTlsCertificateFlags;
}
extern "C" {
    #[link_name = "\u{1}_g_tls_database_verify_chain_async"]
    pub fn g_tls_database_verify_chain_async(
        self_: *mut GTlsDatabase,
        chain: *mut GTlsCertificate,
        purpose: *const gchar,
        identity: *mut GSocketConnectable,
        interaction: *mut GTlsInteraction,
        flags: GTlsDatabaseVerifyFlags,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_tls_database_verify_chain_finish"]
    pub fn g_tls_database_verify_chain_finish(
        self_: *mut GTlsDatabase,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> GTlsCertificateFlags;
}
extern "C" {
    #[link_name = "\u{1}_g_tls_database_create_certificate_handle"]
    pub fn g_tls_database_create_certificate_handle(
        self_: *mut GTlsDatabase,
        certificate: *mut GTlsCertificate,
    ) -> *mut gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_tls_database_lookup_certificate_for_handle"]
    pub fn g_tls_database_lookup_certificate_for_handle(
        self_: *mut GTlsDatabase,
        handle: *const gchar,
        interaction: *mut GTlsInteraction,
        flags: GTlsDatabaseLookupFlags,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> *mut GTlsCertificate;
}
extern "C" {
    #[link_name = "\u{1}_g_tls_database_lookup_certificate_for_handle_async"]
    pub fn g_tls_database_lookup_certificate_for_handle_async(
        self_: *mut GTlsDatabase,
        handle: *const gchar,
        interaction: *mut GTlsInteraction,
        flags: GTlsDatabaseLookupFlags,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_tls_database_lookup_certificate_for_handle_finish"]
    pub fn g_tls_database_lookup_certificate_for_handle_finish(
        self_: *mut GTlsDatabase,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> *mut GTlsCertificate;
}
extern "C" {
    #[link_name = "\u{1}_g_tls_database_lookup_certificate_issuer"]
    pub fn g_tls_database_lookup_certificate_issuer(
        self_: *mut GTlsDatabase,
        certificate: *mut GTlsCertificate,
        interaction: *mut GTlsInteraction,
        flags: GTlsDatabaseLookupFlags,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> *mut GTlsCertificate;
}
extern "C" {
    #[link_name = "\u{1}_g_tls_database_lookup_certificate_issuer_async"]
    pub fn g_tls_database_lookup_certificate_issuer_async(
        self_: *mut GTlsDatabase,
        certificate: *mut GTlsCertificate,
        interaction: *mut GTlsInteraction,
        flags: GTlsDatabaseLookupFlags,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_tls_database_lookup_certificate_issuer_finish"]
    pub fn g_tls_database_lookup_certificate_issuer_finish(
        self_: *mut GTlsDatabase,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> *mut GTlsCertificate;
}
extern "C" {
    #[link_name = "\u{1}_g_tls_database_lookup_certificates_issued_by"]
    pub fn g_tls_database_lookup_certificates_issued_by(
        self_: *mut GTlsDatabase,
        issuer_raw_dn: *mut GByteArray,
        interaction: *mut GTlsInteraction,
        flags: GTlsDatabaseLookupFlags,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> *mut GList;
}
extern "C" {
    #[link_name = "\u{1}_g_tls_database_lookup_certificates_issued_by_async"]
    pub fn g_tls_database_lookup_certificates_issued_by_async(
        self_: *mut GTlsDatabase,
        issuer_raw_dn: *mut GByteArray,
        interaction: *mut GTlsInteraction,
        flags: GTlsDatabaseLookupFlags,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_tls_database_lookup_certificates_issued_by_finish"]
    pub fn g_tls_database_lookup_certificates_issued_by_finish(
        self_: *mut GTlsDatabase,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> *mut GList;
}
pub type GTlsFileDatabaseInterface = _GTlsFileDatabaseInterface;
/// GTlsFileDatabaseInterface:
/// @g_iface: The parent interface.
///
/// Provides an interface for #GTlsFileDatabase implementations.
///
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GTlsFileDatabaseInterface {
    pub g_iface: GTypeInterface,
    pub padding: [gpointer; 8usize],
}
#[test]
fn bindgen_test_layout__GTlsFileDatabaseInterface() {
    assert_eq!(
        ::std::mem::size_of::<_GTlsFileDatabaseInterface>(),
        80usize,
        concat!("Size of: ", stringify!(_GTlsFileDatabaseInterface))
    );
    assert_eq!(
        ::std::mem::align_of::<_GTlsFileDatabaseInterface>(),
        8usize,
        concat!("Alignment of ", stringify!(_GTlsFileDatabaseInterface))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GTlsFileDatabaseInterface>())).g_iface as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTlsFileDatabaseInterface),
            "::",
            stringify!(g_iface)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GTlsFileDatabaseInterface>())).padding as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTlsFileDatabaseInterface),
            "::",
            stringify!(padding)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_g_tls_file_database_get_type"]
    pub fn g_tls_file_database_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_tls_file_database_new"]
    pub fn g_tls_file_database_new(
        anchors: *const gchar,
        error: *mut *mut GError,
    ) -> *mut GTlsDatabase;
}
pub type GTlsInteractionClass = _GTlsInteractionClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GTlsInteractionPrivate {
    _unused: [u8; 0],
}
pub type GTlsInteractionPrivate = _GTlsInteractionPrivate;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GTlsInteraction {
    pub parent_instance: GObject,
    pub priv_: *mut GTlsInteractionPrivate,
}
#[test]
fn bindgen_test_layout__GTlsInteraction() {
    assert_eq!(
        ::std::mem::size_of::<_GTlsInteraction>(),
        32usize,
        concat!("Size of: ", stringify!(_GTlsInteraction))
    );
    assert_eq!(
        ::std::mem::align_of::<_GTlsInteraction>(),
        8usize,
        concat!("Alignment of ", stringify!(_GTlsInteraction))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GTlsInteraction>())).parent_instance as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTlsInteraction),
            "::",
            stringify!(parent_instance)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GTlsInteraction>())).priv_ as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTlsInteraction),
            "::",
            stringify!(priv_)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GTlsInteractionClass {
    pub parent_class: GObjectClass,
    pub ask_password: ::std::option::Option<
        unsafe extern "C" fn(
            interaction: *mut GTlsInteraction,
            password: *mut GTlsPassword,
            cancellable: *mut GCancellable,
            error: *mut *mut GError,
        ) -> GTlsInteractionResult,
    >,
    pub ask_password_async: ::std::option::Option<
        unsafe extern "C" fn(
            interaction: *mut GTlsInteraction,
            password: *mut GTlsPassword,
            cancellable: *mut GCancellable,
            callback: GAsyncReadyCallback,
            user_data: gpointer,
        ),
    >,
    pub ask_password_finish: ::std::option::Option<
        unsafe extern "C" fn(
            interaction: *mut GTlsInteraction,
            result: *mut GAsyncResult,
            error: *mut *mut GError,
        ) -> GTlsInteractionResult,
    >,
    pub request_certificate: ::std::option::Option<
        unsafe extern "C" fn(
            interaction: *mut GTlsInteraction,
            connection: *mut GTlsConnection,
            flags: GTlsCertificateRequestFlags,
            cancellable: *mut GCancellable,
            error: *mut *mut GError,
        ) -> GTlsInteractionResult,
    >,
    pub request_certificate_async: ::std::option::Option<
        unsafe extern "C" fn(
            interaction: *mut GTlsInteraction,
            connection: *mut GTlsConnection,
            flags: GTlsCertificateRequestFlags,
            cancellable: *mut GCancellable,
            callback: GAsyncReadyCallback,
            user_data: gpointer,
        ),
    >,
    pub request_certificate_finish: ::std::option::Option<
        unsafe extern "C" fn(
            interaction: *mut GTlsInteraction,
            result: *mut GAsyncResult,
            error: *mut *mut GError,
        ) -> GTlsInteractionResult,
    >,
    pub padding: [gpointer; 21usize],
}
#[test]
fn bindgen_test_layout__GTlsInteractionClass() {
    assert_eq!(
        ::std::mem::size_of::<_GTlsInteractionClass>(),
        352usize,
        concat!("Size of: ", stringify!(_GTlsInteractionClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_GTlsInteractionClass>(),
        8usize,
        concat!("Alignment of ", stringify!(_GTlsInteractionClass))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GTlsInteractionClass>())).parent_class as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTlsInteractionClass),
            "::",
            stringify!(parent_class)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GTlsInteractionClass>())).ask_password as *const _ as usize
        },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTlsInteractionClass),
            "::",
            stringify!(ask_password)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GTlsInteractionClass>())).ask_password_async as *const _
                as usize
        },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTlsInteractionClass),
            "::",
            stringify!(ask_password_async)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GTlsInteractionClass>())).ask_password_finish as *const _
                as usize
        },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTlsInteractionClass),
            "::",
            stringify!(ask_password_finish)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GTlsInteractionClass>())).request_certificate as *const _
                as usize
        },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTlsInteractionClass),
            "::",
            stringify!(request_certificate)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GTlsInteractionClass>())).request_certificate_async as *const _
                as usize
        },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTlsInteractionClass),
            "::",
            stringify!(request_certificate_async)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GTlsInteractionClass>())).request_certificate_finish as *const _
                as usize
        },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTlsInteractionClass),
            "::",
            stringify!(request_certificate_finish)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GTlsInteractionClass>())).padding as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTlsInteractionClass),
            "::",
            stringify!(padding)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_g_tls_interaction_get_type"]
    pub fn g_tls_interaction_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_tls_interaction_invoke_ask_password"]
    pub fn g_tls_interaction_invoke_ask_password(
        interaction: *mut GTlsInteraction,
        password: *mut GTlsPassword,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> GTlsInteractionResult;
}
extern "C" {
    #[link_name = "\u{1}_g_tls_interaction_ask_password"]
    pub fn g_tls_interaction_ask_password(
        interaction: *mut GTlsInteraction,
        password: *mut GTlsPassword,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> GTlsInteractionResult;
}
extern "C" {
    #[link_name = "\u{1}_g_tls_interaction_ask_password_async"]
    pub fn g_tls_interaction_ask_password_async(
        interaction: *mut GTlsInteraction,
        password: *mut GTlsPassword,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_tls_interaction_ask_password_finish"]
    pub fn g_tls_interaction_ask_password_finish(
        interaction: *mut GTlsInteraction,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> GTlsInteractionResult;
}
extern "C" {
    #[link_name = "\u{1}_g_tls_interaction_invoke_request_certificate"]
    pub fn g_tls_interaction_invoke_request_certificate(
        interaction: *mut GTlsInteraction,
        connection: *mut GTlsConnection,
        flags: GTlsCertificateRequestFlags,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> GTlsInteractionResult;
}
extern "C" {
    #[link_name = "\u{1}_g_tls_interaction_request_certificate"]
    pub fn g_tls_interaction_request_certificate(
        interaction: *mut GTlsInteraction,
        connection: *mut GTlsConnection,
        flags: GTlsCertificateRequestFlags,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> GTlsInteractionResult;
}
extern "C" {
    #[link_name = "\u{1}_g_tls_interaction_request_certificate_async"]
    pub fn g_tls_interaction_request_certificate_async(
        interaction: *mut GTlsInteraction,
        connection: *mut GTlsConnection,
        flags: GTlsCertificateRequestFlags,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_tls_interaction_request_certificate_finish"]
    pub fn g_tls_interaction_request_certificate_finish(
        interaction: *mut GTlsInteraction,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> GTlsInteractionResult;
}
/// GTlsServerConnection:
///
/// TLS server-side connection. This is the server-side implementation
/// of a #GTlsConnection.
///
/// Since: 2.28
pub type GTlsServerConnectionInterface = _GTlsServerConnectionInterface;
/// GTlsServerConnectionInterface:
/// @g_iface: The parent interface.
///
/// vtable for a #GTlsServerConnection implementation.
///
/// Since: 2.26
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GTlsServerConnectionInterface {
    pub g_iface: GTypeInterface,
}
#[test]
fn bindgen_test_layout__GTlsServerConnectionInterface() {
    assert_eq!(
        ::std::mem::size_of::<_GTlsServerConnectionInterface>(),
        16usize,
        concat!("Size of: ", stringify!(_GTlsServerConnectionInterface))
    );
    assert_eq!(
        ::std::mem::align_of::<_GTlsServerConnectionInterface>(),
        8usize,
        concat!("Alignment of ", stringify!(_GTlsServerConnectionInterface))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GTlsServerConnectionInterface>())).g_iface as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTlsServerConnectionInterface),
            "::",
            stringify!(g_iface)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_g_tls_server_connection_get_type"]
    pub fn g_tls_server_connection_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_tls_server_connection_new"]
    pub fn g_tls_server_connection_new(
        base_io_stream: *mut GIOStream,
        certificate: *mut GTlsCertificate,
        error: *mut *mut GError,
    ) -> *mut GIOStream;
}
pub type GTlsPasswordClass = _GTlsPasswordClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GTlsPasswordPrivate {
    _unused: [u8; 0],
}
pub type GTlsPasswordPrivate = _GTlsPasswordPrivate;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GTlsPassword {
    pub parent_instance: GObject,
    pub priv_: *mut GTlsPasswordPrivate,
}
#[test]
fn bindgen_test_layout__GTlsPassword() {
    assert_eq!(
        ::std::mem::size_of::<_GTlsPassword>(),
        32usize,
        concat!("Size of: ", stringify!(_GTlsPassword))
    );
    assert_eq!(
        ::std::mem::align_of::<_GTlsPassword>(),
        8usize,
        concat!("Alignment of ", stringify!(_GTlsPassword))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GTlsPassword>())).parent_instance as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTlsPassword),
            "::",
            stringify!(parent_instance)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GTlsPassword>())).priv_ as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTlsPassword),
            "::",
            stringify!(priv_)
        )
    );
}
/// GTlsPasswordClass:
/// @get_value: virtual method for g_tls_password_get_value()
/// @set_value: virtual method for g_tls_password_set_value()
/// @get_default_warning: virtual method for g_tls_password_get_warning() if no
/// value has been set using g_tls_password_set_warning()
///
/// Class structure for #GTlsPassword.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GTlsPasswordClass {
    pub parent_class: GObjectClass,
    pub get_value: ::std::option::Option<
        unsafe extern "C" fn(password: *mut GTlsPassword, length: *mut gsize) -> *const guchar,
    >,
    pub set_value: ::std::option::Option<
        unsafe extern "C" fn(
            password: *mut GTlsPassword,
            value: *mut guchar,
            length: gssize,
            destroy: GDestroyNotify,
        ),
    >,
    pub get_default_warning:
        ::std::option::Option<unsafe extern "C" fn(password: *mut GTlsPassword) -> *const gchar>,
    pub padding: [gpointer; 4usize],
}
#[test]
fn bindgen_test_layout__GTlsPasswordClass() {
    assert_eq!(
        ::std::mem::size_of::<_GTlsPasswordClass>(),
        192usize,
        concat!("Size of: ", stringify!(_GTlsPasswordClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_GTlsPasswordClass>(),
        8usize,
        concat!("Alignment of ", stringify!(_GTlsPasswordClass))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GTlsPasswordClass>())).parent_class as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTlsPasswordClass),
            "::",
            stringify!(parent_class)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GTlsPasswordClass>())).get_value as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTlsPasswordClass),
            "::",
            stringify!(get_value)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GTlsPasswordClass>())).set_value as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTlsPasswordClass),
            "::",
            stringify!(set_value)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GTlsPasswordClass>())).get_default_warning as *const _ as usize
        },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTlsPasswordClass),
            "::",
            stringify!(get_default_warning)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GTlsPasswordClass>())).padding as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_GTlsPasswordClass),
            "::",
            stringify!(padding)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_g_tls_password_get_type"]
    pub fn g_tls_password_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_tls_password_new"]
    pub fn g_tls_password_new(
        flags: GTlsPasswordFlags,
        description: *const gchar,
    ) -> *mut GTlsPassword;
}
extern "C" {
    #[link_name = "\u{1}_g_tls_password_get_value"]
    pub fn g_tls_password_get_value(
        password: *mut GTlsPassword,
        length: *mut gsize,
    ) -> *const guchar;
}
extern "C" {
    #[link_name = "\u{1}_g_tls_password_set_value"]
    pub fn g_tls_password_set_value(
        password: *mut GTlsPassword,
        value: *const guchar,
        length: gssize,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_tls_password_set_value_full"]
    pub fn g_tls_password_set_value_full(
        password: *mut GTlsPassword,
        value: *mut guchar,
        length: gssize,
        destroy: GDestroyNotify,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_tls_password_get_flags"]
    pub fn g_tls_password_get_flags(password: *mut GTlsPassword) -> GTlsPasswordFlags;
}
extern "C" {
    #[link_name = "\u{1}_g_tls_password_set_flags"]
    pub fn g_tls_password_set_flags(password: *mut GTlsPassword, flags: GTlsPasswordFlags);
}
extern "C" {
    #[link_name = "\u{1}_g_tls_password_get_description"]
    pub fn g_tls_password_get_description(password: *mut GTlsPassword) -> *const gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_tls_password_set_description"]
    pub fn g_tls_password_set_description(password: *mut GTlsPassword, description: *const gchar);
}
extern "C" {
    #[link_name = "\u{1}_g_tls_password_get_warning"]
    pub fn g_tls_password_get_warning(password: *mut GTlsPassword) -> *const gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_tls_password_set_warning"]
    pub fn g_tls_password_set_warning(password: *mut GTlsPassword, warning: *const gchar);
}
/// GVfsFileLookupFunc:
/// @vfs: a #GVfs
/// @identifier: the identifier to lookup a #GFile for. This can either
/// be an URI or a parse name as returned by g_file_get_parse_name()
/// @user_data: user data passed to the function
///
/// This function type is used by g_vfs_register_uri_scheme() to make it
/// possible for a client to associate an URI scheme to a different #GFile
/// implementation.
///
/// The client should return a reference to the new file that has been
/// created for @uri, or %NULL to continue with the default implementation.
///
/// Returns: (transfer full): a #GFile for @identifier.
///
/// Since: 2.50
pub type GVfsFileLookupFunc = ::std::option::Option<
    unsafe extern "C" fn(
        vfs: *mut GVfs,
        identifier: *const ::std::os::raw::c_char,
        user_data: gpointer,
    ) -> *mut GFile,
>;
/// GVfs:
///
/// Virtual File System object.
pub type GVfsClass = _GVfsClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GVfs {
    pub parent_instance: GObject,
}
#[test]
fn bindgen_test_layout__GVfs() {
    assert_eq!(
        ::std::mem::size_of::<_GVfs>(),
        24usize,
        concat!("Size of: ", stringify!(_GVfs))
    );
    assert_eq!(
        ::std::mem::align_of::<_GVfs>(),
        8usize,
        concat!("Alignment of ", stringify!(_GVfs))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GVfs>())).parent_instance as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GVfs),
            "::",
            stringify!(parent_instance)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GVfsClass {
    pub parent_class: GObjectClass,
    pub is_active: ::std::option::Option<unsafe extern "C" fn(vfs: *mut GVfs) -> gboolean>,
    pub get_file_for_path: ::std::option::Option<
        unsafe extern "C" fn(vfs: *mut GVfs, path: *const ::std::os::raw::c_char) -> *mut GFile,
    >,
    pub get_file_for_uri: ::std::option::Option<
        unsafe extern "C" fn(vfs: *mut GVfs, uri: *const ::std::os::raw::c_char) -> *mut GFile,
    >,
    pub get_supported_uri_schemes:
        ::std::option::Option<unsafe extern "C" fn(vfs: *mut GVfs) -> *const *const gchar>,
    pub parse_name: ::std::option::Option<
        unsafe extern "C" fn(vfs: *mut GVfs, parse_name: *const ::std::os::raw::c_char)
            -> *mut GFile,
    >,
    pub local_file_add_info: ::std::option::Option<
        unsafe extern "C" fn(
            vfs: *mut GVfs,
            filename: *const ::std::os::raw::c_char,
            device: guint64,
            attribute_matcher: *mut GFileAttributeMatcher,
            info: *mut GFileInfo,
            cancellable: *mut GCancellable,
            extra_data: *mut gpointer,
            free_extra_data: *mut GDestroyNotify,
        ),
    >,
    pub add_writable_namespaces: ::std::option::Option<
        unsafe extern "C" fn(vfs: *mut GVfs, list: *mut GFileAttributeInfoList),
    >,
    pub local_file_set_attributes: ::std::option::Option<
        unsafe extern "C" fn(
            vfs: *mut GVfs,
            filename: *const ::std::os::raw::c_char,
            info: *mut GFileInfo,
            flags: GFileQueryInfoFlags,
            cancellable: *mut GCancellable,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
    pub local_file_removed: ::std::option::Option<
        unsafe extern "C" fn(vfs: *mut GVfs, filename: *const ::std::os::raw::c_char),
    >,
    pub local_file_moved: ::std::option::Option<
        unsafe extern "C" fn(
            vfs: *mut GVfs,
            source: *const ::std::os::raw::c_char,
            dest: *const ::std::os::raw::c_char,
        ),
    >,
    pub deserialize_icon: ::std::option::Option<
        unsafe extern "C" fn(vfs: *mut GVfs, value: *mut GVariant) -> *mut GIcon,
    >,
    pub _g_reserved1: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved2: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved3: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved4: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved5: ::std::option::Option<unsafe extern "C" fn()>,
    pub _g_reserved6: ::std::option::Option<unsafe extern "C" fn()>,
}
#[test]
fn bindgen_test_layout__GVfsClass() {
    assert_eq!(
        ::std::mem::size_of::<_GVfsClass>(),
        272usize,
        concat!("Size of: ", stringify!(_GVfsClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_GVfsClass>(),
        8usize,
        concat!("Alignment of ", stringify!(_GVfsClass))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GVfsClass>())).parent_class as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GVfsClass),
            "::",
            stringify!(parent_class)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GVfsClass>())).is_active as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_GVfsClass),
            "::",
            stringify!(is_active)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GVfsClass>())).get_file_for_path as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_GVfsClass),
            "::",
            stringify!(get_file_for_path)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GVfsClass>())).get_file_for_uri as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(_GVfsClass),
            "::",
            stringify!(get_file_for_uri)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GVfsClass>())).get_supported_uri_schemes as *const _ as usize
        },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_GVfsClass),
            "::",
            stringify!(get_supported_uri_schemes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GVfsClass>())).parse_name as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(_GVfsClass),
            "::",
            stringify!(parse_name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GVfsClass>())).local_file_add_info as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(_GVfsClass),
            "::",
            stringify!(local_file_add_info)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GVfsClass>())).add_writable_namespaces as *const _ as usize
        },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(_GVfsClass),
            "::",
            stringify!(add_writable_namespaces)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GVfsClass>())).local_file_set_attributes as *const _ as usize
        },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(_GVfsClass),
            "::",
            stringify!(local_file_set_attributes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GVfsClass>())).local_file_removed as *const _ as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(_GVfsClass),
            "::",
            stringify!(local_file_removed)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GVfsClass>())).local_file_moved as *const _ as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(_GVfsClass),
            "::",
            stringify!(local_file_moved)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GVfsClass>())).deserialize_icon as *const _ as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(_GVfsClass),
            "::",
            stringify!(deserialize_icon)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GVfsClass>()))._g_reserved1 as *const _ as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(_GVfsClass),
            "::",
            stringify!(_g_reserved1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GVfsClass>()))._g_reserved2 as *const _ as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(_GVfsClass),
            "::",
            stringify!(_g_reserved2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GVfsClass>()))._g_reserved3 as *const _ as usize },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(_GVfsClass),
            "::",
            stringify!(_g_reserved3)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GVfsClass>()))._g_reserved4 as *const _ as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(_GVfsClass),
            "::",
            stringify!(_g_reserved4)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GVfsClass>()))._g_reserved5 as *const _ as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(_GVfsClass),
            "::",
            stringify!(_g_reserved5)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GVfsClass>()))._g_reserved6 as *const _ as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(_GVfsClass),
            "::",
            stringify!(_g_reserved6)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_g_vfs_get_type"]
    pub fn g_vfs_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_vfs_is_active"]
    pub fn g_vfs_is_active(vfs: *mut GVfs) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_vfs_get_file_for_path"]
    pub fn g_vfs_get_file_for_path(
        vfs: *mut GVfs,
        path: *const ::std::os::raw::c_char,
    ) -> *mut GFile;
}
extern "C" {
    #[link_name = "\u{1}_g_vfs_get_file_for_uri"]
    pub fn g_vfs_get_file_for_uri(vfs: *mut GVfs, uri: *const ::std::os::raw::c_char)
        -> *mut GFile;
}
extern "C" {
    #[link_name = "\u{1}_g_vfs_get_supported_uri_schemes"]
    pub fn g_vfs_get_supported_uri_schemes(vfs: *mut GVfs) -> *const *const gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_vfs_parse_name"]
    pub fn g_vfs_parse_name(
        vfs: *mut GVfs,
        parse_name: *const ::std::os::raw::c_char,
    ) -> *mut GFile;
}
extern "C" {
    #[link_name = "\u{1}_g_vfs_get_default"]
    pub fn g_vfs_get_default() -> *mut GVfs;
}
extern "C" {
    #[link_name = "\u{1}_g_vfs_get_local"]
    pub fn g_vfs_get_local() -> *mut GVfs;
}
extern "C" {
    #[link_name = "\u{1}_g_vfs_register_uri_scheme"]
    pub fn g_vfs_register_uri_scheme(
        vfs: *mut GVfs,
        scheme: *const ::std::os::raw::c_char,
        uri_func: GVfsFileLookupFunc,
        uri_data: gpointer,
        uri_destroy: GDestroyNotify,
        parse_name_func: GVfsFileLookupFunc,
        parse_name_data: gpointer,
        parse_name_destroy: GDestroyNotify,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_vfs_unregister_uri_scheme"]
    pub fn g_vfs_unregister_uri_scheme(
        vfs: *mut GVfs,
        scheme: *const ::std::os::raw::c_char,
    ) -> gboolean;
}
/// GVolumeIface:
/// @g_iface: The parent interface.
/// @changed: Changed signal that is emitted when the volume's state has changed.
/// @removed: The removed signal that is emitted when the #GVolume have been removed. If the recipient is holding references to the object they should release them so the object can be finalized.
/// @get_name: Gets a string containing the name of the #GVolume.
/// @get_icon: Gets a #GIcon for the #GVolume.
/// @get_uuid: Gets the UUID for the #GVolume. The reference is typically based on the file system UUID for the mount in question and should be considered an opaque string. Returns %NULL if there is no UUID available.
/// @get_drive: Gets a #GDrive the volume is located on. Returns %NULL if the #GVolume is not associated with a #GDrive.
/// @get_mount: Gets a #GMount representing the mounted volume. Returns %NULL if the #GVolume is not mounted.
/// @can_mount: Returns %TRUE if the #GVolume can be mounted.
/// @can_eject: Checks if a #GVolume can be ejected.
/// @mount_fn: Mounts a given #GVolume.
/// #GVolume implementations must emit the #GMountOperation::aborted
/// signal before completing a mount operation that is aborted while
/// awaiting input from the user through a #GMountOperation instance.
/// @mount_finish: Finishes a mount operation.
/// @eject: Ejects a given #GVolume.
/// @eject_finish: Finishes an eject operation.
/// @get_identifier: Returns the [identifier][volume-identifier] of the given kind, or %NULL if
/// the #GVolume doesn't have one.
/// @enumerate_identifiers: Returns an array strings listing the kinds
/// of [identifiers][volume-identifier] which the #GVolume has.
/// @should_automount: Returns %TRUE if the #GVolume should be automatically mounted.
/// @get_activation_root: Returns the activation root for the #GVolume if it is known in advance or %NULL if
/// it is not known.
/// @eject_with_operation: Starts ejecting a #GVolume using a #GMountOperation. Since 2.22.
/// @eject_with_operation_finish: Finishes an eject operation using a #GMountOperation. Since 2.22.
/// @get_sort_key: Gets a key used for sorting #GVolume instance or %NULL if no such key exists. Since 2.32.
/// @get_symbolic_icon: Gets a symbolic #GIcon for the #GVolume. Since 2.34.
///
/// Interface for implementing operations for mountable volumes.
pub type GVolumeIface = _GVolumeIface;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GVolumeIface {
    pub g_iface: GTypeInterface,
    pub changed: ::std::option::Option<unsafe extern "C" fn(volume: *mut GVolume)>,
    pub removed: ::std::option::Option<unsafe extern "C" fn(volume: *mut GVolume)>,
    pub get_name: ::std::option::Option<
        unsafe extern "C" fn(volume: *mut GVolume) -> *mut ::std::os::raw::c_char,
    >,
    pub get_icon: ::std::option::Option<unsafe extern "C" fn(volume: *mut GVolume) -> *mut GIcon>,
    pub get_uuid: ::std::option::Option<
        unsafe extern "C" fn(volume: *mut GVolume) -> *mut ::std::os::raw::c_char,
    >,
    pub get_drive: ::std::option::Option<unsafe extern "C" fn(volume: *mut GVolume) -> *mut GDrive>,
    pub get_mount: ::std::option::Option<unsafe extern "C" fn(volume: *mut GVolume) -> *mut GMount>,
    pub can_mount: ::std::option::Option<unsafe extern "C" fn(volume: *mut GVolume) -> gboolean>,
    pub can_eject: ::std::option::Option<unsafe extern "C" fn(volume: *mut GVolume) -> gboolean>,
    pub mount_fn: ::std::option::Option<
        unsafe extern "C" fn(
            volume: *mut GVolume,
            flags: GMountMountFlags,
            mount_operation: *mut GMountOperation,
            cancellable: *mut GCancellable,
            callback: GAsyncReadyCallback,
            user_data: gpointer,
        ),
    >,
    pub mount_finish: ::std::option::Option<
        unsafe extern "C" fn(
            volume: *mut GVolume,
            result: *mut GAsyncResult,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
    pub eject: ::std::option::Option<
        unsafe extern "C" fn(
            volume: *mut GVolume,
            flags: GMountUnmountFlags,
            cancellable: *mut GCancellable,
            callback: GAsyncReadyCallback,
            user_data: gpointer,
        ),
    >,
    pub eject_finish: ::std::option::Option<
        unsafe extern "C" fn(
            volume: *mut GVolume,
            result: *mut GAsyncResult,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
    pub get_identifier: ::std::option::Option<
        unsafe extern "C" fn(volume: *mut GVolume, kind: *const ::std::os::raw::c_char)
            -> *mut ::std::os::raw::c_char,
    >,
    pub enumerate_identifiers: ::std::option::Option<
        unsafe extern "C" fn(volume: *mut GVolume) -> *mut *mut ::std::os::raw::c_char,
    >,
    pub should_automount:
        ::std::option::Option<unsafe extern "C" fn(volume: *mut GVolume) -> gboolean>,
    pub get_activation_root:
        ::std::option::Option<unsafe extern "C" fn(volume: *mut GVolume) -> *mut GFile>,
    pub eject_with_operation: ::std::option::Option<
        unsafe extern "C" fn(
            volume: *mut GVolume,
            flags: GMountUnmountFlags,
            mount_operation: *mut GMountOperation,
            cancellable: *mut GCancellable,
            callback: GAsyncReadyCallback,
            user_data: gpointer,
        ),
    >,
    pub eject_with_operation_finish: ::std::option::Option<
        unsafe extern "C" fn(
            volume: *mut GVolume,
            result: *mut GAsyncResult,
            error: *mut *mut GError,
        ) -> gboolean,
    >,
    pub get_sort_key:
        ::std::option::Option<unsafe extern "C" fn(volume: *mut GVolume) -> *const gchar>,
    pub get_symbolic_icon:
        ::std::option::Option<unsafe extern "C" fn(volume: *mut GVolume) -> *mut GIcon>,
}
#[test]
fn bindgen_test_layout__GVolumeIface() {
    assert_eq!(
        ::std::mem::size_of::<_GVolumeIface>(),
        184usize,
        concat!("Size of: ", stringify!(_GVolumeIface))
    );
    assert_eq!(
        ::std::mem::align_of::<_GVolumeIface>(),
        8usize,
        concat!("Alignment of ", stringify!(_GVolumeIface))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GVolumeIface>())).g_iface as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GVolumeIface),
            "::",
            stringify!(g_iface)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GVolumeIface>())).changed as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GVolumeIface),
            "::",
            stringify!(changed)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GVolumeIface>())).removed as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GVolumeIface),
            "::",
            stringify!(removed)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GVolumeIface>())).get_name as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_GVolumeIface),
            "::",
            stringify!(get_name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GVolumeIface>())).get_icon as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_GVolumeIface),
            "::",
            stringify!(get_icon)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GVolumeIface>())).get_uuid as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_GVolumeIface),
            "::",
            stringify!(get_uuid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GVolumeIface>())).get_drive as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_GVolumeIface),
            "::",
            stringify!(get_drive)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GVolumeIface>())).get_mount as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_GVolumeIface),
            "::",
            stringify!(get_mount)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GVolumeIface>())).can_mount as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_GVolumeIface),
            "::",
            stringify!(can_mount)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GVolumeIface>())).can_eject as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_GVolumeIface),
            "::",
            stringify!(can_eject)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GVolumeIface>())).mount_fn as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_GVolumeIface),
            "::",
            stringify!(mount_fn)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GVolumeIface>())).mount_finish as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_GVolumeIface),
            "::",
            stringify!(mount_finish)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GVolumeIface>())).eject as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_GVolumeIface),
            "::",
            stringify!(eject)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GVolumeIface>())).eject_finish as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(_GVolumeIface),
            "::",
            stringify!(eject_finish)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GVolumeIface>())).get_identifier as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(_GVolumeIface),
            "::",
            stringify!(get_identifier)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GVolumeIface>())).enumerate_identifiers as *const _ as usize
        },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(_GVolumeIface),
            "::",
            stringify!(enumerate_identifiers)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GVolumeIface>())).should_automount as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_GVolumeIface),
            "::",
            stringify!(should_automount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GVolumeIface>())).get_activation_root as *const _ as usize
        },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_GVolumeIface),
            "::",
            stringify!(get_activation_root)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GVolumeIface>())).eject_with_operation as *const _ as usize
        },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(_GVolumeIface),
            "::",
            stringify!(eject_with_operation)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GVolumeIface>())).eject_with_operation_finish as *const _
                as usize
        },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_GVolumeIface),
            "::",
            stringify!(eject_with_operation_finish)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GVolumeIface>())).get_sort_key as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(_GVolumeIface),
            "::",
            stringify!(get_sort_key)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GVolumeIface>())).get_symbolic_icon as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(_GVolumeIface),
            "::",
            stringify!(get_symbolic_icon)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_g_volume_get_type"]
    pub fn g_volume_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_volume_get_name"]
    pub fn g_volume_get_name(volume: *mut GVolume) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_g_volume_get_icon"]
    pub fn g_volume_get_icon(volume: *mut GVolume) -> *mut GIcon;
}
extern "C" {
    #[link_name = "\u{1}_g_volume_get_symbolic_icon"]
    pub fn g_volume_get_symbolic_icon(volume: *mut GVolume) -> *mut GIcon;
}
extern "C" {
    #[link_name = "\u{1}_g_volume_get_uuid"]
    pub fn g_volume_get_uuid(volume: *mut GVolume) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_g_volume_get_drive"]
    pub fn g_volume_get_drive(volume: *mut GVolume) -> *mut GDrive;
}
extern "C" {
    #[link_name = "\u{1}_g_volume_get_mount"]
    pub fn g_volume_get_mount(volume: *mut GVolume) -> *mut GMount;
}
extern "C" {
    #[link_name = "\u{1}_g_volume_can_mount"]
    pub fn g_volume_can_mount(volume: *mut GVolume) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_volume_can_eject"]
    pub fn g_volume_can_eject(volume: *mut GVolume) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_volume_should_automount"]
    pub fn g_volume_should_automount(volume: *mut GVolume) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_volume_mount"]
    pub fn g_volume_mount(
        volume: *mut GVolume,
        flags: GMountMountFlags,
        mount_operation: *mut GMountOperation,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_volume_mount_finish"]
    pub fn g_volume_mount_finish(
        volume: *mut GVolume,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_volume_eject"]
    pub fn g_volume_eject(
        volume: *mut GVolume,
        flags: GMountUnmountFlags,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_volume_eject_finish"]
    pub fn g_volume_eject_finish(
        volume: *mut GVolume,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_volume_get_identifier"]
    pub fn g_volume_get_identifier(
        volume: *mut GVolume,
        kind: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_g_volume_enumerate_identifiers"]
    pub fn g_volume_enumerate_identifiers(volume: *mut GVolume)
        -> *mut *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_g_volume_get_activation_root"]
    pub fn g_volume_get_activation_root(volume: *mut GVolume) -> *mut GFile;
}
extern "C" {
    #[link_name = "\u{1}_g_volume_eject_with_operation"]
    pub fn g_volume_eject_with_operation(
        volume: *mut GVolume,
        flags: GMountUnmountFlags,
        mount_operation: *mut GMountOperation,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_volume_eject_with_operation_finish"]
    pub fn g_volume_eject_with_operation_finish(
        volume: *mut GVolume,
        result: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_volume_get_sort_key"]
    pub fn g_volume_get_sort_key(volume: *mut GVolume) -> *const gchar;
}
pub type GZlibCompressorClass = _GZlibCompressorClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GZlibCompressorClass {
    pub parent_class: GObjectClass,
}
#[test]
fn bindgen_test_layout__GZlibCompressorClass() {
    assert_eq!(
        ::std::mem::size_of::<_GZlibCompressorClass>(),
        136usize,
        concat!("Size of: ", stringify!(_GZlibCompressorClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_GZlibCompressorClass>(),
        8usize,
        concat!("Alignment of ", stringify!(_GZlibCompressorClass))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GZlibCompressorClass>())).parent_class as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GZlibCompressorClass),
            "::",
            stringify!(parent_class)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_g_zlib_compressor_get_type"]
    pub fn g_zlib_compressor_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_zlib_compressor_new"]
    pub fn g_zlib_compressor_new(
        format: GZlibCompressorFormat,
        level: ::std::os::raw::c_int,
    ) -> *mut GZlibCompressor;
}
extern "C" {
    #[link_name = "\u{1}_g_zlib_compressor_get_file_info"]
    pub fn g_zlib_compressor_get_file_info(compressor: *mut GZlibCompressor) -> *mut GFileInfo;
}
extern "C" {
    #[link_name = "\u{1}_g_zlib_compressor_set_file_info"]
    pub fn g_zlib_compressor_set_file_info(
        compressor: *mut GZlibCompressor,
        file_info: *mut GFileInfo,
    );
}
pub type GZlibDecompressorClass = _GZlibDecompressorClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GZlibDecompressorClass {
    pub parent_class: GObjectClass,
}
#[test]
fn bindgen_test_layout__GZlibDecompressorClass() {
    assert_eq!(
        ::std::mem::size_of::<_GZlibDecompressorClass>(),
        136usize,
        concat!("Size of: ", stringify!(_GZlibDecompressorClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_GZlibDecompressorClass>(),
        8usize,
        concat!("Alignment of ", stringify!(_GZlibDecompressorClass))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GZlibDecompressorClass>())).parent_class as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GZlibDecompressorClass),
            "::",
            stringify!(parent_class)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_g_zlib_decompressor_get_type"]
    pub fn g_zlib_decompressor_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_zlib_decompressor_new"]
    pub fn g_zlib_decompressor_new(format: GZlibCompressorFormat) -> *mut GZlibDecompressor;
}
extern "C" {
    #[link_name = "\u{1}_g_zlib_decompressor_get_file_info"]
    pub fn g_zlib_decompressor_get_file_info(
        decompressor: *mut GZlibDecompressor,
    ) -> *mut GFileInfo;
}
/// GDBusInterface:
///
/// Base type for D-Bus interfaces.
///
/// Since: 2.30
pub type GDBusInterfaceIface = _GDBusInterfaceIface;
/// GDBusInterfaceIface:
/// @parent_iface: The parent interface.
/// @get_info: Returns a #GDBusInterfaceInfo. See g_dbus_interface_get_info().
/// @get_object: Gets the enclosing #GDBusObject. See g_dbus_interface_get_object().
/// @set_object: Sets the enclosing #GDBusObject. See g_dbus_interface_set_object().
/// @dup_object: Gets a reference to the enclosing #GDBusObject. See g_dbus_interface_dup_object(). Added in 2.32.
///
/// Base type for D-Bus interfaces.
///
/// Since: 2.30
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GDBusInterfaceIface {
    pub parent_iface: GTypeInterface,
    pub get_info: ::std::option::Option<
        unsafe extern "C" fn(interface_: *mut GDBusInterface) -> *mut GDBusInterfaceInfo,
    >,
    pub get_object: ::std::option::Option<
        unsafe extern "C" fn(interface_: *mut GDBusInterface) -> *mut GDBusObject,
    >,
    pub set_object: ::std::option::Option<
        unsafe extern "C" fn(interface_: *mut GDBusInterface, object: *mut GDBusObject),
    >,
    pub dup_object: ::std::option::Option<
        unsafe extern "C" fn(interface_: *mut GDBusInterface) -> *mut GDBusObject,
    >,
}
#[test]
fn bindgen_test_layout__GDBusInterfaceIface() {
    assert_eq!(
        ::std::mem::size_of::<_GDBusInterfaceIface>(),
        48usize,
        concat!("Size of: ", stringify!(_GDBusInterfaceIface))
    );
    assert_eq!(
        ::std::mem::align_of::<_GDBusInterfaceIface>(),
        8usize,
        concat!("Alignment of ", stringify!(_GDBusInterfaceIface))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GDBusInterfaceIface>())).parent_iface as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDBusInterfaceIface),
            "::",
            stringify!(parent_iface)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GDBusInterfaceIface>())).get_info as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDBusInterfaceIface),
            "::",
            stringify!(get_info)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GDBusInterfaceIface>())).get_object as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDBusInterfaceIface),
            "::",
            stringify!(get_object)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GDBusInterfaceIface>())).set_object as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDBusInterfaceIface),
            "::",
            stringify!(set_object)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GDBusInterfaceIface>())).dup_object as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDBusInterfaceIface),
            "::",
            stringify!(dup_object)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_g_dbus_interface_get_type"]
    pub fn g_dbus_interface_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_dbus_interface_get_info"]
    pub fn g_dbus_interface_get_info(interface_: *mut GDBusInterface) -> *mut GDBusInterfaceInfo;
}
extern "C" {
    #[link_name = "\u{1}_g_dbus_interface_get_object"]
    pub fn g_dbus_interface_get_object(interface_: *mut GDBusInterface) -> *mut GDBusObject;
}
extern "C" {
    #[link_name = "\u{1}_g_dbus_interface_set_object"]
    pub fn g_dbus_interface_set_object(interface_: *mut GDBusInterface, object: *mut GDBusObject);
}
extern "C" {
    #[link_name = "\u{1}_g_dbus_interface_dup_object"]
    pub fn g_dbus_interface_dup_object(interface_: *mut GDBusInterface) -> *mut GDBusObject;
}
pub type GDBusInterfaceSkeletonClass = _GDBusInterfaceSkeletonClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GDBusInterfaceSkeletonPrivate {
    _unused: [u8; 0],
}
pub type GDBusInterfaceSkeletonPrivate = _GDBusInterfaceSkeletonPrivate;
/// GDBusInterfaceSkeleton:
///
/// The #GDBusInterfaceSkeleton structure contains private data and should
/// only be accessed using the provided API.
///
/// Since: 2.30
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GDBusInterfaceSkeleton {
    pub parent_instance: GObject,
    pub priv_: *mut GDBusInterfaceSkeletonPrivate,
}
#[test]
fn bindgen_test_layout__GDBusInterfaceSkeleton() {
    assert_eq!(
        ::std::mem::size_of::<_GDBusInterfaceSkeleton>(),
        32usize,
        concat!("Size of: ", stringify!(_GDBusInterfaceSkeleton))
    );
    assert_eq!(
        ::std::mem::align_of::<_GDBusInterfaceSkeleton>(),
        8usize,
        concat!("Alignment of ", stringify!(_GDBusInterfaceSkeleton))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GDBusInterfaceSkeleton>())).parent_instance as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDBusInterfaceSkeleton),
            "::",
            stringify!(parent_instance)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GDBusInterfaceSkeleton>())).priv_ as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDBusInterfaceSkeleton),
            "::",
            stringify!(priv_)
        )
    );
}
/// GDBusInterfaceSkeletonClass:
/// @parent_class: The parent class.
/// @get_info: Returns a #GDBusInterfaceInfo. See g_dbus_interface_skeleton_get_info() for details.
/// @get_vtable: Returns a #GDBusInterfaceVTable. See g_dbus_interface_skeleton_get_vtable() for details.
/// @get_properties: Returns a #GVariant with all properties. See g_dbus_interface_skeleton_get_properties().
/// @flush: Emits outstanding changes, if any. See g_dbus_interface_skeleton_flush().
/// @g_authorize_method: Signal class handler for the #GDBusInterfaceSkeleton::g-authorize-method signal.
///
/// Class structure for #GDBusInterfaceSkeleton.
///
/// Since: 2.30
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GDBusInterfaceSkeletonClass {
    pub parent_class: GObjectClass,
    pub get_info: ::std::option::Option<
        unsafe extern "C" fn(interface_: *mut GDBusInterfaceSkeleton) -> *mut GDBusInterfaceInfo,
    >,
    pub get_vtable: ::std::option::Option<
        unsafe extern "C" fn(interface_: *mut GDBusInterfaceSkeleton) -> *mut GDBusInterfaceVTable,
    >,
    pub get_properties: ::std::option::Option<
        unsafe extern "C" fn(interface_: *mut GDBusInterfaceSkeleton) -> *mut GVariant,
    >,
    pub flush: ::std::option::Option<unsafe extern "C" fn(interface_: *mut GDBusInterfaceSkeleton)>,
    pub vfunc_padding: [gpointer; 8usize],
    pub g_authorize_method: ::std::option::Option<
        unsafe extern "C" fn(
            interface_: *mut GDBusInterfaceSkeleton,
            invocation: *mut GDBusMethodInvocation,
        ) -> gboolean,
    >,
    pub signal_padding: [gpointer; 8usize],
}
#[test]
fn bindgen_test_layout__GDBusInterfaceSkeletonClass() {
    assert_eq!(
        ::std::mem::size_of::<_GDBusInterfaceSkeletonClass>(),
        304usize,
        concat!("Size of: ", stringify!(_GDBusInterfaceSkeletonClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_GDBusInterfaceSkeletonClass>(),
        8usize,
        concat!("Alignment of ", stringify!(_GDBusInterfaceSkeletonClass))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GDBusInterfaceSkeletonClass>())).parent_class as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDBusInterfaceSkeletonClass),
            "::",
            stringify!(parent_class)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GDBusInterfaceSkeletonClass>())).get_info as *const _ as usize
        },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDBusInterfaceSkeletonClass),
            "::",
            stringify!(get_info)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GDBusInterfaceSkeletonClass>())).get_vtable as *const _ as usize
        },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDBusInterfaceSkeletonClass),
            "::",
            stringify!(get_vtable)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GDBusInterfaceSkeletonClass>())).get_properties as *const _
                as usize
        },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDBusInterfaceSkeletonClass),
            "::",
            stringify!(get_properties)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GDBusInterfaceSkeletonClass>())).flush as *const _ as usize
        },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDBusInterfaceSkeletonClass),
            "::",
            stringify!(flush)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GDBusInterfaceSkeletonClass>())).vfunc_padding as *const _
                as usize
        },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDBusInterfaceSkeletonClass),
            "::",
            stringify!(vfunc_padding)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GDBusInterfaceSkeletonClass>())).g_authorize_method as *const _
                as usize
        },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDBusInterfaceSkeletonClass),
            "::",
            stringify!(g_authorize_method)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GDBusInterfaceSkeletonClass>())).signal_padding as *const _
                as usize
        },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDBusInterfaceSkeletonClass),
            "::",
            stringify!(signal_padding)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_g_dbus_interface_skeleton_get_type"]
    pub fn g_dbus_interface_skeleton_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_dbus_interface_skeleton_get_flags"]
    pub fn g_dbus_interface_skeleton_get_flags(
        interface_: *mut GDBusInterfaceSkeleton,
    ) -> GDBusInterfaceSkeletonFlags;
}
extern "C" {
    #[link_name = "\u{1}_g_dbus_interface_skeleton_set_flags"]
    pub fn g_dbus_interface_skeleton_set_flags(
        interface_: *mut GDBusInterfaceSkeleton,
        flags: GDBusInterfaceSkeletonFlags,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_dbus_interface_skeleton_get_info"]
    pub fn g_dbus_interface_skeleton_get_info(
        interface_: *mut GDBusInterfaceSkeleton,
    ) -> *mut GDBusInterfaceInfo;
}
extern "C" {
    #[link_name = "\u{1}_g_dbus_interface_skeleton_get_vtable"]
    pub fn g_dbus_interface_skeleton_get_vtable(
        interface_: *mut GDBusInterfaceSkeleton,
    ) -> *mut GDBusInterfaceVTable;
}
extern "C" {
    #[link_name = "\u{1}_g_dbus_interface_skeleton_get_properties"]
    pub fn g_dbus_interface_skeleton_get_properties(
        interface_: *mut GDBusInterfaceSkeleton,
    ) -> *mut GVariant;
}
extern "C" {
    #[link_name = "\u{1}_g_dbus_interface_skeleton_flush"]
    pub fn g_dbus_interface_skeleton_flush(interface_: *mut GDBusInterfaceSkeleton);
}
extern "C" {
    #[link_name = "\u{1}_g_dbus_interface_skeleton_export"]
    pub fn g_dbus_interface_skeleton_export(
        interface_: *mut GDBusInterfaceSkeleton,
        connection: *mut GDBusConnection,
        object_path: *const gchar,
        error: *mut *mut GError,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_dbus_interface_skeleton_unexport"]
    pub fn g_dbus_interface_skeleton_unexport(interface_: *mut GDBusInterfaceSkeleton);
}
extern "C" {
    #[link_name = "\u{1}_g_dbus_interface_skeleton_unexport_from_connection"]
    pub fn g_dbus_interface_skeleton_unexport_from_connection(
        interface_: *mut GDBusInterfaceSkeleton,
        connection: *mut GDBusConnection,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_dbus_interface_skeleton_get_connection"]
    pub fn g_dbus_interface_skeleton_get_connection(
        interface_: *mut GDBusInterfaceSkeleton,
    ) -> *mut GDBusConnection;
}
extern "C" {
    #[link_name = "\u{1}_g_dbus_interface_skeleton_get_connections"]
    pub fn g_dbus_interface_skeleton_get_connections(
        interface_: *mut GDBusInterfaceSkeleton,
    ) -> *mut GList;
}
extern "C" {
    #[link_name = "\u{1}_g_dbus_interface_skeleton_has_connection"]
    pub fn g_dbus_interface_skeleton_has_connection(
        interface_: *mut GDBusInterfaceSkeleton,
        connection: *mut GDBusConnection,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_dbus_interface_skeleton_get_object_path"]
    pub fn g_dbus_interface_skeleton_get_object_path(
        interface_: *mut GDBusInterfaceSkeleton,
    ) -> *const gchar;
}
pub type GDBusObjectIface = _GDBusObjectIface;
/// GDBusObjectIface:
/// @parent_iface: The parent interface.
/// @get_object_path: Returns the object path. See g_dbus_object_get_object_path().
/// @get_interfaces: Returns all interfaces. See g_dbus_object_get_interfaces().
/// @get_interface: Returns an interface by name. See g_dbus_object_get_interface().
/// @interface_added: Signal handler for the #GDBusObject::interface-added signal.
/// @interface_removed: Signal handler for the #GDBusObject::interface-removed signal.
///
/// Base object type for D-Bus objects.
///
/// Since: 2.30
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GDBusObjectIface {
    pub parent_iface: GTypeInterface,
    pub get_object_path:
        ::std::option::Option<unsafe extern "C" fn(object: *mut GDBusObject) -> *const gchar>,
    pub get_interfaces:
        ::std::option::Option<unsafe extern "C" fn(object: *mut GDBusObject) -> *mut GList>,
    pub get_interface: ::std::option::Option<
        unsafe extern "C" fn(object: *mut GDBusObject, interface_name: *const gchar)
            -> *mut GDBusInterface,
    >,
    pub interface_added: ::std::option::Option<
        unsafe extern "C" fn(object: *mut GDBusObject, interface_: *mut GDBusInterface),
    >,
    pub interface_removed: ::std::option::Option<
        unsafe extern "C" fn(object: *mut GDBusObject, interface_: *mut GDBusInterface),
    >,
}
#[test]
fn bindgen_test_layout__GDBusObjectIface() {
    assert_eq!(
        ::std::mem::size_of::<_GDBusObjectIface>(),
        56usize,
        concat!("Size of: ", stringify!(_GDBusObjectIface))
    );
    assert_eq!(
        ::std::mem::align_of::<_GDBusObjectIface>(),
        8usize,
        concat!("Alignment of ", stringify!(_GDBusObjectIface))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GDBusObjectIface>())).parent_iface as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDBusObjectIface),
            "::",
            stringify!(parent_iface)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GDBusObjectIface>())).get_object_path as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDBusObjectIface),
            "::",
            stringify!(get_object_path)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GDBusObjectIface>())).get_interfaces as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDBusObjectIface),
            "::",
            stringify!(get_interfaces)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GDBusObjectIface>())).get_interface as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDBusObjectIface),
            "::",
            stringify!(get_interface)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GDBusObjectIface>())).interface_added as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDBusObjectIface),
            "::",
            stringify!(interface_added)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GDBusObjectIface>())).interface_removed as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDBusObjectIface),
            "::",
            stringify!(interface_removed)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_g_dbus_object_get_type"]
    pub fn g_dbus_object_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_dbus_object_get_object_path"]
    pub fn g_dbus_object_get_object_path(object: *mut GDBusObject) -> *const gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_dbus_object_get_interfaces"]
    pub fn g_dbus_object_get_interfaces(object: *mut GDBusObject) -> *mut GList;
}
extern "C" {
    #[link_name = "\u{1}_g_dbus_object_get_interface"]
    pub fn g_dbus_object_get_interface(
        object: *mut GDBusObject,
        interface_name: *const gchar,
    ) -> *mut GDBusInterface;
}
pub type GDBusObjectSkeletonClass = _GDBusObjectSkeletonClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GDBusObjectSkeletonPrivate {
    _unused: [u8; 0],
}
pub type GDBusObjectSkeletonPrivate = _GDBusObjectSkeletonPrivate;
/// GDBusObjectSkeleton:
///
/// The #GDBusObjectSkeleton structure contains private data and should only be
/// accessed using the provided API.
///
/// Since: 2.30
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GDBusObjectSkeleton {
    pub parent_instance: GObject,
    pub priv_: *mut GDBusObjectSkeletonPrivate,
}
#[test]
fn bindgen_test_layout__GDBusObjectSkeleton() {
    assert_eq!(
        ::std::mem::size_of::<_GDBusObjectSkeleton>(),
        32usize,
        concat!("Size of: ", stringify!(_GDBusObjectSkeleton))
    );
    assert_eq!(
        ::std::mem::align_of::<_GDBusObjectSkeleton>(),
        8usize,
        concat!("Alignment of ", stringify!(_GDBusObjectSkeleton))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GDBusObjectSkeleton>())).parent_instance as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDBusObjectSkeleton),
            "::",
            stringify!(parent_instance)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GDBusObjectSkeleton>())).priv_ as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDBusObjectSkeleton),
            "::",
            stringify!(priv_)
        )
    );
}
/// GDBusObjectSkeletonClass:
/// @parent_class: The parent class.
/// @authorize_method: Signal class handler for the #GDBusObjectSkeleton::authorize-method signal.
///
/// Class structure for #GDBusObjectSkeleton.
///
/// Since: 2.30
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GDBusObjectSkeletonClass {
    pub parent_class: GObjectClass,
    pub authorize_method: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut GDBusObjectSkeleton,
            interface_: *mut GDBusInterfaceSkeleton,
            invocation: *mut GDBusMethodInvocation,
        ) -> gboolean,
    >,
    pub padding: [gpointer; 8usize],
}
#[test]
fn bindgen_test_layout__GDBusObjectSkeletonClass() {
    assert_eq!(
        ::std::mem::size_of::<_GDBusObjectSkeletonClass>(),
        208usize,
        concat!("Size of: ", stringify!(_GDBusObjectSkeletonClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_GDBusObjectSkeletonClass>(),
        8usize,
        concat!("Alignment of ", stringify!(_GDBusObjectSkeletonClass))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GDBusObjectSkeletonClass>())).parent_class as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDBusObjectSkeletonClass),
            "::",
            stringify!(parent_class)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GDBusObjectSkeletonClass>())).authorize_method as *const _
                as usize
        },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDBusObjectSkeletonClass),
            "::",
            stringify!(authorize_method)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GDBusObjectSkeletonClass>())).padding as *const _ as usize
        },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDBusObjectSkeletonClass),
            "::",
            stringify!(padding)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_g_dbus_object_skeleton_get_type"]
    pub fn g_dbus_object_skeleton_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_dbus_object_skeleton_new"]
    pub fn g_dbus_object_skeleton_new(object_path: *const gchar) -> *mut GDBusObjectSkeleton;
}
extern "C" {
    #[link_name = "\u{1}_g_dbus_object_skeleton_flush"]
    pub fn g_dbus_object_skeleton_flush(object: *mut GDBusObjectSkeleton);
}
extern "C" {
    #[link_name = "\u{1}_g_dbus_object_skeleton_add_interface"]
    pub fn g_dbus_object_skeleton_add_interface(
        object: *mut GDBusObjectSkeleton,
        interface_: *mut GDBusInterfaceSkeleton,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_dbus_object_skeleton_remove_interface"]
    pub fn g_dbus_object_skeleton_remove_interface(
        object: *mut GDBusObjectSkeleton,
        interface_: *mut GDBusInterfaceSkeleton,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_dbus_object_skeleton_remove_interface_by_name"]
    pub fn g_dbus_object_skeleton_remove_interface_by_name(
        object: *mut GDBusObjectSkeleton,
        interface_name: *const gchar,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_dbus_object_skeleton_set_object_path"]
    pub fn g_dbus_object_skeleton_set_object_path(
        object: *mut GDBusObjectSkeleton,
        object_path: *const gchar,
    );
}
pub type GDBusObjectProxyClass = _GDBusObjectProxyClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GDBusObjectProxyPrivate {
    _unused: [u8; 0],
}
pub type GDBusObjectProxyPrivate = _GDBusObjectProxyPrivate;
/// GDBusObjectProxy:
///
/// The #GDBusObjectProxy structure contains private data and should
/// only be accessed using the provided API.
///
/// Since: 2.30
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GDBusObjectProxy {
    pub parent_instance: GObject,
    pub priv_: *mut GDBusObjectProxyPrivate,
}
#[test]
fn bindgen_test_layout__GDBusObjectProxy() {
    assert_eq!(
        ::std::mem::size_of::<_GDBusObjectProxy>(),
        32usize,
        concat!("Size of: ", stringify!(_GDBusObjectProxy))
    );
    assert_eq!(
        ::std::mem::align_of::<_GDBusObjectProxy>(),
        8usize,
        concat!("Alignment of ", stringify!(_GDBusObjectProxy))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GDBusObjectProxy>())).parent_instance as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDBusObjectProxy),
            "::",
            stringify!(parent_instance)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GDBusObjectProxy>())).priv_ as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDBusObjectProxy),
            "::",
            stringify!(priv_)
        )
    );
}
/// GDBusObjectProxyClass:
/// @parent_class: The parent class.
///
/// Class structure for #GDBusObjectProxy.
///
/// Since: 2.30
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GDBusObjectProxyClass {
    pub parent_class: GObjectClass,
    pub padding: [gpointer; 8usize],
}
#[test]
fn bindgen_test_layout__GDBusObjectProxyClass() {
    assert_eq!(
        ::std::mem::size_of::<_GDBusObjectProxyClass>(),
        200usize,
        concat!("Size of: ", stringify!(_GDBusObjectProxyClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_GDBusObjectProxyClass>(),
        8usize,
        concat!("Alignment of ", stringify!(_GDBusObjectProxyClass))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GDBusObjectProxyClass>())).parent_class as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDBusObjectProxyClass),
            "::",
            stringify!(parent_class)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GDBusObjectProxyClass>())).padding as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDBusObjectProxyClass),
            "::",
            stringify!(padding)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_g_dbus_object_proxy_get_type"]
    pub fn g_dbus_object_proxy_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_dbus_object_proxy_new"]
    pub fn g_dbus_object_proxy_new(
        connection: *mut GDBusConnection,
        object_path: *const gchar,
    ) -> *mut GDBusObjectProxy;
}
extern "C" {
    #[link_name = "\u{1}_g_dbus_object_proxy_get_connection"]
    pub fn g_dbus_object_proxy_get_connection(proxy: *mut GDBusObjectProxy)
        -> *mut GDBusConnection;
}
pub type GDBusObjectManagerIface = _GDBusObjectManagerIface;
/// GDBusObjectManagerIface:
/// @parent_iface: The parent interface.
/// @get_object_path: Virtual function for g_dbus_object_manager_get_object_path().
/// @get_objects: Virtual function for g_dbus_object_manager_get_objects().
/// @get_object: Virtual function for g_dbus_object_manager_get_object().
/// @get_interface: Virtual function for g_dbus_object_manager_get_interface().
/// @object_added: Signal handler for the #GDBusObjectManager::object-added signal.
/// @object_removed: Signal handler for the #GDBusObjectManager::object-removed signal.
/// @interface_added: Signal handler for the #GDBusObjectManager::interface-added signal.
/// @interface_removed: Signal handler for the #GDBusObjectManager::interface-removed signal.
///
/// Base type for D-Bus object managers.
///
/// Since: 2.30
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GDBusObjectManagerIface {
    pub parent_iface: GTypeInterface,
    pub get_object_path: ::std::option::Option<
        unsafe extern "C" fn(manager: *mut GDBusObjectManager) -> *const gchar,
    >,
    pub get_objects:
        ::std::option::Option<unsafe extern "C" fn(manager: *mut GDBusObjectManager) -> *mut GList>,
    pub get_object: ::std::option::Option<
        unsafe extern "C" fn(manager: *mut GDBusObjectManager, object_path: *const gchar)
            -> *mut GDBusObject,
    >,
    pub get_interface: ::std::option::Option<
        unsafe extern "C" fn(
            manager: *mut GDBusObjectManager,
            object_path: *const gchar,
            interface_name: *const gchar,
        ) -> *mut GDBusInterface,
    >,
    pub object_added: ::std::option::Option<
        unsafe extern "C" fn(manager: *mut GDBusObjectManager, object: *mut GDBusObject),
    >,
    pub object_removed: ::std::option::Option<
        unsafe extern "C" fn(manager: *mut GDBusObjectManager, object: *mut GDBusObject),
    >,
    pub interface_added: ::std::option::Option<
        unsafe extern "C" fn(
            manager: *mut GDBusObjectManager,
            object: *mut GDBusObject,
            interface_: *mut GDBusInterface,
        ),
    >,
    pub interface_removed: ::std::option::Option<
        unsafe extern "C" fn(
            manager: *mut GDBusObjectManager,
            object: *mut GDBusObject,
            interface_: *mut GDBusInterface,
        ),
    >,
}
#[test]
fn bindgen_test_layout__GDBusObjectManagerIface() {
    assert_eq!(
        ::std::mem::size_of::<_GDBusObjectManagerIface>(),
        80usize,
        concat!("Size of: ", stringify!(_GDBusObjectManagerIface))
    );
    assert_eq!(
        ::std::mem::align_of::<_GDBusObjectManagerIface>(),
        8usize,
        concat!("Alignment of ", stringify!(_GDBusObjectManagerIface))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GDBusObjectManagerIface>())).parent_iface as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDBusObjectManagerIface),
            "::",
            stringify!(parent_iface)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GDBusObjectManagerIface>())).get_object_path as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDBusObjectManagerIface),
            "::",
            stringify!(get_object_path)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GDBusObjectManagerIface>())).get_objects as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDBusObjectManagerIface),
            "::",
            stringify!(get_objects)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GDBusObjectManagerIface>())).get_object as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDBusObjectManagerIface),
            "::",
            stringify!(get_object)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GDBusObjectManagerIface>())).get_interface as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDBusObjectManagerIface),
            "::",
            stringify!(get_interface)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GDBusObjectManagerIface>())).object_added as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDBusObjectManagerIface),
            "::",
            stringify!(object_added)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GDBusObjectManagerIface>())).object_removed as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDBusObjectManagerIface),
            "::",
            stringify!(object_removed)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GDBusObjectManagerIface>())).interface_added as *const _
                as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDBusObjectManagerIface),
            "::",
            stringify!(interface_added)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GDBusObjectManagerIface>())).interface_removed as *const _
                as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDBusObjectManagerIface),
            "::",
            stringify!(interface_removed)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_g_dbus_object_manager_get_type"]
    pub fn g_dbus_object_manager_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_dbus_object_manager_get_object_path"]
    pub fn g_dbus_object_manager_get_object_path(manager: *mut GDBusObjectManager) -> *const gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_dbus_object_manager_get_objects"]
    pub fn g_dbus_object_manager_get_objects(manager: *mut GDBusObjectManager) -> *mut GList;
}
extern "C" {
    #[link_name = "\u{1}_g_dbus_object_manager_get_object"]
    pub fn g_dbus_object_manager_get_object(
        manager: *mut GDBusObjectManager,
        object_path: *const gchar,
    ) -> *mut GDBusObject;
}
extern "C" {
    #[link_name = "\u{1}_g_dbus_object_manager_get_interface"]
    pub fn g_dbus_object_manager_get_interface(
        manager: *mut GDBusObjectManager,
        object_path: *const gchar,
        interface_name: *const gchar,
    ) -> *mut GDBusInterface;
}
pub type GDBusObjectManagerClientClass = _GDBusObjectManagerClientClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GDBusObjectManagerClientPrivate {
    _unused: [u8; 0],
}
pub type GDBusObjectManagerClientPrivate = _GDBusObjectManagerClientPrivate;
/// GDBusObjectManagerClient:
///
/// The #GDBusObjectManagerClient structure contains private data and should
/// only be accessed using the provided API.
///
/// Since: 2.30
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GDBusObjectManagerClient {
    pub parent_instance: GObject,
    pub priv_: *mut GDBusObjectManagerClientPrivate,
}
#[test]
fn bindgen_test_layout__GDBusObjectManagerClient() {
    assert_eq!(
        ::std::mem::size_of::<_GDBusObjectManagerClient>(),
        32usize,
        concat!("Size of: ", stringify!(_GDBusObjectManagerClient))
    );
    assert_eq!(
        ::std::mem::align_of::<_GDBusObjectManagerClient>(),
        8usize,
        concat!("Alignment of ", stringify!(_GDBusObjectManagerClient))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GDBusObjectManagerClient>())).parent_instance as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDBusObjectManagerClient),
            "::",
            stringify!(parent_instance)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GDBusObjectManagerClient>())).priv_ as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDBusObjectManagerClient),
            "::",
            stringify!(priv_)
        )
    );
}
/// GDBusObjectManagerClientClass:
/// @parent_class: The parent class.
/// @interface_proxy_signal: Signal class handler for the #GDBusObjectManagerClient::interface-proxy-signal signal.
/// @interface_proxy_properties_changed: Signal class handler for the #GDBusObjectManagerClient::interface-proxy-properties-changed signal.
///
/// Class structure for #GDBusObjectManagerClient.
///
/// Since: 2.30
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GDBusObjectManagerClientClass {
    pub parent_class: GObjectClass,
    pub interface_proxy_signal: ::std::option::Option<
        unsafe extern "C" fn(
            manager: *mut GDBusObjectManagerClient,
            object_proxy: *mut GDBusObjectProxy,
            interface_proxy: *mut GDBusProxy,
            sender_name: *const gchar,
            signal_name: *const gchar,
            parameters: *mut GVariant,
        ),
    >,
    pub interface_proxy_properties_changed: ::std::option::Option<
        unsafe extern "C" fn(
            manager: *mut GDBusObjectManagerClient,
            object_proxy: *mut GDBusObjectProxy,
            interface_proxy: *mut GDBusProxy,
            changed_properties: *mut GVariant,
            invalidated_properties: *const *const gchar,
        ),
    >,
    pub padding: [gpointer; 8usize],
}
#[test]
fn bindgen_test_layout__GDBusObjectManagerClientClass() {
    assert_eq!(
        ::std::mem::size_of::<_GDBusObjectManagerClientClass>(),
        216usize,
        concat!("Size of: ", stringify!(_GDBusObjectManagerClientClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_GDBusObjectManagerClientClass>(),
        8usize,
        concat!("Alignment of ", stringify!(_GDBusObjectManagerClientClass))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GDBusObjectManagerClientClass>())).parent_class as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDBusObjectManagerClientClass),
            "::",
            stringify!(parent_class)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GDBusObjectManagerClientClass>())).interface_proxy_signal
                as *const _ as usize
        },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDBusObjectManagerClientClass),
            "::",
            stringify!(interface_proxy_signal)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GDBusObjectManagerClientClass>()))
                .interface_proxy_properties_changed as *const _ as usize
        },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDBusObjectManagerClientClass),
            "::",
            stringify!(interface_proxy_properties_changed)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GDBusObjectManagerClientClass>())).padding as *const _ as usize
        },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDBusObjectManagerClientClass),
            "::",
            stringify!(padding)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_g_dbus_object_manager_client_get_type"]
    pub fn g_dbus_object_manager_client_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_dbus_object_manager_client_new"]
    pub fn g_dbus_object_manager_client_new(
        connection: *mut GDBusConnection,
        flags: GDBusObjectManagerClientFlags,
        name: *const gchar,
        object_path: *const gchar,
        get_proxy_type_func: GDBusProxyTypeFunc,
        get_proxy_type_user_data: gpointer,
        get_proxy_type_destroy_notify: GDestroyNotify,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_dbus_object_manager_client_new_finish"]
    pub fn g_dbus_object_manager_client_new_finish(
        res: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> *mut GDBusObjectManager;
}
extern "C" {
    #[link_name = "\u{1}_g_dbus_object_manager_client_new_sync"]
    pub fn g_dbus_object_manager_client_new_sync(
        connection: *mut GDBusConnection,
        flags: GDBusObjectManagerClientFlags,
        name: *const gchar,
        object_path: *const gchar,
        get_proxy_type_func: GDBusProxyTypeFunc,
        get_proxy_type_user_data: gpointer,
        get_proxy_type_destroy_notify: GDestroyNotify,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> *mut GDBusObjectManager;
}
extern "C" {
    #[link_name = "\u{1}_g_dbus_object_manager_client_new_for_bus"]
    pub fn g_dbus_object_manager_client_new_for_bus(
        bus_type: GBusType,
        flags: GDBusObjectManagerClientFlags,
        name: *const gchar,
        object_path: *const gchar,
        get_proxy_type_func: GDBusProxyTypeFunc,
        get_proxy_type_user_data: gpointer,
        get_proxy_type_destroy_notify: GDestroyNotify,
        cancellable: *mut GCancellable,
        callback: GAsyncReadyCallback,
        user_data: gpointer,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_dbus_object_manager_client_new_for_bus_finish"]
    pub fn g_dbus_object_manager_client_new_for_bus_finish(
        res: *mut GAsyncResult,
        error: *mut *mut GError,
    ) -> *mut GDBusObjectManager;
}
extern "C" {
    #[link_name = "\u{1}_g_dbus_object_manager_client_new_for_bus_sync"]
    pub fn g_dbus_object_manager_client_new_for_bus_sync(
        bus_type: GBusType,
        flags: GDBusObjectManagerClientFlags,
        name: *const gchar,
        object_path: *const gchar,
        get_proxy_type_func: GDBusProxyTypeFunc,
        get_proxy_type_user_data: gpointer,
        get_proxy_type_destroy_notify: GDestroyNotify,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> *mut GDBusObjectManager;
}
extern "C" {
    #[link_name = "\u{1}_g_dbus_object_manager_client_get_connection"]
    pub fn g_dbus_object_manager_client_get_connection(
        manager: *mut GDBusObjectManagerClient,
    ) -> *mut GDBusConnection;
}
extern "C" {
    #[link_name = "\u{1}_g_dbus_object_manager_client_get_flags"]
    pub fn g_dbus_object_manager_client_get_flags(
        manager: *mut GDBusObjectManagerClient,
    ) -> GDBusObjectManagerClientFlags;
}
extern "C" {
    #[link_name = "\u{1}_g_dbus_object_manager_client_get_name"]
    pub fn g_dbus_object_manager_client_get_name(
        manager: *mut GDBusObjectManagerClient,
    ) -> *const gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_dbus_object_manager_client_get_name_owner"]
    pub fn g_dbus_object_manager_client_get_name_owner(
        manager: *mut GDBusObjectManagerClient,
    ) -> *mut gchar;
}
pub type GDBusObjectManagerServerClass = _GDBusObjectManagerServerClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GDBusObjectManagerServerPrivate {
    _unused: [u8; 0],
}
pub type GDBusObjectManagerServerPrivate = _GDBusObjectManagerServerPrivate;
/// GDBusObjectManagerServer:
///
/// The #GDBusObjectManagerServer structure contains private data and should
/// only be accessed using the provided API.
///
/// Since: 2.30
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GDBusObjectManagerServer {
    pub parent_instance: GObject,
    pub priv_: *mut GDBusObjectManagerServerPrivate,
}
#[test]
fn bindgen_test_layout__GDBusObjectManagerServer() {
    assert_eq!(
        ::std::mem::size_of::<_GDBusObjectManagerServer>(),
        32usize,
        concat!("Size of: ", stringify!(_GDBusObjectManagerServer))
    );
    assert_eq!(
        ::std::mem::align_of::<_GDBusObjectManagerServer>(),
        8usize,
        concat!("Alignment of ", stringify!(_GDBusObjectManagerServer))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GDBusObjectManagerServer>())).parent_instance as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDBusObjectManagerServer),
            "::",
            stringify!(parent_instance)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GDBusObjectManagerServer>())).priv_ as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDBusObjectManagerServer),
            "::",
            stringify!(priv_)
        )
    );
}
/// GDBusObjectManagerServerClass:
/// @parent_class: The parent class.
///
/// Class structure for #GDBusObjectManagerServer.
///
/// Since: 2.30
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GDBusObjectManagerServerClass {
    pub parent_class: GObjectClass,
    pub padding: [gpointer; 8usize],
}
#[test]
fn bindgen_test_layout__GDBusObjectManagerServerClass() {
    assert_eq!(
        ::std::mem::size_of::<_GDBusObjectManagerServerClass>(),
        200usize,
        concat!("Size of: ", stringify!(_GDBusObjectManagerServerClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_GDBusObjectManagerServerClass>(),
        8usize,
        concat!("Alignment of ", stringify!(_GDBusObjectManagerServerClass))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GDBusObjectManagerServerClass>())).parent_class as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDBusObjectManagerServerClass),
            "::",
            stringify!(parent_class)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GDBusObjectManagerServerClass>())).padding as *const _ as usize
        },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_GDBusObjectManagerServerClass),
            "::",
            stringify!(padding)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_g_dbus_object_manager_server_get_type"]
    pub fn g_dbus_object_manager_server_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_dbus_object_manager_server_new"]
    pub fn g_dbus_object_manager_server_new(
        object_path: *const gchar,
    ) -> *mut GDBusObjectManagerServer;
}
extern "C" {
    #[link_name = "\u{1}_g_dbus_object_manager_server_get_connection"]
    pub fn g_dbus_object_manager_server_get_connection(
        manager: *mut GDBusObjectManagerServer,
    ) -> *mut GDBusConnection;
}
extern "C" {
    #[link_name = "\u{1}_g_dbus_object_manager_server_set_connection"]
    pub fn g_dbus_object_manager_server_set_connection(
        manager: *mut GDBusObjectManagerServer,
        connection: *mut GDBusConnection,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_dbus_object_manager_server_export"]
    pub fn g_dbus_object_manager_server_export(
        manager: *mut GDBusObjectManagerServer,
        object: *mut GDBusObjectSkeleton,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_dbus_object_manager_server_export_uniquely"]
    pub fn g_dbus_object_manager_server_export_uniquely(
        manager: *mut GDBusObjectManagerServer,
        object: *mut GDBusObjectSkeleton,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_dbus_object_manager_server_is_exported"]
    pub fn g_dbus_object_manager_server_is_exported(
        manager: *mut GDBusObjectManagerServer,
        object: *mut GDBusObjectSkeleton,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_dbus_object_manager_server_unexport"]
    pub fn g_dbus_object_manager_server_unexport(
        manager: *mut GDBusObjectManagerServer,
        object_path: *const gchar,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_dbus_action_group_get_type"]
    pub fn g_dbus_action_group_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_dbus_action_group_get"]
    pub fn g_dbus_action_group_get(
        connection: *mut GDBusConnection,
        bus_name: *const gchar,
        object_path: *const gchar,
    ) -> *mut GDBusActionGroup;
}
pub type GRemoteActionGroupInterface = _GRemoteActionGroupInterface;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GRemoteActionGroupInterface {
    pub g_iface: GTypeInterface,
    pub activate_action_full: ::std::option::Option<
        unsafe extern "C" fn(
            remote: *mut GRemoteActionGroup,
            action_name: *const gchar,
            parameter: *mut GVariant,
            platform_data: *mut GVariant,
        ),
    >,
    pub change_action_state_full: ::std::option::Option<
        unsafe extern "C" fn(
            remote: *mut GRemoteActionGroup,
            action_name: *const gchar,
            value: *mut GVariant,
            platform_data: *mut GVariant,
        ),
    >,
}
#[test]
fn bindgen_test_layout__GRemoteActionGroupInterface() {
    assert_eq!(
        ::std::mem::size_of::<_GRemoteActionGroupInterface>(),
        32usize,
        concat!("Size of: ", stringify!(_GRemoteActionGroupInterface))
    );
    assert_eq!(
        ::std::mem::align_of::<_GRemoteActionGroupInterface>(),
        8usize,
        concat!("Alignment of ", stringify!(_GRemoteActionGroupInterface))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GRemoteActionGroupInterface>())).g_iface as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GRemoteActionGroupInterface),
            "::",
            stringify!(g_iface)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GRemoteActionGroupInterface>())).activate_action_full
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GRemoteActionGroupInterface),
            "::",
            stringify!(activate_action_full)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GRemoteActionGroupInterface>())).change_action_state_full
                as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GRemoteActionGroupInterface),
            "::",
            stringify!(change_action_state_full)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_g_remote_action_group_get_type"]
    pub fn g_remote_action_group_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_remote_action_group_activate_action_full"]
    pub fn g_remote_action_group_activate_action_full(
        remote: *mut GRemoteActionGroup,
        action_name: *const gchar,
        parameter: *mut GVariant,
        platform_data: *mut GVariant,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_remote_action_group_change_action_state_full"]
    pub fn g_remote_action_group_change_action_state_full(
        remote: *mut GRemoteActionGroup,
        action_name: *const gchar,
        value: *mut GVariant,
        platform_data: *mut GVariant,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GMenuModelPrivate {
    _unused: [u8; 0],
}
pub type GMenuModelPrivate = _GMenuModelPrivate;
pub type GMenuModelClass = _GMenuModelClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GMenuAttributeIterPrivate {
    _unused: [u8; 0],
}
pub type GMenuAttributeIterPrivate = _GMenuAttributeIterPrivate;
pub type GMenuAttributeIterClass = _GMenuAttributeIterClass;
pub type GMenuAttributeIter = _GMenuAttributeIter;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GMenuLinkIterPrivate {
    _unused: [u8; 0],
}
pub type GMenuLinkIterPrivate = _GMenuLinkIterPrivate;
pub type GMenuLinkIterClass = _GMenuLinkIterClass;
pub type GMenuLinkIter = _GMenuLinkIter;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GMenuModel {
    pub parent_instance: GObject,
    pub priv_: *mut GMenuModelPrivate,
}
#[test]
fn bindgen_test_layout__GMenuModel() {
    assert_eq!(
        ::std::mem::size_of::<_GMenuModel>(),
        32usize,
        concat!("Size of: ", stringify!(_GMenuModel))
    );
    assert_eq!(
        ::std::mem::align_of::<_GMenuModel>(),
        8usize,
        concat!("Alignment of ", stringify!(_GMenuModel))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GMenuModel>())).parent_instance as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMenuModel),
            "::",
            stringify!(parent_instance)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GMenuModel>())).priv_ as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMenuModel),
            "::",
            stringify!(priv_)
        )
    );
}
/// GMenuModelClass::get_item_attributes:
/// @model: the #GMenuModel to query
/// @item_index: The #GMenuItem to query
/// @attributes: (out) (element-type utf8 GLib.Variant): Attributes on the item
///
/// Gets all the attributes associated with the item in the menu model.
/// /
/// /**
/// GMenuModelClass::get_item_links:
/// @model: the #GMenuModel to query
/// @item_index: The #GMenuItem to query
/// @links: (out) (element-type utf8 Gio.MenuModel): Links from the item
///
/// Gets all the links associated with the item in the menu model.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GMenuModelClass {
    pub parent_class: GObjectClass,
    pub is_mutable: ::std::option::Option<unsafe extern "C" fn(model: *mut GMenuModel) -> gboolean>,
    pub get_n_items: ::std::option::Option<unsafe extern "C" fn(model: *mut GMenuModel) -> gint>,
    pub get_item_attributes: ::std::option::Option<
        unsafe extern "C" fn(
            model: *mut GMenuModel,
            item_index: gint,
            attributes: *mut *mut GHashTable,
        ),
    >,
    pub iterate_item_attributes: ::std::option::Option<
        unsafe extern "C" fn(model: *mut GMenuModel, item_index: gint) -> *mut GMenuAttributeIter,
    >,
    pub get_item_attribute_value: ::std::option::Option<
        unsafe extern "C" fn(
            model: *mut GMenuModel,
            item_index: gint,
            attribute: *const gchar,
            expected_type: *const GVariantType,
        ) -> *mut GVariant,
    >,
    pub get_item_links: ::std::option::Option<
        unsafe extern "C" fn(model: *mut GMenuModel, item_index: gint, links: *mut *mut GHashTable),
    >,
    pub iterate_item_links: ::std::option::Option<
        unsafe extern "C" fn(model: *mut GMenuModel, item_index: gint) -> *mut GMenuLinkIter,
    >,
    pub get_item_link: ::std::option::Option<
        unsafe extern "C" fn(model: *mut GMenuModel, item_index: gint, link: *const gchar)
            -> *mut GMenuModel,
    >,
}
#[test]
fn bindgen_test_layout__GMenuModelClass() {
    assert_eq!(
        ::std::mem::size_of::<_GMenuModelClass>(),
        200usize,
        concat!("Size of: ", stringify!(_GMenuModelClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_GMenuModelClass>(),
        8usize,
        concat!("Alignment of ", stringify!(_GMenuModelClass))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GMenuModelClass>())).parent_class as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMenuModelClass),
            "::",
            stringify!(parent_class)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GMenuModelClass>())).is_mutable as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMenuModelClass),
            "::",
            stringify!(is_mutable)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GMenuModelClass>())).get_n_items as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMenuModelClass),
            "::",
            stringify!(get_n_items)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GMenuModelClass>())).get_item_attributes as *const _ as usize
        },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMenuModelClass),
            "::",
            stringify!(get_item_attributes)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GMenuModelClass>())).iterate_item_attributes as *const _
                as usize
        },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMenuModelClass),
            "::",
            stringify!(iterate_item_attributes)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GMenuModelClass>())).get_item_attribute_value as *const _
                as usize
        },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMenuModelClass),
            "::",
            stringify!(get_item_attribute_value)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GMenuModelClass>())).get_item_links as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMenuModelClass),
            "::",
            stringify!(get_item_links)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GMenuModelClass>())).iterate_item_links as *const _ as usize
        },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMenuModelClass),
            "::",
            stringify!(iterate_item_links)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GMenuModelClass>())).get_item_link as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMenuModelClass),
            "::",
            stringify!(get_item_link)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_g_menu_model_get_type"]
    pub fn g_menu_model_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_menu_model_is_mutable"]
    pub fn g_menu_model_is_mutable(model: *mut GMenuModel) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_menu_model_get_n_items"]
    pub fn g_menu_model_get_n_items(model: *mut GMenuModel) -> gint;
}
extern "C" {
    #[link_name = "\u{1}_g_menu_model_iterate_item_attributes"]
    pub fn g_menu_model_iterate_item_attributes(
        model: *mut GMenuModel,
        item_index: gint,
    ) -> *mut GMenuAttributeIter;
}
extern "C" {
    #[link_name = "\u{1}_g_menu_model_get_item_attribute_value"]
    pub fn g_menu_model_get_item_attribute_value(
        model: *mut GMenuModel,
        item_index: gint,
        attribute: *const gchar,
        expected_type: *const GVariantType,
    ) -> *mut GVariant;
}
extern "C" {
    #[link_name = "\u{1}_g_menu_model_get_item_attribute"]
    pub fn g_menu_model_get_item_attribute(
        model: *mut GMenuModel,
        item_index: gint,
        attribute: *const gchar,
        format_string: *const gchar,
        ...
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_menu_model_iterate_item_links"]
    pub fn g_menu_model_iterate_item_links(
        model: *mut GMenuModel,
        item_index: gint,
    ) -> *mut GMenuLinkIter;
}
extern "C" {
    #[link_name = "\u{1}_g_menu_model_get_item_link"]
    pub fn g_menu_model_get_item_link(
        model: *mut GMenuModel,
        item_index: gint,
        link: *const gchar,
    ) -> *mut GMenuModel;
}
extern "C" {
    #[link_name = "\u{1}_g_menu_model_items_changed"]
    pub fn g_menu_model_items_changed(
        model: *mut GMenuModel,
        position: gint,
        removed: gint,
        added: gint,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GMenuAttributeIter {
    pub parent_instance: GObject,
    pub priv_: *mut GMenuAttributeIterPrivate,
}
#[test]
fn bindgen_test_layout__GMenuAttributeIter() {
    assert_eq!(
        ::std::mem::size_of::<_GMenuAttributeIter>(),
        32usize,
        concat!("Size of: ", stringify!(_GMenuAttributeIter))
    );
    assert_eq!(
        ::std::mem::align_of::<_GMenuAttributeIter>(),
        8usize,
        concat!("Alignment of ", stringify!(_GMenuAttributeIter))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GMenuAttributeIter>())).parent_instance as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMenuAttributeIter),
            "::",
            stringify!(parent_instance)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GMenuAttributeIter>())).priv_ as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMenuAttributeIter),
            "::",
            stringify!(priv_)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GMenuAttributeIterClass {
    pub parent_class: GObjectClass,
    pub get_next: ::std::option::Option<
        unsafe extern "C" fn(
            iter: *mut GMenuAttributeIter,
            out_name: *mut *const gchar,
            value: *mut *mut GVariant,
        ) -> gboolean,
    >,
}
#[test]
fn bindgen_test_layout__GMenuAttributeIterClass() {
    assert_eq!(
        ::std::mem::size_of::<_GMenuAttributeIterClass>(),
        144usize,
        concat!("Size of: ", stringify!(_GMenuAttributeIterClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_GMenuAttributeIterClass>(),
        8usize,
        concat!("Alignment of ", stringify!(_GMenuAttributeIterClass))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GMenuAttributeIterClass>())).parent_class as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMenuAttributeIterClass),
            "::",
            stringify!(parent_class)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GMenuAttributeIterClass>())).get_next as *const _ as usize
        },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMenuAttributeIterClass),
            "::",
            stringify!(get_next)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_g_menu_attribute_iter_get_type"]
    pub fn g_menu_attribute_iter_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_menu_attribute_iter_get_next"]
    pub fn g_menu_attribute_iter_get_next(
        iter: *mut GMenuAttributeIter,
        out_name: *mut *const gchar,
        value: *mut *mut GVariant,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_menu_attribute_iter_next"]
    pub fn g_menu_attribute_iter_next(iter: *mut GMenuAttributeIter) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_menu_attribute_iter_get_name"]
    pub fn g_menu_attribute_iter_get_name(iter: *mut GMenuAttributeIter) -> *const gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_menu_attribute_iter_get_value"]
    pub fn g_menu_attribute_iter_get_value(iter: *mut GMenuAttributeIter) -> *mut GVariant;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GMenuLinkIter {
    pub parent_instance: GObject,
    pub priv_: *mut GMenuLinkIterPrivate,
}
#[test]
fn bindgen_test_layout__GMenuLinkIter() {
    assert_eq!(
        ::std::mem::size_of::<_GMenuLinkIter>(),
        32usize,
        concat!("Size of: ", stringify!(_GMenuLinkIter))
    );
    assert_eq!(
        ::std::mem::align_of::<_GMenuLinkIter>(),
        8usize,
        concat!("Alignment of ", stringify!(_GMenuLinkIter))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GMenuLinkIter>())).parent_instance as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMenuLinkIter),
            "::",
            stringify!(parent_instance)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GMenuLinkIter>())).priv_ as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMenuLinkIter),
            "::",
            stringify!(priv_)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GMenuLinkIterClass {
    pub parent_class: GObjectClass,
    pub get_next: ::std::option::Option<
        unsafe extern "C" fn(
            iter: *mut GMenuLinkIter,
            out_link: *mut *const gchar,
            value: *mut *mut GMenuModel,
        ) -> gboolean,
    >,
}
#[test]
fn bindgen_test_layout__GMenuLinkIterClass() {
    assert_eq!(
        ::std::mem::size_of::<_GMenuLinkIterClass>(),
        144usize,
        concat!("Size of: ", stringify!(_GMenuLinkIterClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_GMenuLinkIterClass>(),
        8usize,
        concat!("Alignment of ", stringify!(_GMenuLinkIterClass))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GMenuLinkIterClass>())).parent_class as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMenuLinkIterClass),
            "::",
            stringify!(parent_class)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GMenuLinkIterClass>())).get_next as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_GMenuLinkIterClass),
            "::",
            stringify!(get_next)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_g_menu_link_iter_get_type"]
    pub fn g_menu_link_iter_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_menu_link_iter_get_next"]
    pub fn g_menu_link_iter_get_next(
        iter: *mut GMenuLinkIter,
        out_link: *mut *const gchar,
        value: *mut *mut GMenuModel,
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_menu_link_iter_next"]
    pub fn g_menu_link_iter_next(iter: *mut GMenuLinkIter) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_menu_link_iter_get_name"]
    pub fn g_menu_link_iter_get_name(iter: *mut GMenuLinkIter) -> *const gchar;
}
extern "C" {
    #[link_name = "\u{1}_g_menu_link_iter_get_value"]
    pub fn g_menu_link_iter_get_value(iter: *mut GMenuLinkIter) -> *mut GMenuModel;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GMenuItem {
    _unused: [u8; 0],
}
pub type GMenuItem = _GMenuItem;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GMenu {
    _unused: [u8; 0],
}
pub type GMenu = _GMenu;
extern "C" {
    #[link_name = "\u{1}_g_menu_get_type"]
    pub fn g_menu_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_menu_new"]
    pub fn g_menu_new() -> *mut GMenu;
}
extern "C" {
    #[link_name = "\u{1}_g_menu_freeze"]
    pub fn g_menu_freeze(menu: *mut GMenu);
}
extern "C" {
    #[link_name = "\u{1}_g_menu_insert_item"]
    pub fn g_menu_insert_item(menu: *mut GMenu, position: gint, item: *mut GMenuItem);
}
extern "C" {
    #[link_name = "\u{1}_g_menu_prepend_item"]
    pub fn g_menu_prepend_item(menu: *mut GMenu, item: *mut GMenuItem);
}
extern "C" {
    #[link_name = "\u{1}_g_menu_append_item"]
    pub fn g_menu_append_item(menu: *mut GMenu, item: *mut GMenuItem);
}
extern "C" {
    #[link_name = "\u{1}_g_menu_remove"]
    pub fn g_menu_remove(menu: *mut GMenu, position: gint);
}
extern "C" {
    #[link_name = "\u{1}_g_menu_remove_all"]
    pub fn g_menu_remove_all(menu: *mut GMenu);
}
extern "C" {
    #[link_name = "\u{1}_g_menu_insert"]
    pub fn g_menu_insert(
        menu: *mut GMenu,
        position: gint,
        label: *const gchar,
        detailed_action: *const gchar,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_menu_prepend"]
    pub fn g_menu_prepend(menu: *mut GMenu, label: *const gchar, detailed_action: *const gchar);
}
extern "C" {
    #[link_name = "\u{1}_g_menu_append"]
    pub fn g_menu_append(menu: *mut GMenu, label: *const gchar, detailed_action: *const gchar);
}
extern "C" {
    #[link_name = "\u{1}_g_menu_insert_section"]
    pub fn g_menu_insert_section(
        menu: *mut GMenu,
        position: gint,
        label: *const gchar,
        section: *mut GMenuModel,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_menu_prepend_section"]
    pub fn g_menu_prepend_section(menu: *mut GMenu, label: *const gchar, section: *mut GMenuModel);
}
extern "C" {
    #[link_name = "\u{1}_g_menu_append_section"]
    pub fn g_menu_append_section(menu: *mut GMenu, label: *const gchar, section: *mut GMenuModel);
}
extern "C" {
    #[link_name = "\u{1}_g_menu_insert_submenu"]
    pub fn g_menu_insert_submenu(
        menu: *mut GMenu,
        position: gint,
        label: *const gchar,
        submenu: *mut GMenuModel,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_menu_prepend_submenu"]
    pub fn g_menu_prepend_submenu(menu: *mut GMenu, label: *const gchar, submenu: *mut GMenuModel);
}
extern "C" {
    #[link_name = "\u{1}_g_menu_append_submenu"]
    pub fn g_menu_append_submenu(menu: *mut GMenu, label: *const gchar, submenu: *mut GMenuModel);
}
extern "C" {
    #[link_name = "\u{1}_g_menu_item_get_type"]
    pub fn g_menu_item_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_menu_item_new"]
    pub fn g_menu_item_new(label: *const gchar, detailed_action: *const gchar) -> *mut GMenuItem;
}
extern "C" {
    #[link_name = "\u{1}_g_menu_item_new_from_model"]
    pub fn g_menu_item_new_from_model(model: *mut GMenuModel, item_index: gint) -> *mut GMenuItem;
}
extern "C" {
    #[link_name = "\u{1}_g_menu_item_new_submenu"]
    pub fn g_menu_item_new_submenu(label: *const gchar, submenu: *mut GMenuModel)
        -> *mut GMenuItem;
}
extern "C" {
    #[link_name = "\u{1}_g_menu_item_new_section"]
    pub fn g_menu_item_new_section(label: *const gchar, section: *mut GMenuModel)
        -> *mut GMenuItem;
}
extern "C" {
    #[link_name = "\u{1}_g_menu_item_get_attribute_value"]
    pub fn g_menu_item_get_attribute_value(
        menu_item: *mut GMenuItem,
        attribute: *const gchar,
        expected_type: *const GVariantType,
    ) -> *mut GVariant;
}
extern "C" {
    #[link_name = "\u{1}_g_menu_item_get_attribute"]
    pub fn g_menu_item_get_attribute(
        menu_item: *mut GMenuItem,
        attribute: *const gchar,
        format_string: *const gchar,
        ...
    ) -> gboolean;
}
extern "C" {
    #[link_name = "\u{1}_g_menu_item_get_link"]
    pub fn g_menu_item_get_link(menu_item: *mut GMenuItem, link: *const gchar) -> *mut GMenuModel;
}
extern "C" {
    #[link_name = "\u{1}_g_menu_item_set_attribute_value"]
    pub fn g_menu_item_set_attribute_value(
        menu_item: *mut GMenuItem,
        attribute: *const gchar,
        value: *mut GVariant,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_menu_item_set_attribute"]
    pub fn g_menu_item_set_attribute(
        menu_item: *mut GMenuItem,
        attribute: *const gchar,
        format_string: *const gchar,
        ...
    );
}
extern "C" {
    #[link_name = "\u{1}_g_menu_item_set_link"]
    pub fn g_menu_item_set_link(
        menu_item: *mut GMenuItem,
        link: *const gchar,
        model: *mut GMenuModel,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_menu_item_set_label"]
    pub fn g_menu_item_set_label(menu_item: *mut GMenuItem, label: *const gchar);
}
extern "C" {
    #[link_name = "\u{1}_g_menu_item_set_submenu"]
    pub fn g_menu_item_set_submenu(menu_item: *mut GMenuItem, submenu: *mut GMenuModel);
}
extern "C" {
    #[link_name = "\u{1}_g_menu_item_set_section"]
    pub fn g_menu_item_set_section(menu_item: *mut GMenuItem, section: *mut GMenuModel);
}
extern "C" {
    #[link_name = "\u{1}_g_menu_item_set_action_and_target_value"]
    pub fn g_menu_item_set_action_and_target_value(
        menu_item: *mut GMenuItem,
        action: *const gchar,
        target_value: *mut GVariant,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_menu_item_set_action_and_target"]
    pub fn g_menu_item_set_action_and_target(
        menu_item: *mut GMenuItem,
        action: *const gchar,
        format_string: *const gchar,
        ...
    );
}
extern "C" {
    #[link_name = "\u{1}_g_menu_item_set_detailed_action"]
    pub fn g_menu_item_set_detailed_action(
        menu_item: *mut GMenuItem,
        detailed_action: *const gchar,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_menu_item_set_icon"]
    pub fn g_menu_item_set_icon(menu_item: *mut GMenuItem, icon: *mut GIcon);
}
extern "C" {
    #[link_name = "\u{1}_g_dbus_connection_export_menu_model"]
    pub fn g_dbus_connection_export_menu_model(
        connection: *mut GDBusConnection,
        object_path: *const gchar,
        menu: *mut GMenuModel,
        error: *mut *mut GError,
    ) -> guint;
}
extern "C" {
    #[link_name = "\u{1}_g_dbus_connection_unexport_menu_model"]
    pub fn g_dbus_connection_unexport_menu_model(
        connection: *mut GDBusConnection,
        export_id: guint,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GDBusMenuModel {
    _unused: [u8; 0],
}
pub type GDBusMenuModel = _GDBusMenuModel;
extern "C" {
    #[link_name = "\u{1}_g_dbus_menu_model_get_type"]
    pub fn g_dbus_menu_model_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_dbus_menu_model_get"]
    pub fn g_dbus_menu_model_get(
        connection: *mut GDBusConnection,
        bus_name: *const gchar,
        object_path: *const gchar,
    ) -> *mut GDBusMenuModel;
}
extern "C" {
    #[link_name = "\u{1}_g_notification_get_type"]
    pub fn g_notification_get_type() -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_notification_new"]
    pub fn g_notification_new(title: *const gchar) -> *mut GNotification;
}
extern "C" {
    #[link_name = "\u{1}_g_notification_set_title"]
    pub fn g_notification_set_title(notification: *mut GNotification, title: *const gchar);
}
extern "C" {
    #[link_name = "\u{1}_g_notification_set_body"]
    pub fn g_notification_set_body(notification: *mut GNotification, body: *const gchar);
}
extern "C" {
    #[link_name = "\u{1}_g_notification_set_icon"]
    pub fn g_notification_set_icon(notification: *mut GNotification, icon: *mut GIcon);
}
extern "C" {
    #[link_name = "\u{1}_g_notification_set_urgent"]
    pub fn g_notification_set_urgent(notification: *mut GNotification, urgent: gboolean);
}
extern "C" {
    #[link_name = "\u{1}_g_notification_set_priority"]
    pub fn g_notification_set_priority(
        notification: *mut GNotification,
        priority: GNotificationPriority,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_notification_add_button"]
    pub fn g_notification_add_button(
        notification: *mut GNotification,
        label: *const gchar,
        detailed_action: *const gchar,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_notification_add_button_with_target"]
    pub fn g_notification_add_button_with_target(
        notification: *mut GNotification,
        label: *const gchar,
        action: *const gchar,
        target_format: *const gchar,
        ...
    );
}
extern "C" {
    #[link_name = "\u{1}_g_notification_add_button_with_target_value"]
    pub fn g_notification_add_button_with_target_value(
        notification: *mut GNotification,
        label: *const gchar,
        action: *const gchar,
        target: *mut GVariant,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_notification_set_default_action"]
    pub fn g_notification_set_default_action(
        notification: *mut GNotification,
        detailed_action: *const gchar,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_notification_set_default_action_and_target"]
    pub fn g_notification_set_default_action_and_target(
        notification: *mut GNotification,
        action: *const gchar,
        target_format: *const gchar,
        ...
    );
}
extern "C" {
    #[link_name = "\u{1}_g_notification_set_default_action_and_target_value"]
    pub fn g_notification_set_default_action_and_target_value(
        notification: *mut GNotification,
        action: *const gchar,
        target: *mut GVariant,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_list_model_get_type"]
    pub fn g_list_model_get_type() -> GType;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GListModel {
    _unused: [u8; 0],
}
pub type GListModel = _GListModel;
pub type GListModelInterface = _GListModelInterface;
pub type GListModel_autoptr = *mut GListModel;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GListModelInterface {
    pub g_iface: GTypeInterface,
    pub get_item_type: ::std::option::Option<unsafe extern "C" fn(list: *mut GListModel) -> GType>,
    pub get_n_items: ::std::option::Option<unsafe extern "C" fn(list: *mut GListModel) -> guint>,
    pub get_item: ::std::option::Option<
        unsafe extern "C" fn(list: *mut GListModel, position: guint) -> gpointer,
    >,
}
#[test]
fn bindgen_test_layout__GListModelInterface() {
    assert_eq!(
        ::std::mem::size_of::<_GListModelInterface>(),
        40usize,
        concat!("Size of: ", stringify!(_GListModelInterface))
    );
    assert_eq!(
        ::std::mem::align_of::<_GListModelInterface>(),
        8usize,
        concat!("Alignment of ", stringify!(_GListModelInterface))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GListModelInterface>())).g_iface as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GListModelInterface),
            "::",
            stringify!(g_iface)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GListModelInterface>())).get_item_type as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GListModelInterface),
            "::",
            stringify!(get_item_type)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GListModelInterface>())).get_n_items as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GListModelInterface),
            "::",
            stringify!(get_n_items)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GListModelInterface>())).get_item as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_GListModelInterface),
            "::",
            stringify!(get_item)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_g_list_model_get_item_type"]
    pub fn g_list_model_get_item_type(list: *mut GListModel) -> GType;
}
extern "C" {
    #[link_name = "\u{1}_g_list_model_get_n_items"]
    pub fn g_list_model_get_n_items(list: *mut GListModel) -> guint;
}
extern "C" {
    #[link_name = "\u{1}_g_list_model_get_item"]
    pub fn g_list_model_get_item(list: *mut GListModel, position: guint) -> gpointer;
}
extern "C" {
    #[link_name = "\u{1}_g_list_model_get_object"]
    pub fn g_list_model_get_object(list: *mut GListModel, position: guint) -> *mut GObject;
}
extern "C" {
    #[link_name = "\u{1}_g_list_model_items_changed"]
    pub fn g_list_model_items_changed(
        list: *mut GListModel,
        position: guint,
        removed: guint,
        added: guint,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_list_store_get_type"]
    pub fn g_list_store_get_type() -> GType;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GListStore {
    _unused: [u8; 0],
}
pub type GListStore = _GListStore;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GListStoreClass {
    pub parent_class: GObjectClass,
}
#[test]
fn bindgen_test_layout_GListStoreClass() {
    assert_eq!(
        ::std::mem::size_of::<GListStoreClass>(),
        136usize,
        concat!("Size of: ", stringify!(GListStoreClass))
    );
    assert_eq!(
        ::std::mem::align_of::<GListStoreClass>(),
        8usize,
        concat!("Alignment of ", stringify!(GListStoreClass))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GListStoreClass>())).parent_class as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GListStoreClass),
            "::",
            stringify!(parent_class)
        )
    );
}
pub type GListStore_autoptr = *mut GListStore;
extern "C" {
    #[link_name = "\u{1}_g_list_store_new"]
    pub fn g_list_store_new(item_type: GType) -> *mut GListStore;
}
extern "C" {
    #[link_name = "\u{1}_g_list_store_insert"]
    pub fn g_list_store_insert(store: *mut GListStore, position: guint, item: gpointer);
}
extern "C" {
    #[link_name = "\u{1}_g_list_store_insert_sorted"]
    pub fn g_list_store_insert_sorted(
        store: *mut GListStore,
        item: gpointer,
        compare_func: GCompareDataFunc,
        user_data: gpointer,
    ) -> guint;
}
extern "C" {
    #[link_name = "\u{1}_g_list_store_sort"]
    pub fn g_list_store_sort(
        store: *mut GListStore,
        compare_func: GCompareDataFunc,
        user_data: gpointer,
    );
}
extern "C" {
    #[link_name = "\u{1}_g_list_store_append"]
    pub fn g_list_store_append(store: *mut GListStore, item: gpointer);
}
extern "C" {
    #[link_name = "\u{1}_g_list_store_remove"]
    pub fn g_list_store_remove(store: *mut GListStore, position: guint);
}
extern "C" {
    #[link_name = "\u{1}_g_list_store_remove_all"]
    pub fn g_list_store_remove_all(store: *mut GListStore);
}
extern "C" {
    #[link_name = "\u{1}_g_list_store_splice"]
    pub fn g_list_store_splice(
        store: *mut GListStore,
        position: guint,
        n_removals: guint,
        additions: *mut gpointer,
        n_additions: guint,
    );
}
pub type GAction_autoptr = *mut GAction;
pub type GActionMap_autoptr = *mut GActionMap;
pub type GAppInfo_autoptr = *mut GAppInfo;
pub type GAppLaunchContext_autoptr = *mut GAppLaunchContext;
pub type GAppInfoMonitor_autoptr = *mut GAppInfoMonitor;
pub type GApplicationCommandLine_autoptr = *mut GApplicationCommandLine;
pub type GApplication_autoptr = *mut GApplication;
pub type GAsyncInitable_autoptr = *mut GAsyncInitable;
pub type GAsyncResult_autoptr = *mut GAsyncResult;
pub type GBufferedInputStream_autoptr = *mut GBufferedInputStream;
pub type GBufferedOutputStream_autoptr = *mut GBufferedOutputStream;
pub type GBytesIcon_autoptr = *mut GBytesIcon;
pub type GCancellable_autoptr = *mut GCancellable;
pub type GCharsetConverter_autoptr = *mut GCharsetConverter;
pub type GConverter_autoptr = *mut GConverter;
pub type GConverterInputStream_autoptr = *mut GConverterInputStream;
pub type GConverterOutputStream_autoptr = *mut GConverterOutputStream;
pub type GCredentials_autoptr = *mut GCredentials;
pub type GDatagramBased_autoptr = *mut GDatagramBased;
pub type GDataInputStream_autoptr = *mut GDataInputStream;
pub type GDataOutputStream_autoptr = *mut GDataOutputStream;
pub type GDBusActionGroup_autoptr = *mut GDBusActionGroup;
pub type GDBusAuthObserver_autoptr = *mut GDBusAuthObserver;
pub type GDBusConnection_autoptr = *mut GDBusConnection;
pub type GDBusInterface_autoptr = *mut GDBusInterface;
pub type GDBusInterfaceSkeleton_autoptr = *mut GDBusInterfaceSkeleton;
pub type GDBusMenuModel_autoptr = *mut GDBusMenuModel;
pub type GDBusMessage_autoptr = *mut GDBusMessage;
pub type GDBusMethodInvocation_autoptr = *mut GDBusMethodInvocation;
pub type GDBusNodeInfo_autoptr = *mut GDBusNodeInfo;
pub type GDBusObject_autoptr = *mut GDBusObject;
pub type GDBusObjectManagerClient_autoptr = *mut GDBusObjectManagerClient;
pub type GDBusObjectManager_autoptr = *mut GDBusObjectManager;
pub type GDBusObjectManagerServer_autoptr = *mut GDBusObjectManagerServer;
pub type GDBusObjectProxy_autoptr = *mut GDBusObjectProxy;
pub type GDBusObjectSkeleton_autoptr = *mut GDBusObjectSkeleton;
pub type GDBusProxy_autoptr = *mut GDBusProxy;
pub type GDBusServer_autoptr = *mut GDBusServer;
pub type GDrive_autoptr = *mut GDrive;
pub type GEmblemedIcon_autoptr = *mut GEmblemedIcon;
pub type GEmblem_autoptr = *mut GEmblem;
pub type GFileEnumerator_autoptr = *mut GFileEnumerator;
pub type GFile_autoptr = *mut GFile;
pub type GFileAttributeInfoList_autoptr = *mut GFileAttributeInfoList;
pub type GFileIcon_autoptr = *mut GFileIcon;
pub type GFileInfo_autoptr = *mut GFileInfo;
pub type GFileInputStream_autoptr = *mut GFileInputStream;
pub type GFileIOStream_autoptr = *mut GFileIOStream;
pub type GFileMonitor_autoptr = *mut GFileMonitor;
pub type GFilenameCompleter_autoptr = *mut GFilenameCompleter;
pub type GFileOutputStream_autoptr = *mut GFileOutputStream;
pub type GFilterInputStream_autoptr = *mut GFilterInputStream;
pub type GFilterOutputStream_autoptr = *mut GFilterOutputStream;
pub type GIcon_autoptr = *mut GIcon;
pub type GInetAddress_autoptr = *mut GInetAddress;
pub type GInetAddressMask_autoptr = *mut GInetAddressMask;
pub type GInetSocketAddress_autoptr = *mut GInetSocketAddress;
pub type GInitable_autoptr = *mut GInitable;
pub type GInputStream_autoptr = *mut GInputStream;
pub type GIOModule_autoptr = *mut GIOModule;
pub type GIOStream_autoptr = *mut GIOStream;
pub type GLoadableIcon_autoptr = *mut GLoadableIcon;
pub type GMemoryInputStream_autoptr = *mut GMemoryInputStream;
pub type GMemoryOutputStream_autoptr = *mut GMemoryOutputStream;
pub type GMenu_autoptr = *mut GMenu;
pub type GMenuItem_autoptr = *mut GMenuItem;
pub type GMenuModel_autoptr = *mut GMenuModel;
pub type GMenuAttributeIter_autoptr = *mut GMenuAttributeIter;
pub type GMenuLinkIter_autoptr = *mut GMenuLinkIter;
pub type GMount_autoptr = *mut GMount;
pub type GMountOperation_autoptr = *mut GMountOperation;
pub type GNativeVolumeMonitor_autoptr = *mut GNativeVolumeMonitor;
pub type GNetworkAddress_autoptr = *mut GNetworkAddress;
pub type GNetworkMonitor_autoptr = *mut GNetworkMonitor;
pub type GNetworkService_autoptr = *mut GNetworkService;
pub type GNotification_autoptr = *mut GNotification;
pub type GOutputStream_autoptr = *mut GOutputStream;
pub type GPermission_autoptr = *mut GPermission;
pub type GPollableInputStream_autoptr = *mut GPollableInputStream;
pub type GPollableOutputStream_autoptr = *mut GPollableOutputStream;
pub type GPropertyAction_autoptr = *mut GPropertyAction;
pub type GProxyAddressEnumerator_autoptr = *mut GProxyAddressEnumerator;
pub type GProxyAddress_autoptr = *mut GProxyAddress;
pub type GProxy_autoptr = *mut GProxy;
pub type GProxyResolver_autoptr = *mut GProxyResolver;
pub type GRemoteActionGroup_autoptr = *mut GRemoteActionGroup;
pub type GResolver_autoptr = *mut GResolver;
pub type GSeekable_autoptr = *mut GSeekable;
pub type GSettingsBackend_autoptr = *mut GSettingsBackend;
pub type GSettingsSchema_autoptr = *mut GSettingsSchema;
pub type GSettings_autoptr = *mut GSettings;
pub type GSimpleActionGroup_autoptr = *mut GSimpleActionGroup;
pub type GSimpleAction_autoptr = *mut GSimpleAction;
pub type GSimpleAsyncResult_autoptr = *mut GSimpleAsyncResult;
pub type GSimplePermission_autoptr = *mut GSimplePermission;
pub type GSimpleProxyResolver_autoptr = *mut GSimpleProxyResolver;
pub type GSocketAddressEnumerator_autoptr = *mut GSocketAddressEnumerator;
pub type GSocketAddress_autoptr = *mut GSocketAddress;
pub type GSocketClient_autoptr = *mut GSocketClient;
pub type GSocketConnectable_autoptr = *mut GSocketConnectable;
pub type GSocketConnection_autoptr = *mut GSocketConnection;
pub type GSocketControlMessage_autoptr = *mut GSocketControlMessage;
pub type GSocket_autoptr = *mut GSocket;
pub type GSocketListener_autoptr = *mut GSocketListener;
pub type GSocketService_autoptr = *mut GSocketService;
pub type GSubprocess_autoptr = *mut GSubprocess;
pub type GSubprocessLauncher_autoptr = *mut GSubprocessLauncher;
pub type GTask_autoptr = *mut GTask;
pub type GTcpConnection_autoptr = *mut GTcpConnection;
pub type GTcpWrapperConnection_autoptr = *mut GTcpWrapperConnection;
pub type GTestDBus_autoptr = *mut GTestDBus;
pub type GThemedIcon_autoptr = *mut GThemedIcon;
pub type GThreadedSocketService_autoptr = *mut GThreadedSocketService;
pub type GTlsBackend_autoptr = *mut GTlsBackend;
pub type GTlsCertificate_autoptr = *mut GTlsCertificate;
pub type GTlsClientConnection_autoptr = *mut GTlsClientConnection;
pub type GTlsConnection_autoptr = *mut GTlsConnection;
pub type GTlsDatabase_autoptr = *mut GTlsDatabase;
pub type GTlsFileDatabase_autoptr = *mut GTlsFileDatabase;
pub type GTlsInteraction_autoptr = *mut GTlsInteraction;
pub type GTlsPassword_autoptr = *mut GTlsPassword;
pub type GTlsServerConnection_autoptr = *mut GTlsServerConnection;
pub type GVfs_autoptr = *mut GVfs;
pub type GVolume_autoptr = *mut GVolume;
pub type GVolumeMonitor_autoptr = *mut GVolumeMonitor;
pub type GZlibCompressor_autoptr = *mut GZlibCompressor;
pub type GZlibDecompressor_autoptr = *mut GZlibDecompressor;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NiceAgent {
    _unused: [u8; 0],
}
/// NiceAgent:
///
/// The #NiceAgent is the main GObject of the libnice library and represents
/// the ICE agent.
pub type NiceAgent = _NiceAgent;
pub type sa_family_t = __uint8_t;
pub type socklen_t = __darwin_socklen_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct iovec {
    pub iov_base: *mut ::std::os::raw::c_void,
    pub iov_len: usize,
}
#[test]
fn bindgen_test_layout_iovec() {
    assert_eq!(
        ::std::mem::size_of::<iovec>(),
        16usize,
        concat!("Size of: ", stringify!(iovec))
    );
    assert_eq!(
        ::std::mem::align_of::<iovec>(),
        8usize,
        concat!("Alignment of ", stringify!(iovec))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<iovec>())).iov_base as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(iovec),
            "::",
            stringify!(iov_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<iovec>())).iov_len as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(iovec),
            "::",
            stringify!(iov_len)
        )
    );
}
pub type sae_associd_t = __uint32_t;
pub type sae_connid_t = __uint32_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sa_endpoints {
    pub sae_srcif: ::std::os::raw::c_uint,
    pub sae_srcaddr: *const sockaddr,
    pub sae_srcaddrlen: socklen_t,
    pub sae_dstaddr: *const sockaddr,
    pub sae_dstaddrlen: socklen_t,
}
#[test]
fn bindgen_test_layout_sa_endpoints() {
    assert_eq!(
        ::std::mem::size_of::<sa_endpoints>(),
        40usize,
        concat!("Size of: ", stringify!(sa_endpoints))
    );
    assert_eq!(
        ::std::mem::align_of::<sa_endpoints>(),
        8usize,
        concat!("Alignment of ", stringify!(sa_endpoints))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sa_endpoints>())).sae_srcif as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sa_endpoints),
            "::",
            stringify!(sae_srcif)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sa_endpoints>())).sae_srcaddr as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sa_endpoints),
            "::",
            stringify!(sae_srcaddr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sa_endpoints>())).sae_srcaddrlen as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(sa_endpoints),
            "::",
            stringify!(sae_srcaddrlen)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sa_endpoints>())).sae_dstaddr as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(sa_endpoints),
            "::",
            stringify!(sae_dstaddr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sa_endpoints>())).sae_dstaddrlen as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(sa_endpoints),
            "::",
            stringify!(sae_dstaddrlen)
        )
    );
}
pub type sa_endpoints_t = sa_endpoints;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct linger {
    pub l_onoff: ::std::os::raw::c_int,
    pub l_linger: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_linger() {
    assert_eq!(
        ::std::mem::size_of::<linger>(),
        8usize,
        concat!("Size of: ", stringify!(linger))
    );
    assert_eq!(
        ::std::mem::align_of::<linger>(),
        4usize,
        concat!("Alignment of ", stringify!(linger))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<linger>())).l_onoff as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(linger),
            "::",
            stringify!(l_onoff)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<linger>())).l_linger as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(linger),
            "::",
            stringify!(l_linger)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct so_np_extensions {
    pub npx_flags: u_int32_t,
    pub npx_mask: u_int32_t,
}
#[test]
fn bindgen_test_layout_so_np_extensions() {
    assert_eq!(
        ::std::mem::size_of::<so_np_extensions>(),
        8usize,
        concat!("Size of: ", stringify!(so_np_extensions))
    );
    assert_eq!(
        ::std::mem::align_of::<so_np_extensions>(),
        4usize,
        concat!("Alignment of ", stringify!(so_np_extensions))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<so_np_extensions>())).npx_flags as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(so_np_extensions),
            "::",
            stringify!(npx_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<so_np_extensions>())).npx_mask as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(so_np_extensions),
            "::",
            stringify!(npx_mask)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sockaddr {
    pub sa_len: __uint8_t,
    pub sa_family: sa_family_t,
    pub sa_data: [::std::os::raw::c_char; 14usize],
}
#[test]
fn bindgen_test_layout_sockaddr() {
    assert_eq!(
        ::std::mem::size_of::<sockaddr>(),
        16usize,
        concat!("Size of: ", stringify!(sockaddr))
    );
    assert_eq!(
        ::std::mem::align_of::<sockaddr>(),
        1usize,
        concat!("Alignment of ", stringify!(sockaddr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sockaddr>())).sa_len as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr),
            "::",
            stringify!(sa_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sockaddr>())).sa_family as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr),
            "::",
            stringify!(sa_family)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sockaddr>())).sa_data as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr),
            "::",
            stringify!(sa_data)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sockproto {
    pub sp_family: __uint16_t,
    pub sp_protocol: __uint16_t,
}
#[test]
fn bindgen_test_layout_sockproto() {
    assert_eq!(
        ::std::mem::size_of::<sockproto>(),
        4usize,
        concat!("Size of: ", stringify!(sockproto))
    );
    assert_eq!(
        ::std::mem::align_of::<sockproto>(),
        2usize,
        concat!("Alignment of ", stringify!(sockproto))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sockproto>())).sp_family as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sockproto),
            "::",
            stringify!(sp_family)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sockproto>())).sp_protocol as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(sockproto),
            "::",
            stringify!(sp_protocol)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sockaddr_storage {
    pub ss_len: __uint8_t,
    pub ss_family: sa_family_t,
    pub __ss_pad1: [::std::os::raw::c_char; 6usize],
    pub __ss_align: __int64_t,
    pub __ss_pad2: [::std::os::raw::c_char; 112usize],
}
#[test]
fn bindgen_test_layout_sockaddr_storage() {
    assert_eq!(
        ::std::mem::size_of::<sockaddr_storage>(),
        128usize,
        concat!("Size of: ", stringify!(sockaddr_storage))
    );
    assert_eq!(
        ::std::mem::align_of::<sockaddr_storage>(),
        8usize,
        concat!("Alignment of ", stringify!(sockaddr_storage))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sockaddr_storage>())).ss_len as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_storage),
            "::",
            stringify!(ss_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sockaddr_storage>())).ss_family as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_storage),
            "::",
            stringify!(ss_family)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sockaddr_storage>())).__ss_pad1 as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_storage),
            "::",
            stringify!(__ss_pad1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sockaddr_storage>())).__ss_align as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_storage),
            "::",
            stringify!(__ss_align)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sockaddr_storage>())).__ss_pad2 as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_storage),
            "::",
            stringify!(__ss_pad2)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct msghdr {
    pub msg_name: *mut ::std::os::raw::c_void,
    pub msg_namelen: socklen_t,
    pub msg_iov: *mut iovec,
    pub msg_iovlen: ::std::os::raw::c_int,
    pub msg_control: *mut ::std::os::raw::c_void,
    pub msg_controllen: socklen_t,
    pub msg_flags: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_msghdr() {
    assert_eq!(
        ::std::mem::size_of::<msghdr>(),
        48usize,
        concat!("Size of: ", stringify!(msghdr))
    );
    assert_eq!(
        ::std::mem::align_of::<msghdr>(),
        8usize,
        concat!("Alignment of ", stringify!(msghdr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<msghdr>())).msg_name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(msghdr),
            "::",
            stringify!(msg_name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<msghdr>())).msg_namelen as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(msghdr),
            "::",
            stringify!(msg_namelen)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<msghdr>())).msg_iov as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(msghdr),
            "::",
            stringify!(msg_iov)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<msghdr>())).msg_iovlen as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(msghdr),
            "::",
            stringify!(msg_iovlen)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<msghdr>())).msg_control as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(msghdr),
            "::",
            stringify!(msg_control)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<msghdr>())).msg_controllen as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(msghdr),
            "::",
            stringify!(msg_controllen)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<msghdr>())).msg_flags as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(msghdr),
            "::",
            stringify!(msg_flags)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cmsghdr {
    pub cmsg_len: socklen_t,
    pub cmsg_level: ::std::os::raw::c_int,
    pub cmsg_type: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_cmsghdr() {
    assert_eq!(
        ::std::mem::size_of::<cmsghdr>(),
        12usize,
        concat!("Size of: ", stringify!(cmsghdr))
    );
    assert_eq!(
        ::std::mem::align_of::<cmsghdr>(),
        4usize,
        concat!("Alignment of ", stringify!(cmsghdr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cmsghdr>())).cmsg_len as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cmsghdr),
            "::",
            stringify!(cmsg_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cmsghdr>())).cmsg_level as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(cmsghdr),
            "::",
            stringify!(cmsg_level)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cmsghdr>())).cmsg_type as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cmsghdr),
            "::",
            stringify!(cmsg_type)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sf_hdtr {
    pub headers: *mut iovec,
    pub hdr_cnt: ::std::os::raw::c_int,
    pub trailers: *mut iovec,
    pub trl_cnt: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_sf_hdtr() {
    assert_eq!(
        ::std::mem::size_of::<sf_hdtr>(),
        32usize,
        concat!("Size of: ", stringify!(sf_hdtr))
    );
    assert_eq!(
        ::std::mem::align_of::<sf_hdtr>(),
        8usize,
        concat!("Alignment of ", stringify!(sf_hdtr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sf_hdtr>())).headers as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sf_hdtr),
            "::",
            stringify!(headers)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sf_hdtr>())).hdr_cnt as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sf_hdtr),
            "::",
            stringify!(hdr_cnt)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sf_hdtr>())).trailers as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(sf_hdtr),
            "::",
            stringify!(trailers)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sf_hdtr>())).trl_cnt as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(sf_hdtr),
            "::",
            stringify!(trl_cnt)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_accept"]
    pub fn accept(
        arg1: ::std::os::raw::c_int,
        arg2: *mut sockaddr,
        arg3: *mut socklen_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_bind"]
    pub fn bind(
        arg1: ::std::os::raw::c_int,
        arg2: *const sockaddr,
        arg3: socklen_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_connect"]
    pub fn connect(
        arg1: ::std::os::raw::c_int,
        arg2: *const sockaddr,
        arg3: socklen_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_getpeername"]
    pub fn getpeername(
        arg1: ::std::os::raw::c_int,
        arg2: *mut sockaddr,
        arg3: *mut socklen_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_getsockname"]
    pub fn getsockname(
        arg1: ::std::os::raw::c_int,
        arg2: *mut sockaddr,
        arg3: *mut socklen_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_getsockopt"]
    pub fn getsockopt(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_int,
        arg3: ::std::os::raw::c_int,
        arg4: *mut ::std::os::raw::c_void,
        arg5: *mut socklen_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_listen"]
    pub fn listen(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_recv"]
    pub fn recv(
        arg1: ::std::os::raw::c_int,
        arg2: *mut ::std::os::raw::c_void,
        arg3: usize,
        arg4: ::std::os::raw::c_int,
    ) -> isize;
}
extern "C" {
    #[link_name = "\u{1}_recvfrom"]
    pub fn recvfrom(
        arg1: ::std::os::raw::c_int,
        arg2: *mut ::std::os::raw::c_void,
        arg3: usize,
        arg4: ::std::os::raw::c_int,
        arg5: *mut sockaddr,
        arg6: *mut socklen_t,
    ) -> isize;
}
extern "C" {
    #[link_name = "\u{1}_recvmsg"]
    pub fn recvmsg(
        arg1: ::std::os::raw::c_int,
        arg2: *mut msghdr,
        arg3: ::std::os::raw::c_int,
    ) -> isize;
}
extern "C" {
    #[link_name = "\u{1}_send"]
    pub fn send(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_void,
        arg3: usize,
        arg4: ::std::os::raw::c_int,
    ) -> isize;
}
extern "C" {
    #[link_name = "\u{1}_sendmsg"]
    pub fn sendmsg(
        arg1: ::std::os::raw::c_int,
        arg2: *const msghdr,
        arg3: ::std::os::raw::c_int,
    ) -> isize;
}
extern "C" {
    #[link_name = "\u{1}_sendto"]
    pub fn sendto(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_void,
        arg3: usize,
        arg4: ::std::os::raw::c_int,
        arg5: *const sockaddr,
        arg6: socklen_t,
    ) -> isize;
}
extern "C" {
    #[link_name = "\u{1}_setsockopt"]
    pub fn setsockopt(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_int,
        arg3: ::std::os::raw::c_int,
        arg4: *const ::std::os::raw::c_void,
        arg5: socklen_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_shutdown"]
    pub fn shutdown(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_sockatmark"]
    pub fn sockatmark(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_socket"]
    pub fn socket(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_int,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_socketpair"]
    pub fn socketpair(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_int,
        arg3: ::std::os::raw::c_int,
        arg4: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_sendfile"]
    pub fn sendfile(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_int,
        arg3: off_t,
        arg4: *mut off_t,
        arg5: *mut sf_hdtr,
        arg6: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_pfctlinput"]
    pub fn pfctlinput(arg1: ::std::os::raw::c_int, arg2: *mut sockaddr);
}
extern "C" {
    #[link_name = "\u{1}_connectx"]
    pub fn connectx(
        arg1: ::std::os::raw::c_int,
        arg2: *const sa_endpoints_t,
        arg3: sae_associd_t,
        arg4: ::std::os::raw::c_uint,
        arg5: *const iovec,
        arg6: ::std::os::raw::c_uint,
        arg7: *mut usize,
        arg8: *mut sae_connid_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_disconnectx"]
    pub fn disconnectx(
        arg1: ::std::os::raw::c_int,
        arg2: sae_associd_t,
        arg3: sae_connid_t,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct in_addr {
    pub s_addr: in_addr_t,
}
#[test]
fn bindgen_test_layout_in_addr() {
    assert_eq!(
        ::std::mem::size_of::<in_addr>(),
        4usize,
        concat!("Size of: ", stringify!(in_addr))
    );
    assert_eq!(
        ::std::mem::align_of::<in_addr>(),
        4usize,
        concat!("Alignment of ", stringify!(in_addr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<in_addr>())).s_addr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(in_addr),
            "::",
            stringify!(s_addr)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sockaddr_in {
    pub sin_len: __uint8_t,
    pub sin_family: sa_family_t,
    pub sin_port: in_port_t,
    pub sin_addr: in_addr,
    pub sin_zero: [::std::os::raw::c_char; 8usize],
}
#[test]
fn bindgen_test_layout_sockaddr_in() {
    assert_eq!(
        ::std::mem::size_of::<sockaddr_in>(),
        16usize,
        concat!("Size of: ", stringify!(sockaddr_in))
    );
    assert_eq!(
        ::std::mem::align_of::<sockaddr_in>(),
        4usize,
        concat!("Alignment of ", stringify!(sockaddr_in))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sockaddr_in>())).sin_len as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_in),
            "::",
            stringify!(sin_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sockaddr_in>())).sin_family as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_in),
            "::",
            stringify!(sin_family)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sockaddr_in>())).sin_port as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_in),
            "::",
            stringify!(sin_port)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sockaddr_in>())).sin_addr as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_in),
            "::",
            stringify!(sin_addr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sockaddr_in>())).sin_zero as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_in),
            "::",
            stringify!(sin_zero)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ip_opts {
    pub ip_dst: in_addr,
    pub ip_opts: [::std::os::raw::c_char; 40usize],
}
#[test]
fn bindgen_test_layout_ip_opts() {
    assert_eq!(
        ::std::mem::size_of::<ip_opts>(),
        44usize,
        concat!("Size of: ", stringify!(ip_opts))
    );
    assert_eq!(
        ::std::mem::align_of::<ip_opts>(),
        4usize,
        concat!("Alignment of ", stringify!(ip_opts))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ip_opts>())).ip_dst as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ip_opts),
            "::",
            stringify!(ip_dst)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ip_opts>())).ip_opts as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ip_opts),
            "::",
            stringify!(ip_opts)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ip_mreq {
    pub imr_multiaddr: in_addr,
    pub imr_interface: in_addr,
}
#[test]
fn bindgen_test_layout_ip_mreq() {
    assert_eq!(
        ::std::mem::size_of::<ip_mreq>(),
        8usize,
        concat!("Size of: ", stringify!(ip_mreq))
    );
    assert_eq!(
        ::std::mem::align_of::<ip_mreq>(),
        4usize,
        concat!("Alignment of ", stringify!(ip_mreq))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ip_mreq>())).imr_multiaddr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ip_mreq),
            "::",
            stringify!(imr_multiaddr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ip_mreq>())).imr_interface as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ip_mreq),
            "::",
            stringify!(imr_interface)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ip_mreqn {
    pub imr_multiaddr: in_addr,
    pub imr_address: in_addr,
    pub imr_ifindex: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_ip_mreqn() {
    assert_eq!(
        ::std::mem::size_of::<ip_mreqn>(),
        12usize,
        concat!("Size of: ", stringify!(ip_mreqn))
    );
    assert_eq!(
        ::std::mem::align_of::<ip_mreqn>(),
        4usize,
        concat!("Alignment of ", stringify!(ip_mreqn))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ip_mreqn>())).imr_multiaddr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ip_mreqn),
            "::",
            stringify!(imr_multiaddr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ip_mreqn>())).imr_address as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ip_mreqn),
            "::",
            stringify!(imr_address)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ip_mreqn>())).imr_ifindex as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ip_mreqn),
            "::",
            stringify!(imr_ifindex)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ip_mreq_source {
    pub imr_multiaddr: in_addr,
    pub imr_sourceaddr: in_addr,
    pub imr_interface: in_addr,
}
#[test]
fn bindgen_test_layout_ip_mreq_source() {
    assert_eq!(
        ::std::mem::size_of::<ip_mreq_source>(),
        12usize,
        concat!("Size of: ", stringify!(ip_mreq_source))
    );
    assert_eq!(
        ::std::mem::align_of::<ip_mreq_source>(),
        4usize,
        concat!("Alignment of ", stringify!(ip_mreq_source))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ip_mreq_source>())).imr_multiaddr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ip_mreq_source),
            "::",
            stringify!(imr_multiaddr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ip_mreq_source>())).imr_sourceaddr as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ip_mreq_source),
            "::",
            stringify!(imr_sourceaddr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ip_mreq_source>())).imr_interface as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ip_mreq_source),
            "::",
            stringify!(imr_interface)
        )
    );
}
#[repr(C)]
pub struct group_req {
    pub _bindgen_opaque_blob: [u32; 33usize],
}
#[test]
fn bindgen_test_layout_group_req() {
    assert_eq!(
        ::std::mem::size_of::<group_req>(),
        132usize,
        concat!("Size of: ", stringify!(group_req))
    );
    assert_eq!(
        ::std::mem::align_of::<group_req>(),
        4usize,
        concat!("Alignment of ", stringify!(group_req))
    );
}
#[repr(C)]
pub struct group_source_req {
    pub _bindgen_opaque_blob: [u32; 65usize],
}
#[test]
fn bindgen_test_layout_group_source_req() {
    assert_eq!(
        ::std::mem::size_of::<group_source_req>(),
        260usize,
        concat!("Size of: ", stringify!(group_source_req))
    );
    assert_eq!(
        ::std::mem::align_of::<group_source_req>(),
        4usize,
        concat!("Alignment of ", stringify!(group_source_req))
    );
}
#[repr(C)]
pub struct __msfilterreq {
    pub _bindgen_opaque_blob: [u32; 38usize],
}
#[test]
fn bindgen_test_layout___msfilterreq() {
    assert_eq!(
        ::std::mem::size_of::<__msfilterreq>(),
        152usize,
        concat!("Size of: ", stringify!(__msfilterreq))
    );
    assert_eq!(
        ::std::mem::align_of::<__msfilterreq>(),
        4usize,
        concat!("Alignment of ", stringify!(__msfilterreq))
    );
}
extern "C" {
    #[link_name = "\u{1}_setipv4sourcefilter"]
    pub fn setipv4sourcefilter(
        arg1: ::std::os::raw::c_int,
        arg2: in_addr,
        arg3: in_addr,
        arg4: u32,
        arg5: u32,
        arg6: *mut in_addr,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_getipv4sourcefilter"]
    pub fn getipv4sourcefilter(
        arg1: ::std::os::raw::c_int,
        arg2: in_addr,
        arg3: in_addr,
        arg4: *mut u32,
        arg5: *mut u32,
        arg6: *mut in_addr,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_setsourcefilter"]
    pub fn setsourcefilter(
        arg1: ::std::os::raw::c_int,
        arg2: u32,
        arg3: *mut sockaddr,
        arg4: socklen_t,
        arg5: u32,
        arg6: u32,
        arg7: *mut sockaddr_storage,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_getsourcefilter"]
    pub fn getsourcefilter(
        arg1: ::std::os::raw::c_int,
        arg2: u32,
        arg3: *mut sockaddr,
        arg4: socklen_t,
        arg5: *mut u32,
        arg6: *mut u32,
        arg7: *mut sockaddr_storage,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct in_pktinfo {
    pub ipi_ifindex: ::std::os::raw::c_uint,
    pub ipi_spec_dst: in_addr,
    pub ipi_addr: in_addr,
}
#[test]
fn bindgen_test_layout_in_pktinfo() {
    assert_eq!(
        ::std::mem::size_of::<in_pktinfo>(),
        12usize,
        concat!("Size of: ", stringify!(in_pktinfo))
    );
    assert_eq!(
        ::std::mem::align_of::<in_pktinfo>(),
        4usize,
        concat!("Alignment of ", stringify!(in_pktinfo))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<in_pktinfo>())).ipi_ifindex as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(in_pktinfo),
            "::",
            stringify!(ipi_ifindex)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<in_pktinfo>())).ipi_spec_dst as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(in_pktinfo),
            "::",
            stringify!(ipi_spec_dst)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<in_pktinfo>())).ipi_addr as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(in_pktinfo),
            "::",
            stringify!(ipi_addr)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct in6_addr {
    pub __u6_addr: in6_addr__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union in6_addr__bindgen_ty_1 {
    pub __u6_addr8: [__uint8_t; 16usize],
    pub __u6_addr16: [__uint16_t; 8usize],
    pub __u6_addr32: [__uint32_t; 4usize],
    _bindgen_union_align: [u32; 4usize],
}
#[test]
fn bindgen_test_layout_in6_addr__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<in6_addr__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(in6_addr__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<in6_addr__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(in6_addr__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<in6_addr__bindgen_ty_1>())).__u6_addr8 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(in6_addr__bindgen_ty_1),
            "::",
            stringify!(__u6_addr8)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<in6_addr__bindgen_ty_1>())).__u6_addr16 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(in6_addr__bindgen_ty_1),
            "::",
            stringify!(__u6_addr16)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<in6_addr__bindgen_ty_1>())).__u6_addr32 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(in6_addr__bindgen_ty_1),
            "::",
            stringify!(__u6_addr32)
        )
    );
}
#[test]
fn bindgen_test_layout_in6_addr() {
    assert_eq!(
        ::std::mem::size_of::<in6_addr>(),
        16usize,
        concat!("Size of: ", stringify!(in6_addr))
    );
    assert_eq!(
        ::std::mem::align_of::<in6_addr>(),
        4usize,
        concat!("Alignment of ", stringify!(in6_addr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<in6_addr>())).__u6_addr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(in6_addr),
            "::",
            stringify!(__u6_addr)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sockaddr_in6 {
    pub sin6_len: __uint8_t,
    pub sin6_family: sa_family_t,
    pub sin6_port: in_port_t,
    pub sin6_flowinfo: __uint32_t,
    pub sin6_addr: in6_addr,
    pub sin6_scope_id: __uint32_t,
}
#[test]
fn bindgen_test_layout_sockaddr_in6() {
    assert_eq!(
        ::std::mem::size_of::<sockaddr_in6>(),
        28usize,
        concat!("Size of: ", stringify!(sockaddr_in6))
    );
    assert_eq!(
        ::std::mem::align_of::<sockaddr_in6>(),
        4usize,
        concat!("Alignment of ", stringify!(sockaddr_in6))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sockaddr_in6>())).sin6_len as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_in6),
            "::",
            stringify!(sin6_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sockaddr_in6>())).sin6_family as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_in6),
            "::",
            stringify!(sin6_family)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sockaddr_in6>())).sin6_port as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_in6),
            "::",
            stringify!(sin6_port)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sockaddr_in6>())).sin6_flowinfo as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_in6),
            "::",
            stringify!(sin6_flowinfo)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sockaddr_in6>())).sin6_addr as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_in6),
            "::",
            stringify!(sin6_addr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sockaddr_in6>())).sin6_scope_id as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_in6),
            "::",
            stringify!(sin6_scope_id)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_in6addr_any"]
    pub static mut in6addr_any: in6_addr;
}
extern "C" {
    #[link_name = "\u{1}_in6addr_loopback"]
    pub static mut in6addr_loopback: in6_addr;
}
extern "C" {
    #[link_name = "\u{1}_in6addr_nodelocal_allnodes"]
    pub static mut in6addr_nodelocal_allnodes: in6_addr;
}
extern "C" {
    #[link_name = "\u{1}_in6addr_linklocal_allnodes"]
    pub static mut in6addr_linklocal_allnodes: in6_addr;
}
extern "C" {
    #[link_name = "\u{1}_in6addr_linklocal_allrouters"]
    pub static mut in6addr_linklocal_allrouters: in6_addr;
}
extern "C" {
    #[link_name = "\u{1}_in6addr_linklocal_allv2routers"]
    pub static mut in6addr_linklocal_allv2routers: in6_addr;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ipv6_mreq {
    pub ipv6mr_multiaddr: in6_addr,
    pub ipv6mr_interface: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_ipv6_mreq() {
    assert_eq!(
        ::std::mem::size_of::<ipv6_mreq>(),
        20usize,
        concat!("Size of: ", stringify!(ipv6_mreq))
    );
    assert_eq!(
        ::std::mem::align_of::<ipv6_mreq>(),
        4usize,
        concat!("Alignment of ", stringify!(ipv6_mreq))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ipv6_mreq>())).ipv6mr_multiaddr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ipv6_mreq),
            "::",
            stringify!(ipv6mr_multiaddr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ipv6_mreq>())).ipv6mr_interface as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ipv6_mreq),
            "::",
            stringify!(ipv6mr_interface)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct in6_pktinfo {
    pub ipi6_addr: in6_addr,
    pub ipi6_ifindex: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_in6_pktinfo() {
    assert_eq!(
        ::std::mem::size_of::<in6_pktinfo>(),
        20usize,
        concat!("Size of: ", stringify!(in6_pktinfo))
    );
    assert_eq!(
        ::std::mem::align_of::<in6_pktinfo>(),
        4usize,
        concat!("Alignment of ", stringify!(in6_pktinfo))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<in6_pktinfo>())).ipi6_addr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(in6_pktinfo),
            "::",
            stringify!(ipi6_addr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<in6_pktinfo>())).ipi6_ifindex as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(in6_pktinfo),
            "::",
            stringify!(ipi6_ifindex)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ip6_mtuinfo {
    pub ip6m_addr: sockaddr_in6,
    pub ip6m_mtu: u32,
}
#[test]
fn bindgen_test_layout_ip6_mtuinfo() {
    assert_eq!(
        ::std::mem::size_of::<ip6_mtuinfo>(),
        32usize,
        concat!("Size of: ", stringify!(ip6_mtuinfo))
    );
    assert_eq!(
        ::std::mem::align_of::<ip6_mtuinfo>(),
        4usize,
        concat!("Alignment of ", stringify!(ip6_mtuinfo))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ip6_mtuinfo>())).ip6m_addr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ip6_mtuinfo),
            "::",
            stringify!(ip6m_addr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ip6_mtuinfo>())).ip6m_mtu as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(ip6_mtuinfo),
            "::",
            stringify!(ip6m_mtu)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_inet6_option_space"]
    pub fn inet6_option_space(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_inet6_option_init"]
    pub fn inet6_option_init(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *mut *mut cmsghdr,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_inet6_option_append"]
    pub fn inet6_option_append(
        arg1: *mut cmsghdr,
        arg2: *const __uint8_t,
        arg3: ::std::os::raw::c_int,
        arg4: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_inet6_option_alloc"]
    pub fn inet6_option_alloc(
        arg1: *mut cmsghdr,
        arg2: ::std::os::raw::c_int,
        arg3: ::std::os::raw::c_int,
        arg4: ::std::os::raw::c_int,
    ) -> *mut __uint8_t;
}
extern "C" {
    #[link_name = "\u{1}_inet6_option_next"]
    pub fn inet6_option_next(
        arg1: *const cmsghdr,
        arg2: *mut *mut __uint8_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_inet6_option_find"]
    pub fn inet6_option_find(
        arg1: *const cmsghdr,
        arg2: *mut *mut __uint8_t,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_inet6_rthdr_space"]
    pub fn inet6_rthdr_space(arg1: ::std::os::raw::c_int, arg2: ::std::os::raw::c_int) -> usize;
}
extern "C" {
    #[link_name = "\u{1}_inet6_rthdr_init"]
    pub fn inet6_rthdr_init(
        arg1: *mut ::std::os::raw::c_void,
        arg2: ::std::os::raw::c_int,
    ) -> *mut cmsghdr;
}
extern "C" {
    #[link_name = "\u{1}_inet6_rthdr_add"]
    pub fn inet6_rthdr_add(
        arg1: *mut cmsghdr,
        arg2: *const in6_addr,
        arg3: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_inet6_rthdr_lasthop"]
    pub fn inet6_rthdr_lasthop(
        arg1: *mut cmsghdr,
        arg2: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_inet6_rthdr_segments"]
    pub fn inet6_rthdr_segments(arg1: *const cmsghdr) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_inet6_rthdr_getaddr"]
    pub fn inet6_rthdr_getaddr(arg1: *mut cmsghdr, arg2: ::std::os::raw::c_int) -> *mut in6_addr;
}
extern "C" {
    #[link_name = "\u{1}_inet6_rthdr_getflags"]
    pub fn inet6_rthdr_getflags(
        arg1: *const cmsghdr,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_inet6_opt_init"]
    pub fn inet6_opt_init(
        arg1: *mut ::std::os::raw::c_void,
        arg2: socklen_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_inet6_opt_append"]
    pub fn inet6_opt_append(
        arg1: *mut ::std::os::raw::c_void,
        arg2: socklen_t,
        arg3: ::std::os::raw::c_int,
        arg4: __uint8_t,
        arg5: socklen_t,
        arg6: __uint8_t,
        arg7: *mut *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_inet6_opt_finish"]
    pub fn inet6_opt_finish(
        arg1: *mut ::std::os::raw::c_void,
        arg2: socklen_t,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_inet6_opt_set_val"]
    pub fn inet6_opt_set_val(
        arg1: *mut ::std::os::raw::c_void,
        arg2: ::std::os::raw::c_int,
        arg3: *mut ::std::os::raw::c_void,
        arg4: socklen_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_inet6_opt_next"]
    pub fn inet6_opt_next(
        arg1: *mut ::std::os::raw::c_void,
        arg2: socklen_t,
        arg3: ::std::os::raw::c_int,
        arg4: *mut __uint8_t,
        arg5: *mut socklen_t,
        arg6: *mut *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_inet6_opt_find"]
    pub fn inet6_opt_find(
        arg1: *mut ::std::os::raw::c_void,
        arg2: socklen_t,
        arg3: ::std::os::raw::c_int,
        arg4: __uint8_t,
        arg5: *mut socklen_t,
        arg6: *mut *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_inet6_opt_get_val"]
    pub fn inet6_opt_get_val(
        arg1: *mut ::std::os::raw::c_void,
        arg2: ::std::os::raw::c_int,
        arg3: *mut ::std::os::raw::c_void,
        arg4: socklen_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_inet6_rth_space"]
    pub fn inet6_rth_space(arg1: ::std::os::raw::c_int, arg2: ::std::os::raw::c_int) -> socklen_t;
}
extern "C" {
    #[link_name = "\u{1}_inet6_rth_init"]
    pub fn inet6_rth_init(
        arg1: *mut ::std::os::raw::c_void,
        arg2: socklen_t,
        arg3: ::std::os::raw::c_int,
        arg4: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[link_name = "\u{1}_inet6_rth_add"]
    pub fn inet6_rth_add(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *const in6_addr,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_inet6_rth_reverse"]
    pub fn inet6_rth_reverse(
        arg1: *const ::std::os::raw::c_void,
        arg2: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_inet6_rth_segments"]
    pub fn inet6_rth_segments(arg1: *const ::std::os::raw::c_void) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_inet6_rth_getaddr"]
    pub fn inet6_rth_getaddr(
        arg1: *const ::std::os::raw::c_void,
        arg2: ::std::os::raw::c_int,
    ) -> *mut in6_addr;
}
extern "C" {
    #[link_name = "\u{1}_addrsel_policy_init"]
    pub fn addrsel_policy_init();
}
extern "C" {
    #[link_name = "\u{1}_bindresvport"]
    pub fn bindresvport(
        arg1: ::std::os::raw::c_int,
        arg2: *mut sockaddr_in,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_bindresvport_sa"]
    pub fn bindresvport_sa(
        arg1: ::std::os::raw::c_int,
        arg2: *mut sockaddr,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_inet_addr"]
    pub fn inet_addr(arg1: *const ::std::os::raw::c_char) -> in_addr_t;
}
extern "C" {
    #[link_name = "\u{1}_inet_ntoa"]
    pub fn inet_ntoa(arg1: in_addr) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_inet_ntop"]
    pub fn inet_ntop(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_void,
        arg3: *mut ::std::os::raw::c_char,
        arg4: socklen_t,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_inet_pton"]
    pub fn inet_pton(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ascii2addr"]
    pub fn ascii2addr(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_addr2ascii"]
    pub fn addr2ascii(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_void,
        arg3: ::std::os::raw::c_int,
        arg4: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_inet_aton"]
    pub fn inet_aton(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut in_addr,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_inet_lnaof"]
    pub fn inet_lnaof(arg1: in_addr) -> in_addr_t;
}
extern "C" {
    #[link_name = "\u{1}_inet_makeaddr"]
    pub fn inet_makeaddr(arg1: in_addr_t, arg2: in_addr_t) -> in_addr;
}
extern "C" {
    #[link_name = "\u{1}_inet_netof"]
    pub fn inet_netof(arg1: in_addr) -> in_addr_t;
}
extern "C" {
    #[link_name = "\u{1}_inet_network"]
    pub fn inet_network(arg1: *const ::std::os::raw::c_char) -> in_addr_t;
}
extern "C" {
    #[link_name = "\u{1}_inet_net_ntop"]
    pub fn inet_net_ntop(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_void,
        arg3: ::std::os::raw::c_int,
        arg4: *mut ::std::os::raw::c_char,
        arg5: __darwin_size_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_inet_net_pton"]
    pub fn inet_net_pton(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut ::std::os::raw::c_void,
        arg4: __darwin_size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_inet_neta"]
    pub fn inet_neta(
        arg1: in_addr_t,
        arg2: *mut ::std::os::raw::c_char,
        arg3: __darwin_size_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_inet_nsap_addr"]
    pub fn inet_nsap_addr(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut ::std::os::raw::c_uchar,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[link_name = "\u{1}_inet_nsap_ntoa"]
    pub fn inet_nsap_ntoa(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_uchar,
        arg3: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
/// NiceAddress:
///
/// The #NiceAddress structure that represents an IPv4 or IPv6 address.
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NiceAddress {
    pub s: _NiceAddress__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _NiceAddress__bindgen_ty_1 {
    pub addr: sockaddr,
    pub ip4: sockaddr_in,
    pub ip6: sockaddr_in6,
    _bindgen_union_align: [u32; 7usize],
}
#[test]
fn bindgen_test_layout__NiceAddress__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<_NiceAddress__bindgen_ty_1>(),
        28usize,
        concat!("Size of: ", stringify!(_NiceAddress__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<_NiceAddress__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(_NiceAddress__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NiceAddress__bindgen_ty_1>())).addr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NiceAddress__bindgen_ty_1),
            "::",
            stringify!(addr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NiceAddress__bindgen_ty_1>())).ip4 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NiceAddress__bindgen_ty_1),
            "::",
            stringify!(ip4)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NiceAddress__bindgen_ty_1>())).ip6 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NiceAddress__bindgen_ty_1),
            "::",
            stringify!(ip6)
        )
    );
}
#[test]
fn bindgen_test_layout__NiceAddress() {
    assert_eq!(
        ::std::mem::size_of::<_NiceAddress>(),
        28usize,
        concat!("Size of: ", stringify!(_NiceAddress))
    );
    assert_eq!(
        ::std::mem::align_of::<_NiceAddress>(),
        4usize,
        concat!("Alignment of ", stringify!(_NiceAddress))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NiceAddress>())).s as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NiceAddress),
            "::",
            stringify!(s)
        )
    );
}
pub type NiceAddress = _NiceAddress;
extern "C" {
    /// nice_address_init:
    /// @addr: The #NiceAddress to init
    ///
    /// Initialize a #NiceAddress into an undefined address
    #[link_name = "\u{1}_nice_address_init"]
    pub fn nice_address_init(addr: *mut NiceAddress);
}
extern "C" {
    /// nice_address_new:
    ///
    /// Create a new #NiceAddress with undefined address
    /// You must free it with nice_address_free()
    ///
    /// Returns: The new #NiceAddress
    #[link_name = "\u{1}_nice_address_new"]
    pub fn nice_address_new() -> *mut NiceAddress;
}
extern "C" {
    /// nice_address_free:
    /// @addr: The #NiceAddress to free
    ///
    /// Frees a #NiceAddress created with nice_address_new() or nice_address_dup()
    #[link_name = "\u{1}_nice_address_free"]
    pub fn nice_address_free(addr: *mut NiceAddress);
}
extern "C" {
    /// nice_address_dup:
    /// @addr: The #NiceAddress to dup
    ///
    /// Creates a new #NiceAddress with the same address as @addr
    ///
    /// Returns: The new #NiceAddress
    #[link_name = "\u{1}_nice_address_dup"]
    pub fn nice_address_dup(addr: *const NiceAddress) -> *mut NiceAddress;
}
extern "C" {
    /// nice_address_set_ipv4:
    /// @addr: The #NiceAddress to modify
    /// @addr_ipv4: The IPv4 address
    ///
    /// Set @addr to an IPv4 address using the data from @addr_ipv4
    ///
    /// <note>
    /// <para>
    /// This function will reset the port to 0, so make sure you call it before
    /// nice_address_set_port()
    /// </para>
    /// </note>
    #[link_name = "\u{1}_nice_address_set_ipv4"]
    pub fn nice_address_set_ipv4(addr: *mut NiceAddress, addr_ipv4: guint32);
}
extern "C" {
    /// nice_address_set_ipv6:
    /// @addr: The #NiceAddress to modify
    /// @addr_ipv6: The IPv6 address
    ///
    /// Set @addr to an IPv6 address using the data from @addr_ipv6
    ///
    /// <note>
    /// <para>
    /// This function will reset the port to 0, so make sure you call it before
    /// nice_address_set_port()
    /// </para>
    /// </note>
    #[link_name = "\u{1}_nice_address_set_ipv6"]
    pub fn nice_address_set_ipv6(addr: *mut NiceAddress, addr_ipv6: *const guchar);
}
extern "C" {
    /// nice_address_set_port:
    /// @addr: The #NiceAddress to modify
    /// @port: The port to set
    ///
    /// Set the port of @addr to @port
    #[link_name = "\u{1}_nice_address_set_port"]
    pub fn nice_address_set_port(addr: *mut NiceAddress, port: guint);
}
extern "C" {
    /// nice_address_get_port:
    /// @addr: The #NiceAddress to query
    ///
    /// Retreive the port of @addr
    ///
    /// Returns: The port of @addr
    #[link_name = "\u{1}_nice_address_get_port"]
    pub fn nice_address_get_port(addr: *const NiceAddress) -> guint;
}
extern "C" {
    /// nice_address_set_from_string:
    /// @addr: The #NiceAddress to modify
    /// @str: The string to set
    ///
    /// Sets an IPv4 or IPv6 address from the string @str
    ///
    /// Returns: %TRUE if success, %FALSE on error
    #[link_name = "\u{1}_nice_address_set_from_string"]
    pub fn nice_address_set_from_string(addr: *mut NiceAddress, str: *const gchar) -> gboolean;
}
extern "C" {
    /// nice_address_set_from_sockaddr:
    /// @addr: The #NiceAddress to modify
    /// @sin: The sockaddr to set
    ///
    /// Sets an IPv4 or IPv6 address from the sockaddr structure @sin
    ///
    #[link_name = "\u{1}_nice_address_set_from_sockaddr"]
    pub fn nice_address_set_from_sockaddr(addr: *mut NiceAddress, sin: *const sockaddr);
}
extern "C" {
    /// nice_address_copy_to_sockaddr:
    /// @addr: The #NiceAddress to query
    /// @sin: The sockaddr to fill
    ///
    /// Fills the sockaddr structure @sin with the address contained in @addr
    ///
    #[link_name = "\u{1}_nice_address_copy_to_sockaddr"]
    pub fn nice_address_copy_to_sockaddr(addr: *const NiceAddress, sin: *mut sockaddr);
}
extern "C" {
    /// nice_address_equal:
    /// @a: First #NiceAddress to compare
    /// @b: Second #NiceAddress to compare
    ///
    /// Compares two #NiceAddress structures to see if they contain the same address
    /// and the same port.
    ///
    /// Returns: %TRUE if @a and @b are the same address, %FALSE if they are different
    #[link_name = "\u{1}_nice_address_equal"]
    pub fn nice_address_equal(a: *const NiceAddress, b: *const NiceAddress) -> gboolean;
}
extern "C" {
    /// nice_address_equal_no_port:
    /// @a: First #NiceAddress to compare
    /// @b: Second #NiceAddress to compare
    ///
    /// Compares two #NiceAddress structures to see if they contain the same address,
    /// ignoring the port.
    ///
    /// Returns: %TRUE if @a and @b are the same address, %FALSE if they
    /// are different
    ///
    /// Since: 0.1.8
    #[link_name = "\u{1}_nice_address_equal_no_port"]
    pub fn nice_address_equal_no_port(a: *const NiceAddress, b: *const NiceAddress) -> gboolean;
}
extern "C" {
    /// nice_address_to_string:
    /// @addr: The #NiceAddress to query
    /// @dst: The string to fill
    ///
    /// Transforms the address @addr into a human readable string
    ///
    #[link_name = "\u{1}_nice_address_to_string"]
    pub fn nice_address_to_string(addr: *const NiceAddress, dst: *mut gchar);
}
extern "C" {
    /// nice_address_is_private:
    /// @addr: The #NiceAddress to query
    ///
    /// Verifies if the address in @addr is a private address or not
    ///
    /// Returns: %TRUE if @addr is a private address, %FALSE otherwise
    #[link_name = "\u{1}_nice_address_is_private"]
    pub fn nice_address_is_private(addr: *const NiceAddress) -> gboolean;
}
extern "C" {
    /// nice_address_is_valid:
    /// @addr: The #NiceAddress to query
    ///
    /// Validate whether the #NiceAddress @addr is a valid IPv4 or IPv6 address
    ///
    /// Returns: %TRUE if @addr is valid, %FALSE otherwise
    #[link_name = "\u{1}_nice_address_is_valid"]
    pub fn nice_address_is_valid(addr: *const NiceAddress) -> gboolean;
}
extern "C" {
    /// nice_address_ip_version:
    /// @addr: The #NiceAddress to query
    ///
    /// Returns the IP version of the address
    ///
    /// Returns: 4 for IPv4, 6 for IPv6 and 0 for undefined address
    #[link_name = "\u{1}_nice_address_ip_version"]
    pub fn nice_address_ip_version(addr: *const NiceAddress) -> ::std::os::raw::c_int;
}
pub const NiceCandidateType_NICE_CANDIDATE_TYPE_HOST: NiceCandidateType = 0;
pub const NiceCandidateType_NICE_CANDIDATE_TYPE_SERVER_REFLEXIVE: NiceCandidateType = 1;
pub const NiceCandidateType_NICE_CANDIDATE_TYPE_PEER_REFLEXIVE: NiceCandidateType = 2;
pub const NiceCandidateType_NICE_CANDIDATE_TYPE_RELAYED: NiceCandidateType = 3;
/// NiceCandidateType:
/// @NICE_CANDIDATE_TYPE_HOST: A host candidate
/// @NICE_CANDIDATE_TYPE_SERVER_REFLEXIVE: A server reflexive candidate
/// @NICE_CANDIDATE_TYPE_PEER_REFLEXIVE: A peer reflexive candidate
/// @NICE_CANDIDATE_TYPE_RELAYED: A relay candidate
///
/// An enum represneting the type of a candidate
pub type NiceCandidateType = u32;
pub const NiceCandidateTransport_NICE_CANDIDATE_TRANSPORT_UDP: NiceCandidateTransport = 0;
pub const NiceCandidateTransport_NICE_CANDIDATE_TRANSPORT_TCP_ACTIVE: NiceCandidateTransport = 1;
pub const NiceCandidateTransport_NICE_CANDIDATE_TRANSPORT_TCP_PASSIVE: NiceCandidateTransport = 2;
pub const NiceCandidateTransport_NICE_CANDIDATE_TRANSPORT_TCP_SO: NiceCandidateTransport = 3;
/// NiceCandidateTransport:
/// @NICE_CANDIDATE_TRANSPORT_UDP: UDP transport
/// @NICE_CANDIDATE_TRANSPORT_TCP_ACTIVE: TCP Active transport
/// @NICE_CANDIDATE_TRANSPORT_TCP_PASSIVE: TCP Passive transport
/// @NICE_CANDIDATE_TRANSPORT_TCP_SO: TCP Simultaneous-Open transport
///
/// An enum representing the type of transport to use
pub type NiceCandidateTransport = u32;
pub const NiceRelayType_NICE_RELAY_TYPE_TURN_UDP: NiceRelayType = 0;
pub const NiceRelayType_NICE_RELAY_TYPE_TURN_TCP: NiceRelayType = 1;
pub const NiceRelayType_NICE_RELAY_TYPE_TURN_TLS: NiceRelayType = 2;
/// NiceRelayType:
/// @NICE_RELAY_TYPE_TURN_UDP: A TURN relay using UDP
/// @NICE_RELAY_TYPE_TURN_TCP: A TURN relay using TCP
/// @NICE_RELAY_TYPE_TURN_TLS: A TURN relay using TLS over TCP
///
/// An enum representing the type of relay to use
pub type NiceRelayType = u32;
pub type NiceCandidate = _NiceCandidate;
pub type TurnServer = _TurnServer;
/// TurnServer:
/// @ref_count: Reference count for the structure.
/// @server: The #NiceAddress of the TURN server
/// @username: The TURN username
/// @password: The TURN password
/// @type: The #NiceRelayType of the server
///
/// A structure to store the TURN relay settings
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _TurnServer {
    pub ref_count: gint,
    pub server: NiceAddress,
    pub username: *mut gchar,
    pub password: *mut gchar,
    pub type_: NiceRelayType,
}
#[test]
fn bindgen_test_layout__TurnServer() {
    assert_eq!(
        ::std::mem::size_of::<_TurnServer>(),
        56usize,
        concat!("Size of: ", stringify!(_TurnServer))
    );
    assert_eq!(
        ::std::mem::align_of::<_TurnServer>(),
        8usize,
        concat!("Alignment of ", stringify!(_TurnServer))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_TurnServer>())).ref_count as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_TurnServer),
            "::",
            stringify!(ref_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_TurnServer>())).server as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_TurnServer),
            "::",
            stringify!(server)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_TurnServer>())).username as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_TurnServer),
            "::",
            stringify!(username)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_TurnServer>())).password as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_TurnServer),
            "::",
            stringify!(password)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_TurnServer>())).type_ as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_TurnServer),
            "::",
            stringify!(type_)
        )
    );
}
/// NiceCandidate:
/// @type: The type of candidate
/// @transport: The transport being used for the candidate
/// @addr: The #NiceAddress of the candidate
/// @base_addr: The #NiceAddress of the base address used by the candidate
/// @priority: The priority of the candidate <emphasis> see note </emphasis>
/// @stream_id: The ID of the stream to which belongs the candidate
/// @component_id: The ID of the component to which belongs the candidate
/// @foundation: The foundation of the candidate
/// @username: The candidate-specific username to use (overrides the one set
/// by nice_agent_set_local_credentials() or nice_agent_set_remote_credentials())
/// @password: The candidate-specific password to use (overrides the one set
/// by nice_agent_set_local_credentials() or nice_agent_set_remote_credentials())
/// @turn: The #TurnServer settings if the candidate is
/// of type %NICE_CANDIDATE_TYPE_RELAYED
/// @sockptr: The underlying socket
///
/// A structure to represent an ICE candidate
/// <note>
/// <para>
/// The @priority is an integer as specified in the ICE draft 19. If you are
/// using the MSN or the GOOGLE compatibility mode (which are based on ICE
/// draft 6, which uses a floating point qvalue as priority), then the @priority
/// value will represent the qvalue multiplied by 1000.
/// </para>
/// </note>
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NiceCandidate {
    pub type_: NiceCandidateType,
    pub transport: NiceCandidateTransport,
    pub addr: NiceAddress,
    pub base_addr: NiceAddress,
    pub priority: guint32,
    pub stream_id: guint,
    pub component_id: guint,
    pub foundation: [gchar; 33usize],
    pub username: *mut gchar,
    pub password: *mut gchar,
    pub turn: *mut TurnServer,
    pub sockptr: gpointer,
}
#[test]
fn bindgen_test_layout__NiceCandidate() {
    assert_eq!(
        ::std::mem::size_of::<_NiceCandidate>(),
        144usize,
        concat!("Size of: ", stringify!(_NiceCandidate))
    );
    assert_eq!(
        ::std::mem::align_of::<_NiceCandidate>(),
        8usize,
        concat!("Alignment of ", stringify!(_NiceCandidate))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NiceCandidate>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NiceCandidate),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NiceCandidate>())).transport as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_NiceCandidate),
            "::",
            stringify!(transport)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NiceCandidate>())).addr as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_NiceCandidate),
            "::",
            stringify!(addr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NiceCandidate>())).base_addr as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(_NiceCandidate),
            "::",
            stringify!(base_addr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NiceCandidate>())).priority as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_NiceCandidate),
            "::",
            stringify!(priority)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NiceCandidate>())).stream_id as *const _ as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(_NiceCandidate),
            "::",
            stringify!(stream_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NiceCandidate>())).component_id as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_NiceCandidate),
            "::",
            stringify!(component_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NiceCandidate>())).foundation as *const _ as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(_NiceCandidate),
            "::",
            stringify!(foundation)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NiceCandidate>())).username as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(_NiceCandidate),
            "::",
            stringify!(username)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NiceCandidate>())).password as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(_NiceCandidate),
            "::",
            stringify!(password)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NiceCandidate>())).turn as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(_NiceCandidate),
            "::",
            stringify!(turn)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NiceCandidate>())).sockptr as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_NiceCandidate),
            "::",
            stringify!(sockptr)
        )
    );
}
extern "C" {
    /// nice_candidate_new:
    /// @type: The #NiceCandidateType of the candidate to create
    ///
    /// Creates a new candidate. Must be freed with nice_candidate_free()
    ///
    /// Returns: A new #NiceCandidate
    #[link_name = "\u{1}_nice_candidate_new"]
    pub fn nice_candidate_new(type_: NiceCandidateType) -> *mut NiceCandidate;
}
extern "C" {
    /// nice_candidate_free:
    /// @candidate: The candidate to free
    ///
    /// Frees a #NiceCandidate
    #[link_name = "\u{1}_nice_candidate_free"]
    pub fn nice_candidate_free(candidate: *mut NiceCandidate);
}
extern "C" {
    /// nice_candidate_copy:
    /// @candidate: The candidate to copy
    ///
    /// Makes a copy of a #NiceCandidate
    ///
    /// Returns: A new #NiceCandidate, a copy of @candidate
    #[link_name = "\u{1}_nice_candidate_copy"]
    pub fn nice_candidate_copy(candidate: *const NiceCandidate) -> *mut NiceCandidate;
}
extern "C" {
    #[link_name = "\u{1}_nice_candidate_get_type"]
    pub fn nice_candidate_get_type() -> GType;
}
extern "C" {
    /// nice_debug_enable:
    /// @with_stun: Also enable STUN debugging messages
    ///
    /// Enables libnice debug output to the terminal. Note that the
    /// `G_MESSAGES_DEBUG` and `NICE_DEBUG` environment variables must be set to the
    /// set of logging domains to print, in order for any output to be printed. Set
    /// them to `all` to print all debugging messages, or any of the following
    /// domains:
    /// - `libnice-stun`
    /// - `libnice-tests`
    /// - `libnice-socket`
    /// - `libnice`
    /// - `libnice-pseudotcp`
    /// - `libnice-pseudotcp-verbose`
    #[link_name = "\u{1}_nice_debug_enable"]
    pub fn nice_debug_enable(with_stun: gboolean);
}
extern "C" {
    /// nice_debug_disable:
    /// @with_stun: Also disable stun debugging messages
    ///
    /// Disables libnice debug output to the terminal
    #[link_name = "\u{1}_nice_debug_disable"]
    pub fn nice_debug_disable(with_stun: gboolean);
}
/// NiceInputMessage:
/// @buffers: (array length=n_buffers): unowned array of #GInputVector buffers to
/// store data in for this message
/// @n_buffers: number of #GInputVectors in @buffers, or -1 to indicate @buffers
/// is %NULL-terminated
/// @from: (allow-none): return location to store the address of the peer who
/// transmitted the message, or %NULL
/// @length: total number of valid bytes contiguously stored in @buffers
///
/// Represents a single message received off the network. For reliable
/// connections, this is essentially just an array of buffers (specifically,
/// @from can be ignored). for non-reliable connections, it represents a single
/// packet as received from the OS.
///
/// @n_buffers may be -1 to indicate that @buffers is terminated by a
/// #GInputVector with a %NULL buffer pointer.
///
/// By providing arrays of #NiceInputMessages to functions like
/// nice_agent_recv_messages(), multiple messages may be received with a single
/// call, which is more efficient than making multiple calls in a loop. In this
/// manner, nice_agent_recv_messages() is analogous to recvmmsg(); and
/// #NiceInputMessage to struct mmsghdr.
///
/// Since: 0.1.5
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NiceInputMessage {
    pub buffers: *mut GInputVector,
    pub n_buffers: gint,
    pub from: *mut NiceAddress,
    pub length: gsize,
}
#[test]
fn bindgen_test_layout_NiceInputMessage() {
    assert_eq!(
        ::std::mem::size_of::<NiceInputMessage>(),
        32usize,
        concat!("Size of: ", stringify!(NiceInputMessage))
    );
    assert_eq!(
        ::std::mem::align_of::<NiceInputMessage>(),
        8usize,
        concat!("Alignment of ", stringify!(NiceInputMessage))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NiceInputMessage>())).buffers as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NiceInputMessage),
            "::",
            stringify!(buffers)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NiceInputMessage>())).n_buffers as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(NiceInputMessage),
            "::",
            stringify!(n_buffers)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NiceInputMessage>())).from as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(NiceInputMessage),
            "::",
            stringify!(from)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NiceInputMessage>())).length as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(NiceInputMessage),
            "::",
            stringify!(length)
        )
    );
}
/// NiceOutputMessage:
/// @buffers: (array length=n_buffers): unowned array of #GOutputVector buffers
/// which contain data to transmit for this message
/// @n_buffers: number of #GOutputVectors in @buffers, or -1 to indicate @buffers
/// is %NULL-terminated
///
/// Represents a single message to transmit on the network. For
/// reliable connections, this is essentially just an array of
/// buffer. for non-reliable connections, it represents a single packet
/// to send to the OS.
///
/// @n_buffers may be -1 to indicate that @buffers is terminated by a
/// #GOutputVector with a %NULL buffer pointer.
///
/// By providing arrays of #NiceOutputMessages to functions like
/// nice_agent_send_messages_nonblocking(), multiple messages may be transmitted
/// with a single call, which is more efficient than making multiple calls in a
/// loop. In this manner, nice_agent_send_messages_nonblocking() is analogous to
/// sendmmsg(); and #NiceOutputMessage to struct mmsghdr.
///
/// Since: 0.1.5
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NiceOutputMessage {
    pub buffers: *mut GOutputVector,
    pub n_buffers: gint,
}
#[test]
fn bindgen_test_layout_NiceOutputMessage() {
    assert_eq!(
        ::std::mem::size_of::<NiceOutputMessage>(),
        16usize,
        concat!("Size of: ", stringify!(NiceOutputMessage))
    );
    assert_eq!(
        ::std::mem::align_of::<NiceOutputMessage>(),
        8usize,
        concat!("Alignment of ", stringify!(NiceOutputMessage))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NiceOutputMessage>())).buffers as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NiceOutputMessage),
            "::",
            stringify!(buffers)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NiceOutputMessage>())).n_buffers as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(NiceOutputMessage),
            "::",
            stringify!(n_buffers)
        )
    );
}
pub type NiceAgentClass = _NiceAgentClass;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NiceAgentClass {
    pub parent_class: GObjectClass,
}
#[test]
fn bindgen_test_layout__NiceAgentClass() {
    assert_eq!(
        ::std::mem::size_of::<_NiceAgentClass>(),
        136usize,
        concat!("Size of: ", stringify!(_NiceAgentClass))
    );
    assert_eq!(
        ::std::mem::align_of::<_NiceAgentClass>(),
        8usize,
        concat!("Alignment of ", stringify!(_NiceAgentClass))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NiceAgentClass>())).parent_class as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NiceAgentClass),
            "::",
            stringify!(parent_class)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_nice_agent_get_type"]
    pub fn nice_agent_get_type() -> GType;
}
pub const NiceComponentState_NICE_COMPONENT_STATE_DISCONNECTED: NiceComponentState = 0;
pub const NiceComponentState_NICE_COMPONENT_STATE_GATHERING: NiceComponentState = 1;
pub const NiceComponentState_NICE_COMPONENT_STATE_CONNECTING: NiceComponentState = 2;
pub const NiceComponentState_NICE_COMPONENT_STATE_CONNECTED: NiceComponentState = 3;
pub const NiceComponentState_NICE_COMPONENT_STATE_READY: NiceComponentState = 4;
pub const NiceComponentState_NICE_COMPONENT_STATE_FAILED: NiceComponentState = 5;
pub const NiceComponentState_NICE_COMPONENT_STATE_LAST: NiceComponentState = 6;
/// NiceComponentState:
/// @NICE_COMPONENT_STATE_DISCONNECTED: No activity scheduled
/// @NICE_COMPONENT_STATE_GATHERING: Gathering local candidates
/// @NICE_COMPONENT_STATE_CONNECTING: Establishing connectivity
/// @NICE_COMPONENT_STATE_CONNECTED: At least one working candidate pair
/// @NICE_COMPONENT_STATE_READY: ICE concluded, candidate pair selection
/// is now final
/// @NICE_COMPONENT_STATE_FAILED: Connectivity checks have been completed,
/// but connectivity was not established
/// @NICE_COMPONENT_STATE_LAST: Dummy state
///
/// An enum representing the state of a component.
/// <para> See also: #NiceAgent::component-state-changed </para>
pub type NiceComponentState = u32;
pub const NiceComponentType_NICE_COMPONENT_TYPE_RTP: NiceComponentType = 1;
pub const NiceComponentType_NICE_COMPONENT_TYPE_RTCP: NiceComponentType = 2;
/// NiceComponentType:
/// @NICE_COMPONENT_TYPE_RTP: RTP Component type
/// @NICE_COMPONENT_TYPE_RTCP: RTCP Component type
///
/// Convenience enum representing the type of a component for use as the
/// component_id for RTP/RTCP usages.
/// <example>
/// <title>Example of use.</title>
/// <programlisting>
/// nice_agent_send (agent, stream_id, NICE_COMPONENT_TYPE_RTP, len, buf);
/// </programlisting>
/// </example>
pub type NiceComponentType = u32;
pub const NiceCompatibility_NICE_COMPATIBILITY_RFC5245: NiceCompatibility = 0;
pub const NiceCompatibility_NICE_COMPATIBILITY_DRAFT19: NiceCompatibility = 0;
pub const NiceCompatibility_NICE_COMPATIBILITY_GOOGLE: NiceCompatibility = 1;
pub const NiceCompatibility_NICE_COMPATIBILITY_MSN: NiceCompatibility = 2;
pub const NiceCompatibility_NICE_COMPATIBILITY_WLM2009: NiceCompatibility = 3;
pub const NiceCompatibility_NICE_COMPATIBILITY_OC2007: NiceCompatibility = 4;
pub const NiceCompatibility_NICE_COMPATIBILITY_OC2007R2: NiceCompatibility = 5;
pub const NiceCompatibility_NICE_COMPATIBILITY_LAST: NiceCompatibility = 5;
/// NiceCompatibility:
/// @NICE_COMPATIBILITY_RFC5245: Use compatibility with the RFC5245 ICE-UDP specs
/// and RFC6544 ICE-TCP specs
/// @NICE_COMPATIBILITY_GOOGLE: Use compatibility for Google Talk specs
/// @NICE_COMPATIBILITY_MSN: Use compatibility for MSN Messenger specs
/// @NICE_COMPATIBILITY_WLM2009: Use compatibility with Windows Live Messenger
/// 2009
/// @NICE_COMPATIBILITY_OC2007: Use compatibility with Microsoft Office Communicator 2007
/// @NICE_COMPATIBILITY_OC2007R2: Use compatibility with Microsoft Office Communicator 2007 R2
/// @NICE_COMPATIBILITY_DRAFT19: Use compatibility for ICE Draft 19 specs
/// @NICE_COMPATIBILITY_LAST: Dummy last compatibility mode
///
/// An enum to specify which compatible specifications the #NiceAgent should use.
/// Use with nice_agent_new()
///
/// <warning>@NICE_COMPATIBILITY_DRAFT19 is deprecated and should not be used
/// in newly-written code. It is kept for compatibility reasons and
/// represents the same compatibility as @NICE_COMPATIBILITY_RFC5245 </warning>
/// <note>
/// <para>
/// If @NICE_COMPATIBILITY_RFC5245 compatibility mode is used for a non-reliable
/// agent, then ICE-UDP will be used with higher priority and ICE-TCP will also
/// be used when the UDP connectivity fails. If it is used with a reliable agent,
/// then ICE-UDP will be used with the TCP-Over-UDP (#PseudoTcpSocket) if ICE-TCP
/// fails and ICE-UDP succeeds.
/// </para>
/// </note>
///
pub type NiceCompatibility = u32;
pub const NiceProxyType_NICE_PROXY_TYPE_NONE: NiceProxyType = 0;
pub const NiceProxyType_NICE_PROXY_TYPE_SOCKS5: NiceProxyType = 1;
pub const NiceProxyType_NICE_PROXY_TYPE_HTTP: NiceProxyType = 2;
pub const NiceProxyType_NICE_PROXY_TYPE_LAST: NiceProxyType = 2;
/// NiceProxyType:
/// @NICE_PROXY_TYPE_NONE: Do not use a proxy
/// @NICE_PROXY_TYPE_SOCKS5: Use a SOCKS5 proxy
/// @NICE_PROXY_TYPE_HTTP: Use an HTTP proxy
/// @NICE_PROXY_TYPE_LAST: Dummy last proxy type
///
/// An enum to specify which proxy type to use for relaying.
/// Note that the proxies will only be used with TCP TURN relaying.
/// <para> See also: #NiceAgent:proxy-type </para>
///
/// Since: 0.0.4
pub type NiceProxyType = u32;
/// NiceAgentRecvFunc:
/// @agent: The #NiceAgent Object
/// @stream_id: The id of the stream
/// @component_id: The id of the component of the stream
/// which received the data
/// @len: The length of the data
/// @buf: The buffer containing the data received
/// @user_data: The user data set in nice_agent_attach_recv()
///
/// Callback function when data is received on a component
///
pub type NiceAgentRecvFunc = ::std::option::Option<
    unsafe extern "C" fn(
        agent: *mut NiceAgent,
        stream_id: guint,
        component_id: guint,
        len: guint,
        buf: *mut gchar,
        user_data: gpointer,
    ),
>;
extern "C" {
    /// nice_agent_new:
    /// @ctx: The Glib Mainloop Context to use for timers
    /// @compat: The compatibility mode of the agent
    ///
    /// Create a new #NiceAgent.
    /// The returned object must be freed with g_object_unref()
    ///
    /// Returns: The new agent GObject
    #[link_name = "\u{1}_nice_agent_new"]
    pub fn nice_agent_new(ctx: *mut GMainContext, compat: NiceCompatibility) -> *mut NiceAgent;
}
extern "C" {
    /// nice_agent_new_reliable:
    /// @ctx: The Glib Mainloop Context to use for timers
    /// @compat: The compatibility mode of the agent
    ///
    /// Create a new #NiceAgent in reliable mode. If the connectivity is established
    /// through ICE-UDP, then a #PseudoTcpSocket will be transparently used to
    /// ensure reliability of the messages.
    /// The returned object must be freed with g_object_unref()
    /// <para> See also: #NiceAgent::reliable-transport-writable </para>
    ///
    /// Since: 0.0.11
    ///
    /// Returns: The new agent GObject
    #[link_name = "\u{1}_nice_agent_new_reliable"]
    pub fn nice_agent_new_reliable(
        ctx: *mut GMainContext,
        compat: NiceCompatibility,
    ) -> *mut NiceAgent;
}
extern "C" {
    /// nice_agent_add_local_address:
    /// @agent: The #NiceAgent Object
    /// @addr: The address to listen to
    /// If the port is 0, then a random port will be chosen by the system
    ///
    /// Add a local address from which to derive local host candidates for
    /// candidate gathering.
    /// <para>
    /// Since 0.0.5, if this method is not called, libnice will automatically
    /// discover the local addresses available
    /// </para>
    ///
    /// See also: nice_agent_gather_candidates()
    /// Returns: %TRUE on success, %FALSE on fatal (memory allocation) errors
    #[link_name = "\u{1}_nice_agent_add_local_address"]
    pub fn nice_agent_add_local_address(agent: *mut NiceAgent, addr: *mut NiceAddress) -> gboolean;
}
extern "C" {
    /// nice_agent_add_stream:
    /// @agent: The #NiceAgent Object
    /// @n_components: The number of components to add to the stream
    ///
    /// Adds a data stream to @agent containing @n_components components. The
    /// returned stream ID is guaranteed to be positive on success.
    ///
    /// Returns: The ID of the new stream, 0 on failure
    #[link_name = "\u{1}_nice_agent_add_stream"]
    pub fn nice_agent_add_stream(agent: *mut NiceAgent, n_components: guint) -> guint;
}
extern "C" {
    /// nice_agent_remove_stream:
    /// @agent: The #NiceAgent Object
    /// @stream_id: The ID of the stream to remove
    ///
    /// Remove and free a previously created data stream from @agent. If any I/O
    /// streams have been created using nice_agent_get_io_stream(), they should be
    /// closed completely using g_io_stream_close() before this is called, or they
    /// will get broken pipe errors.
    ///
    #[link_name = "\u{1}_nice_agent_remove_stream"]
    pub fn nice_agent_remove_stream(agent: *mut NiceAgent, stream_id: guint);
}
extern "C" {
    /// nice_agent_set_port_range:
    /// @agent: The #NiceAgent Object
    /// @stream_id: The ID of the stream
    /// @component_id: The ID of the component
    /// @min_port: The minimum port to use
    /// @max_port: The maximum port to use
    ///
    /// Sets a preferred port range for allocating host candidates.
    /// <para>
    /// If a local host candidate cannot be created on that port
    /// range, then the nice_agent_gather_candidates() call will fail.
    /// </para>
    /// <para>
    /// This MUST be called before nice_agent_gather_candidates()
    /// </para>
    ///
    #[link_name = "\u{1}_nice_agent_set_port_range"]
    pub fn nice_agent_set_port_range(
        agent: *mut NiceAgent,
        stream_id: guint,
        component_id: guint,
        min_port: guint,
        max_port: guint,
    );
}
extern "C" {
    /// nice_agent_set_relay_info:
    /// @agent: The #NiceAgent Object
    /// @stream_id: The ID of the stream
    /// @component_id: The ID of the component
    /// @server_ip: The IP address of the TURN server
    /// @server_port: The port of the TURN server
    /// @username: The TURN username to use for the allocate
    /// @password: The TURN password to use for the allocate
    /// @type: The type of relay to use
    ///
    /// Sets the settings for using a relay server during the candidate discovery.
    /// This may be called multiple times to add multiple relay servers to the
    /// discovery process; one TCP and one UDP, for example.
    ///
    /// Returns: %TRUE if the TURN settings were accepted.
    /// %FALSE if the address was invalid.
    #[link_name = "\u{1}_nice_agent_set_relay_info"]
    pub fn nice_agent_set_relay_info(
        agent: *mut NiceAgent,
        stream_id: guint,
        component_id: guint,
        server_ip: *const gchar,
        server_port: guint,
        username: *const gchar,
        password: *const gchar,
        type_: NiceRelayType,
    ) -> gboolean;
}
extern "C" {
    /// nice_agent_gather_candidates:
    /// @agent: The #NiceAgent object
    /// @stream_id: The ID of the stream to start
    ///
    /// Allocate and start listening on local candidate ports and start the remote
    /// candidate gathering process.
    /// Once done, #NiceAgent::candidate-gathering-done is called for the stream.
    /// As soon as this function is called, #NiceAgent::new-candidate signals may be
    /// emitted, even before this function returns.
    ///
    /// nice_agent_get_local_candidates() will only return non-empty results after
    /// calling this function.
    ///
    /// <para>See also: nice_agent_add_local_address()</para>
    /// <para>See also: nice_agent_set_port_range()</para>
    ///
    /// Returns: %FALSE if the stream ID is invalid or if a host candidate couldn't
    /// be allocated on the requested interfaces/ports; %TRUE otherwise
    ///
    /// <note>
    /// <para>
    /// Local addresses can be previously set with nice_agent_add_local_address()
    /// </para>
    /// <para>
    /// Since 0.0.5, If no local address was previously added, then the nice agent
    /// will automatically detect the local address using
    /// nice_interfaces_get_local_ips()
    /// </para>
    /// </note>
    #[link_name = "\u{1}_nice_agent_gather_candidates"]
    pub fn nice_agent_gather_candidates(agent: *mut NiceAgent, stream_id: guint) -> gboolean;
}
extern "C" {
    /// nice_agent_set_remote_credentials:
    /// @agent: The #NiceAgent Object
    /// @stream_id: The ID of the stream
    /// @ufrag: nul-terminated string containing an ICE username fragment
    /// (length must be between 22 and 256 chars)
    /// @pwd: nul-terminated string containing an ICE password
    /// (length must be between 4 and 256 chars)
    ///
    /// Sets the remote credentials for stream @stream_id.
    ///
    /// <note>
    /// <para>
    /// Stream credentials do not override per-candidate credentials if set
    /// </para>
    /// <para>
    /// Due to the native of peer-reflexive candidates, any agent using a per-stream
    /// credentials (RFC5245, WLM2009, OC2007R2 and DRAFT19) instead of
    /// per-candidate credentials (GOOGLE, MSN, OC2007), must
    /// use the nice_agent_set_remote_credentials() API instead of setting the
    /// username and password on the candidates.
    /// </para>
    /// </note>
    ///
    /// Returns: %TRUE on success, %FALSE on error.
    #[link_name = "\u{1}_nice_agent_set_remote_credentials"]
    pub fn nice_agent_set_remote_credentials(
        agent: *mut NiceAgent,
        stream_id: guint,
        ufrag: *const gchar,
        pwd: *const gchar,
    ) -> gboolean;
}
extern "C" {
    /// nice_agent_set_local_credentials:
    /// @agent: The #NiceAgent Object
    /// @stream_id: The ID of the stream
    /// @ufrag: nul-terminated string containing an ICE username fragment
    /// (length must be between 22 and 256 chars)
    /// @pwd: nul-terminated string containing an ICE password
    /// (length must be between 4 and 256 chars)
    ///
    /// Sets the local credentials for stream @stream_id.
    ///
    /// <note>
    /// <para>
    /// This is only effective before ICE negotiation has started.
    /// </para>
    /// </note>
    ///
    /// Since 0.1.11
    /// Returns: %TRUE on success, %FALSE on error.
    #[link_name = "\u{1}_nice_agent_set_local_credentials"]
    pub fn nice_agent_set_local_credentials(
        agent: *mut NiceAgent,
        stream_id: guint,
        ufrag: *const gchar,
        pwd: *const gchar,
    ) -> gboolean;
}
extern "C" {
    /// nice_agent_get_local_credentials:
    /// @agent: The #NiceAgent Object
    /// @stream_id: The ID of the stream
    /// @ufrag: (out callee-allocates): return location for a nul-terminated string
    /// containing an ICE username fragment; must be freed with g_free()
    /// @pwd: (out callee-allocates): return location for a nul-terminated string
    /// containing an ICE password; must be freed with g_free()
    ///
    /// Gets the local credentials for stream @stream_id. This may be called any time
    /// after creating a stream using nice_agent_add_stream().
    ///
    /// An error will be returned if this is called for a non-existent stream, or if
    /// either of @ufrag or @pwd are %NULL.
    ///
    /// Returns: %TRUE on success, %FALSE on error.
    #[link_name = "\u{1}_nice_agent_get_local_credentials"]
    pub fn nice_agent_get_local_credentials(
        agent: *mut NiceAgent,
        stream_id: guint,
        ufrag: *mut *mut gchar,
        pwd: *mut *mut gchar,
    ) -> gboolean;
}
extern "C" {
    /// nice_agent_set_remote_candidates:
    /// @agent: The #NiceAgent Object
    /// @stream_id: The ID of the stream the candidates are for
    /// @component_id: The ID of the component the candidates are for
    /// @candidates: (element-type NiceCandidate) (transfer none): a #GSList of
    /// #NiceCandidate items describing each candidate to add
    ///
    /// Sets, adds or updates the remote candidates for a component of a stream.
    ///
    /// <note>
    /// <para>
    /// NICE_AGENT_MAX_REMOTE_CANDIDATES is the absolute maximum limit
    /// for remote candidates.
    /// </para>
    /// <para>
    /// You must first call nice_agent_gather_candidates() and wait for the
    /// #NiceAgent::candidate-gathering-done signale before
    /// calling nice_agent_set_remote_candidates()
    /// </para>
    /// <para>
    /// Since 0.1.3, there is no need to wait for the candidate-gathering-done signal.
    /// Remote candidates can be set even while gathering local candidates.
    /// Newly discovered local candidates will automatically be paired with
    /// existing remote candidates.
    /// </para>
    /// </note>
    ///
    /// Returns: The number of candidates added, negative on errors (memory
    /// allocation error or invalid component)
    #[link_name = "\u{1}_nice_agent_set_remote_candidates"]
    pub fn nice_agent_set_remote_candidates(
        agent: *mut NiceAgent,
        stream_id: guint,
        component_id: guint,
        candidates: *const GSList,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// nice_agent_send:
    /// @agent: The #NiceAgent Object
    /// @stream_id: The ID of the stream to send to
    /// @component_id: The ID of the component to send to
    /// @len: The length of the buffer to send
    /// @buf: The buffer of data to send
    ///
    /// Sends a data payload over a stream's component.
    ///
    /// <note>
    /// <para>
    /// Component state MUST be NICE_COMPONENT_STATE_READY, or as a special case,
    /// in any state if component was in READY state before and was then restarted
    /// </para>
    /// <para>
    /// In reliable mode, the -1 error value means either that you are not yet
    /// connected or that the send buffer is full (equivalent to EWOULDBLOCK).
    /// In both cases, you simply need to wait for the
    /// #NiceAgent::reliable-transport-writable signal to be fired before resending
    /// the data.
    /// </para>
    /// <para>
    /// In non-reliable mode, it will virtually never happen with UDP sockets, but
    /// it might happen if the active candidate is a TURN-TCP connection that got
    /// disconnected.
    /// </para>
    /// <para>
    /// In both reliable and non-reliable mode, a -1 error code could also mean that
    /// the stream_id and/or component_id are invalid.
    /// </para>
    /// </note>
    ///
    /// Returns: The number of bytes sent, or negative error code
    #[link_name = "\u{1}_nice_agent_send"]
    pub fn nice_agent_send(
        agent: *mut NiceAgent,
        stream_id: guint,
        component_id: guint,
        len: guint,
        buf: *const gchar,
    ) -> gint;
}
extern "C" {
    /// nice_agent_send_messages_nonblocking:
    /// @agent: a #NiceAgent
    /// @stream_id: the ID of the stream to send to
    /// @component_id: the ID of the component to send to
    /// @messages: (array length=n_messages): array of messages to send, of at least
    /// @n_messages entries in length
    /// @n_messages: number of entries in @messages
    /// @cancellable: (allow-none): a #GCancellable to cancel the operation from
    /// another thread, or %NULL
    /// @error: (allow-none): return location for a #GError, or %NULL
    ///
    /// Sends multiple messages on the socket identified by the given
    /// stream/component pair. Transmission is non-blocking, so a
    /// %G_IO_ERROR_WOULD_BLOCK error may be returned if the send buffer is full.
    ///
    /// As with nice_agent_send(), the given component must be in
    /// %NICE_COMPONENT_STATE_READY or, as a special case, in any state if it was
    /// previously ready and was then restarted.
    ///
    /// On success, the number of messages written to the socket will be returned,
    /// which may be less than @n_messages if transmission would have blocked
    /// part-way through. Zero will be returned if @n_messages is zero, or if
    /// transmission would have blocked on the first message.
    ///
    /// In reliable mode, it is instead recommended to use
    /// nice_agent_send().  The return value can be less than @n_messages
    /// or 0 even if it is still possible to send a partial message. In
    /// this case, "nice-agent-writable" will never be triggered, so the
    /// application would have to use nice_agent_sent() to fill the buffer or have
    /// to retry sending at a later point.
    ///
    /// On failure, -1 will be returned and @error will be set. If the #NiceAgent is
    /// reliable and the socket is not yet connected, %G_IO_ERROR_BROKEN_PIPE will be
    /// returned; if the write buffer is full, %G_IO_ERROR_WOULD_BLOCK will be
    /// returned. In both cases, wait for the #NiceAgent::reliable-transport-writable
    /// signal before trying again. If the given @stream_id or @component_id are
    /// invalid or not yet connected, %G_IO_ERROR_BROKEN_PIPE will be returned.
    /// %G_IO_ERROR_FAILED will be returned for other errors.
    ///
    /// Returns: the number of messages sent (may be zero), or -1 on error
    ///
    /// Since: 0.1.5
    #[link_name = "\u{1}_nice_agent_send_messages_nonblocking"]
    pub fn nice_agent_send_messages_nonblocking(
        agent: *mut NiceAgent,
        stream_id: guint,
        component_id: guint,
        messages: *const NiceOutputMessage,
        n_messages: guint,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gint;
}
extern "C" {
    /// nice_agent_get_local_candidates:
    /// @agent: The #NiceAgent Object
    /// @stream_id: The ID of the stream
    /// @component_id: The ID of the component
    ///
    /// Retrieve from the agent the list of all local candidates
    /// for a stream's component
    ///
    /// <note>
    /// <para>
    /// The caller owns the returned GSList as well as the candidates contained
    /// within it.
    /// To get full results, the client should wait for the
    /// #NiceAgent::candidate-gathering-done signal.
    /// </para>
    /// </note>
    ///
    /// Returns: (element-type NiceCandidate) (transfer full): a #GSList of
    /// #NiceCandidate objects representing the local candidates of @agent
    #[link_name = "\u{1}_nice_agent_get_local_candidates"]
    pub fn nice_agent_get_local_candidates(
        agent: *mut NiceAgent,
        stream_id: guint,
        component_id: guint,
    ) -> *mut GSList;
}
extern "C" {
    /// nice_agent_get_remote_candidates:
    /// @agent: The #NiceAgent Object
    /// @stream_id: The ID of the stream
    /// @component_id: The ID of the component
    ///
    /// Get a list of the remote candidates set on a stream's component
    ///
    /// <note>
    /// <para>
    /// The caller owns the returned GSList as well as the candidates contained
    /// within it.
    /// </para>
    /// <para>
    /// The list of remote candidates can change during processing.
    /// The client should register for the #NiceAgent::new-remote-candidate signal
    /// to get notified of new remote candidates.
    /// </para>
    /// </note>
    ///
    /// Returns: (element-type NiceCandidate) (transfer full): a #GSList of
    /// #NiceCandidates objects representing the remote candidates set on the @agent
    #[link_name = "\u{1}_nice_agent_get_remote_candidates"]
    pub fn nice_agent_get_remote_candidates(
        agent: *mut NiceAgent,
        stream_id: guint,
        component_id: guint,
    ) -> *mut GSList;
}
extern "C" {
    /// nice_agent_restart:
    /// @agent: The #NiceAgent Object
    ///
    /// Restarts the session as defined in ICE draft 19. This function
    /// needs to be called both when initiating (ICE spec section 9.1.1.1.
    /// "ICE Restarts"), as well as when reacting (spec section 9.2.1.1.
    /// "Detecting ICE Restart") to a restart.
    ///
    /// Returns: %TRUE on success %FALSE on error
    #[link_name = "\u{1}_nice_agent_restart"]
    pub fn nice_agent_restart(agent: *mut NiceAgent) -> gboolean;
}
extern "C" {
    /// nice_agent_restart_stream:
    /// @agent: The #NiceAgent Object
    /// @stream_id: The ID of the stream
    ///
    /// Restarts a single stream as defined in RFC 5245. This function
    /// needs to be called both when initiating (ICE spec section 9.1.1.1.
    /// "ICE Restarts"), as well as when reacting (spec section 9.2.1.1.
    /// "Detecting ICE Restart") to a restart.
    ///
    /// Unlike nice_agent_restart(), this applies to a single stream. It also
    /// does not generate a new tie breaker.
    ///
    /// Returns: %TRUE on success %FALSE on error
    ///
    /// Since: 0.1.6
    #[link_name = "\u{1}_nice_agent_restart_stream"]
    pub fn nice_agent_restart_stream(agent: *mut NiceAgent, stream_id: guint) -> gboolean;
}
extern "C" {
    /// nice_agent_attach_recv: (skip)
    /// @agent: The #NiceAgent Object
    /// @stream_id: The ID of stream
    /// @component_id: The ID of the component
    /// @ctx: The Glib Mainloop Context to use for listening on the component
    /// @func: The callback function to be called when data is received on
    /// the stream's component (will not be called for STUN messages that
    /// should be handled by #NiceAgent itself)
    /// @data: user data associated with the callback
    ///
    /// Attaches the stream's component's sockets to the Glib Mainloop Context in
    /// order to be notified whenever data becomes available for a component,
    /// and to enable #NiceAgent to receive STUN messages (during the
    /// establishment of ICE connectivity).
    ///
    /// This must not be used in combination with nice_agent_recv_messages() (or
    /// #NiceIOStream or #NiceInputStream) on the same stream/component pair.
    ///
    /// Calling nice_agent_attach_recv() with a %NULL @func will detach any existing
    /// callback and cause reception to be paused for the given stream/component
    /// pair. You must iterate the previously specified #GMainContext sufficiently to
    /// ensure all pending I/O callbacks have been received before calling this
    /// function to unset @func, otherwise data loss of received packets may occur.
    ///
    /// Returns: %TRUE on success, %FALSE if the stream or component IDs are invalid.
    #[link_name = "\u{1}_nice_agent_attach_recv"]
    pub fn nice_agent_attach_recv(
        agent: *mut NiceAgent,
        stream_id: guint,
        component_id: guint,
        ctx: *mut GMainContext,
        func: NiceAgentRecvFunc,
        data: gpointer,
    ) -> gboolean;
}
extern "C" {
    /// nice_agent_recv:
    /// @agent: a #NiceAgent
    /// @stream_id: the ID of the stream to receive on
    /// @component_id: the ID of the component to receive on
    /// @buf: (array length=buf_len) (out caller-allocates): caller-allocated buffer
    /// to write the received data into, of length at least @buf_len
    /// @buf_len: length of @buf
    /// @cancellable: (allow-none): a #GCancellable to allow the operation to be
    /// cancelled from another thread, or %NULL
    /// @error: (allow-none): return location for a #GError, or %NULL
    ///
    /// A single-message version of nice_agent_recv_messages().
    ///
    /// Returns: the number of bytes written to @buf on success (guaranteed to be
    /// greater than 0 unless @buf_len is 0), 0 if in reliable mode and the remote
    /// peer closed the stream, or -1 on error
    ///
    /// Since: 0.1.5
    #[link_name = "\u{1}_nice_agent_recv"]
    pub fn nice_agent_recv(
        agent: *mut NiceAgent,
        stream_id: guint,
        component_id: guint,
        buf: *mut guint8,
        buf_len: gsize,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gssize;
}
extern "C" {
    /// nice_agent_recv_messages:
    /// @agent: a #NiceAgent
    /// @stream_id: the ID of the stream to receive on
    /// @component_id: the ID of the component to receive on
    /// @messages: (array length=n_messages) (out caller-allocates): caller-allocated
    /// array of #NiceInputMessages to write the received messages into, of length at
    /// least @n_messages
    /// @n_messages: number of entries in @messages
    /// @cancellable: (allow-none): a #GCancellable to allow the operation to be
    /// cancelled from another thread, or %NULL
    /// @error: (allow-none): return location for a #GError, or %NULL
    ///
    /// Block on receiving data from the given stream/component combination on
    /// @agent, returning only once exactly @n_messages messages have been received
    /// and written into @messages, the stream is closed by the other end or by
    /// calling nice_agent_remove_stream(), or @cancellable is cancelled.
    ///
    /// Any STUN packets received will not be added to @messages; instead,
    /// they'll be passed for processing to #NiceAgent itself. Since #NiceAgent
    /// does not poll for messages on its own, it's therefore essential to keep
    /// calling this function for ICE connection establishment to work.
    ///
    /// In the non-error case, in reliable mode, this will block until all buffers in
    /// all @n_messages have been filled with received data (i.e. @messages is
    /// treated as a large, flat array of buffers). In non-reliable mode, it will
    /// block until @n_messages messages have been received, each of which does not
    /// have to fill all the buffers in its #NiceInputMessage. In the non-reliable
    /// case, each #NiceInputMessage must have enough buffers to contain an entire
    /// message (65536 bytes), or any excess data may be silently dropped.
    ///
    /// For each received message, #NiceInputMessage::length will be set to the
    /// number of valid bytes stored in the message’s buffers. The bytes are stored
    /// sequentially in the buffers; there are no gaps apart from at the end of the
    /// buffer array (in non-reliable mode). If non-%NULL on input,
    /// #NiceInputMessage::from will have the address of the sending peer stored in
    /// it. The base addresses, sizes, and number of buffers in each message will not
    /// be modified in any case.
    ///
    /// This must not be used in combination with nice_agent_attach_recv() on the
    /// same stream/component pair.
    ///
    /// If the stream/component pair doesn’t exist, or if a suitable candidate socket
    /// hasn’t yet been selected for it, a %G_IO_ERROR_BROKEN_PIPE error will be
    /// returned. A %G_IO_ERROR_CANCELLED error will be returned if the operation was
    /// cancelled. %G_IO_ERROR_FAILED will be returned for other errors.
    ///
    /// Returns: the number of valid messages written to @messages on success
    /// (guaranteed to be greater than 0 unless @n_messages is 0), 0 if the remote
    /// peer closed the stream, or -1 on error
    ///
    /// Since: 0.1.5
    #[link_name = "\u{1}_nice_agent_recv_messages"]
    pub fn nice_agent_recv_messages(
        agent: *mut NiceAgent,
        stream_id: guint,
        component_id: guint,
        messages: *mut NiceInputMessage,
        n_messages: guint,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gint;
}
extern "C" {
    /// nice_agent_recv_nonblocking:
    /// @agent: a #NiceAgent
    /// @stream_id: the ID of the stream to receive on
    /// @component_id: the ID of the component to receive on
    /// @buf: (array length=buf_len) (out caller-allocates): caller-allocated buffer
    /// to write the received data into, of length at least @buf_len
    /// @buf_len: length of @buf
    /// @cancellable: (allow-none): a #GCancellable to allow the operation to be
    /// cancelled from another thread, or %NULL
    /// @error: (allow-none): return location for a #GError, or %NULL
    ///
    /// A single-message version of nice_agent_recv_messages_nonblocking().
    ///
    /// Returns: the number of bytes received into @buf on success (guaranteed to be
    /// greater than 0 unless @buf_len is 0), 0 if in reliable mode and the remote
    /// peer closed the stream, or -1 on error
    ///
    /// Since: 0.1.5
    #[link_name = "\u{1}_nice_agent_recv_nonblocking"]
    pub fn nice_agent_recv_nonblocking(
        agent: *mut NiceAgent,
        stream_id: guint,
        component_id: guint,
        buf: *mut guint8,
        buf_len: gsize,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gssize;
}
extern "C" {
    /// nice_agent_recv_messages_nonblocking:
    /// @agent: a #NiceAgent
    /// @stream_id: the ID of the stream to receive on
    /// @component_id: the ID of the component to receive on
    /// @messages: (array length=n_messages) (out caller-allocates): caller-allocated
    /// array of #NiceInputMessages to write the received messages into, of length at
    /// least @n_messages
    /// @n_messages: number of entries in @messages
    /// @cancellable: (allow-none): a #GCancellable to allow the operation to be
    /// cancelled from another thread, or %NULL
    /// @error: (allow-none): return location for a #GError, or %NULL
    ///
    /// Try to receive data from the given stream/component combination on @agent,
    /// without blocking. If receiving data would block, -1 is returned and
    /// %G_IO_ERROR_WOULD_BLOCK is set in @error. If any other error occurs, -1 is
    /// returned and @error is set accordingly. Otherwise, 0 is returned if (and only
    /// if) @n_messages is 0. In all other cases, the number of valid messages stored
    /// in @messages is returned, and will be greater than 0.
    ///
    /// This function behaves similarly to nice_agent_recv_messages(), except that it
    /// will not block on filling (in reliable mode) or receiving (in non-reliable
    /// mode) exactly @n_messages messages. In reliable mode, it will receive bytes
    /// into @messages until it would block; in non-reliable mode, it will receive
    /// messages until it would block.
    ///
    /// Any STUN packets received will not be added to @messages; instead,
    /// they'll be passed for processing to #NiceAgent itself. Since #NiceAgent
    /// does not poll for messages on its own, it's therefore essential to keep
    /// calling this function for ICE connection establishment to work.
    ///
    /// As this function is non-blocking, @cancellable is included only for parity
    /// with nice_agent_recv_messages(). If @cancellable is cancelled before this
    /// function is called, a %G_IO_ERROR_CANCELLED error will be returned
    /// immediately.
    ///
    /// This must not be used in combination with nice_agent_attach_recv() on the
    /// same stream/component pair.
    ///
    /// Returns: the number of valid messages written to @messages on success
    /// (guaranteed to be greater than 0 unless @n_messages is 0), 0 if in reliable
    /// mode and the remote peer closed the stream, or -1 on error
    ///
    /// Since: 0.1.5
    #[link_name = "\u{1}_nice_agent_recv_messages_nonblocking"]
    pub fn nice_agent_recv_messages_nonblocking(
        agent: *mut NiceAgent,
        stream_id: guint,
        component_id: guint,
        messages: *mut NiceInputMessage,
        n_messages: guint,
        cancellable: *mut GCancellable,
        error: *mut *mut GError,
    ) -> gint;
}
extern "C" {
    /// nice_agent_set_selected_pair:
    /// @agent: The #NiceAgent Object
    /// @stream_id: The ID of the stream
    /// @component_id: The ID of the component
    /// @lfoundation: The local foundation of the candidate to use
    /// @rfoundation: The remote foundation of the candidate to use
    ///
    /// Sets the selected candidate pair for media transmission
    /// for a given stream's component. Calling this function will
    /// disable all further ICE processing (connection check,
    /// state machine updates, etc). Note that keepalives will
    /// continue to be sent.
    ///
    /// Returns: %TRUE on success, %FALSE if the candidate pair cannot be found
    #[link_name = "\u{1}_nice_agent_set_selected_pair"]
    pub fn nice_agent_set_selected_pair(
        agent: *mut NiceAgent,
        stream_id: guint,
        component_id: guint,
        lfoundation: *const gchar,
        rfoundation: *const gchar,
    ) -> gboolean;
}
extern "C" {
    /// nice_agent_get_selected_pair:
    /// @agent: The #NiceAgent Object
    /// @stream_id: The ID of the stream
    /// @component_id: The ID of the component
    /// @local: The local selected candidate
    /// @remote: The remote selected candidate
    ///
    /// Retreive the selected candidate pair for media transmission
    /// for a given stream's component.
    ///
    /// Returns: %TRUE on success, %FALSE if there is no selected candidate pair
    #[link_name = "\u{1}_nice_agent_get_selected_pair"]
    pub fn nice_agent_get_selected_pair(
        agent: *mut NiceAgent,
        stream_id: guint,
        component_id: guint,
        local: *mut *mut NiceCandidate,
        remote: *mut *mut NiceCandidate,
    ) -> gboolean;
}
extern "C" {
    /// nice_agent_get_selected_socket:
    /// @agent: The #NiceAgent Object
    /// @stream_id: The ID of the stream
    /// @component_id: The ID of the component
    ///
    /// Retreive the local socket associated with the selected candidate pair
    /// for media transmission for a given stream's component.
    ///
    /// This is useful for adding ICE support to legacy applications that already
    /// have a protocol that maintains a connection. If the socket is duplicated
    /// before unrefing the agent, the application can take over and continue to use
    /// it. New applications are encouraged to use the built in libnice stream
    /// handling instead and let libnice handle the connection maintenance.
    ///
    /// Users of this method are encouraged to not use a TURN relay or any kind
    /// of proxy, as in this case, the socket will not be available to the
    /// application because the packets are encapsulated.
    ///
    /// Returns: (transfer full) (nullable): pointer to the #GSocket, or %NULL if
    /// there is no selected candidate or if the selected candidate is a relayed
    /// candidate.
    ///
    /// Since: 0.1.5
    #[link_name = "\u{1}_nice_agent_get_selected_socket"]
    pub fn nice_agent_get_selected_socket(
        agent: *mut NiceAgent,
        stream_id: guint,
        component_id: guint,
    ) -> *mut GSocket;
}
extern "C" {
    /// nice_agent_set_selected_remote_candidate:
    /// @agent: The #NiceAgent Object
    /// @stream_id: The ID of the stream
    /// @component_id: The ID of the component
    /// @candidate: The #NiceCandidate to select
    ///
    /// Sets the selected remote candidate for media transmission
    /// for a given stream's component. This is used to force the selection of
    /// a specific remote candidate even when connectivity checks are failing
    /// (e.g. non-ICE compatible candidates).
    /// Calling this function will disable all further ICE processing
    /// (connection check, state machine updates, etc). Note that keepalives will
    /// continue to be sent.
    ///
    /// Returns: %TRUE on success, %FALSE on failure
    #[link_name = "\u{1}_nice_agent_set_selected_remote_candidate"]
    pub fn nice_agent_set_selected_remote_candidate(
        agent: *mut NiceAgent,
        stream_id: guint,
        component_id: guint,
        candidate: *mut NiceCandidate,
    ) -> gboolean;
}
extern "C" {
    /// nice_agent_set_stream_tos:
    /// @agent: The #NiceAgent Object
    /// @stream_id: The ID of the stream
    /// @tos: The ToS to set
    ///
    /// Sets the IP_TOS and/or IPV6_TCLASS field on the stream's sockets' options
    ///
    /// Since: 0.0.9
    #[link_name = "\u{1}_nice_agent_set_stream_tos"]
    pub fn nice_agent_set_stream_tos(agent: *mut NiceAgent, stream_id: guint, tos: gint);
}
extern "C" {
    /// nice_agent_set_software:
    /// @agent: The #NiceAgent Object
    /// @software: The value of the SOFTWARE attribute to add.
    ///
    /// This function will set the value of the SOFTWARE attribute to be added to
    /// STUN requests, responses and error responses sent during connectivity checks.
    /// <para>
    /// The SOFTWARE attribute will only be added in the #NICE_COMPATIBILITY_RFC5245
    /// and #NICE_COMPATIBILITY_WLM2009 compatibility modes.
    ///
    /// </para>
    /// <note>
    /// <para>
    /// The @software argument will be appended with the libnice version before
    /// being sent.
    /// </para>
    /// <para>
    /// The @software argument must be in UTF-8 encoding and only the first
    /// 128 characters will be sent.
    /// </para>
    /// </note>
    ///
    /// Since: 0.0.10
    ///
    #[link_name = "\u{1}_nice_agent_set_software"]
    pub fn nice_agent_set_software(agent: *mut NiceAgent, software: *const gchar);
}
extern "C" {
    /// nice_agent_set_stream_name:
    /// @agent: The #NiceAgent Object
    /// @stream_id: The ID of the stream to change
    /// @name: The new name of the stream or %NULL
    ///
    /// This function will assign a media type to a stream. The only values
    /// that can be used to produce a valid SDP are: "audio", "video",
    /// "text", "application", "image" and "message".
    ///
    /// This is only useful when parsing and generating an SDP of the
    /// candidates.
    ///
    /// <para>See also: nice_agent_generate_local_sdp()</para>
    /// <para>See also: nice_agent_parse_remote_sdp()</para>
    /// <para>See also: nice_agent_get_stream_name()</para>
    ///
    /// Returns: %TRUE if the name has been set. %FALSE in case of error
    /// (invalid stream or duplicate name).
    /// Since: 0.1.4
    #[link_name = "\u{1}_nice_agent_set_stream_name"]
    pub fn nice_agent_set_stream_name(
        agent: *mut NiceAgent,
        stream_id: guint,
        name: *const gchar,
    ) -> gboolean;
}
extern "C" {
    /// nice_agent_get_stream_name:
    /// @agent: The #NiceAgent Object
    /// @stream_id: The ID of the stream to change
    ///
    /// This function will return the name assigned to a stream.
    ///
    /// <para>See also: nice_agent_set_stream_name()</para>
    ///
    /// Returns: The name of the stream. The name is only valid while the stream
    /// exists or until it changes through a call to nice_agent_set_stream_name().
    ///
    ///
    /// Since: 0.1.4
    #[link_name = "\u{1}_nice_agent_get_stream_name"]
    pub fn nice_agent_get_stream_name(agent: *mut NiceAgent, stream_id: guint) -> *const gchar;
}
extern "C" {
    /// nice_agent_get_default_local_candidate:
    /// @agent: The #NiceAgent Object
    /// @stream_id: The ID of the stream
    /// @component_id: The ID of the component
    ///
    /// This helper function will return the recommended default candidate to be
    /// used for non-ICE compatible clients. This will usually be the candidate
    /// with the lowest priority, since it will be the longest path but the one with
    /// the most chances of success.
    /// <note>
    /// <para>
    /// This function is only useful in order to manually generate the
    /// local SDP
    /// </para>
    /// </note>
    ///
    /// Returns: The candidate to be used as the default candidate, or %NULL in case
    /// of error. Must be freed with nice_candidate_free() once done.
    ///
    #[link_name = "\u{1}_nice_agent_get_default_local_candidate"]
    pub fn nice_agent_get_default_local_candidate(
        agent: *mut NiceAgent,
        stream_id: guint,
        component_id: guint,
    ) -> *mut NiceCandidate;
}
extern "C" {
    /// nice_agent_generate_local_sdp:
    /// @agent: The #NiceAgent Object
    ///
    /// Generate an SDP string containing the local candidates and credentials for
    /// all streams and components in the agent.
    ///
    /// <note>
    /// <para>
    /// The SDP will not contain any codec lines and the 'm' line will not list
    /// any payload types.
    /// </para>
    /// <para>
    /// It is highly recommended to set names on the streams prior to calling this
    /// function. Unnamed streams will show up as '-' in the 'm' line, but the SDP
    /// will not be parseable with nice_agent_parse_remote_sdp() if a stream is
    /// unnamed.
    /// </para>
    /// <para>
    /// The default candidate in the SDP will be selected based on the lowest
    /// priority candidate for the first component.
    /// </para>
    /// </note>
    ///
    /// <para>See also: nice_agent_set_stream_name() </para>
    /// <para>See also: nice_agent_parse_remote_sdp() </para>
    /// <para>See also: nice_agent_generate_local_stream_sdp() </para>
    /// <para>See also: nice_agent_generate_local_candidate_sdp() </para>
    /// <para>See also: nice_agent_get_default_local_candidate() </para>
    ///
    /// Returns: A string representing the local SDP. Must be freed with g_free()
    /// once done.
    ///
    /// Since: 0.1.4
    #[link_name = "\u{1}_nice_agent_generate_local_sdp"]
    pub fn nice_agent_generate_local_sdp(agent: *mut NiceAgent) -> *mut gchar;
}
extern "C" {
    /// nice_agent_generate_local_stream_sdp:
    /// @agent: The #NiceAgent Object
    /// @stream_id: The ID of the stream
    /// @include_non_ice: Whether or not to include non ICE specific lines
    /// (m=, c= and a=rtcp: lines)
    ///
    /// Generate an SDP string containing the local candidates and credentials
    /// for a stream.
    ///
    /// <note>
    /// <para>
    /// The SDP will not contain any codec lines and the 'm' line will not list
    /// any payload types.
    /// </para>
    /// <para>
    /// It is highly recommended to set the name of the stream prior to calling this
    /// function. Unnamed streams will show up as '-' in the 'm' line.
    /// </para>
    /// <para>
    /// The default candidate in the SDP will be selected based on the lowest
    /// priority candidate.
    /// </para>
    /// </note>
    ///
    /// <para>See also: nice_agent_set_stream_name() </para>
    /// <para>See also: nice_agent_parse_remote_stream_sdp() </para>
    /// <para>See also: nice_agent_generate_local_sdp() </para>
    /// <para>See also: nice_agent_generate_local_candidate_sdp() </para>
    /// <para>See also: nice_agent_get_default_local_candidate() </para>
    ///
    /// Returns: A string representing the local SDP for the stream. Must be freed
    /// with g_free() once done.
    ///
    /// Since: 0.1.4
    #[link_name = "\u{1}_nice_agent_generate_local_stream_sdp"]
    pub fn nice_agent_generate_local_stream_sdp(
        agent: *mut NiceAgent,
        stream_id: guint,
        include_non_ice: gboolean,
    ) -> *mut gchar;
}
extern "C" {
    /// nice_agent_generate_local_candidate_sdp:
    /// @agent: The #NiceAgent Object
    /// @candidate: The candidate to generate
    ///
    /// Generate an SDP string representing a local candidate.
    ///
    /// <para>See also: nice_agent_parse_remote_candidate_sdp() </para>
    /// <para>See also: nice_agent_generate_local_sdp() </para>
    /// <para>See also: nice_agent_generate_local_stream_sdp() </para>
    ///
    /// Returns: A string representing the SDP for the candidate. Must be freed
    /// with g_free() once done.
    ///
    /// Since: 0.1.4
    #[link_name = "\u{1}_nice_agent_generate_local_candidate_sdp"]
    pub fn nice_agent_generate_local_candidate_sdp(
        agent: *mut NiceAgent,
        candidate: *mut NiceCandidate,
    ) -> *mut gchar;
}
extern "C" {
    /// nice_agent_parse_remote_sdp:
    /// @agent: The #NiceAgent Object
    /// @sdp: The remote SDP to parse
    ///
    /// Parse an SDP string and extracts candidates and credentials from it and sets
    /// them on the agent.
    ///
    /// <note>
    /// <para>
    /// This function will return an error if a stream has not been assigned a name
    /// with nice_agent_set_stream_name() as it becomes troublesome to assign the
    /// streams from the agent to the streams in the SDP.
    /// </para>
    /// </note>
    ///
    ///
    /// <para>See also: nice_agent_set_stream_name() </para>
    /// <para>See also: nice_agent_generate_local_sdp() </para>
    /// <para>See also: nice_agent_parse_remote_stream_sdp() </para>
    /// <para>See also: nice_agent_parse_remote_candidate_sdp() </para>
    ///
    /// Returns: The number of candidates added, negative on errors
    ///
    /// Since: 0.1.4
    #[link_name = "\u{1}_nice_agent_parse_remote_sdp"]
    pub fn nice_agent_parse_remote_sdp(
        agent: *mut NiceAgent,
        sdp: *const gchar,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// nice_agent_parse_remote_stream_sdp:
    /// @agent: The #NiceAgent Object
    /// @stream_id: The ID of the stream to parse
    /// @sdp: The remote SDP to parse
    /// @ufrag: Pointer to store the ice ufrag if non %NULL. Must be freed with
    /// g_free() after use
    /// @pwd: Pointer to store the ice password if non %NULL. Must be freed with
    /// g_free() after use
    ///
    /// Parse an SDP string representing a single stream and extracts candidates
    /// and credentials from it.
    ///
    /// <para>See also: nice_agent_generate_local_stream_sdp() </para>
    /// <para>See also: nice_agent_parse_remote_sdp() </para>
    /// <para>See also: nice_agent_parse_remote_candidate_sdp() </para>
    ///
    /// Returns: (element-type NiceCandidate) (transfer full): A #GSList of
    /// candidates parsed from the SDP, or %NULL in case of errors
    ///
    /// Since: 0.1.4
    #[link_name = "\u{1}_nice_agent_parse_remote_stream_sdp"]
    pub fn nice_agent_parse_remote_stream_sdp(
        agent: *mut NiceAgent,
        stream_id: guint,
        sdp: *const gchar,
        ufrag: *mut *mut gchar,
        pwd: *mut *mut gchar,
    ) -> *mut GSList;
}
extern "C" {
    /// nice_agent_parse_remote_candidate_sdp:
    /// @agent: The #NiceAgent Object
    /// @stream_id: The ID of the stream the candidate belongs to
    /// @sdp: The remote SDP to parse
    ///
    /// Parse an SDP string and extracts the candidate from it.
    ///
    /// <para>See also: nice_agent_generate_local_candidate_sdp() </para>
    /// <para>See also: nice_agent_parse_remote_sdp() </para>
    /// <para>See also: nice_agent_parse_remote_stream_sdp() </para>
    ///
    /// Returns: The parsed candidate or %NULL if there was an error.
    ///
    /// Since: 0.1.4
    #[link_name = "\u{1}_nice_agent_parse_remote_candidate_sdp"]
    pub fn nice_agent_parse_remote_candidate_sdp(
        agent: *mut NiceAgent,
        stream_id: guint,
        sdp: *const gchar,
    ) -> *mut NiceCandidate;
}
extern "C" {
    /// nice_agent_get_io_stream:
    /// @agent: A #NiceAgent
    /// @stream_id: The ID of the stream to wrap
    /// @component_id: The ID of the component to wrap
    ///
    /// Gets a #GIOStream wrapper around the given stream and component in
    /// @agent. The I/O stream will be valid for as long as @stream_id is valid.
    /// The #GInputStream and #GOutputStream implement #GPollableInputStream and
    /// #GPollableOutputStream.
    ///
    /// This function may only be called on reliable #NiceAgents. It is a
    /// programming error to try and create an I/O stream wrapper for an
    /// unreliable stream.
    ///
    /// Returns: (transfer full): A #GIOStream.
    ///
    /// Since: 0.1.5
    #[link_name = "\u{1}_nice_agent_get_io_stream"]
    pub fn nice_agent_get_io_stream(
        agent: *mut NiceAgent,
        stream_id: guint,
        component_id: guint,
    ) -> *mut GIOStream;
}
extern "C" {
    /// nice_component_state_to_string:
    /// @state: a #NiceComponentState
    ///
    /// Returns a string representation of the state, generally to use in debug
    /// messages.
    ///
    /// Returns: (transfer none): a string representation of @state
    /// Since: 0.1.6
    #[link_name = "\u{1}_nice_component_state_to_string"]
    pub fn nice_component_state_to_string(state: NiceComponentState) -> *const gchar;
}
extern "C" {
    /// nice_agent_forget_relays:
    /// @agent: The #NiceAgent Object
    /// @stream_id: The ID of the stream
    /// @component_id: The ID of the component
    ///
    /// Forget all the relay servers previously added using
    /// nice_agent_set_relay_info(). Currently connected streams will keep
    /// using the relay as long as they have not been restarted and haven't
    /// succesfully negotiated a different path.
    ///
    /// Returns: %FALSE if the component could not be found, %TRUE otherwise
    ///
    /// Since: 0.1.6
    #[link_name = "\u{1}_nice_agent_forget_relays"]
    pub fn nice_agent_forget_relays(
        agent: *mut NiceAgent,
        stream_id: guint,
        component_id: guint,
    ) -> gboolean;
}
extern "C" {
    /// nice_agent_get_component_state:
    /// @agent: The #NiceAgent Object
    /// @stream_id: The ID of the stream
    /// @component_id: The ID of the component
    ///
    /// Retrieves the current state of a component.
    ///
    /// Returns: the #NiceComponentState of the component and
    /// %NICE_COMPONENT_STATE_FAILED if the component was invalid.
    ///
    /// Since: 0.1.8
    #[link_name = "\u{1}_nice_agent_get_component_state"]
    pub fn nice_agent_get_component_state(
        agent: *mut NiceAgent,
        stream_id: guint,
        component_id: guint,
    ) -> NiceComponentState;
}
pub type __builtin_va_list = [__va_list_tag; 1usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __va_list_tag {
    pub gp_offset: ::std::os::raw::c_uint,
    pub fp_offset: ::std::os::raw::c_uint,
    pub overflow_arg_area: *mut ::std::os::raw::c_void,
    pub reg_save_area: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout___va_list_tag() {
    assert_eq!(
        ::std::mem::size_of::<__va_list_tag>(),
        24usize,
        concat!("Size of: ", stringify!(__va_list_tag))
    );
    assert_eq!(
        ::std::mem::align_of::<__va_list_tag>(),
        8usize,
        concat!("Alignment of ", stringify!(__va_list_tag))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).gp_offset as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(gp_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).fp_offset as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(fp_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).overflow_arg_area as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(overflow_arg_area)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).reg_save_area as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(reg_save_area)
        )
    );
}
